/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/base/runtime_option.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
#include <sys/literal_strings.h>


using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////


// Class Invoke Tables
#ifdef FMCGEN
bool RuntimeOption::FastMethodCall = true;
#else
bool RuntimeOption::FastMethodCall = false;
#endif
extern struct ObjectStaticCallbacks cw_reflectionfunctionabstract;
extern struct ObjectStaticCallbacks cw_reflectionobject;
extern struct ObjectStaticCallbacks cw_splfileobject;
extern struct ObjectStaticCallbacks cw_unexpectedvalueexception;
extern struct ObjectStaticCallbacks cw_stdclass;
extern struct ObjectStaticCallbacks cw_reflectionexception;
extern struct ObjectStaticCallbacks cw_overflowexception;
extern struct ObjectStaticCallbacks cw_splfileinfo;
extern struct ObjectStaticCallbacks cw_arrayiterator;
extern struct ObjectStaticCallbacks cw_appenditerator;
extern struct ObjectStaticCallbacks cw_outofboundsexception;
extern struct ObjectStaticCallbacks cw_logicexception;
extern struct ObjectStaticCallbacks cw_rangeexception;
extern struct ObjectStaticCallbacks cw_splobjectstorage;
extern struct ObjectStaticCallbacks cw_invalidargumentexception;
extern struct ObjectStaticCallbacks cw_reflectionclass;
extern struct ObjectStaticCallbacks cw_underflowexception;
extern struct ObjectStaticCallbacks cw_reflectionextension;
extern struct ObjectStaticCallbacks cw_outofrangeexception;
extern struct ObjectStaticCallbacks cw_reflectionmethod;
extern struct ObjectStaticCallbacks cw_badmethodcallexception;
extern struct ObjectStaticCallbacks cw_pear_error;
extern struct ObjectStaticCallbacks cw_reflectionproperty;
extern struct ObjectStaticCallbacks cw___php_incomplete_class;
extern struct ObjectStaticCallbacks cw_runtimeexception;
extern struct ObjectStaticCallbacks cw_exception;
extern struct ObjectStaticCallbacks cw_reflectionfunction;
extern struct ObjectStaticCallbacks cw_errorexception;
extern struct ObjectStaticCallbacks cw_recursivedirectoryiterator;
extern struct ObjectStaticCallbacks cw_directoryiterator;
extern struct ObjectStaticCallbacks cw_badfunctioncallexception;
extern struct ObjectStaticCallbacks cw_lengthexception;
extern struct ObjectStaticCallbacks cw_domainexception;
extern struct ObjectStaticCallbacks cw_recursiveiteratoriterator;
extern struct ObjectStaticCallbacks cw_directory;
extern struct ObjectStaticCallbacks cw_filteriterator;
extern struct ObjectStaticCallbacks cw_reflectionparameter;
Object co_pdoexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdoexception)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdoexception
Variant c_pdoexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdoexception
Variant c_pdoexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdoexception
Variant &c_pdoexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdoexception
void c_pdoexception::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_pdoexception
void c_pdoexception::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdoexception
Variant c_pdoexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdoexception
Variant c_pdoexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdoexception
Variant c_pdoexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdoexception
bool c_pdoexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdoexception
bool c_pdoexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdoexception
bool c_pdoexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdoexception
Variant c_pdoexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdoexception
Variant c_pdoexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdoexception
Variant c_pdoexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdoexception
Variant& c_pdoexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdoexception
Variant& c_pdoexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdoexception
Variant& c_pdoexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdoexception
Variant c_pdoexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdoexception
IMPLEMENT_CLASS(pdoexception)
c_pdoexception *c_pdoexception::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_pdoexception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_pdoexception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_pdoexception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_pdoexception::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdoexception::cloneImpl() {
  c_pdoexception *obj = NEW(c_pdoexception)();
  cloneSet(obj);
  return obj;
}
void c_pdoexception::cloneSet(c_pdoexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
Variant c_pdoexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
Variant c_pdoexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdoexception
Variant c_pdoexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdoexception
Variant c_pdoexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdoexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdoexception = {
  c_pdoexception::os_getInit,
  c_pdoexception::os_get,
  c_pdoexception::os_lval,
  c_pdoexception::os_invoke,
  c_pdoexception::os_constant,
};
Object co_domdocumentfragment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocumentfragment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumentfragment
Variant c_domdocumentfragment::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumentfragment
Variant c_domdocumentfragment::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumentfragment
Variant &c_domdocumentfragment::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumentfragment
void c_domdocumentfragment::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumentfragment
void c_domdocumentfragment::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocumentfragment
Variant c_domdocumentfragment::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumentfragment
Variant c_domdocumentfragment::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumentfragment
Variant c_domdocumentfragment::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocumentfragment
bool c_domdocumentfragment::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumentfragment
bool c_domdocumentfragment::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumentfragment
bool c_domdocumentfragment::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocumentfragment
Variant c_domdocumentfragment::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumentfragment
Variant c_domdocumentfragment::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumentfragment
Variant c_domdocumentfragment::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocumentfragment
Variant& c_domdocumentfragment::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumentfragment
Variant& c_domdocumentfragment::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumentfragment
Variant& c_domdocumentfragment::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumentfragment
Variant c_domdocumentfragment::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumentfragment
IMPLEMENT_CLASS(domdocumentfragment)
c_domdocumentfragment *c_domdocumentfragment::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domdocumentfragment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domdocumentfragment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domdocumentfragment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domdocumentfragment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocumentfragment::cloneImpl() {
  c_domdocumentfragment *obj = NEW(c_domdocumentfragment)();
  cloneSet(obj);
  return obj;
}
void c_domdocumentfragment::cloneSet(c_domdocumentfragment *clone) {
  c_domnode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x66:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendxml(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendxml")) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendxml(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x66:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendxml")) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x66:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendxml(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendxml")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocumentfragment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocumentfragment = {
  c_domdocumentfragment::os_getInit,
  c_domdocumentfragment::os_get,
  c_domdocumentfragment::os_lval,
  c_domdocumentfragment::os_invoke,
  c_domdocumentfragment::os_constant,
};
Object co_domtext(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domtext)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domtext
Variant c_domtext::os_getInit(const char *s, int64 hash) {
  return c_domcharacterdata::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domtext
Variant c_domtext::os_get(const char *s, int64 hash) {
  return c_domcharacterdata::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domtext
Variant &c_domtext::os_lval(const char *s, int64 hash) {
  return c_domcharacterdata::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domtext
void c_domtext::o_getArray(Array &props) const {
  c_domcharacterdata::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domtext
void c_domtext::o_setArray(CArrRef props) {
  c_domcharacterdata::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_domtext
Variant c_domtext::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domtext
Variant c_domtext::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domcharacterdata::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domtext
Variant c_domtext::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domtext
bool c_domtext::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domtext
bool c_domtext::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domcharacterdata::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domtext
bool c_domtext::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_domtext
Variant c_domtext::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domtext
Variant c_domtext::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domcharacterdata::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domtext
Variant c_domtext::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domtext
Variant& c_domtext::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domtext
Variant& c_domtext::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domcharacterdata::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domtext
Variant& c_domtext::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domtext
Variant c_domtext::os_constant(const char *s) {
  return c_domcharacterdata::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domtext
IMPLEMENT_CLASS(domtext)
c_domtext *c_domtext::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domtext::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_domtext::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_domtext::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_domtext::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domtext::cloneImpl() {
  c_domtext *obj = NEW(c_domtext)();
  cloneSet(obj);
  return obj;
}
void c_domtext::cloneSet(c_domtext *clone) {
  c_domcharacterdata::cloneSet(clone);
}
Variant c_domtext::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
Variant c_domtext::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "iswhitespaceinelementcontent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splittext")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
Variant c_domtext::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "iswhitespaceinelementcontent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splittext")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domtext
Variant c_domtext::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domtext
Variant c_domtext::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "iswhitespaceinelementcontent")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splittext")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_domcharacterdata::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domtext::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domcharacterdata::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domtext = {
  c_domtext::os_getInit,
  c_domtext::os_get,
  c_domtext::os_lval,
  c_domtext::os_invoke,
  c_domtext::os_constant,
};
Object co_debuggerclient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_debuggerclient)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerclient
Variant c_debuggerclient::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerclient
Variant c_debuggerclient::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerclient
Variant &c_debuggerclient::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerclient
void c_debuggerclient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerclient
void c_debuggerclient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_debuggerclient
Variant c_debuggerclient::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerclient
Variant c_debuggerclient::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerclient
Variant c_debuggerclient::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_debuggerclient
bool c_debuggerclient::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerclient
bool c_debuggerclient::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerclient
bool c_debuggerclient::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_debuggerclient
Variant c_debuggerclient::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerclient
Variant c_debuggerclient::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerclient
Variant c_debuggerclient::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_debuggerclient
Variant& c_debuggerclient::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerclient
Variant& c_debuggerclient::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerclient
Variant& c_debuggerclient::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerclient
Variant c_debuggerclient::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x2038737F45604DE2LL, q_debuggerclient_AUTO_COMPLETE_VARIABLES, "AUTO_COMPLETE_VARIABLES");
      break;
    case 7:
      HASH_RETURN(0x1B352E31B034F827LL, q_debuggerclient_AUTO_COMPLETE_FILENAMES, "AUTO_COMPLETE_FILENAMES");
      HASH_RETURN(0x0F17BB5BEC004CA7LL, q_debuggerclient_AUTO_COMPLETE_CLASSES, "AUTO_COMPLETE_CLASSES");
      break;
    case 9:
      HASH_RETURN(0x6A811D407DC24A29LL, q_debuggerclient_AUTO_COMPLETE_CLASS_CONSTANTS, "AUTO_COMPLETE_CLASS_CONSTANTS");
      break;
    case 11:
      HASH_RETURN(0x1858E5511222BC8BLL, q_debuggerclient_AUTO_COMPLETE_CLASS_PROPERTIES, "AUTO_COMPLETE_CLASS_PROPERTIES");
      HASH_RETURN(0x1DE12226E1E87B6BLL, q_debuggerclient_AUTO_COMPLETE_CODE, "AUTO_COMPLETE_CODE");
      break;
    case 15:
      HASH_RETURN(0x2C29DCF63AAC70EFLL, q_debuggerclient_AUTO_COMPLETE_CLASS_METHODS, "AUTO_COMPLETE_CLASS_METHODS");
      HASH_RETURN(0x76A6B174D3E2108FLL, q_debuggerclient_AUTO_COMPLETE_KEYWORDS, "AUTO_COMPLETE_KEYWORDS");
      break;
    case 19:
      HASH_RETURN(0x78221A7B002235D3LL, q_debuggerclient_AUTO_COMPLETE_CONSTANTS, "AUTO_COMPLETE_CONSTANTS");
      break;
    case 31:
      HASH_RETURN(0x7CAE318E6EF6449FLL, q_debuggerclient_AUTO_COMPLETE_FUNCTIONS, "AUTO_COMPLETE_FUNCTIONS");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerclient
IMPLEMENT_CLASS(debuggerclient)
c_debuggerclient *c_debuggerclient::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_debuggerclient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_debuggerclient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_debuggerclient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_debuggerclient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_debuggerclient::cloneImpl() {
  c_debuggerclient *obj = NEW(c_debuggerclient)();
  cloneSet(obj);
  return obj;
}
void c_debuggerclient::cloneSet(c_debuggerclient *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
Variant c_debuggerclient::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x8c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      break;
    case 0x8d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_arg(arg0, arg1));
        }
      }
      break;
    case 0x8e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_helpcmds(count, arg0, arg1), null);
          return (t_helpcmds(count,arg0, arg1, params.slice(2, count - 2, false)), null);
        }
      }
      break;
    case 0x8f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_ask(count, arg0));
          return (t_ask(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 0x90:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_error(count, arg0), null);
          return (t_error(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x91:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xend(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x92:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helptitle(arg0), null);
        }
      }
      break;
    case 0x93:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      break;
    case 0x94:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_tutorial(arg0), null);
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x95:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argvalue(arg0));
        }
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_output(count, arg0), null);
          return (t_output(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x97:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_info(count, arg0), null);
          return (t_info(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x99:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_printframe(arg0), null);
        }
      }
      break;
    case 0x9a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_print(count, arg0), null);
          return (t_print(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x9b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_code(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_code(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_code(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_code(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0x9c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpsection(arg0), null);
        }
      }
      break;
    case 0x9d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 0x9e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpbody(arg0), null);
        }
      }
      break;
    case 0x9f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 0xa0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_help(count, arg0), null);
          return (t_help(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0xa1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 0xa2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addcompletion(arg0), null);
        }
      }
      break;
    case 0xa3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argrest(arg0));
        }
      }
      break;
    case 0xa4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 0xa5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_wrap(arg0));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addcompletion(arg0), null);
        }
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_ask(count, arg0));
          return (t_ask(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_printframe(arg0), null);
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpbody(arg0), null);
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_helpcmds(count, arg0, arg1), null);
          return (t_helpcmds(count,arg0, arg1, params.slice(2, count - 2, false)), null);
        }
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_print(count, arg0), null);
          return (t_print(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argrest(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_error(count, arg0), null);
          return (t_error(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_info(count, arg0), null);
          return (t_info(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helptitle(arg0), null);
        }
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argvalue(arg0));
        }
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_tutorial(arg0), null);
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpsection(arg0), null);
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_arg(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_help(count, arg0), null);
          return (t_help(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xend(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_wrap(arg0));
        }
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_code(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_code(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_code(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_code(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_output(count, arg0), null);
          return (t_output(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
Variant c_debuggerclient::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x8c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      break;
    case 0x8d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        return (t_arg(a0, a1));
      }
      break;
    case 0x8e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        Array params;
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_helpcmds(count,a0, a1, params), null);
      }
      break;
    case 0x8f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        if (count <= 1) return (t_ask(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_ask(count,a0, params));
      }
      break;
    case 0x90:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        if (count <= 1) return (t_error(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_error(count,a0, params), null);
      }
      break;
    case 0x91:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        return (t_xend(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x92:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        return (t_helptitle(a0), null);
      }
      break;
    case 0x93:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      break;
    case 0x94:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        return (t_tutorial(a0), null);
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x95:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        return (t_argvalue(a0));
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        if (count <= 1) return (t_output(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_output(count,a0, params), null);
      }
      break;
    case 0x97:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        if (count <= 1) return (t_info(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_info(count,a0, params), null);
      }
      break;
    case 0x99:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        return (t_printframe(a0), null);
      }
      break;
    case 0x9a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        if (count <= 1) return (t_print(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_print(count,a0, params), null);
      }
      break;
    case 0x9b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        if (count <= 1) return (t_code(a0), null);
        if (count == 2) return (t_code(a0, a1), null);
        if (count == 3) return (t_code(a0, a1, a2), null);
        return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 0x9c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        return (t_helpsection(a0), null);
      }
      break;
    case 0x9d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 0x9e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        return (t_helpbody(a0), null);
      }
      break;
    case 0x9f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 0xa0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        if (count <= 1) return (t_help(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_help(count,a0, params), null);
      }
      break;
    case 0xa1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 0xa2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        return (t_addcompletion(a0), null);
      }
      break;
    case 0xa3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        return (t_argrest(a0));
      }
      break;
    case 0xa4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 0xa5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        return (t_wrap(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        if (count <= 1) return (t_ask(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_ask(count,a0, params));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        Array params;
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_helpcmds(count,a0, a1, params), null);
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        if (count <= 1) return (t_print(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_print(count,a0, params), null);
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        if (count <= 1) return (t_error(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_error(count,a0, params), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        if (count <= 1) return (t_info(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_info(count,a0, params), null);
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        return (t_arg(a0, a1));
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        if (count <= 1) return (t_help(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_help(count,a0, params), null);
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        if (count <= 1) return (t_code(a0), null);
        if (count == 2) return (t_code(a0, a1), null);
        if (count == 3) return (t_code(a0, a1, a2), null);
        return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        if (count <= 1) return (t_output(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_output(count,a0, params), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerclient
Variant c_debuggerclient::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerclient
Variant c_debuggerclient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x8c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argcount());
      }
      break;
    case 0x8d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_arg(a0, a1));
      }
      break;
    case 0x8e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        return (t_helpcmds(count, a0, a1,vargs), null);
      }
      break;
    case 0x8f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_ask(count, a0));
        return (t_ask(count, a0,vargs));
      }
      break;
    case 0x90:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_error(count, a0), null);
        return (t_error(count, a0,vargs), null);
      }
      break;
    case 0x91:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xend(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x92:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helptitle(a0), null);
      }
      break;
    case 0x93:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcommand());
      }
      break;
    case 0x94:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_tutorial(a0), null);
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x95:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argvalue(a0));
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_output(count, a0), null);
        return (t_output(count, a0,vargs), null);
      }
      break;
    case 0x97:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstacktrace());
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_info(count, a0), null);
        return (t_info(count, a0,vargs), null);
      }
      break;
    case 0x99:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_printframe(a0), null);
      }
      break;
    case 0x9a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_print(count, a0), null);
        return (t_print(count, a0,vargs), null);
      }
      break;
    case 0x9b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_code(a0), null);
        else if (count == 2) return (t_code(a0, a1), null);
        else if (count == 3) return (t_code(a0, a1, a2), null);
        else return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 0x9c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpsection(a0), null);
      }
      break;
    case 0x9d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_quit(), null);
      }
      break;
    case 0x9e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpbody(a0), null);
      }
      break;
    case 0x9f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getframe());
      }
      break;
    case 0xa0:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_help(count, a0), null);
        return (t_help(count, a0,vargs), null);
      }
      break;
    case 0xa1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_args());
      }
      break;
    case 0xa2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addcompletion(a0), null);
      }
      break;
    case 0xa3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argrest(a0));
      }
      break;
    case 0xa4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcurrentlocation());
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 0xa5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_wrap(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_ask(count, a0));
        return (t_ask(count, a0,vargs));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        return (t_helpcmds(count, a0, a1,vargs), null);
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_print(count, a0), null);
        return (t_print(count, a0,vargs), null);
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_error(count, a0), null);
        return (t_error(count, a0,vargs), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_info(count, a0), null);
        return (t_info(count, a0,vargs), null);
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_arg(a0, a1));
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_help(count, a0), null);
        return (t_help(count, a0,vargs), null);
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_code(a0), null);
        else if (count == 2) return (t_code(a0, a1), null);
        else if (count == 3) return (t_code(a0, a1, a2), null);
        else return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_output(count, a0), null);
        return (t_output(count, a0,vargs), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_debuggerclient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_debuggerclient = {
  c_debuggerclient::os_getInit,
  c_debuggerclient::os_get,
  c_debuggerclient::os_lval,
  c_debuggerclient::os_invoke,
  c_debuggerclient::os_constant,
};
Object co_domcdatasection(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcdatasection)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcdatasection
Variant c_domcdatasection::os_getInit(const char *s, int64 hash) {
  return c_domtext::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcdatasection
Variant c_domcdatasection::os_get(const char *s, int64 hash) {
  return c_domtext::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcdatasection
Variant &c_domcdatasection::os_lval(const char *s, int64 hash) {
  return c_domtext::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcdatasection
void c_domcdatasection::o_getArray(Array &props) const {
  c_domtext::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domcdatasection
void c_domcdatasection::o_setArray(CArrRef props) {
  c_domtext::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcdatasection
Variant c_domcdatasection::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcdatasection
Variant c_domcdatasection::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domtext::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcdatasection
Variant c_domcdatasection::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcdatasection
bool c_domcdatasection::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcdatasection
bool c_domcdatasection::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domtext::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcdatasection
bool c_domcdatasection::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcdatasection
Variant c_domcdatasection::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcdatasection
Variant c_domcdatasection::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domtext::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcdatasection
Variant c_domcdatasection::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcdatasection
Variant& c_domcdatasection::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcdatasection
Variant& c_domcdatasection::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domtext::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcdatasection
Variant& c_domcdatasection::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcdatasection
Variant c_domcdatasection::os_constant(const char *s) {
  return c_domtext::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcdatasection
IMPLEMENT_CLASS(domcdatasection)
c_domcdatasection *c_domcdatasection::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domcdatasection::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_domcdatasection::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_domcdatasection::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domcdatasection::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcdatasection::cloneImpl() {
  c_domcdatasection *obj = NEW(c_domcdatasection)();
  cloneSet(obj);
  return obj;
}
void c_domcdatasection::cloneSet(c_domcdatasection *clone) {
  c_domtext::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "iswhitespaceinelementcontent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splittext")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "iswhitespaceinelementcontent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splittext")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcdatasection
Variant c_domcdatasection::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "iswhitespaceinelementcontent")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splittext")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_domtext::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcdatasection::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domtext::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcdatasection = {
  c_domcdatasection::os_getInit,
  c_domcdatasection::os_get,
  c_domcdatasection::os_lval,
  c_domcdatasection::os_invoke,
  c_domcdatasection::os_constant,
};
Object co_locale(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_locale)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_locale
Variant c_locale::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_locale
Variant c_locale::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_locale
Variant &c_locale::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_locale
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_locale
void c_locale::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_locale
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_locale
void c_locale::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_locale
#ifndef OMIT_JUMP_TABLE_CLASS_get_locale
Variant c_locale::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_locale
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_locale
Variant c_locale::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_locale
Variant c_locale::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_exists_locale
bool c_locale::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_locale
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_locale
bool c_locale::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_locale
bool c_locale::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_set_locale
Variant c_locale::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_locale
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_locale
Variant c_locale::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_locale
Variant c_locale::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_lval_locale
Variant& c_locale::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_locale
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_locale
Variant& c_locale::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_locale
Variant& c_locale::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_locale
Variant c_locale::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_RETURN(0x78695696B47AF8CDLL, q_locale_ACTUAL_LOCALE, "ACTUAL_LOCALE");
      HASH_RETURN(0x35B10383BBF3BAE1LL, q_locale_VALID_LOCALE, "VALID_LOCALE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_locale
IMPLEMENT_CLASS(locale)
c_locale *c_locale::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_locale::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_locale::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_locale::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_locale::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_locale::cloneImpl() {
  c_locale *obj = NEW(c_locale)();
  cloneSet(obj);
  return obj;
}
void c_locale::cloneSet(c_locale *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_locale
Variant c_locale::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_locale
Variant c_locale::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_locale
Variant c_locale::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_locale
Variant c_locale::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_locale::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_locale = {
  c_locale::os_getInit,
  c_locale::os_get,
  c_locale::os_lval,
  c_locale::os_invoke,
  c_locale::os_constant,
};
Object co_domdocumenttype(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocumenttype)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumenttype
Variant c_domdocumenttype::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumenttype
Variant c_domdocumenttype::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumenttype
Variant &c_domdocumenttype::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumenttype
void c_domdocumenttype::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumenttype
void c_domdocumenttype::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocumenttype
Variant c_domdocumenttype::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumenttype
Variant c_domdocumenttype::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumenttype
Variant c_domdocumenttype::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocumenttype
bool c_domdocumenttype::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumenttype
bool c_domdocumenttype::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumenttype
bool c_domdocumenttype::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocumenttype
Variant c_domdocumenttype::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumenttype
Variant c_domdocumenttype::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumenttype
Variant c_domdocumenttype::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocumenttype
Variant& c_domdocumenttype::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumenttype
Variant& c_domdocumenttype::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumenttype
Variant& c_domdocumenttype::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumenttype
Variant c_domdocumenttype::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumenttype
IMPLEMENT_CLASS(domdocumenttype)
c_domdocumenttype *c_domdocumenttype::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domdocumenttype::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domdocumenttype::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domdocumenttype::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domdocumenttype::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocumenttype::cloneImpl() {
  c_domdocumenttype *obj = NEW(c_domdocumenttype)();
  cloneSet(obj);
  return obj;
}
void c_domdocumenttype::cloneSet(c_domdocumenttype *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domdocumenttype::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumenttype
Variant c_domdocumenttype::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocumenttype::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocumenttype = {
  c_domdocumenttype::os_getInit,
  c_domdocumenttype::os_get,
  c_domdocumenttype::os_lval,
  c_domdocumenttype::os_invoke,
  c_domdocumenttype::os_constant,
};
Object co_sqlite3stmt(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3stmt)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3stmt
Variant c_sqlite3stmt::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3stmt
Variant c_sqlite3stmt::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3stmt
Variant &c_sqlite3stmt::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3stmt
void c_sqlite3stmt::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3stmt
void c_sqlite3stmt::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3stmt
Variant c_sqlite3stmt::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3stmt
Variant c_sqlite3stmt::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3stmt
Variant c_sqlite3stmt::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3stmt
bool c_sqlite3stmt::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3stmt
bool c_sqlite3stmt::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3stmt
bool c_sqlite3stmt::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3stmt
Variant c_sqlite3stmt::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3stmt
Variant c_sqlite3stmt::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3stmt
Variant c_sqlite3stmt::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3stmt
Variant& c_sqlite3stmt::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3stmt
Variant& c_sqlite3stmt::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3stmt
Variant& c_sqlite3stmt::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3stmt
Variant c_sqlite3stmt::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3stmt
IMPLEMENT_CLASS(sqlite3stmt)
c_sqlite3stmt *c_sqlite3stmt::create(Object a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_sqlite3stmt::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_sqlite3stmt::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  }
}
void c_sqlite3stmt::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_sqlite3stmt::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3stmt::cloneImpl() {
  c_sqlite3stmt *obj = NEW(c_sqlite3stmt)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3stmt::cloneSet(c_sqlite3stmt *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x18d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindparam(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindparam(arg0, ref(arg1), arg2));
        }
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 0x18b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0x18e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindparam(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindparam(arg0, ref(arg1), arg2));
        }
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x18d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 0x18b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0x18e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 0x18d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_paramcount());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_execute());
      }
      break;
    case 0x18b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 0x18e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_clear());
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3stmt::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3stmt = {
  c_sqlite3stmt::os_getInit,
  c_sqlite3stmt::os_get,
  c_sqlite3stmt::os_lval,
  c_sqlite3stmt::os_invoke,
  c_sqlite3stmt::os_constant,
};
Object co_domnodelist(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnodelist)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodelist
Variant c_domnodelist::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodelist
Variant c_domnodelist::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodelist
Variant &c_domnodelist::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodelist
void c_domnodelist::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodelist
void c_domnodelist::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnodelist
Variant c_domnodelist::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodelist
Variant c_domnodelist::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodelist
Variant c_domnodelist::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnodelist
bool c_domnodelist::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodelist
bool c_domnodelist::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodelist
bool c_domnodelist::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnodelist
Variant c_domnodelist::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodelist
Variant c_domnodelist::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodelist
Variant c_domnodelist::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnodelist
Variant& c_domnodelist::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodelist
Variant& c_domnodelist::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodelist
Variant& c_domnodelist::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodelist
Variant c_domnodelist::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodelist
IMPLEMENT_CLASS(domnodelist)
c_domnodelist *c_domnodelist::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnodelist::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnodelist::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnodelist::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnodelist::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnodelist::cloneImpl() {
  c_domnodelist *obj = NEW(c_domnodelist)();
  cloneSet(obj);
  return obj;
}
void c_domnodelist::cloneSet(c_domnodelist *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnodelist::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
Variant c_domnodelist::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
Variant c_domnodelist::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodelist
Variant c_domnodelist::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodelist
Variant c_domnodelist::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnodelist::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnodelist = {
  c_domnodelist::os_getInit,
  c_domnodelist::os_get,
  c_domnodelist::os_lval,
  c_domnodelist::os_invoke,
  c_domnodelist::os_constant,
};
Object co_normalizer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_normalizer)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_normalizer
Variant c_normalizer::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_normalizer
Variant c_normalizer::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_normalizer
Variant &c_normalizer::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_normalizer
void c_normalizer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_normalizer
void c_normalizer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_normalizer
Variant c_normalizer::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_normalizer
Variant c_normalizer::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_normalizer
Variant c_normalizer::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_normalizer
bool c_normalizer::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_normalizer
bool c_normalizer::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_normalizer
bool c_normalizer::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_normalizer
Variant c_normalizer::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_normalizer
Variant c_normalizer::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_normalizer
Variant c_normalizer::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_normalizer
Variant& c_normalizer::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_normalizer
Variant& c_normalizer::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_normalizer
Variant& c_normalizer::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_normalizer
Variant c_normalizer::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 1:
      HASH_RETURN(0x2C9DA0E379A28381LL, q_normalizer_FORM_KD, "FORM_KD");
      HASH_RETURN(0x1C369D0E14B76C41LL, q_normalizer_FORM_KC, "FORM_KC");
      HASH_RETURN(0x3E3AA0A97BD09921LL, q_normalizer_NFKC, "NFKC");
      break;
    case 2:
      HASH_RETURN(0x07512AA38ADD1AE2LL, q_normalizer_FORM_D, "FORM_D");
      break;
    case 6:
      HASH_RETURN(0x51422F059BEFCD86LL, q_normalizer_NFC, "NFC");
      break;
    case 15:
      HASH_RETURN(0x58B301790FA834EFLL, q_normalizer_NFD, "NFD");
      HASH_RETURN(0x3CF19F2D23C185CFLL, q_normalizer_NFKD, "NFKD");
      break;
    case 19:
      HASH_RETURN(0x2EFDCA1922BFB273LL, q_normalizer_NONE, "NONE");
      break;
    case 31:
      HASH_RETURN(0x3BE3511FDA9A9E7FLL, q_normalizer_FORM_C, "FORM_C");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_normalizer
IMPLEMENT_CLASS(normalizer)
c_normalizer *c_normalizer::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_normalizer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_normalizer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_normalizer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_normalizer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_normalizer::cloneImpl() {
  c_normalizer *obj = NEW(c_normalizer)();
  cloneSet(obj);
  return obj;
}
void c_normalizer::cloneSet(c_normalizer *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
Variant c_normalizer::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(o_getClassName(), arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_normalize(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(o_getClassName(), arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_isnormalized(o_getClassName(), arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(o_getClassName(), arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_normalize(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(o_getClassName(), arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_isnormalized(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
Variant c_normalizer::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_normalizer
Variant c_normalizer::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(c, arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_normalize(c, arg0, arg1));
        }
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(c, arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_isnormalized(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(c, arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_isnormalized(c, arg0, arg1));
        }
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(c, arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_normalize(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_normalizer
Variant c_normalizer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_normalizer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_normalizer = {
  c_normalizer::os_getInit,
  c_normalizer::os_get,
  c_normalizer::os_lval,
  c_normalizer::os_invoke,
  c_normalizer::os_constant,
};
Object co_domcharacterdata(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcharacterdata)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcharacterdata
Variant c_domcharacterdata::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcharacterdata
Variant c_domcharacterdata::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcharacterdata
Variant &c_domcharacterdata::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcharacterdata
void c_domcharacterdata::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domcharacterdata
void c_domcharacterdata::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcharacterdata
Variant c_domcharacterdata::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcharacterdata
Variant c_domcharacterdata::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcharacterdata
Variant c_domcharacterdata::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcharacterdata
bool c_domcharacterdata::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcharacterdata
bool c_domcharacterdata::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcharacterdata
bool c_domcharacterdata::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcharacterdata
Variant c_domcharacterdata::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcharacterdata
Variant c_domcharacterdata::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcharacterdata
Variant c_domcharacterdata::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcharacterdata
Variant& c_domcharacterdata::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcharacterdata
Variant& c_domcharacterdata::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcharacterdata
Variant& c_domcharacterdata::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcharacterdata
Variant c_domcharacterdata::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcharacterdata
IMPLEMENT_CLASS(domcharacterdata)
c_domcharacterdata *c_domcharacterdata::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domcharacterdata::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domcharacterdata::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domcharacterdata::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domcharacterdata::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcharacterdata::cloneImpl() {
  c_domcharacterdata *obj = NEW(c_domcharacterdata)();
  cloneSet(obj);
  return obj;
}
void c_domcharacterdata::cloneSet(c_domcharacterdata *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domcharacterdata::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcharacterdata
Variant c_domcharacterdata::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcharacterdata::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcharacterdata = {
  c_domcharacterdata::os_getInit,
  c_domcharacterdata::os_get,
  c_domcharacterdata::os_lval,
  c_domcharacterdata::os_invoke,
  c_domcharacterdata::os_constant,
};
Object co_domentityreference(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domentityreference)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentityreference
Variant c_domentityreference::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentityreference
Variant c_domentityreference::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentityreference
Variant &c_domentityreference::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domentityreference
void c_domentityreference::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domentityreference
void c_domentityreference::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_domentityreference
Variant c_domentityreference::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentityreference
Variant c_domentityreference::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentityreference
Variant c_domentityreference::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domentityreference
bool c_domentityreference::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentityreference
bool c_domentityreference::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentityreference
bool c_domentityreference::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_domentityreference
Variant c_domentityreference::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentityreference
Variant c_domentityreference::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentityreference
Variant c_domentityreference::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domentityreference
Variant& c_domentityreference::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentityreference
Variant& c_domentityreference::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentityreference
Variant& c_domentityreference::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domentityreference
Variant c_domentityreference::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domentityreference
IMPLEMENT_CLASS(domentityreference)
c_domentityreference *c_domentityreference::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domentityreference::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_domentityreference::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_domentityreference::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domentityreference::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domentityreference::cloneImpl() {
  c_domentityreference *obj = NEW(c_domentityreference)();
  cloneSet(obj);
  return obj;
}
void c_domentityreference::cloneSet(c_domentityreference *clone) {
  c_domnode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
Variant c_domentityreference::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
Variant c_domentityreference::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentityreference
Variant c_domentityreference::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentityreference
Variant c_domentityreference::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domentityreference::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domentityreference = {
  c_domentityreference::os_getInit,
  c_domentityreference::os_get,
  c_domentityreference::os_lval,
  c_domentityreference::os_invoke,
  c_domentityreference::os_constant,
};
Object co_simplexmlelementiterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_simplexmlelementiterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelementiterator
Variant &c_simplexmlelementiterator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelementiterator
void c_simplexmlelementiterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelementiterator
void c_simplexmlelementiterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_simplexmlelementiterator
bool c_simplexmlelementiterator::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelementiterator
bool c_simplexmlelementiterator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelementiterator
bool c_simplexmlelementiterator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelementiterator
IMPLEMENT_CLASS(simplexmlelementiterator)
c_simplexmlelementiterator *c_simplexmlelementiterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_simplexmlelementiterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_simplexmlelementiterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_simplexmlelementiterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_simplexmlelementiterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_simplexmlelementiterator::cloneImpl() {
  c_simplexmlelementiterator *obj = NEW(c_simplexmlelementiterator)();
  cloneSet(obj);
  return obj;
}
void c_simplexmlelementiterator::cloneSet(c_simplexmlelementiterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_simplexmlelementiterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_simplexmlelementiterator = {
  c_simplexmlelementiterator::os_getInit,
  c_simplexmlelementiterator::os_get,
  c_simplexmlelementiterator::os_lval,
  c_simplexmlelementiterator::os_invoke,
  c_simplexmlelementiterator::os_constant,
};
Object co_datetimezone(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_datetimezone)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetimezone
Variant c_datetimezone::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetimezone
Variant c_datetimezone::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetimezone
Variant &c_datetimezone::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_datetimezone
void c_datetimezone::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_datetimezone
void c_datetimezone::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_datetimezone
Variant c_datetimezone::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetimezone
Variant c_datetimezone::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetimezone
Variant c_datetimezone::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_datetimezone
bool c_datetimezone::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetimezone
bool c_datetimezone::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetimezone
bool c_datetimezone::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_datetimezone
Variant c_datetimezone::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetimezone
Variant c_datetimezone::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetimezone
Variant c_datetimezone::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_datetimezone
Variant& c_datetimezone::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetimezone
Variant& c_datetimezone::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetimezone
Variant& c_datetimezone::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_datetimezone
Variant c_datetimezone::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x5213CDB166554802LL, q_datetimezone_AFRICA, "AFRICA");
      break;
    case 10:
      HASH_RETURN(0x1F67AB7044E3CA2ALL, q_datetimezone_EUROPE, "EUROPE");
      break;
    case 12:
      HASH_RETURN(0x76F99914EEA96ECCLL, q_datetimezone_ARCTIC, "ARCTIC");
      break;
    case 13:
      HASH_RETURN(0x338F44565E0C038DLL, q_datetimezone_AMERICA, "AMERICA");
      break;
    case 15:
      HASH_RETURN(0x22CAA6990573E5EFLL, q_datetimezone_PACIFIC, "PACIFIC");
      break;
    case 19:
      HASH_RETURN(0x7879534F49C301F3LL, q_datetimezone_PER_COUNTRY, "PER_COUNTRY");
      break;
    case 20:
      HASH_RETURN(0x6FB9D84AA364CA14LL, q_datetimezone_UTC, "UTC");
      break;
    case 23:
      HASH_RETURN(0x5A01AACAA61E0FF7LL, q_datetimezone_ASIA, "ASIA");
      HASH_RETURN(0x3E74CAEDAD25E137LL, q_datetimezone_INDIAN, "INDIAN");
      break;
    case 24:
      HASH_RETURN(0x0C4F30470A9EEBF8LL, q_datetimezone_ALL, "ALL");
      break;
    case 25:
      HASH_RETURN(0x2BEDCED53E63BC79LL, q_datetimezone_ATLANTIC, "ATLANTIC");
      break;
    case 30:
      HASH_RETURN(0x3C168ED86522549ELL, q_datetimezone_AUSTRALIA, "AUSTRALIA");
      HASH_RETURN(0x690180C3BA732B5ELL, q_datetimezone_ALL_WITH_BC, "ALL_WITH_BC");
      break;
    case 31:
      HASH_RETURN(0x6B29DE65F46EAFDFLL, q_datetimezone_ANTARCTICA, "ANTARCTICA");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_datetimezone
IMPLEMENT_CLASS(datetimezone)
c_datetimezone *c_datetimezone::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_datetimezone::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_datetimezone::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_datetimezone::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_datetimezone::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_datetimezone::cloneImpl() {
  c_datetimezone *obj = NEW(c_datetimezone)();
  cloneSet(obj);
  return obj;
}
void c_datetimezone::cloneSet(c_datetimezone *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
Variant c_datetimezone::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x88:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getoffset(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listidentifiers")) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "gettransitions")) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b_1, "getname")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listabbreviations")) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getoffset")) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getoffset(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
Variant c_datetimezone::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x88:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listidentifiers")) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "gettransitions")) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b_1, "getname")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listabbreviations")) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getoffset")) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetimezone
Variant c_datetimezone::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(c));
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(c));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listabbreviations")) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listidentifiers")) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetimezone
Variant c_datetimezone::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x88:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettransitions());
      }
      break;
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(o_getClassName()));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listidentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "gettransitions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b_1, "getname")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listabbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getoffset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_datetimezone::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(c));
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(c));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listabbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listidentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_datetimezone = {
  c_datetimezone::os_getInit,
  c_datetimezone::os_get,
  c_datetimezone::os_lval,
  c_datetimezone::os_invoke,
  c_datetimezone::os_constant,
};
Object co_domnodeiterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnodeiterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodeiterator
Variant c_domnodeiterator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodeiterator
Variant c_domnodeiterator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodeiterator
Variant &c_domnodeiterator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodeiterator
void c_domnodeiterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodeiterator
void c_domnodeiterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnodeiterator
Variant c_domnodeiterator::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodeiterator
Variant c_domnodeiterator::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodeiterator
Variant c_domnodeiterator::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnodeiterator
bool c_domnodeiterator::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodeiterator
bool c_domnodeiterator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodeiterator
bool c_domnodeiterator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnodeiterator
Variant c_domnodeiterator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodeiterator
Variant c_domnodeiterator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodeiterator
Variant c_domnodeiterator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnodeiterator
Variant& c_domnodeiterator::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodeiterator
Variant& c_domnodeiterator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodeiterator
Variant& c_domnodeiterator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodeiterator
Variant c_domnodeiterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodeiterator
IMPLEMENT_CLASS(domnodeiterator)
c_domnodeiterator *c_domnodeiterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnodeiterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnodeiterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnodeiterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnodeiterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnodeiterator::cloneImpl() {
  c_domnodeiterator *obj = NEW(c_domnodeiterator)();
  cloneSet(obj);
  return obj;
}
void c_domnodeiterator::cloneSet(c_domnodeiterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodeiterator
Variant c_domnodeiterator::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnodeiterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnodeiterator = {
  c_domnodeiterator::os_getInit,
  c_domnodeiterator::os_get,
  c_domnodeiterator::os_lval,
  c_domnodeiterator::os_invoke,
  c_domnodeiterator::os_constant,
};
Object co_domimplementation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domimplementation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domimplementation
Variant c_domimplementation::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domimplementation
Variant c_domimplementation::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domimplementation
Variant &c_domimplementation::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domimplementation
void c_domimplementation::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domimplementation
void c_domimplementation::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_domimplementation
Variant c_domimplementation::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domimplementation
Variant c_domimplementation::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domimplementation
Variant c_domimplementation::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domimplementation
bool c_domimplementation::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domimplementation
bool c_domimplementation::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domimplementation
bool c_domimplementation::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_domimplementation
Variant c_domimplementation::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domimplementation
Variant c_domimplementation::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domimplementation
Variant c_domimplementation::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domimplementation
Variant& c_domimplementation::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domimplementation
Variant& c_domimplementation::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domimplementation
Variant& c_domimplementation::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domimplementation
Variant c_domimplementation::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domimplementation
IMPLEMENT_CLASS(domimplementation)
c_domimplementation *c_domimplementation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domimplementation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domimplementation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domimplementation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domimplementation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domimplementation::cloneImpl() {
  c_domimplementation *obj = NEW(c_domimplementation)();
  cloneSet(obj);
  return obj;
}
void c_domimplementation::cloneSet(c_domimplementation *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
Variant c_domimplementation::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x75:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocument(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_createdocument(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 0x76:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocumenttype());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocumenttype(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_createdocumenttype(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createdocumenttype(arg0, arg1, arg2));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x77:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_hasfeature(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createdocumenttype")) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocumenttype());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocumenttype(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_createdocumenttype(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createdocumenttype(arg0, arg1, arg2));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasfeature")) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_hasfeature(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createdocument")) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocument(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_createdocument(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
Variant c_domimplementation::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x75:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        if (count == 1) return (t_createdocument(a0));
        if (count == 2) return (t_createdocument(a0, a1));
        return (t_createdocument(a0, a1, a2));
      }
      break;
    case 0x76:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        if (count == 1) return (t_createdocumenttype(a0));
        if (count == 2) return (t_createdocumenttype(a0, a1));
        return (t_createdocumenttype(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x77:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createdocumenttype")) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        if (count == 1) return (t_createdocumenttype(a0));
        if (count == 2) return (t_createdocumenttype(a0, a1));
        return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasfeature")) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createdocument")) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        if (count == 1) return (t_createdocument(a0));
        if (count == 2) return (t_createdocument(a0, a1));
        return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domimplementation
Variant c_domimplementation::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domimplementation
Variant c_domimplementation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x75:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 0x76:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x77:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasfeature(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createdocumenttype")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasfeature")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createdocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domimplementation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domimplementation = {
  c_domimplementation::os_getInit,
  c_domimplementation::os_get,
  c_domimplementation::os_lval,
  c_domimplementation::os_invoke,
  c_domimplementation::os_constant,
};
Object co_soapheader(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapheader)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapheader
Variant c_soapheader::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapheader
Variant c_soapheader::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapheader
Variant &c_soapheader::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapheader
void c_soapheader::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapheader
void c_soapheader::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapheader
Variant c_soapheader::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapheader
Variant c_soapheader::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapheader
Variant c_soapheader::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapheader
bool c_soapheader::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapheader
bool c_soapheader::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapheader
bool c_soapheader::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapheader
Variant c_soapheader::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapheader
Variant c_soapheader::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapheader
Variant c_soapheader::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapheader
Variant& c_soapheader::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapheader
Variant& c_soapheader::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapheader
Variant& c_soapheader::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapheader
Variant c_soapheader::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapheader
IMPLEMENT_CLASS(soapheader)
c_soapheader *c_soapheader::create(String a0, String a1, Variant a2, bool a3, Variant a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_soapheader::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_soapheader::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_soapheader::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_soapheader::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapheader::cloneImpl() {
  c_soapheader *obj = NEW(c_soapheader)();
  cloneSet(obj);
  return obj;
}
void c_soapheader::cloneSet(c_soapheader *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
Variant c_soapheader::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
Variant c_soapheader::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapheader
Variant c_soapheader::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapheader
Variant c_soapheader::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapheader::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapheader = {
  c_soapheader::os_getInit,
  c_soapheader::os_get,
  c_soapheader::os_lval,
  c_soapheader::os_invoke,
  c_soapheader::os_constant,
};
Object co_domnotation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnotation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnotation
Variant c_domnotation::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnotation
Variant c_domnotation::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnotation
Variant &c_domnotation::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnotation
void c_domnotation::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnotation
void c_domnotation::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnotation
Variant c_domnotation::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnotation
Variant c_domnotation::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnotation
Variant c_domnotation::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnotation
bool c_domnotation::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnotation
bool c_domnotation::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnotation
bool c_domnotation::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnotation
Variant c_domnotation::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnotation
Variant c_domnotation::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnotation
Variant c_domnotation::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnotation
Variant& c_domnotation::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnotation
Variant& c_domnotation::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnotation
Variant& c_domnotation::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnotation
Variant c_domnotation::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnotation
IMPLEMENT_CLASS(domnotation)
c_domnotation *c_domnotation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnotation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnotation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnotation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnotation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnotation::cloneImpl() {
  c_domnotation *obj = NEW(c_domnotation)();
  cloneSet(obj);
  return obj;
}
void c_domnotation::cloneSet(c_domnotation *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domnotation::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
Variant c_domnotation::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
Variant c_domnotation::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnotation
Variant c_domnotation::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnotation
Variant c_domnotation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnotation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnotation = {
  c_domnotation::os_getInit,
  c_domnotation::os_get,
  c_domnotation::os_lval,
  c_domnotation::os_invoke,
  c_domnotation::os_constant,
};
Object co_debuggerproxy(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_debuggerproxy)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerproxy
Variant c_debuggerproxy::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerproxy
Variant c_debuggerproxy::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerproxy
Variant &c_debuggerproxy::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerproxy
void c_debuggerproxy::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerproxy
void c_debuggerproxy::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_get_debuggerproxy
Variant c_debuggerproxy::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerproxy
Variant c_debuggerproxy::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerproxy
Variant c_debuggerproxy::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_exists_debuggerproxy
bool c_debuggerproxy::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerproxy
bool c_debuggerproxy::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerproxy
bool c_debuggerproxy::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_set_debuggerproxy
Variant c_debuggerproxy::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerproxy
Variant c_debuggerproxy::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerproxy
Variant c_debuggerproxy::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_lval_debuggerproxy
Variant& c_debuggerproxy::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerproxy
Variant& c_debuggerproxy::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerproxy
Variant& c_debuggerproxy::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerproxy
Variant c_debuggerproxy::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerproxy
IMPLEMENT_CLASS(debuggerproxy)
c_debuggerproxy *c_debuggerproxy::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_debuggerproxy::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_debuggerproxy::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_debuggerproxy::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_debuggerproxy::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_debuggerproxy::cloneImpl() {
  c_debuggerproxy *obj = NEW(c_debuggerproxy)();
  cloneSet(obj);
  return obj;
}
void c_debuggerproxy::cloneSet(c_debuggerproxy *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
Variant c_debuggerproxy::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xaa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
Variant c_debuggerproxy::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xaa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerproxy
Variant c_debuggerproxy::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerproxy
Variant c_debuggerproxy::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xaa:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islocal());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_debuggerproxy::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_debuggerproxy = {
  c_debuggerproxy::os_getInit,
  c_debuggerproxy::os_get,
  c_debuggerproxy::os_lval,
  c_debuggerproxy::os_invoke,
  c_debuggerproxy::os_constant,
};
Object co_domcomment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcomment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcomment
Variant c_domcomment::os_getInit(const char *s, int64 hash) {
  return c_domcharacterdata::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcomment
Variant c_domcomment::os_get(const char *s, int64 hash) {
  return c_domcharacterdata::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcomment
Variant &c_domcomment::os_lval(const char *s, int64 hash) {
  return c_domcharacterdata::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcomment
void c_domcomment::o_getArray(Array &props) const {
  c_domcharacterdata::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domcomment
void c_domcomment::o_setArray(CArrRef props) {
  c_domcharacterdata::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcomment
Variant c_domcomment::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcomment
Variant c_domcomment::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domcharacterdata::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcomment
Variant c_domcomment::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcomment
bool c_domcomment::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcomment
bool c_domcomment::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domcharacterdata::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcomment
bool c_domcomment::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcomment
Variant c_domcomment::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcomment
Variant c_domcomment::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domcharacterdata::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcomment
Variant c_domcomment::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcomment
Variant& c_domcomment::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcomment
Variant& c_domcomment::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domcharacterdata::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcomment
Variant& c_domcomment::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcomment
Variant c_domcomment::os_constant(const char *s) {
  return c_domcharacterdata::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcomment
IMPLEMENT_CLASS(domcomment)
c_domcomment *c_domcomment::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domcomment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_domcomment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_domcomment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_domcomment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcomment::cloneImpl() {
  c_domcomment *obj = NEW(c_domcomment)();
  cloneSet(obj);
  return obj;
}
void c_domcomment::cloneSet(c_domcomment *clone) {
  c_domcharacterdata::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
Variant c_domcomment::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
Variant c_domcomment::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcomment
Variant c_domcomment::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcomment
Variant c_domcomment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deletedata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appenddata")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replacedata")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertdata")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_domcharacterdata::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcomment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domcharacterdata::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcomment = {
  c_domcomment::os_getInit,
  c_domcomment::os_get,
  c_domcomment::os_lval,
  c_domcomment::os_invoke,
  c_domcomment::os_constant,
};
Object co_sqlite3(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3
Variant c_sqlite3::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3
Variant c_sqlite3::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3
Variant &c_sqlite3::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3
void c_sqlite3::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3
void c_sqlite3::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3
Variant c_sqlite3::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3
Variant c_sqlite3::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3
Variant c_sqlite3::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3
bool c_sqlite3::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3
bool c_sqlite3::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3
bool c_sqlite3::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3
Variant c_sqlite3::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3
Variant c_sqlite3::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3
Variant c_sqlite3::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3
Variant& c_sqlite3::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3
Variant& c_sqlite3::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3
Variant& c_sqlite3::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3
Variant c_sqlite3::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3
IMPLEMENT_CLASS(sqlite3)
c_sqlite3 *c_sqlite3::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_sqlite3::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_sqlite3::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_sqlite3::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_sqlite3::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3::cloneImpl() {
  c_sqlite3 *obj = NEW(c_sqlite3)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3::cloneSet(c_sqlite3 *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
Variant c_sqlite3::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 0x17b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 0x17c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadextension(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x17d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_createfunction(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createfunction(arg0, arg1, arg2));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x17e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x180:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_escapestring(arg0));
        }
      }
      break;
    case 0x17f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      break;
    case 0x181:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_createaggregate(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createaggregate(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x182:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_open(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_open(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_open(arg0, arg1, arg2), null);
        }
      }
      break;
    case 0x183:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 0x184:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_openblob(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openblob(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x185:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_prepare(arg0));
        }
      }
      break;
    case 0x186:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_querysingle(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_querysingle(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_openblob(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openblob(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_createaggregate(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createaggregate(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_open(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_open(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_open(arg0, arg1, arg2), null);
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_createfunction(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createfunction(arg0, arg1, arg2));
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadextension(arg0));
        }
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_querysingle(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_querysingle(arg0, arg1));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_prepare(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_escapestring(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
Variant c_sqlite3::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 0x17b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 0x17c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x17d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(a0, a1));
        return (t_createfunction(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x17e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x180:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(a0));
      }
      break;
    case 0x17f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      break;
    case 0x181:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 0x182:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(a0), null);
        if (count == 2) return (t_open(a0, a1), null);
        return (t_open(a0, a1, a2), null);
      }
      break;
    case 0x183:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 0x184:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(a0, a1, a2));
        return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 0x185:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(a0));
      }
      break;
    case 0x186:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(a0));
        return (t_querysingle(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(a0, a1, a2));
        return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(a0), null);
        if (count == 2) return (t_open(a0, a1), null);
        return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(a0, a1));
        return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(a0));
        return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3
Variant c_sqlite3::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3
Variant c_sqlite3::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 0x17b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_version());
      }
      break;
    case 0x17c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadextension(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x17d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x17e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lastinsertrowid());
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 0x180:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_escapestring(a0));
      }
      break;
    case 0x17f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrormsg());
      }
      break;
    case 0x181:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 0x182:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 0x183:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_changes());
      }
      break;
    case 0x184:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 0x185:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrorcode());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_prepare(a0));
      }
      break;
    case 0x186:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3 = {
  c_sqlite3::os_getInit,
  c_sqlite3::os_get,
  c_sqlite3::os_lval,
  c_sqlite3::os_invoke,
  c_sqlite3::os_constant,
};
Object co_domattr(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domattr)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domattr
Variant c_domattr::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domattr
Variant c_domattr::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domattr
Variant &c_domattr::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domattr
void c_domattr::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domattr
void c_domattr::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_domattr
Variant c_domattr::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domattr
Variant c_domattr::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domattr
Variant c_domattr::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domattr
bool c_domattr::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domattr
bool c_domattr::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domattr
bool c_domattr::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_domattr
Variant c_domattr::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domattr
Variant c_domattr::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domattr
Variant c_domattr::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domattr
Variant& c_domattr::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domattr
Variant& c_domattr::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domattr
Variant& c_domattr::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domattr
Variant c_domattr::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domattr
IMPLEMENT_CLASS(domattr)
c_domattr *c_domattr::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domattr::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domattr::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domattr::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domattr::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domattr::cloneImpl() {
  c_domattr *obj = NEW(c_domattr)();
  cloneSet(obj);
  return obj;
}
void c_domattr::cloneSet(c_domattr *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domattr::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
Variant c_domattr::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x30:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isid")) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
Variant c_domattr::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x30:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isid")) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domattr
Variant c_domattr::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domattr
Variant c_domattr::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x30:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isid());
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domattr::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domattr = {
  c_domattr::os_getInit,
  c_domattr::os_get,
  c_domattr::os_lval,
  c_domattr::os_invoke,
  c_domattr::os_constant,
};
Object co_soapvar(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapvar)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapvar
Variant c_soapvar::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapvar
Variant c_soapvar::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapvar
Variant &c_soapvar::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapvar
void c_soapvar::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapvar
void c_soapvar::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapvar
Variant c_soapvar::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapvar
Variant c_soapvar::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapvar
Variant c_soapvar::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapvar
bool c_soapvar::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapvar
bool c_soapvar::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapvar
bool c_soapvar::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapvar
Variant c_soapvar::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapvar
Variant c_soapvar::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapvar
Variant c_soapvar::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapvar
Variant& c_soapvar::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapvar
Variant& c_soapvar::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapvar
Variant& c_soapvar::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapvar
Variant c_soapvar::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapvar
IMPLEMENT_CLASS(soapvar)
c_soapvar *c_soapvar::create(Variant a0, Variant a1, String a2, String a3, String a4, String a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_soapvar::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_soapvar::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_soapvar::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_soapvar::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapvar::cloneImpl() {
  c_soapvar *obj = NEW(c_soapvar)();
  cloneSet(obj);
  return obj;
}
void c_soapvar::cloneSet(c_soapvar *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
Variant c_soapvar::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
Variant c_soapvar::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapvar
Variant c_soapvar::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapvar
Variant c_soapvar::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapvar::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapvar = {
  c_soapvar::os_getInit,
  c_soapvar::os_get,
  c_soapvar::os_lval,
  c_soapvar::os_invoke,
  c_soapvar::os_constant,
};
Object co_domnamednodemap(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnamednodemap)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnamednodemap
Variant c_domnamednodemap::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnamednodemap
Variant c_domnamednodemap::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnamednodemap
Variant &c_domnamednodemap::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnamednodemap
void c_domnamednodemap::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnamednodemap
void c_domnamednodemap::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnamednodemap
Variant c_domnamednodemap::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnamednodemap
Variant c_domnamednodemap::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnamednodemap
Variant c_domnamednodemap::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnamednodemap
bool c_domnamednodemap::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnamednodemap
bool c_domnamednodemap::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnamednodemap
bool c_domnamednodemap::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnamednodemap
Variant c_domnamednodemap::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnamednodemap
Variant c_domnamednodemap::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnamednodemap
Variant c_domnamednodemap::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnamednodemap
Variant& c_domnamednodemap::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnamednodemap
Variant& c_domnamednodemap::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnamednodemap
Variant& c_domnamednodemap::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnamednodemap
Variant c_domnamednodemap::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnamednodemap
IMPLEMENT_CLASS(domnamednodemap)
c_domnamednodemap *c_domnamednodemap::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnamednodemap::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnamednodemap::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnamednodemap::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnamednodemap::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnamednodemap::cloneImpl() {
  c_domnamednodemap *obj = NEW(c_domnamednodemap)();
  cloneSet(obj);
  return obj;
}
void c_domnamednodemap::cloneSet(c_domnamednodemap *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnamednodemap::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 0x78:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnameditem(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x7b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getnameditemns(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getnameditem")) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnameditem(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getnameditemns")) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getnameditemns(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 0x78:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x7b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getnameditem")) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getnameditemns")) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnamednodemap
Variant c_domnamednodemap::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 0x78:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditem(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x7b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditemns(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getnameditem")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getnameditemns")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnamednodemap::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnamednodemap = {
  c_domnamednodemap::os_getInit,
  c_domnamednodemap::os_get,
  c_domnamednodemap::os_lval,
  c_domnamednodemap::os_invoke,
  c_domnamednodemap::os_constant,
};
Object co_sqlite3result(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3result)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3result
Variant c_sqlite3result::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3result
Variant c_sqlite3result::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3result
Variant &c_sqlite3result::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3result
void c_sqlite3result::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3result
void c_sqlite3result::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3result
Variant c_sqlite3result::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3result
Variant c_sqlite3result::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3result
Variant c_sqlite3result::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3result
bool c_sqlite3result::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3result
bool c_sqlite3result::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3result
bool c_sqlite3result::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3result
Variant c_sqlite3result::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3result
Variant c_sqlite3result::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3result
Variant c_sqlite3result::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3result
Variant& c_sqlite3result::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3result
Variant& c_sqlite3result::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3result
Variant& c_sqlite3result::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3result
Variant c_sqlite3result::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3result
IMPLEMENT_CLASS(sqlite3result)
c_sqlite3result *c_sqlite3result::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_sqlite3result::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_sqlite3result::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_sqlite3result::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_sqlite3result::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3result::cloneImpl() {
  c_sqlite3result *obj = NEW(c_sqlite3result)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3result::cloneSet(c_sqlite3result *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x187:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columnname(arg0));
        }
      }
      break;
    case 0x188:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columntype(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x189:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 0x18a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetcharray());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetcharray(arg0));
        }
      }
      break;
    case 0x18b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0x18c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columnname(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetcharray());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetcharray(arg0));
        }
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columntype(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x187:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(a0));
      }
      break;
    case 0x188:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x189:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 0x18a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        return (t_fetcharray(a0));
      }
      break;
    case 0x18b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0x18c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3result
Variant c_sqlite3result::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x187:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columnname(a0));
      }
      break;
    case 0x188:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columntype(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x189:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_numcolumns());
      }
      break;
    case 0x18a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 0x18b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 0x18c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_finalize());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3result::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3result = {
  c_sqlite3result::os_getInit,
  c_sqlite3result::os_get,
  c_sqlite3result::os_lval,
  c_sqlite3result::os_invoke,
  c_sqlite3result::os_constant,
};
Object co_simplexmlelement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_simplexmlelement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelement
Variant c_simplexmlelement::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelement
Variant c_simplexmlelement::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelement
Variant &c_simplexmlelement::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelement
void c_simplexmlelement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelement
void c_simplexmlelement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_simplexmlelement
Variant c_simplexmlelement::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelement
Variant c_simplexmlelement::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelement
Variant c_simplexmlelement::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_simplexmlelement
bool c_simplexmlelement::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelement
bool c_simplexmlelement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelement
bool c_simplexmlelement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_simplexmlelement
Variant c_simplexmlelement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelement
Variant c_simplexmlelement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelement
Variant c_simplexmlelement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_simplexmlelement
Variant& c_simplexmlelement::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelement
Variant& c_simplexmlelement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelement
Variant& c_simplexmlelement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelement
Variant c_simplexmlelement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelement
IMPLEMENT_CLASS(simplexmlelement)
c_simplexmlelement *c_simplexmlelement::create(String a0, int64 a1, bool a2, String a3, bool a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_simplexmlelement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_simplexmlelement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_simplexmlelement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_simplexmlelement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_simplexmlelement::cloneImpl() {
  c_simplexmlelement *obj = NEW(c_simplexmlelement)();
  cloneSet(obj);
  return obj;
}
void c_simplexmlelement::cloneSet(c_simplexmlelement *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_simplexmlelement::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x141:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addattribute(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addattribute(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addattribute(arg0, arg1, arg2), null);
        }
      }
      break;
    case 0xf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x142:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xpath(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 0xa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetexists(arg0));
        }
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x143:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registerxpathnamespace(arg0, arg1));
        }
      }
      break;
    case 0xb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetget(arg0));
        }
      }
      break;
    case 0x144:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnamespaces(arg0));
        }
      }
      break;
    case 0x145:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___unset(arg0));
        }
      }
      break;
    case 0x146:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_asxml());
          CVarRef arg0((ad->getValue(pos)));
          return (t_asxml(arg0));
        }
      }
      break;
    case 0x147:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getdocnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getdocnamespaces(arg0));
        }
      }
      break;
    case 0xc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetunset(arg0), null);
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x148:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_children());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_children(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_children(arg0, arg1));
        }
      }
      break;
    case 0x149:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addchild(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addchild(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addchild(arg0, arg1, arg2));
        }
      }
      break;
    case 0x14a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___isset(arg0));
        }
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 0x14b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_attributes());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_attributes(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_attributes(arg0, arg1));
        }
      }
      break;
    case 0xd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_offsetset(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700_1, "offsetexists")) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetexists(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addchild")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addchild(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addchild(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addchild(arg0, arg1, arg2));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addattribute")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addattribute(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addattribute(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addattribute(arg0, arg1, arg2), null);
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68_1, "offsetget")) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetget(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xpath(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___unset(arg0));
        }
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_attributes());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_attributes(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_attributes(arg0, arg1));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b_1, "getname")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getnamespaces")) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnamespaces(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asxml")) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_asxml());
          CVarRef arg0((ad->getValue(pos)));
          return (t_asxml(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_children());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_children(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_children(arg0, arg1));
        }
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___isset(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getdocnamespaces")) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getdocnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getdocnamespaces(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8_1, "offsetset")) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_offsetset(arg0, arg1), null);
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546_1, "offsetunset")) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetunset(arg0), null);
        }
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerxpathnamespace")) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registerxpathnamespace(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x141:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(a0), null);
        if (count == 2) return (t_addattribute(a0, a1), null);
        return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 0xf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x142:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0xa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(a0));
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x143:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    case 0xb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(a0));
      }
      break;
    case 0x144:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        return (t_getnamespaces(a0));
      }
      break;
    case 0x145:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(a0));
      }
      break;
    case 0x146:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        return (t_asxml(a0));
      }
      break;
    case 0x147:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        return (t_getdocnamespaces(a0));
      }
      break;
    case 0xc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(a0), null);
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x148:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        if (count == 1) return (t_children(a0));
        return (t_children(a0, a1));
      }
      break;
    case 0x149:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(a0));
        if (count == 2) return (t_addchild(a0, a1));
        return (t_addchild(a0, a1, a2));
      }
      break;
    case 0x14a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        return (t___isset(a0));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 0x14b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        if (count == 1) return (t_attributes(a0));
        return (t_attributes(a0, a1));
      }
      break;
    case 0xd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(a0, a1), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700_1, "offsetexists")) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addchild")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(a0));
        if (count == 2) return (t_addchild(a0, a1));
        return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addattribute")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(a0), null);
        if (count == 2) return (t_addattribute(a0, a1), null);
        return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68_1, "offsetget")) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(a0));
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        if (count == 1) return (t_attributes(a0));
        return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b_1, "getname")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getnamespaces")) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        return (t_getnamespaces(a0));
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asxml")) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        if (count == 1) return (t_children(a0));
        return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getdocnamespaces")) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8_1, "offsetset")) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546_1, "offsetunset")) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerxpathnamespace")) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelement
Variant c_simplexmlelement::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x141:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 0xf:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_count());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x142:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xpath(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0xa:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetexists(a0));
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 0x143:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    case 0xb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetget(a0));
      }
      break;
    case 0x144:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      break;
    case 0x145:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___unset(a0));
      }
      break;
    case 0x146:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 0x147:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 0xc:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetunset(a0), null);
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x148:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 0x149:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 0x14a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___isset(a0));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x14b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 0xd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetset(a0, a1), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700_1, "offsetexists")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getiterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addchild")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addattribute")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68_1, "offsetget")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xpath(a0));
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b_1, "getname")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getnamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asxml")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getdocnamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8_1, "offsetset")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546_1, "offsetunset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerxpathnamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_simplexmlelement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_simplexmlelement = {
  c_simplexmlelement::os_getInit,
  c_simplexmlelement::os_get,
  c_simplexmlelement::os_lval,
  c_simplexmlelement::os_invoke,
  c_simplexmlelement::os_constant,
};
Object co_memcache(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_memcache)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_memcache
Variant c_memcache::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_memcache
Variant c_memcache::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_memcache
Variant &c_memcache::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_memcache
void c_memcache::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_memcache
void c_memcache::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_get_memcache
Variant c_memcache::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_memcache
Variant c_memcache::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_memcache
Variant c_memcache::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_exists_memcache
bool c_memcache::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_memcache
bool c_memcache::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_memcache
bool c_memcache::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_set_memcache
Variant c_memcache::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_memcache
Variant c_memcache::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_memcache
Variant c_memcache::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_lval_memcache
Variant& c_memcache::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_memcache
Variant& c_memcache::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_memcache
Variant& c_memcache::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_memcache
Variant c_memcache::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_memcache
IMPLEMENT_CLASS(memcache)
c_memcache *c_memcache::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_memcache::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_memcache::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_memcache::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_memcache::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_memcache::cloneImpl() {
  c_memcache *obj = NEW(c_memcache)();
  cloneSet(obj);
  return obj;
}
void c_memcache::cloneSet(c_memcache *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
Variant c_memcache::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xc9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addserver(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addserver(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_addserver(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_addserver(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_addserver(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 6) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5));
          CVarRef arg6((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 7) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
          CVarRef arg7((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 8) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
          CVarRef arg8((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
        }
      }
      break;
    case 0xca:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_set(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_set(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_set(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xcb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setserverparams(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_setserverparams(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_setserverparams(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_setserverparams(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_setserverparams(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setserverparams(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xcc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_increment(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_increment(arg0, arg1));
        }
      }
      break;
    case 0xcd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_decrement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_decrement(arg0, arg1));
        }
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getstats(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_getstats(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getstats(arg0, arg1, arg2));
        }
      }
      break;
    case 0xcf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getserverstatus(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getserverstatus(arg0, arg1));
        }
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0xd0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setoptimeout(arg0));
        }
      }
      break;
    case 0xd1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setcompressthreshold(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setcompressthreshold(arg0, arg1));
        }
      }
      break;
    case 0xd2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_get(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t_get(arg0, ref(arg1)));
        }
      }
      break;
    case 0xd4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_add(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_add(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_add(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xd3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_pconnect(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_pconnect(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_pconnect(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_pconnect(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0xd5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 0xd6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_delete(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_delete(arg0, arg1));
        }
      }
      break;
    case 0xd7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_connect(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_connect(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_connect(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_connect(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 0xd8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_replace(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_replace(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replace(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xda:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getextendedstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getextendedstats(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_getextendedstats(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getextendedstats(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_replace(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_replace(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replace(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_increment(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_increment(arg0, arg1));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setoptimeout(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_add(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_add(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_add(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getserverstatus(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getserverstatus(arg0, arg1));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setcompressthreshold(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setcompressthreshold(arg0, arg1));
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_delete(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_delete(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getstats(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_getstats(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getstats(arg0, arg1, arg2));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_decrement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_decrement(arg0, arg1));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_set(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_set(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_set(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getextendedstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getextendedstats(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_getextendedstats(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getextendedstats(arg0, arg1, arg2));
        }
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addserver(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addserver(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_addserver(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_addserver(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_addserver(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 6) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5));
          CVarRef arg6((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 7) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
          CVarRef arg7((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 8) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
          CVarRef arg8((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
        }
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_get(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t_get(arg0, ref(arg1)));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_pconnect(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_pconnect(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_pconnect(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_pconnect(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setserverparams(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_setserverparams(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_setserverparams(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_setserverparams(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_setserverparams(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setserverparams(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_connect(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_connect(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_connect(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_connect(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
Variant c_memcache::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xc9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        if (count <= 1) return (t_addserver(a0));
        if (count == 2) return (t_addserver(a0, a1));
        if (count == 3) return (t_addserver(a0, a1, a2));
        if (count == 4) return (t_addserver(a0, a1, a2, a3));
        if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        return (t_addserver(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0xca:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        if (count <= 2) return (t_set(a0, a1));
        if (count == 3) return (t_set(a0, a1, a2));
        return (t_set(a0, a1, a2, a3));
      }
      break;
    case 0xcb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        if (count <= 1) return (t_setserverparams(a0));
        if (count == 2) return (t_setserverparams(a0, a1));
        if (count == 3) return (t_setserverparams(a0, a1, a2));
        if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xcc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        if (count <= 1) return (t_increment(a0));
        return (t_increment(a0, a1));
      }
      break;
    case 0xcd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        if (count <= 1) return (t_decrement(a0));
        return (t_decrement(a0, a1));
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        if (count <= 0) return (t_getstats());
        if (count == 1) return (t_getstats(a0));
        if (count == 2) return (t_getstats(a0, a1));
        return (t_getstats(a0, a1, a2));
      }
      break;
    case 0xcf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        if (count <= 1) return (t_getserverstatus(a0));
        return (t_getserverstatus(a0, a1));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0xd0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        return (t_setoptimeout(a0));
      }
      break;
    case 0xd1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        if (count <= 1) return (t_setcompressthreshold(a0));
        return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 0xd2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        if (count <= 1) return (t_get(a0));
        return (t_get(a0, ref(a1)));
      }
      break;
    case 0xd4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        if (count <= 2) return (t_add(a0, a1));
        if (count == 3) return (t_add(a0, a1, a2));
        return (t_add(a0, a1, a2, a3));
      }
      break;
    case 0xd3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        if (count <= 1) return (t_pconnect(a0), null);
        if (count == 2) return (t_pconnect(a0, a1), null);
        if (count == 3) return (t_pconnect(a0, a1, a2), null);
        return (t_pconnect(a0, a1, a2, a3), null);
      }
      break;
    case 0xd5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 0xd6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        if (count <= 1) return (t_delete(a0));
        return (t_delete(a0, a1));
      }
      break;
    case 0xd7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        if (count <= 1) return (t_connect(a0), null);
        if (count == 2) return (t_connect(a0, a1), null);
        if (count == 3) return (t_connect(a0, a1, a2), null);
        return (t_connect(a0, a1, a2, a3), null);
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 0xd8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        if (count <= 2) return (t_replace(a0, a1));
        if (count == 3) return (t_replace(a0, a1, a2));
        return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 0xda:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        if (count <= 0) return (t_getextendedstats());
        if (count == 1) return (t_getextendedstats(a0));
        if (count == 2) return (t_getextendedstats(a0, a1));
        return (t_getextendedstats(a0, a1, a2));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        if (count <= 2) return (t_replace(a0, a1));
        if (count == 3) return (t_replace(a0, a1, a2));
        return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        if (count <= 1) return (t_increment(a0));
        return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        return (t_setoptimeout(a0));
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        if (count <= 2) return (t_add(a0, a1));
        if (count == 3) return (t_add(a0, a1, a2));
        return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        if (count <= 1) return (t_getserverstatus(a0));
        return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        if (count <= 1) return (t_setcompressthreshold(a0));
        return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        if (count <= 1) return (t_delete(a0));
        return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        if (count <= 0) return (t_getstats());
        if (count == 1) return (t_getstats(a0));
        if (count == 2) return (t_getstats(a0, a1));
        return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        if (count <= 1) return (t_decrement(a0));
        return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        if (count <= 2) return (t_set(a0, a1));
        if (count == 3) return (t_set(a0, a1, a2));
        return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        if (count <= 0) return (t_getextendedstats());
        if (count == 1) return (t_getextendedstats(a0));
        if (count == 2) return (t_getextendedstats(a0, a1));
        return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        if (count <= 1) return (t_addserver(a0));
        if (count == 2) return (t_addserver(a0, a1));
        if (count == 3) return (t_addserver(a0, a1, a2));
        if (count == 4) return (t_addserver(a0, a1, a2, a3));
        if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        return (t_addserver(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        if (count <= 1) return (t_get(a0));
        return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        if (count <= 1) return (t_pconnect(a0), null);
        if (count == 2) return (t_pconnect(a0, a1), null);
        if (count == 3) return (t_pconnect(a0, a1, a2), null);
        return (t_pconnect(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        if (count <= 1) return (t_setserverparams(a0));
        if (count == 2) return (t_setserverparams(a0, a1));
        if (count == 3) return (t_setserverparams(a0, a1, a2));
        if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        if (count <= 1) return (t_connect(a0), null);
        if (count == 2) return (t_connect(a0, a1), null);
        if (count == 3) return (t_connect(a0, a1, a2), null);
        return (t_connect(a0, a1, a2, a3), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_memcache
Variant c_memcache::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_memcache
Variant c_memcache::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xc9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        Variant a6;
        Variant a7;
        Variant a8;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a6 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a7 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a8 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addserver(a0));
        else if (count == 2) return (t_addserver(a0, a1));
        else if (count == 3) return (t_addserver(a0, a1, a2));
        else if (count == 4) return (t_addserver(a0, a1, a2, a3));
        else if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        else if (count == 6) return (t_addserver(a0, a1, a2, a3, a4, a5));
        else if (count == 7) return (t_addserver(a0, a1, a2, a3, a4, a5, a6));
        else if (count == 8) return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7));
        else return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7, a8));
      }
      break;
    case 0xca:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_set(a0, a1));
        else if (count == 3) return (t_set(a0, a1, a2));
        else return (t_set(a0, a1, a2, a3));
      }
      break;
    case 0xcb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setserverparams(a0));
        else if (count == 2) return (t_setserverparams(a0, a1));
        else if (count == 3) return (t_setserverparams(a0, a1, a2));
        else if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        else if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        else return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0xcc:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 0xcd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getstats());
        else if (count == 1) return (t_getstats(a0));
        else if (count == 2) return (t_getstats(a0, a1));
        else return (t_getstats(a0, a1, a2));
      }
      break;
    case 0xcf:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getserverstatus(a0));
        else return (t_getserverstatus(a0, a1));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 0xd0:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setoptimeout(a0));
      }
      break;
    case 0xd1:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setcompressthreshold(a0));
        else return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 0xd2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_get(a0));
        else return (t_get(a0, ref(a1)));
      }
      break;
    case 0xd4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_add(a0, a1));
        else if (count == 3) return (t_add(a0, a1, a2));
        else return (t_add(a0, a1, a2, a3));
      }
      break;
    case 0xd3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_pconnect(a0), null);
        else if (count == 2) return (t_pconnect(a0, a1), null);
        else if (count == 3) return (t_pconnect(a0, a1, a2), null);
        else return (t_pconnect(a0, a1, a2, a3), null);
      }
      break;
    case 0xd5:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 0xd6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 0xd7:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_connect(a0), null);
        else if (count == 2) return (t_connect(a0, a1), null);
        else if (count == 3) return (t_connect(a0, a1, a2), null);
        else return (t_connect(a0, a1, a2, a3), null);
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 0xd8:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_replace(a0, a1));
        else if (count == 3) return (t_replace(a0, a1, a2));
        else return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 0xda:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getextendedstats());
        else if (count == 1) return (t_getextendedstats(a0));
        else if (count == 2) return (t_getextendedstats(a0, a1));
        else return (t_getextendedstats(a0, a1, a2));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_replace(a0, a1));
        else if (count == 3) return (t_replace(a0, a1, a2));
        else return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setoptimeout(a0));
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_add(a0, a1));
        else if (count == 3) return (t_add(a0, a1, a2));
        else return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getserverstatus(a0));
        else return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setcompressthreshold(a0));
        else return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getstats());
        else if (count == 1) return (t_getstats(a0));
        else if (count == 2) return (t_getstats(a0, a1));
        else return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_set(a0, a1));
        else if (count == 3) return (t_set(a0, a1, a2));
        else return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getextendedstats());
        else if (count == 1) return (t_getextendedstats(a0));
        else if (count == 2) return (t_getextendedstats(a0, a1));
        else return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        Variant a6;
        Variant a7;
        Variant a8;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a6 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a7 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a8 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addserver(a0));
        else if (count == 2) return (t_addserver(a0, a1));
        else if (count == 3) return (t_addserver(a0, a1, a2));
        else if (count == 4) return (t_addserver(a0, a1, a2, a3));
        else if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        else if (count == 6) return (t_addserver(a0, a1, a2, a3, a4, a5));
        else if (count == 7) return (t_addserver(a0, a1, a2, a3, a4, a5, a6));
        else if (count == 8) return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7));
        else return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7, a8));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_get(a0));
        else return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_pconnect(a0), null);
        else if (count == 2) return (t_pconnect(a0, a1), null);
        else if (count == 3) return (t_pconnect(a0, a1, a2), null);
        else return (t_pconnect(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setserverparams(a0));
        else if (count == 2) return (t_setserverparams(a0, a1));
        else if (count == 3) return (t_setserverparams(a0, a1, a2));
        else if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        else if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        else return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_connect(a0), null);
        else if (count == 2) return (t_connect(a0, a1), null);
        else if (count == 3) return (t_connect(a0, a1, a2), null);
        else return (t_connect(a0, a1, a2, a3), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_memcache::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_memcache = {
  c_memcache::os_getInit,
  c_memcache::os_get,
  c_memcache::os_lval,
  c_memcache::os_invoke,
  c_memcache::os_constant,
};
Object co_domprocessinginstruction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domprocessinginstruction)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domprocessinginstruction
Variant c_domprocessinginstruction::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domprocessinginstruction
Variant c_domprocessinginstruction::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domprocessinginstruction
Variant &c_domprocessinginstruction::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domprocessinginstruction
void c_domprocessinginstruction::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domprocessinginstruction
void c_domprocessinginstruction::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_domprocessinginstruction
Variant c_domprocessinginstruction::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domprocessinginstruction
Variant c_domprocessinginstruction::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domprocessinginstruction
Variant c_domprocessinginstruction::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domprocessinginstruction
bool c_domprocessinginstruction::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domprocessinginstruction
bool c_domprocessinginstruction::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domprocessinginstruction
bool c_domprocessinginstruction::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_domprocessinginstruction
Variant c_domprocessinginstruction::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domprocessinginstruction
Variant c_domprocessinginstruction::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domprocessinginstruction
Variant c_domprocessinginstruction::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domprocessinginstruction
Variant c_domprocessinginstruction::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domprocessinginstruction
IMPLEMENT_CLASS(domprocessinginstruction)
c_domprocessinginstruction *c_domprocessinginstruction::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domprocessinginstruction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domprocessinginstruction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domprocessinginstruction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domprocessinginstruction::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domprocessinginstruction::cloneImpl() {
  c_domprocessinginstruction *obj = NEW(c_domprocessinginstruction)();
  cloneSet(obj);
  return obj;
}
void c_domprocessinginstruction::cloneSet(c_domprocessinginstruction *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domprocessinginstruction::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domprocessinginstruction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domprocessinginstruction = {
  c_domprocessinginstruction::os_getInit,
  c_domprocessinginstruction::os_get,
  c_domprocessinginstruction::os_lval,
  c_domprocessinginstruction::os_invoke,
  c_domprocessinginstruction::os_constant,
};
Object co_pdostatement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdostatement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdostatement
Variant c_pdostatement::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdostatement
Variant c_pdostatement::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdostatement
Variant &c_pdostatement::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdostatement
void c_pdostatement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_pdostatement
void c_pdostatement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdostatement
Variant c_pdostatement::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdostatement
Variant c_pdostatement::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdostatement
Variant c_pdostatement::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdostatement
bool c_pdostatement::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdostatement
bool c_pdostatement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdostatement
bool c_pdostatement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdostatement
Variant c_pdostatement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdostatement
Variant c_pdostatement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdostatement
Variant c_pdostatement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdostatement
Variant& c_pdostatement::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdostatement
Variant& c_pdostatement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdostatement
Variant& c_pdostatement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdostatement
Variant c_pdostatement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdostatement
IMPLEMENT_CLASS(pdostatement)
c_pdostatement *c_pdostatement::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_pdostatement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_pdostatement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_pdostatement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_pdostatement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdostatement::cloneImpl() {
  c_pdostatement *obj = NEW(c_pdostatement)();
  cloneSet(obj);
  return obj;
}
void c_pdostatement::cloneSet(c_pdostatement *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
Variant c_pdostatement::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchcolumn());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetchcolumn(arg0));
        }
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0xe9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getcolumnmeta(arg0));
        }
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0xea:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindcolumn(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_bindcolumn(arg0, ref(arg1), arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_bindcolumn(arg0, ref(arg1), arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindcolumn(arg0, ref(arg1), arg2, arg3, arg4));
        }
      }
      break;
    case 0xec:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setfetchmode(count, arg0));
          return (t_setfetchmode(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 0xed:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindparam(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_bindparam(arg0, ref(arg1), arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_bindparam(arg0, ref(arg1), arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindparam(arg0, ref(arg1), arg2, arg3, arg4));
        }
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_execute());
          CVarRef arg0((ad->getValue(pos)));
          return (t_execute(arg0));
        }
      }
      break;
    case 0xf2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchobject());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchobject(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetchobject(arg0, arg1));
        }
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 0xf3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchall());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchall(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fetchall(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetchall(arg0, arg1, arg2));
        }
      }
      break;
    case 0xf5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetch());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetch(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fetch(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetch(arg0, arg1, arg2));
        }
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 0xf6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchall());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchall(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fetchall(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetchall(arg0, arg1, arg2));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_execute());
          CVarRef arg0((ad->getValue(pos)));
          return (t_execute(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindparam(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_bindparam(arg0, ref(arg1), arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_bindparam(arg0, ref(arg1), arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindparam(arg0, ref(arg1), arg2, arg3, arg4));
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchcolumn());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetchcolumn(arg0));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindcolumn(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_bindcolumn(arg0, ref(arg1), arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_bindcolumn(arg0, ref(arg1), arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindcolumn(arg0, ref(arg1), arg2, arg3, arg4));
        }
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchobject());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchobject(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetchobject(arg0, arg1));
        }
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setfetchmode(count, arg0));
          return (t_setfetchmode(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getcolumnmeta(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetch());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetch(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fetch(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetch(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
Variant c_pdostatement::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        return (t_fetchcolumn(a0));
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0xe9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0xea:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xec:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setfetchmode(count,a0, params));
      }
      break;
    case 0xed:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        return (t_execute(a0));
      }
      break;
    case 0xf2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        if (count == 1) return (t_fetchobject(a0));
        return (t_fetchobject(a0, a1));
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 0xf3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        if (count == 1) return (t_fetchall(a0));
        if (count == 2) return (t_fetchall(a0, a1));
        return (t_fetchall(a0, a1, a2));
      }
      break;
    case 0xf5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        if (count == 1) return (t_fetch(a0));
        if (count == 2) return (t_fetch(a0, a1));
        return (t_fetch(a0, a1, a2));
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 0xf6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        if (count == 1) return (t_fetchall(a0));
        if (count == 2) return (t_fetchall(a0, a1));
        return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        if (count == 1) return (t_fetchobject(a0));
        return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setfetchmode(count,a0, params));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        if (count == 1) return (t_fetch(a0));
        if (count == 2) return (t_fetch(a0, a1));
        return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdostatement
Variant c_pdostatement::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdostatement
Variant c_pdostatement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0xe9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcolumnmeta(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0xea:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_nextrowset());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xec:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 0xed:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columncount());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_closecursor());
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rowcount());
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 0xf2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 0xf3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 0xf5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 0xf6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_debugdumpparams());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdostatement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdostatement = {
  c_pdostatement::os_getInit,
  c_pdostatement::os_get,
  c_pdostatement::os_lval,
  c_pdostatement::os_invoke,
  c_pdostatement::os_constant,
};
Object co_soapclient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapclient)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapclient
Variant c_soapclient::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapclient
Variant c_soapclient::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapclient
Variant &c_soapclient::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapclient
void c_soapclient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapclient
void c_soapclient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapclient
Variant c_soapclient::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapclient
Variant c_soapclient::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapclient
Variant c_soapclient::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapclient
bool c_soapclient::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapclient
bool c_soapclient::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapclient
bool c_soapclient::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapclient
Variant c_soapclient::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapclient
Variant c_soapclient::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapclient
Variant c_soapclient::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapclient
Variant& c_soapclient::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapclient
Variant& c_soapclient::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapclient
Variant& c_soapclient::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapclient
Variant c_soapclient::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapclient
IMPLEMENT_CLASS(soapclient)
c_soapclient *c_soapclient::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapclient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_soapclient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_soapclient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_soapclient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapclient::cloneImpl() {
  c_soapclient *obj = NEW(c_soapclient)();
  cloneSet(obj);
  return obj;
}
void c_soapclient::cloneSet(c_soapclient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_soapclient::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
Variant c_soapclient::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x14c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 4) return (t___dorequest(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___dorequest(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x14d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 0x14e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setsoapheaders());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setsoapheaders(arg0));
        }
      }
      break;
    case 0x14f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___setcookie(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___setcookie(arg0, arg1));
        }
      }
      break;
    case 0x150:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___soapcall(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___soapcall(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___soapcall(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t___soapcall(arg0, arg1, arg2, arg3, ref(arg4)));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x151:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setlocation());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setlocation(arg0));
        }
      }
      break;
    case 0x152:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x153:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 0x154:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 0x155:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 0x156:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 0x8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___call(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___call(arg0, arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 4) return (t___dorequest(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___dorequest(arg0, arg1, arg2, arg3, arg4));
        }
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___setcookie(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___setcookie(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___soapcall(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___soapcall(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___soapcall(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t___soapcall(arg0, arg1, arg2, arg3, ref(arg4)));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setsoapheaders());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setsoapheaders(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setlocation());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setlocation(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
Variant c_soapclient::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x14c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        return (t___dorequest(a0, a1, a2, a3, a4));
      }
      break;
    case 0x14d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 0x14e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        return (t___setsoapheaders(a0));
      }
      break;
    case 0x14f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(a0));
        return (t___setcookie(a0, a1));
      }
      break;
    case 0x150:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(a0, a1));
        if (count == 3) return (t___soapcall(a0, a1, a2));
        if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x151:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        return (t___setlocation(a0));
      }
      break;
    case 0x152:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x153:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 0x154:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 0x155:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 0x156:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 0x8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(a0));
        return (t___setcookie(a0, a1));
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(a0, a1));
        if (count == 3) return (t___soapcall(a0, a1, a2));
        if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        return (t___setlocation(a0));
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapclient
Variant c_soapclient::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapclient
Variant c_soapclient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x14c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      break;
    case 0x14d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequest());
      }
      break;
    case 0x14e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 0x14f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      break;
    case 0x150:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x151:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      break;
    case 0x152:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequestheaders());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x153:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getfunctions());
      }
      break;
    case 0x154:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponseheaders());
      }
      break;
    case 0x155:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponse());
      }
      break;
    case 0x156:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___gettypes());
      }
      break;
    case 0x8:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___call(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapclient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapclient = {
  c_soapclient::os_getInit,
  c_soapclient::os_get,
  c_soapclient::os_lval,
  c_soapclient::os_invoke,
  c_soapclient::os_constant,
};
Object co_soapparam(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapparam)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapparam
Variant c_soapparam::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapparam
Variant c_soapparam::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapparam
Variant &c_soapparam::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapparam
void c_soapparam::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapparam
void c_soapparam::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapparam
Variant c_soapparam::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapparam
Variant c_soapparam::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapparam
Variant c_soapparam::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapparam
bool c_soapparam::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapparam
bool c_soapparam::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapparam
bool c_soapparam::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapparam
Variant c_soapparam::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapparam
Variant c_soapparam::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapparam
Variant c_soapparam::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapparam
Variant& c_soapparam::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapparam
Variant& c_soapparam::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapparam
Variant& c_soapparam::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapparam
Variant c_soapparam::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapparam
IMPLEMENT_CLASS(soapparam)
c_soapparam *c_soapparam::create(Variant a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapparam::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_soapparam::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  }
}
void c_soapparam::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_soapparam::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapparam::cloneImpl() {
  c_soapparam *obj = NEW(c_soapparam)();
  cloneSet(obj);
  return obj;
}
void c_soapparam::cloneSet(c_soapparam *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
Variant c_soapparam::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
Variant c_soapparam::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapparam
Variant c_soapparam::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapparam
Variant c_soapparam::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapparam::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapparam = {
  c_soapparam::os_getInit,
  c_soapparam::os_get,
  c_soapparam::os_lval,
  c_soapparam::os_invoke,
  c_soapparam::os_constant,
};
Object co_datetime(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_datetime)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetime
Variant c_datetime::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetime
Variant c_datetime::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetime
Variant &c_datetime::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_datetime
void c_datetime::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_datetime
void c_datetime::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_datetime
Variant c_datetime::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetime
Variant c_datetime::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetime
Variant c_datetime::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_datetime
bool c_datetime::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetime
bool c_datetime::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetime
bool c_datetime::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_datetime
Variant c_datetime::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetime
Variant c_datetime::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetime
Variant c_datetime::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_datetime
Variant& c_datetime::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetime
Variant& c_datetime::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetime
Variant& c_datetime::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_datetime
Variant c_datetime::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_RETURN(0x65F665B8975D4C44LL, q_datetime_RSS, "RSS");
      break;
    case 5:
      HASH_RETURN(0x4C70260A54584B05LL, q_datetime_ATOM, "ATOM");
      break;
    case 9:
      HASH_RETURN(0x0D93F5DDBEAD7BC9LL, q_datetime_ISO8601, "ISO8601");
      break;
    case 10:
      HASH_RETURN(0x2E8A54E476F8FF8ALL, q_datetime_RFC850, "RFC850");
      break;
    case 12:
      HASH_RETURN(0x2183317DB64F7D2CLL, q_datetime_COOKIE, "COOKIE");
      HASH_RETURN(0x51E9E1D29858652CLL, q_datetime_RFC1036, "RFC1036");
      HASH_RETURN(0x2035891FE861602CLL, q_datetime_RFC3339, "RFC3339");
      break;
    case 23:
      HASH_RETURN(0x1CC8F0E77D83F017LL, q_datetime_RFC2822, "RFC2822");
      break;
    case 27:
      HASH_RETURN(0x64B53064426F891BLL, q_datetime_RFC822, "RFC822");
      HASH_RETURN(0x0D99FD60C002B3DBLL, q_datetime_W3C, "W3C");
      break;
    case 30:
      HASH_RETURN(0x325DE23E7968F7FELL, q_datetime_RFC1123, "RFC1123");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_datetime
IMPLEMENT_CLASS(datetime)
c_datetime *c_datetime::create(String a0, Object a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_datetime::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_datetime::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_datetime::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_datetime::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_datetime::cloneImpl() {
  c_datetime *obj = NEW(c_datetime)();
  cloneSet(obj);
  return obj;
}
void c_datetime::cloneSet(c_datetime *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
Variant c_datetime::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x80:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_format(arg0));
        }
      }
      break;
    case 0x81:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setdate(arg0, arg1, arg2));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 0x83:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_settime(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_settime(arg0, arg1, arg2));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x84:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 0x85:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_setisodate(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setisodate(arg0, arg1, arg2));
        }
      }
      break;
    case 0x86:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_settimezone(arg0));
        }
      }
      break;
    case 0x87:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_modify(arg0));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_modify(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setdate")) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setdate(arg0, arg1, arg2));
        }
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getoffset")) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "gettimezone")) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setisodate")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_setisodate(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setisodate(arg0, arg1, arg2));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "settime")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_settime(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_settime(arg0, arg1, arg2));
        }
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "settimezone")) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_settimezone(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_format(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
Variant c_datetime::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x80:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(a0));
      }
      break;
    case 0x81:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 0x83:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(a0, a1));
        return (t_settime(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x84:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 0x85:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(a0, a1));
        return (t_setisodate(a0, a1, a2));
      }
      break;
    case 0x86:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(a0));
      }
      break;
    case 0x87:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setdate")) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getoffset")) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "gettimezone")) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setisodate")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(a0, a1));
        return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "settime")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(a0, a1));
        return (t_settime(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "settimezone")) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetime
Variant c_datetime::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetime
Variant c_datetime::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x80:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_format(a0));
      }
      break;
    case 0x81:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setdate(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset());
      }
      break;
    case 0x83:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x84:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettimezone());
      }
      break;
    case 0x85:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 0x86:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_settimezone(a0));
      }
      break;
    case 0x87:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_modify(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setdate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getoffset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "gettimezone")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setisodate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "settime")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "settimezone")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_datetime::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_datetime = {
  c_datetime::os_getInit,
  c_datetime::os_get,
  c_datetime::os_lval,
  c_datetime::os_invoke,
  c_datetime::os_constant,
};
Object co_collator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_collator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_collator
Variant c_collator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_collator
Variant c_collator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_collator
Variant &c_collator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_collator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_collator
void c_collator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_collator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_collator
void c_collator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_collator
#ifndef OMIT_JUMP_TABLE_CLASS_get_collator
Variant c_collator::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_collator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_collator
Variant c_collator::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_collator
Variant c_collator::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_collator
bool c_collator::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_collator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_collator
bool c_collator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_collator
bool c_collator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_set_collator
Variant c_collator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_collator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_collator
Variant c_collator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_collator
Variant c_collator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_collator
Variant& c_collator::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_collator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_collator
Variant& c_collator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_collator
Variant& c_collator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_collator
Variant c_collator::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_RETURN(0x44D1DA387595A403LL, q_collator_SORT_REGULAR, "SORT_REGULAR");
      HASH_RETURN(0x243ECA9F2933DFC3LL, q_collator_ON, "ON");
      break;
    case 4:
      HASH_RETURN(0x2FC0EE2E1B088E44LL, q_collator_NUMERIC_COLLATION, "NUMERIC_COLLATION");
      break;
    case 7:
      HASH_RETURN(0x11D151DDDD2A4107LL, q_collator_HIRAGANA_QUATERNARY_MODE, "HIRAGANA_QUATERNARY_MODE");
      break;
    case 12:
      HASH_RETURN(0x12C49411F55E648CLL, q_collator_QUATERNARY, "QUATERNARY");
      break;
    case 20:
      HASH_RETURN(0x6A7AD33CDF49E8D4LL, q_collator_SORT_NUMERIC, "SORT_NUMERIC");
      HASH_RETURN(0x342F3FCC372ABD54LL, q_collator_NON_IGNORABLE, "NON_IGNORABLE");
      break;
    case 21:
      HASH_RETURN(0x43A7AE36C693E955LL, q_collator_DEFAULT_VALUE, "DEFAULT_VALUE");
      break;
    case 24:
      HASH_RETURN(0x6DED35804EDAD218LL, q_collator_CASE_LEVEL, "CASE_LEVEL");
      HASH_RETURN(0x0AE48A6C6BE5D798LL, q_collator_LOWER_FIRST, "LOWER_FIRST");
      break;
    case 27:
      HASH_RETURN(0x2C6A6D2A478AF4DBLL, q_collator_UPPER_FIRST, "UPPER_FIRST");
      break;
    case 29:
      HASH_RETURN(0x58342E71EC59E4DDLL, q_collator_IDENTICAL, "IDENTICAL");
      break;
    case 32:
      HASH_RETURN(0x092DDC88428C3A20LL, q_collator_PRIMARY, "PRIMARY");
      break;
    case 33:
      HASH_RETURN(0x713FE3D58B4C7661LL, q_collator_FRENCH_COLLATION, "FRENCH_COLLATION");
      HASH_RETURN(0x25FE54F210EC5FE1LL, q_collator_SECONDARY, "SECONDARY");
      HASH_RETURN(0x6E252898020550A1LL, q_collator_TERTIARY, "TERTIARY");
      break;
    case 35:
      HASH_RETURN(0x2C984380FDBF8563LL, q_collator_STRENGTH, "STRENGTH");
      break;
    case 39:
      HASH_RETURN(0x7306AAA31A7C8BE7LL, q_collator_DEFAULT_STRENGTH, "DEFAULT_STRENGTH");
      break;
    case 45:
      HASH_RETURN(0x304F6E12C5B7486DLL, q_collator_CASE_FIRST, "CASE_FIRST");
      break;
    case 52:
      HASH_RETURN(0x395D56BB0A8525F4LL, q_collator_NORMALIZATION_MODE, "NORMALIZATION_MODE");
      break;
    case 53:
      HASH_RETURN(0x595FDD99C9EFE835LL, q_collator_ALTERNATE_HANDLING, "ALTERNATE_HANDLING");
      break;
    case 60:
      HASH_RETURN(0x334AAA38C97C62FCLL, q_collator_SORT_STRING, "SORT_STRING");
      HASH_RETURN(0x0039CBFC3620143CLL, q_collator_SHIFTED, "SHIFTED");
      break;
    case 61:
      HASH_RETURN(0x136402C9E51A75FDLL, q_collator_OFF, "OFF");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_collator
IMPLEMENT_CLASS(collator)
c_collator *c_collator::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_collator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_collator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_collator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_collator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_collator::cloneImpl() {
  c_collator *obj = NEW(c_collator)();
  cloneSet(obj);
  return obj;
}
void c_collator::cloneSet(c_collator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_collator
Variant c_collator::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0x22:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          return (t_sortwithsortkeys(ref(arg0)));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x24:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          if (count <= 1) return (t_sort(ref(arg0)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_sort(ref(arg0), arg1));
        }
      }
      break;
    case 0x25:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 0x26:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 0x14:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          if (count <= 1) return (t_asort(ref(arg0)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_asort(ref(arg0), arg1));
        }
      }
      break;
    case 0x27:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setstrength(arg0));
        }
      }
      break;
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(o_getClassName(), arg0));
        }
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0x2a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getlocale());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getlocale(arg0));
        }
      }
      break;
    case 0x2b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 0x2c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_compare(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getlocale());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getlocale(arg0));
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          if (count <= 1) return (t_sort(ref(arg0)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_sort(ref(arg0), arg1));
        }
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          return (t_sortwithsortkeys(ref(arg0)));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          if (count <= 1) return (t_asort(ref(arg0)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_asort(ref(arg0), arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_compare(arg0, arg1));
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(o_getClassName(), arg0));
        }
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setstrength(arg0));
        }
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_collator
Variant c_collator::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0x22:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x24:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        if (count <= 1) return (t_sort(ref(a0)));
        return (t_sort(ref(a0), a1));
      }
      break;
    case 0x25:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 0x26:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 0x14:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        if (count <= 1) return (t_asort(ref(a0)));
        return (t_asort(ref(a0), a1));
      }
      break;
    case 0x27:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        return (t_setstrength(a0));
      }
      break;
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x2a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        if (count <= 0) return (t_getlocale());
        return (t_getlocale(a0));
      }
      break;
    case 0x2b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 0x2c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        return (t_compare(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        if (count <= 0) return (t_getlocale());
        return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        if (count <= 1) return (t_sort(ref(a0)));
        return (t_sort(ref(a0), a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        if (count <= 1) return (t_asort(ref(a0)));
        return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_collator
Variant c_collator::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(c, arg0));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(c, arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_collator
Variant c_collator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0x22:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x24:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_sort(ref(a0)));
        else return (t_sort(ref(a0), a1));
      }
      break;
    case 0x25:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrorcode());
      }
      break;
    case 0x26:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstrength());
      }
      break;
    case 0x14:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_asort(ref(a0)));
        else return (t_asort(ref(a0), a1));
      }
      break;
    case 0x27:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstrength(a0));
      }
      break;
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x2a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getlocale());
        else return (t_getlocale(a0));
      }
      break;
    case 0x2b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrormessage());
      }
      break;
    case 0x2c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_compare(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getlocale());
        else return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_sort(ref(a0)));
        else return (t_sort(ref(a0), a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_asort(ref(a0)));
        else return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_collator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(c, a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(c, a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_collator = {
  c_collator::os_getInit,
  c_collator::os_get,
  c_collator::os_lval,
  c_collator::os_invoke,
  c_collator::os_constant,
};
Object co_pdo(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdo)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdo
Variant c_pdo::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdo
Variant c_pdo::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdo
Variant &c_pdo::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdo
void c_pdo::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_pdo
void c_pdo::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdo
Variant c_pdo::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdo
Variant c_pdo::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdo
Variant c_pdo::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdo
bool c_pdo::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdo
bool c_pdo::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdo
bool c_pdo::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdo
Variant c_pdo::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdo
Variant c_pdo::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdo
Variant c_pdo::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdo
Variant& c_pdo::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdo
Variant& c_pdo::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdo
Variant& c_pdo::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdo
Variant c_pdo::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 0:
      HASH_RETURN(0x1800ED92A8884D00LL, q_pdo_ATTR_CASE, "ATTR_CASE");
      break;
    case 2:
      HASH_RETURN(0x07BAFBAE5A431902LL, q_pdo_ATTR_STATEMENT_CLASS, "ATTR_STATEMENT_CLASS");
      break;
    case 4:
      HASH_RETURN(0x0229D662F91D9C04LL, q_pdo_ERRMODE_EXCEPTION, "ERRMODE_EXCEPTION");
      break;
    case 8:
      HASH_RETURN(0x3BE7A02FD980AA08LL, q_pdo_CASE_NATURAL, "CASE_NATURAL");
      break;
    case 13:
      HASH_RETURN(0x099B533427CCC20DLL, q_pdo_FETCH_OBJ, "FETCH_OBJ");
      break;
    case 17:
      HASH_RETURN(0x5FAD218776C6E511LL, q_pdo_FETCH_INTO, "FETCH_INTO");
      break;
    case 25:
      HASH_RETURN(0x78CB81320C710019LL, q_pdo_FETCH_BOUND, "FETCH_BOUND");
      break;
    case 27:
      HASH_RETURN(0x3158D52C3627FE1BLL, q_pdo_MYSQL_ATTR_INIT_COMMAND, "MYSQL_ATTR_INIT_COMMAND");
      break;
    case 28:
      HASH_RETURN(0x03CF598D3CCCD01CLL, q_pdo_ATTR_CLIENT_VERSION, "ATTR_CLIENT_VERSION");
      break;
    case 29:
      HASH_RETURN(0x2BE16C4111A7B41DLL, q_pdo_ATTR_FETCH_CATALOG_NAMES, "ATTR_FETCH_CATALOG_NAMES");
      break;
    case 30:
      HASH_RETURN(0x2A5BA04D0218F11ELL, q_pdo_CASE_LOWER, "CASE_LOWER");
      break;
    case 35:
      HASH_RETURN(0x16B15CF4B0DD7E23LL, q_pdo_FETCH_GROUP, "FETCH_GROUP");
      break;
    case 37:
      HASH_RETURN(0x37F650C462FB6A25LL, q_pdo_CASE_UPPER, "CASE_UPPER");
      break;
    case 42:
      HASH_RETURN(0x262D9BE84029992ALL, q_pdo_PARAM_EVT_FETCH_POST, "PARAM_EVT_FETCH_POST");
      break;
    case 51:
      HASH_RETURN(0x15D2BCCED7726933LL, q_pdo_ATTR_TIMEOUT, "ATTR_TIMEOUT");
      break;
    case 59:
      HASH_RETURN(0x01B17428BEE0243BLL, q_pdo_PARAM_EVT_EXEC_PRE, "PARAM_EVT_EXEC_PRE");
      break;
    case 60:
      HASH_RETURN(0x2739A1D49673D43CLL, q_pdo_ATTR_ERRMODE, "ATTR_ERRMODE");
      HASH_RETURN(0x6AC5C285F4DD863CLL, q_pdo_ATTR_DEFAULT_FETCH_MODE, "ATTR_DEFAULT_FETCH_MODE");
      break;
    case 61:
      HASH_RETURN(0x3E11051E4101D73DLL, q_pdo_ATTR_EMULATE_PREPARES, "ATTR_EMULATE_PREPARES");
      break;
    case 68:
      HASH_RETURN(0x2189354E22363544LL, q_pdo_ATTR_PREFETCH, "ATTR_PREFETCH");
      break;
    case 72:
      HASH_RETURN(0x428D5CA64BB99E48LL, q_pdo_FETCH_UNIQUE, "FETCH_UNIQUE");
      break;
    case 78:
      HASH_RETURN(0x39B4E90F36E93B4ELL, q_pdo_MYSQL_ATTR_READ_DEFAULT_GROUP, "MYSQL_ATTR_READ_DEFAULT_GROUP");
      break;
    case 82:
      HASH_RETURN(0x58A833E2336C6152LL, q_pdo_ATTR_SERVER_INFO, "ATTR_SERVER_INFO");
      break;
    case 86:
      HASH_RETURN(0x57B75F4773C81556LL, q_pdo_PARAM_EVT_NORMALIZE, "PARAM_EVT_NORMALIZE");
      break;
    case 91:
      HASH_RETURN(0x5495020CF262F15BLL, q_pdo_ATTR_CONNECTION_STATUS, "ATTR_CONNECTION_STATUS");
      HASH_RETURN(0x37888F551D85275BLL, q_pdo_ATTR_ORACLE_NULLS, "ATTR_ORACLE_NULLS");
      break;
    case 97:
      HASH_RETURN(0x416A0550A8F12E61LL, q_pdo_MYSQL_ATTR_FOUND_ROWS, "MYSQL_ATTR_FOUND_ROWS");
      break;
    case 101:
      HASH_RETURN(0x15A3522970275465LL, q_pdo_FETCH_ORI_NEXT, "FETCH_ORI_NEXT");
      break;
    case 104:
      HASH_RETURN(0x162EAA2134F1C068LL, q_pdo_ATTR_FETCH_TABLE_NAMES, "ATTR_FETCH_TABLE_NAMES");
      break;
    case 111:
      HASH_RETURN(0x350E9275757FD66FLL, q_pdo_FETCH_ORI_REL, "FETCH_ORI_REL");
      break;
    case 112:
      HASH_RETURN(0x6870D9DE66F43D70LL, q_pdo_FETCH_ASSOC, "FETCH_ASSOC");
      break;
    case 113:
      HASH_RETURN(0x713C8339790FC071LL, q_pdo_ATTR_CURSOR_NAME, "ATTR_CURSOR_NAME");
      break;
    case 116:
      HASH_RETURN(0x1FB97A35B6711374LL, q_pdo_ATTR_MAX_COLUMN_LEN, "ATTR_MAX_COLUMN_LEN");
      break;
    case 117:
      HASH_RETURN(0x0E51487F9370EE75LL, q_pdo_ATTR_AUTOCOMMIT, "ATTR_AUTOCOMMIT");
      break;
    case 121:
      HASH_RETURN(0x630122BA9EC73379LL, q_pdo_PARAM_NULL, "PARAM_NULL");
      HASH_RETURN(0x05B00276031D7D79LL, q_pdo_PARAM_EVT_ALLOC, "PARAM_EVT_ALLOC");
      break;
    case 125:
      HASH_RETURN(0x500C039681520C7DLL, q_pdo_PARAM_BOOL, "PARAM_BOOL");
      break;
    case 126:
      HASH_RETURN(0x5CF4F38A0D7D087ELL, q_pdo_NULL_NATURAL, "NULL_NATURAL");
      break;
    case 131:
      HASH_RETURN(0x3F414F2735132983LL, q_pdo_PARAM_INT, "PARAM_INT");
      break;
    case 132:
      HASH_RETURN(0x2011B5A528057784LL, q_pdo_FETCH_NUM, "FETCH_NUM");
      break;
    case 133:
      HASH_RETURN(0x5451E44C627DD885LL, q_pdo_FETCH_ORI_PRIOR, "FETCH_ORI_PRIOR");
      break;
    case 134:
      HASH_RETURN(0x1B8BA5EEAABCB786LL, q_pdo_PARAM_EVT_EXEC_POST, "PARAM_EVT_EXEC_POST");
      HASH_RETURN(0x1B51C692B91D7486LL, q_pdo_MYSQL_ATTR_USE_BUFFERED_QUERY, "MYSQL_ATTR_USE_BUFFERED_QUERY");
      break;
    case 136:
      HASH_RETURN(0x7E64209D5A925F88LL, q_pdo_PARAM_STR, "PARAM_STR");
      break;
    case 138:
      HASH_RETURN(0x45AB9806DE21EA8ALL, q_pdo_ATTR_CURSOR, "ATTR_CURSOR");
      break;
    case 141:
      HASH_RETURN(0x0EDB017494A81E8DLL, q_pdo_ATTR_DRIVER_NAME, "ATTR_DRIVER_NAME");
      break;
    case 142:
      HASH_RETURN(0x126B3038F3355A8ELL, q_pdo_FETCH_USE_DEFAULT, "FETCH_USE_DEFAULT");
      break;
    case 143:
      HASH_RETURN(0x1F200B094608BE8FLL, q_pdo_ATTR_SERVER_VERSION, "ATTR_SERVER_VERSION");
      HASH_RETURN(0x1175C5F56147488FLL, q_pdo_MYSQL_ATTR_DIRECT_QUERY, "MYSQL_ATTR_DIRECT_QUERY");
      break;
    case 150:
      HASH_RETURN(0x25BE9238386C2796LL, q_pdo_FETCH_PROPS_LATE, "FETCH_PROPS_LATE");
      break;
    case 153:
      HASH_RETURN(0x657BEA5F741C4999LL, q_pdo_FETCH_COLUMN, "FETCH_COLUMN");
      HASH_RETURN(0x18B801DE8D8C9099LL, q_pdo_FETCH_CLASSTYPE, "FETCH_CLASSTYPE");
      break;
    case 156:
      HASH_RETURN(0x1EC178DF86F4FD9CLL, q_pdo_FETCH_SERIALIZE, "FETCH_SERIALIZE");
      break;
    case 160:
      HASH_RETURN(0x052245CE02FBF4A0LL, q_pdo_MYSQL_ATTR_LOCAL_INFILE, "MYSQL_ATTR_LOCAL_INFILE");
      break;
    case 162:
      HASH_RETURN(0x28D5B850B76FEEA2LL, q_pdo_FETCH_BOTH, "FETCH_BOTH");
      HASH_RETURN(0x0D0BCCC6768A88A2LL, q_pdo_FETCH_KEY_PAIR, "FETCH_KEY_PAIR");
      break;
    case 164:
      HASH_RETURN(0x6851B7545234FCA4LL, q_pdo_PARAM_EVT_FETCH_PRE, "PARAM_EVT_FETCH_PRE");
      break;
    case 168:
      HASH_RETURN(0x167DD614E842FAA8LL, q_pdo_CURSOR_FWDONLY, "CURSOR_FWDONLY");
      break;
    case 169:
      HASH_RETURN(0x6AEB66DE7A454FA9LL, q_pdo_FETCH_ORI_FIRST, "FETCH_ORI_FIRST");
      break;
    case 170:
      HASH_RETURN(0x392400A66B305EAALL, q_pdo_CURSOR_SCROLL, "CURSOR_SCROLL");
      break;
    case 171:
      HASH_RETURN(0x2F6AE87AF5701AABLL, q_pdo_FETCH_ORI_LAST, "FETCH_ORI_LAST");
      break;
    case 180:
      HASH_RETURN(0x56D59339A0F5D8B4LL, q_pdo_ATTR_PERSISTENT, "ATTR_PERSISTENT");
      break;
    case 184:
      HASH_RETURN(0x08657D6005DD08B8LL, q_pdo_NULL_EMPTY_STRING, "NULL_EMPTY_STRING");
      break;
    case 197:
      HASH_RETURN(0x60CE39F6493319C5LL, q_pdo_ATTR_STRINGIFY_FETCHES, "ATTR_STRINGIFY_FETCHES");
      break;
    case 198:
      HASH_RETURN(0x61BD1667BB46C9C6LL, q_pdo_MYSQL_ATTR_READ_DEFAULT_FILE, "MYSQL_ATTR_READ_DEFAULT_FILE");
      break;
    case 200:
      HASH_RETURN(0x30D00303975C98C8LL, q_pdo_FETCH_FUNC, "FETCH_FUNC");
      HASH_RETURN(0x47D4494BE4FA26C8LL, q_pdo_FETCH_ORI_ABS, "FETCH_ORI_ABS");
      break;
    case 202:
      HASH_RETURN(0x29B68A596E0615CALL, q_pdo_NULL_TO_STRING, "NULL_TO_STRING");
      break;
    case 203:
      HASH_RETURN(0x73FAA1AA068D19CBLL, q_pdo_MYSQL_ATTR_MAX_BUFFER_SIZE, "MYSQL_ATTR_MAX_BUFFER_SIZE");
      break;
    case 208:
      HASH_RETURN(0x439351C7C64634D0LL, q_pdo_FETCH_CLASS, "FETCH_CLASS");
      break;
    case 209:
      HASH_RETURN(0x5C75BB222F23C4D1LL, q_pdo_FETCH_LAZY, "FETCH_LAZY");
      break;
    case 211:
      HASH_RETURN(0x57F9152D7EC3A5D3LL, q_pdo_MYSQL_ATTR_COMPRESS, "MYSQL_ATTR_COMPRESS");
      break;
    case 220:
      HASH_RETURN(0x4D1DDF7F772C54DCLL, q_pdo_ERRMODE_WARNING, "ERRMODE_WARNING");
      break;
    case 235:
      HASH_RETURN(0x2E4175EAAB1F75EBLL, q_pdo_ERRMODE_SILENT, "ERRMODE_SILENT");
      break;
    case 245:
      HASH_RETURN(0x16017F3F58821EF5LL, q_pdo_ERR_NONE, "ERR_NONE");
      break;
    case 246:
      HASH_RETURN(0x674F9B0D2030C3F6LL, q_pdo_PARAM_LOB, "PARAM_LOB");
      break;
    case 247:
      HASH_RETURN(0x16EC9F213D7F57F7LL, q_pdo_FETCH_NAMED, "FETCH_NAMED");
      break;
    case 248:
      HASH_RETURN(0x6C0021FD5D20A1F8LL, q_pdo_PARAM_INPUT_OUTPUT, "PARAM_INPUT_OUTPUT");
      break;
    case 251:
      HASH_RETURN(0x13EC16B8F7B7B1FBLL, q_pdo_MYSQL_ATTR_IGNORE_SPACE, "MYSQL_ATTR_IGNORE_SPACE");
      break;
    case 253:
      HASH_RETURN(0x51938FCA0AE827FDLL, q_pdo_PARAM_STMT, "PARAM_STMT");
      break;
    case 254:
      HASH_RETURN(0x56335EC3392D8EFELL, q_pdo_PARAM_EVT_FREE, "PARAM_EVT_FREE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdo
IMPLEMENT_CLASS(pdo)
c_pdo *c_pdo::create(String a0, String a1, String a2, Array a3) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3);
  return this;
}
ObjectData *c_pdo::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3));
    } while (false);
  }
  return this;
}
void c_pdo::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_pdo::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
void c_pdo::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdo::cloneImpl() {
  c_pdo *obj = NEW(c_pdo)();
  cloneSet(obj);
  return obj;
}
void c_pdo::cloneSet(c_pdo *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
Variant c_pdo::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_lastinsertid());
          CVarRef arg0((ad->getValue(pos)));
          return (t_lastinsertid(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    case 0xe0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 0xe1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 0xe3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_quote(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_quote(arg0, arg1));
        }
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_prepare(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_prepare(arg0, arg1));
        }
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_lastinsertid());
          CVarRef arg0((ad->getValue(pos)));
          return (t_lastinsertid(arg0));
        }
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_quote(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_quote(arg0, arg1));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_prepare(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_prepare(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
Variant c_pdo::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        return (t_lastinsertid(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 0xe0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 0xe1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 0xe3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(a0));
        return (t_quote(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(a0));
        return (t_prepare(a0, a1));
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(a0));
        return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(a0));
        return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdo
Variant c_pdo::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdo
Variant c_pdo::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 0xe0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rollback());
      }
      break;
    case 0xe1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_commit());
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 0xe3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_begintransaction());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdo::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdo = {
  c_pdo::os_getInit,
  c_pdo::os_get,
  c_pdo::os_lval,
  c_pdo::os_invoke,
  c_pdo::os_constant,
};
Object co_domentity(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domentity)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentity
Variant c_domentity::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentity
Variant c_domentity::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentity
Variant &c_domentity::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domentity
void c_domentity::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domentity
void c_domentity::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_domentity
Variant c_domentity::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentity
Variant c_domentity::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentity
Variant c_domentity::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domentity
bool c_domentity::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentity
bool c_domentity::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentity
bool c_domentity::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_domentity
Variant c_domentity::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentity
Variant c_domentity::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentity
Variant c_domentity::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domentity
Variant& c_domentity::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentity
Variant& c_domentity::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentity
Variant& c_domentity::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domentity
Variant c_domentity::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domentity
IMPLEMENT_CLASS(domentity)
c_domentity *c_domentity::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domentity::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domentity::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domentity::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domentity::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domentity::cloneImpl() {
  c_domentity *obj = NEW(c_domentity)();
  cloneSet(obj);
  return obj;
}
void c_domentity::cloneSet(c_domentity *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domentity::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
Variant c_domentity::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
Variant c_domentity::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentity
Variant c_domentity::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentity
Variant c_domentity::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domentity::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domentity = {
  c_domentity::os_getInit,
  c_domentity::os_get,
  c_domentity::os_lval,
  c_domentity::os_invoke,
  c_domentity::os_constant,
};
Object co_xmlwriter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_xmlwriter)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_xmlwriter
Variant c_xmlwriter::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_xmlwriter
Variant c_xmlwriter::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_xmlwriter
Variant &c_xmlwriter::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_xmlwriter
void c_xmlwriter::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_xmlwriter
void c_xmlwriter::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_xmlwriter
Variant c_xmlwriter::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_xmlwriter
Variant c_xmlwriter::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_xmlwriter
Variant c_xmlwriter::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_xmlwriter
bool c_xmlwriter::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_xmlwriter
bool c_xmlwriter::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_xmlwriter
bool c_xmlwriter::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_xmlwriter
Variant c_xmlwriter::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_xmlwriter
Variant c_xmlwriter::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_xmlwriter
Variant c_xmlwriter::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_xmlwriter
Variant& c_xmlwriter::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_xmlwriter
Variant& c_xmlwriter::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_xmlwriter
Variant& c_xmlwriter::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_xmlwriter
Variant c_xmlwriter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_xmlwriter
IMPLEMENT_CLASS(xmlwriter)
c_xmlwriter *c_xmlwriter::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_xmlwriter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_xmlwriter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_xmlwriter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_xmlwriter::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_xmlwriter::cloneImpl() {
  c_xmlwriter *obj = NEW(c_xmlwriter)();
  cloneSet(obj);
  return obj;
}
void c_xmlwriter::cloneSet(c_xmlwriter *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x18f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_writeelementns(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeelementns(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x192:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_outputmemory());
          CVarRef arg0((ad->getValue(pos)));
          return (t_outputmemory(arg0));
        }
      }
      break;
    case 0x191:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 0x190:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 0x193:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_startdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_startdocument(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_startdocument(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 0x194:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdtdentity(arg0, arg1));
        }
      }
      break;
    case 0x195:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 0x196:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecomment(arg0));
        }
      }
      break;
    case 0x197:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeattribute(arg0, arg1));
        }
      }
      break;
    case 0x198:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x199:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writedtd(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_writedtd(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_writedtd(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtd(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x19a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      break;
    case 0x19b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 0x19c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startelement(arg0));
        }
      }
      break;
    case 0x19d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 0x19e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdelement(arg0));
        }
      }
      break;
    case 0x1a0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 0x19f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecdata(arg0));
        }
      }
      break;
    case 0x1a1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdelement(arg0, arg1));
        }
      }
      break;
    case 0x1a2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeattributens(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x1a3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writepi(arg0, arg1));
        }
      }
      break;
    case 0x1a4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindentstring(arg0));
        }
      }
      break;
    case 0x1a5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startattribute(arg0));
        }
      }
      break;
    case 0x1a6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writeelement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeelement(arg0, arg1));
        }
      }
      break;
    case 0x1a7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 0x1a8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writeraw(arg0));
        }
      }
      break;
    case 0x1a9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_writedtdentity(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_writedtdentity(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_writedtdentity(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 0x1aa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 0x1ab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_startdtd(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_startdtd(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdtd(arg0, arg1, arg2));
        }
      }
      break;
    case 0x1ac:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindent(arg0));
        }
      }
      break;
    case 0x1ad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 0x1ae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdattlist(arg0));
        }
      }
      break;
    case 0x1af:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 0x1b0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdattlist(arg0, arg1));
        }
      }
      break;
    case 0x1b1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 0x1b3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_openuri(arg0));
        }
      }
      break;
    case 0x1b2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 0x1b4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 0x1b5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startpi(arg0));
        }
      }
      break;
    case 0x1b6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_text(arg0));
        }
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 0x1b7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writecdata")) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecdata(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startdtd")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_startdtd(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_startdtd(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdtd(arg0, arg1, arg2));
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writedtd")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writedtd(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_writedtd(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_writedtd(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtd(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openmemory")) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endcdata")) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writecomment")) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecomment(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startattribute")) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startattribute(arg0));
        }
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeelement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writeelement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeelement(arg0, arg1));
        }
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_text(arg0));
        }
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startcdata")) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endpi")) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writedtdattlist")) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdattlist(arg0, arg1));
        }
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setindentstring")) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindentstring(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endelement")) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endcomment")) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeraw")) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writeraw(arg0));
        }
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startdocument")) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_startdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_startdocument(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_startdocument(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputmemory")) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_outputmemory());
          CVarRef arg0((ad->getValue(pos)));
          return (t_outputmemory(arg0));
        }
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openuri")) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_openuri(arg0));
        }
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "enddtd")) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writedtdentity")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_writedtdentity(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_writedtdentity(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_writedtdentity(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "enddtdelement")) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeattribute")) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeattribute(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endattribute")) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startattributens")) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writedtdelement")) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdelement(arg0, arg1));
        }
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeattributens")) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeattributens(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "enddtdentity")) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writepi")) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writepi(arg0, arg1));
        }
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeelementns")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_writeelementns(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeelementns(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startpi")) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startpi(arg0));
        }
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "enddocument")) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startdtdentity")) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdtdentity(arg0, arg1));
        }
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startelement")) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startelement(arg0));
        }
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setindent")) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindent(arg0));
        }
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startelementns")) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startdtdattlist")) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdattlist(arg0));
        }
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "enddtdattlist")) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startdtdelement")) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdelement(arg0));
        }
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullendelement")) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startcomment")) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x18f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 0x192:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        return (t_outputmemory(a0));
      }
      break;
    case 0x191:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 0x190:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 0x193:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        if (count == 1) return (t_startdocument(a0));
        if (count == 2) return (t_startdocument(a0, a1));
        return (t_startdocument(a0, a1, a2));
      }
      break;
    case 0x194:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 0x195:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 0x196:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(a0));
      }
      break;
    case 0x197:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(a0, a1));
      }
      break;
    case 0x198:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x199:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(a0));
        if (count == 2) return (t_writedtd(a0, a1));
        if (count == 3) return (t_writedtd(a0, a1, a2));
        return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x19a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      break;
    case 0x19b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 0x19c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(a0));
      }
      break;
    case 0x19d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 0x19e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(a0));
      }
      break;
    case 0x1a0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 0x19f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(a0));
      }
      break;
    case 0x1a1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 0x1a2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 0x1a3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(a0, a1));
      }
      break;
    case 0x1a4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(a0));
      }
      break;
    case 0x1a5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(a0));
      }
      break;
    case 0x1a6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(a0));
        return (t_writeelement(a0, a1));
      }
      break;
    case 0x1a7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 0x1a8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(a0));
      }
      break;
    case 0x1a9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(a0, a1));
        if (count == 3) return (t_writedtdentity(a0, a1, a2));
        if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x1aa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 0x1ab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(a0));
        if (count == 2) return (t_startdtd(a0, a1));
        return (t_startdtd(a0, a1, a2));
      }
      break;
    case 0x1ac:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(a0));
      }
      break;
    case 0x1ad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 0x1ae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(a0));
      }
      break;
    case 0x1af:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 0x1b0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 0x1b1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 0x1b3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(a0));
      }
      break;
    case 0x1b2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 0x1b4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 0x1b5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(a0));
      }
      break;
    case 0x1b6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(a0));
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 0x1b7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writecdata")) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startdtd")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(a0));
        if (count == 2) return (t_startdtd(a0, a1));
        return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writedtd")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(a0));
        if (count == 2) return (t_writedtd(a0, a1));
        if (count == 3) return (t_writedtd(a0, a1, a2));
        return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openmemory")) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endcdata")) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writecomment")) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(a0));
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startattribute")) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeelement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(a0));
        return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startcdata")) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endpi")) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writedtdattlist")) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setindentstring")) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endelement")) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endcomment")) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeraw")) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startdocument")) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        if (count == 1) return (t_startdocument(a0));
        if (count == 2) return (t_startdocument(a0, a1));
        return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputmemory")) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openuri")) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "enddtd")) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writedtdentity")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(a0, a1));
        if (count == 3) return (t_writedtdentity(a0, a1, a2));
        if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "enddtdelement")) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeattribute")) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endattribute")) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startattributens")) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writedtdelement")) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeattributens")) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "enddtdentity")) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writepi")) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeelementns")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startpi")) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "enddocument")) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startdtdentity")) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startelement")) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setindent")) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startelementns")) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startdtdattlist")) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "enddtdattlist")) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startdtdelement")) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullendelement")) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startcomment")) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_xmlwriter
Variant c_xmlwriter::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x18f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 0x192:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 0x191:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdattlist());
      }
      break;
    case 0x190:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fullendelement());
      }
      break;
    case 0x193:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 0x194:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 0x195:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcdata());
      }
      break;
    case 0x196:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecomment(a0));
      }
      break;
    case 0x197:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattribute(a0, a1));
      }
      break;
    case 0x198:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcomment());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x199:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x19a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdentity());
      }
      break;
    case 0x19b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 0x19c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelement(a0));
      }
      break;
    case 0x19d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 0x19e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdelement(a0));
      }
      break;
    case 0x1a0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddocument());
      }
      break;
    case 0x19f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecdata(a0));
      }
      break;
    case 0x1a1:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 0x1a2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 0x1a3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writepi(a0, a1));
      }
      break;
    case 0x1a4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindentstring(a0));
      }
      break;
    case 0x1a5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattribute(a0));
      }
      break;
    case 0x1a6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 0x1a7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endelement());
      }
      break;
    case 0x1a8:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeraw(a0));
      }
      break;
    case 0x1a9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x1aa:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endpi());
      }
      break;
    case 0x1ab:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 0x1ac:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindent(a0));
      }
      break;
    case 0x1ad:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdelement());
      }
      break;
    case 0x1ae:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdattlist(a0));
      }
      break;
    case 0x1af:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcdata());
      }
      break;
    case 0x1b0:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 0x1b1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtd());
      }
      break;
    case 0x1b3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openuri(a0));
      }
      break;
    case 0x1b2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openmemory());
      }
      break;
    case 0x1b4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endattribute());
      }
      break;
    case 0x1b5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startpi(a0));
      }
      break;
    case 0x1b6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_text(a0));
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 0x1b7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writecdata")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startdtd")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writedtd")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openmemory")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endcdata")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writecomment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecomment(a0));
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeelement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startcdata")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endpi")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writedtdattlist")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setindentstring")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endelement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endcomment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeraw")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startdocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputmemory")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "enddtd")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writedtdentity")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "enddtdelement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endattribute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startattributens")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writedtdelement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeattributens")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "enddtdentity")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writepi")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeelementns")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startpi")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "enddocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startdtdentity")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startelement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setindent")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startelementns")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startdtdattlist")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "enddtdattlist")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startdtdelement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullendelement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startcomment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_xmlwriter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_xmlwriter = {
  c_xmlwriter::os_getInit,
  c_xmlwriter::os_get,
  c_xmlwriter::os_lval,
  c_xmlwriter::os_invoke,
  c_xmlwriter::os_constant,
};
Object co_domexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domexception)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domexception
Variant c_domexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domexception
Variant c_domexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domexception
Variant &c_domexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domexception
void c_domexception::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domexception
void c_domexception::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_domexception
Variant c_domexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domexception
Variant c_domexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domexception
Variant c_domexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domexception
bool c_domexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domexception
bool c_domexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domexception
bool c_domexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_domexception
Variant c_domexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domexception
Variant c_domexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domexception
Variant c_domexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domexception
Variant& c_domexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domexception
Variant& c_domexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domexception
Variant& c_domexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domexception
Variant c_domexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domexception
IMPLEMENT_CLASS(domexception)
c_domexception *c_domexception::create(String a0, int64 a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domexception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domexception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domexception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domexception::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domexception::cloneImpl() {
  c_domexception *obj = NEW(c_domexception)();
  cloneSet(obj);
  return obj;
}
void c_domexception::cloneSet(c_domexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
Variant c_domexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
Variant c_domexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domexception
Variant c_domexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domexception
Variant c_domexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domexception = {
  c_domexception::os_getInit,
  c_domexception::os_get,
  c_domexception::os_lval,
  c_domexception::os_invoke,
  c_domexception::os_constant,
};
Object co_domxpath(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domxpath)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domxpath
Variant c_domxpath::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domxpath
Variant c_domxpath::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domxpath
Variant &c_domxpath::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domxpath
void c_domxpath::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domxpath
void c_domxpath::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_domxpath
Variant c_domxpath::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domxpath
Variant c_domxpath::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domxpath
Variant c_domxpath::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domxpath
bool c_domxpath::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domxpath
bool c_domxpath::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domxpath
bool c_domxpath::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_domxpath
Variant c_domxpath::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domxpath
Variant c_domxpath::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domxpath
Variant c_domxpath::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domxpath
Variant& c_domxpath::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domxpath
Variant& c_domxpath::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domxpath
Variant& c_domxpath::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domxpath
Variant c_domxpath::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domxpath
IMPLEMENT_CLASS(domxpath)
c_domxpath *c_domxpath::create(Variant a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domxpath::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_domxpath::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_domxpath::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domxpath::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domxpath::cloneImpl() {
  c_domxpath *obj = NEW(c_domxpath)();
  cloneSet(obj);
  return obj;
}
void c_domxpath::cloneSet(c_domxpath *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domxpath::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
Variant c_domxpath::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_query(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_query(arg0, arg1));
        }
      }
      break;
    case 0x7d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_evaluate(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_evaluate(arg0, arg1));
        }
      }
      break;
    case 0x7e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_registerphpfunctions());
          CVarRef arg0((ad->getValue(pos)));
          return (t_registerphpfunctions(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x7f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registernamespace(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerphpfunctions")) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_registerphpfunctions());
          CVarRef arg0((ad->getValue(pos)));
          return (t_registerphpfunctions(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_query(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_query(arg0, arg1));
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registernamespace")) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registernamespace(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_evaluate(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_evaluate(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
Variant c_domxpath::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(a0));
        return (t_query(a0, a1));
      }
      break;
    case 0x7d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(a0));
        return (t_evaluate(a0, a1));
      }
      break;
    case 0x7e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        return (t_registerphpfunctions(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x7f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerphpfunctions")) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(a0));
        return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registernamespace")) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(a0));
        return (t_evaluate(a0, a1));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domxpath
Variant c_domxpath::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domxpath
Variant c_domxpath::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 0x7d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      break;
    case 0x7e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x7f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernamespace(a0, a1));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerphpfunctions")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registernamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domxpath::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domxpath = {
  c_domxpath::os_getInit,
  c_domxpath::os_get,
  c_domxpath::os_lval,
  c_domxpath::os_invoke,
  c_domxpath::os_constant,
};
Object co_soapserver(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapserver)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapserver
Variant c_soapserver::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapserver
Variant c_soapserver::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapserver
Variant &c_soapserver::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapserver
void c_soapserver::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapserver
void c_soapserver::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapserver
Variant c_soapserver::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapserver
Variant c_soapserver::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapserver
Variant c_soapserver::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapserver
bool c_soapserver::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapserver
bool c_soapserver::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapserver
bool c_soapserver::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapserver
Variant c_soapserver::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapserver
Variant c_soapserver::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapserver
Variant c_soapserver::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapserver
Variant& c_soapserver::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapserver
Variant& c_soapserver::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapserver
Variant& c_soapserver::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapserver
Variant c_soapserver::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapserver
IMPLEMENT_CLASS(soapserver)
c_soapserver *c_soapserver::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapserver::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_soapserver::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_soapserver::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_soapserver::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapserver::cloneImpl() {
  c_soapserver *obj = NEW(c_soapserver)();
  cloneSet(obj);
  return obj;
}
void c_soapserver::cloneSet(c_soapserver *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
Variant c_soapserver::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x157:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addfunction(arg0), null);
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x120:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addsoapheader(arg0), null);
        }
      }
      break;
    case 0x159:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setpersistence(arg0), null);
        }
      }
      break;
    case 0x15a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_handle(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t_handle(arg0), null);
        }
      }
      break;
    case 0x15b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setobject(arg0), null);
        }
      }
      break;
    case 0x15c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_fault(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_fault(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_fault(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fault(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 0x15d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setclass(count, arg0), null);
          return (t_setclass(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_fault(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_fault(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_fault(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fault(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setpersistence(arg0), null);
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_handle(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t_handle(arg0), null);
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setclass(count, arg0), null);
          return (t_setclass(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setobject(arg0), null);
        }
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addsoapheader(arg0), null);
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addfunction(arg0), null);
        }
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
Variant c_soapserver::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x157:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(a0), null);
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x120:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(a0), null);
      }
      break;
    case 0x159:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(a0), null);
      }
      break;
    case 0x15a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        return (t_handle(a0), null);
      }
      break;
    case 0x15b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(a0), null);
      }
      break;
    case 0x15c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(a0, a1), null);
        if (count == 3) return (t_fault(a0, a1, a2), null);
        if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x15d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setclass(count,a0, params), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(a0, a1), null);
        if (count == 3) return (t_fault(a0, a1, a2), null);
        if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setclass(count,a0, params), null);
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(a0), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapserver
Variant c_soapserver::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapserver
Variant c_soapserver::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x157:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addfunction(a0), null);
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x120:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addsoapheader(a0), null);
      }
      break;
    case 0x159:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setpersistence(a0), null);
      }
      break;
    case 0x15a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 0x15b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setobject(a0), null);
      }
      break;
    case 0x15c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x15d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addfunction(a0), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapserver::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapserver = {
  c_soapserver::os_getInit,
  c_soapserver::os_get,
  c_soapserver::os_lval,
  c_soapserver::os_invoke,
  c_soapserver::os_constant,
};
Object co_domnode(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnode)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnode
Variant c_domnode::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnode
Variant c_domnode::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnode
Variant &c_domnode::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnode
void c_domnode::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnode
void c_domnode::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnode
Variant c_domnode::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnode
Variant c_domnode::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnode
Variant c_domnode::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnode
bool c_domnode::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnode
bool c_domnode::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnode
bool c_domnode::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnode
Variant c_domnode::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnode
Variant c_domnode::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnode
Variant c_domnode::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnode
Variant& c_domnode::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnode
Variant& c_domnode::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnode
Variant& c_domnode::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnode
Variant c_domnode::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnode
IMPLEMENT_CLASS(domnode)
c_domnode *c_domnode::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnode::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnode::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnode::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnode::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnode::cloneImpl() {
  c_domnode *obj = NEW(c_domnode)();
  cloneSet(obj);
  return obj;
}
void c_domnode::cloneSet(c_domnode *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnode::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
Variant c_domnode::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
Variant c_domnode::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnode
Variant c_domnode::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnode
Variant c_domnode::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnode::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnode = {
  c_domnode::os_getInit,
  c_domnode::os_get,
  c_domnode::os_lval,
  c_domnode::os_invoke,
  c_domnode::os_constant,
};
Object co_domdocument(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocument)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocument
Variant c_domdocument::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocument
Variant c_domdocument::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocument
Variant &c_domdocument::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocument
void c_domdocument::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocument
void c_domdocument::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocument
Variant c_domdocument::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocument
Variant c_domdocument::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocument
Variant c_domdocument::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocument
bool c_domdocument::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocument
bool c_domdocument::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocument
bool c_domdocument::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocument
Variant c_domdocument::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocument
Variant c_domdocument::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocument
Variant c_domdocument::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocument
Variant& c_domdocument::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocument
Variant& c_domdocument::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocument
Variant& c_domdocument::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocument
Variant c_domdocument::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocument
IMPLEMENT_CLASS(domdocument)
c_domdocument *c_domdocument::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domdocument::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domdocument::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domdocument::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domdocument::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocument::cloneImpl() {
  c_domdocument *obj = NEW(c_domdocument)();
  cloneSet(obj);
  return obj;
}
void c_domdocument::cloneSet(c_domdocument *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domdocument::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
Variant c_domdocument::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      break;
    case 0x49:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcdatasection(arg0));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x4a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      break;
    case 0x4c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidatesource(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x4d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidate(arg0));
        }
      }
      break;
    case 0x4e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtml(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x4f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createentityreference(arg0));
        }
      }
      break;
    case 0x50:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidate(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x51:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_savexml());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_savexml(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_savexml(arg0, arg1));
        }
      }
      break;
    case 0x52:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createprocessinginstruction(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createprocessinginstruction(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x53:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registernodeclass(arg0, arg1));
        }
      }
      break;
    case 0x54:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_load(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_load(arg0, arg1));
        }
      }
      break;
    case 0x55:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createattributens(arg0, arg1));
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x56:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createelement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createelement(arg0, arg1));
        }
      }
      break;
    case 0x57:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_createelementns(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x58:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_importnode(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_importnode(arg0, arg1));
        }
      }
      break;
    case 0x59:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidatesource(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x5a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createtextnode(arg0));
        }
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x5b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 0x5c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_loadxml(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_loadxml(arg0, arg1));
        }
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x5d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_save(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_save(arg0, arg1));
        }
      }
      break;
    case 0x5e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createattribute(arg0));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x5f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_xinclude());
          CVarRef arg0((ad->getValue(pos)));
          return (t_xinclude(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x60:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtmlfile(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x61:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_savehtmlfile(arg0));
        }
      }
      break;
    case 0x62:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementbyid(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x63:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcomment(arg0));
        }
      }
      break;
    case 0x64:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 0x65:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getelementbyid")) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementbyid(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_xinclude());
          CVarRef arg0((ad->getValue(pos)));
          return (t_xinclude(arg0));
        }
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createcdatasection")) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcdatasection(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemavalidatesource")) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidatesource(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_save(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_save(arg0, arg1));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createattributens")) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createattributens(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxngvalidate")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidate(arg0));
        }
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadhtml")) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtml(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createelement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createelement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createelement(arg0, arg1));
        }
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxngvalidatesource")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidatesource(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createattribute")) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createattribute(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importnode")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_importnode(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_importnode(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadhtmlfile")) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtmlfile(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadxml")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_loadxml(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_loadxml(arg0, arg1));
        }
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createentityreference")) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createentityreference(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createcomment")) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcomment(arg0));
        }
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemavalidate")) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidate(arg0));
        }
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getelementsbytagname")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getelementsbytagnamens")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "savehtmlfile")) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_savehtmlfile(arg0));
        }
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "savehtml")) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_load(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_load(arg0, arg1));
        }
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "savexml")) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_savexml());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_savexml(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_savexml(arg0, arg1));
        }
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizedocument")) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createelementns")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_createelementns(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createprocessinginstruction")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createprocessinginstruction(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createprocessinginstruction(arg0, arg1));
        }
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registernodeclass")) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registernodeclass(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createdocumentfragment")) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createtextnode")) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createtextnode(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
Variant c_domdocument::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x49:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x4c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x4d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(a0));
      }
      break;
    case 0x4e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x4f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(a0));
      }
      break;
    case 0x50:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x51:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        if (count == 1) return (t_savexml(a0));
        return (t_savexml(a0, a1));
      }
      break;
    case 0x52:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(a0));
        return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x53:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(a0, a1));
      }
      break;
    case 0x54:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(a0));
        return (t_load(a0, a1));
      }
      break;
    case 0x55:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(a0, a1));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x56:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(a0));
        return (t_createelement(a0, a1));
      }
      break;
    case 0x57:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(a0, a1));
        return (t_createelementns(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x58:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(a0));
        return (t_importnode(a0, a1));
      }
      break;
    case 0x59:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x5a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x5b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 0x5c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(a0));
        return (t_loadxml(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x5d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(a0));
        return (t_save(a0, a1));
      }
      break;
    case 0x5e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(a0));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x5f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        return (t_xinclude(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x60:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x61:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(a0));
      }
      break;
    case 0x62:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x63:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(a0));
      }
      break;
    case 0x64:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 0x65:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getelementbyid")) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createcdatasection")) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemavalidatesource")) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(a0));
        return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createattributens")) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxngvalidate")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadhtml")) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(a0));
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createelement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(a0));
        return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxngvalidatesource")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createattribute")) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importnode")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(a0));
        return (t_importnode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadhtmlfile")) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadxml")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(a0));
        return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createentityreference")) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createcomment")) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemavalidate")) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getelementsbytagname")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getelementsbytagnamens")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "savehtmlfile")) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "savehtml")) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(a0));
        return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "savexml")) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        if (count == 1) return (t_savexml(a0));
        return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizedocument")) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createelementns")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(a0, a1));
        return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createprocessinginstruction")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(a0));
        return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registernodeclass")) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createdocumentfragment")) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createtextnode")) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocument
Variant c_domdocument::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocument
Variant c_domdocument::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x49:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcdatasection(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_validate());
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x4c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidatesource(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x4d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidate(a0));
      }
      break;
    case 0x4e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtml(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x4f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createentityreference(a0));
      }
      break;
    case 0x50:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidate(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x51:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 0x52:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x53:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernodeclass(a0, a1));
      }
      break;
    case 0x54:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 0x55:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattributens(a0, a1));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x56:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 0x57:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x58:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      break;
    case 0x59:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidatesource(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x5a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createtextnode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x5b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtml());
      }
      break;
    case 0x5c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x5d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 0x5e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattribute(a0));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x5f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x60:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtmlfile(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x61:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtmlfile(a0));
      }
      break;
    case 0x62:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementbyid(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 0x63:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcomment(a0));
      }
      break;
    case 0x64:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalizedocument(), null);
      }
      break;
    case 0x65:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createdocumentfragment());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getelementbyid")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createcdatasection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemavalidatesource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createattributens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxngvalidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadhtml")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtml(a0));
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createelement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxngvalidatesource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importnode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadhtmlfile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadxml")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createentityreference")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createcomment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemavalidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getelementsbytagname")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getelementsbytagnamens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "savehtmlfile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "savehtml")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "savexml")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizedocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createelementns")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createprocessinginstruction")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registernodeclass")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createdocumentfragment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createtextnode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocument::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocument = {
  c_domdocument::os_getInit,
  c_domdocument::os_get,
  c_domdocument::os_lval,
  c_domdocument::os_invoke,
  c_domdocument::os_constant,
};
Object co_libxmlerror(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_libxmlerror)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_libxmlerror
Variant c_libxmlerror::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_libxmlerror
Variant c_libxmlerror::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_libxmlerror
Variant &c_libxmlerror::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_libxmlerror
void c_libxmlerror::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_libxmlerror
void c_libxmlerror::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_libxmlerror
Variant c_libxmlerror::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_libxmlerror
Variant c_libxmlerror::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_libxmlerror
Variant c_libxmlerror::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_libxmlerror
bool c_libxmlerror::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_libxmlerror
bool c_libxmlerror::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_libxmlerror
bool c_libxmlerror::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_libxmlerror
Variant c_libxmlerror::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_libxmlerror
Variant c_libxmlerror::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_libxmlerror
Variant c_libxmlerror::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_libxmlerror
Variant& c_libxmlerror::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_libxmlerror
Variant& c_libxmlerror::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_libxmlerror
Variant& c_libxmlerror::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_libxmlerror
Variant c_libxmlerror::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_libxmlerror
IMPLEMENT_CLASS(libxmlerror)
c_libxmlerror *c_libxmlerror::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_libxmlerror::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_libxmlerror::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_libxmlerror::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_libxmlerror::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_libxmlerror::cloneImpl() {
  c_libxmlerror *obj = NEW(c_libxmlerror)();
  cloneSet(obj);
  return obj;
}
void c_libxmlerror::cloneSet(c_libxmlerror *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_libxmlerror
Variant c_libxmlerror::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_libxmlerror::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_libxmlerror = {
  c_libxmlerror::os_getInit,
  c_libxmlerror::os_get,
  c_libxmlerror::os_lval,
  c_libxmlerror::os_invoke,
  c_libxmlerror::os_constant,
};
Object co_soapfault(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapfault)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapfault
Variant c_soapfault::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapfault
Variant c_soapfault::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapfault
Variant &c_soapfault::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapfault
void c_soapfault::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapfault
void c_soapfault::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapfault
Variant c_soapfault::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapfault
Variant c_soapfault::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapfault
Variant c_soapfault::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapfault
bool c_soapfault::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapfault
bool c_soapfault::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapfault
bool c_soapfault::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapfault
Variant c_soapfault::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapfault
Variant c_soapfault::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapfault
Variant c_soapfault::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapfault
Variant& c_soapfault::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapfault
Variant& c_soapfault::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapfault
Variant& c_soapfault::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapfault
Variant c_soapfault::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapfault
IMPLEMENT_CLASS(soapfault)
c_soapfault *c_soapfault::create(Variant a0, String a1, String a2, Variant a3, String a4, Variant a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_soapfault::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_soapfault::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_soapfault::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_soapfault::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapfault::cloneImpl() {
  c_soapfault *obj = NEW(c_soapfault)();
  cloneSet(obj);
  return obj;
}
void c_soapfault::cloneSet(c_soapfault *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
Variant c_soapfault::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
Variant c_soapfault::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapfault
Variant c_soapfault::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapfault
Variant c_soapfault::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapfault::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapfault = {
  c_soapfault::os_getInit,
  c_soapfault::os_get,
  c_soapfault::os_lval,
  c_soapfault::os_invoke,
  c_soapfault::os_constant,
};
Object co_domelement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domelement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domelement
Variant c_domelement::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domelement
Variant c_domelement::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domelement
Variant &c_domelement::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domelement
void c_domelement::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domelement
void c_domelement::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_domelement
Variant c_domelement::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domelement
Variant c_domelement::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domelement
Variant c_domelement::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domelement
bool c_domelement::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domelement
bool c_domelement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domelement
bool c_domelement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_domelement
Variant c_domelement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domelement
Variant c_domelement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domelement
Variant c_domelement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domelement
Variant& c_domelement::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domelement
Variant& c_domelement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domelement
Variant& c_domelement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domelement
Variant c_domelement::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domelement
IMPLEMENT_CLASS(domelement)
c_domelement *c_domelement::create(String a0, String a1, String a2) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2);
  return this;
}
ObjectData *c_domelement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2));
    } while (false);
  }
  return this;
}
void c_domelement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2));
  } while (false);
}
void c_domelement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else (t___construct(a0, a1, a2), null);
}
void c_domelement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domelement::cloneImpl() {
  c_domelement *obj = NEW(c_domelement)();
  cloneSet(obj);
  return obj;
}
void c_domelement::cloneSet(c_domelement *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domelement::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
Variant c_domelement::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      break;
    case 0x67:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      break;
    case 0x68:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getattributenodens(arg0, arg1));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2), null);
        }
      }
      break;
    case 0x69:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasattribute(arg0));
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x6a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_hasattributens(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x6b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenodens(arg0));
        }
      }
      break;
    case 0x6c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x6d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getattributens(arg0, arg1));
        }
      }
      break;
    case 0x6e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_removeattributens(arg0, arg1));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x6f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattributenode(arg0));
        }
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x70:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattribute(arg0, arg1));
        }
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x71:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattributenode(arg0, arg1));
        }
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0x72:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattributenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x73:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattribute(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x74:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenode(arg0));
        }
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeattributens")) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_removeattributens(arg0, arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setidattributens")) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setidattribute")) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattribute(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getattributenodens")) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getattributenodens(arg0, arg1));
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getattributens")) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getattributens(arg0, arg1));
        }
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeattribute")) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattribute(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getelementsbytagname")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getelementsbytagnamens")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setidattributenode")) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattributenode(arg0, arg1));
        }
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setattributenodens")) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenodens(arg0));
        }
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasattributens")) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_hasattributens(arg0, arg1));
        }
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setattributens")) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setattributenode")) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenode(arg0));
        }
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2), null);
        }
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeattributenode")) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattributenode(arg0));
        }
      }
      break;
    case 108:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasattribute")) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasattribute(arg0));
        }
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getattributenode")) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattributenode(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
Variant c_domelement::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x67:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x68:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        return (t___construct(a0, a1, a2), null);
      }
      break;
    case 0x69:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(a0));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x6a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x6b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(a0));
      }
      break;
    case 0x6c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x6d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(a0, a1));
      }
      break;
    case 0x6e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(a0, a1));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x6f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x70:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x71:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x72:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x73:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x74:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeattributens")) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setidattributens")) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setidattribute")) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getattributenodens")) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getattributens")) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeattribute")) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getelementsbytagname")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getelementsbytagnamens")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setidattributenode")) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setattributenodens")) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasattributens")) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setattributens")) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setattributenode")) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeattributenode")) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasattribute")) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getattributenode")) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domelement
Variant c_domelement::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domelement
Variant c_domelement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x67:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x68:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 0x69:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattribute(a0));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x6a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributens(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x6b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenodens(a0));
      }
      break;
    case 0x6c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x6d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributens(a0, a1));
      }
      break;
    case 0x6e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributens(a0, a1));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x6f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x70:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattribute(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x71:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x72:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x73:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattribute(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 0x74:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenode(a0));
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replacechild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeattributens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setidattributens")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "clonenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setidattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getlineno")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getattributenodens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getattributens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasattributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertbefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getnodepath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getelementsbytagname")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getelementsbytagnamens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setidattributenode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendchild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setattributenodens")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasattributens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setattributens")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setattributenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupnamespaceuri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removechild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupprefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isdefaultnamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeattributenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "issamenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "issupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "haschildnodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getattributenode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domelement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domelement = {
  c_domelement::os_getInit,
  c_domelement::os_get,
  c_domelement::os_lval,
  c_domelement::os_invoke,
  c_domelement::os_constant,
};
Variant get_builtin_class_var_init(const char *s, const char *var) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_CLASS_VAR_INIT(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_CLASS_VAR_INIT(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_CLASS_VAR_INIT(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 18:
      HASH_GET_CLASS_VAR_INIT(0x78B42582709BAF12LL, debuggerproxy);
      break;
    case 19:
      HASH_GET_CLASS_VAR_INIT(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_CLASS_VAR_INIT(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_CLASS_VAR_INIT(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_CLASS_VAR_INIT(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_CLASS_VAR_INIT(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_CLASS_VAR_INIT(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_CLASS_VAR_INIT(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_CLASS_VAR_INIT(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_CLASS_VAR_INIT(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_CLASS_VAR_INIT(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_CLASS_VAR_INIT(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 61:
      HASH_GET_CLASS_VAR_INIT(0x4C6991D3CF5CA03DLL, collator);
      break;
    case 62:
      HASH_GET_CLASS_VAR_INIT(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_CLASS_VAR_INIT(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_CLASS_VAR_INIT(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_CLASS_VAR_INIT(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_CLASS_VAR_INIT(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_CLASS_VAR_INIT(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_CLASS_VAR_INIT(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_CLASS_VAR_INIT(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_CLASS_VAR_INIT(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_CLASS_VAR_INIT(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_CLASS_VAR_INIT(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_CLASS_VAR_INIT(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_CLASS_VAR_INIT(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_CLASS_VAR_INIT(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_CLASS_VAR_INIT(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_CLASS_VAR_INIT(0x70747A09B3523662LL, domnode);
      break;
    case 99:
      HASH_GET_CLASS_VAR_INIT(0x7D1235273F521A63LL, debuggerclient);
      break;
    case 101:
      HASH_GET_CLASS_VAR_INIT(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_CLASS_VAR_INIT(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_CLASS_VAR_INIT(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_CLASS_VAR_INIT(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_CLASS_VAR_INIT(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_CLASS_VAR_INIT(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_CLASS_VAR_INIT(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 117:
      HASH_GET_CLASS_VAR_INIT(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_CLASS_VAR_INIT(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_CLASS_VAR_INIT(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_CLASS_VAR_INIT(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_CLASS_VAR_INIT(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_CLASS_VAR_INIT(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_CLASS_VAR_INIT(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_CLASS_VAR_INIT(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_CLASS_VAR_INIT(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_CLASS_VAR_INIT(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_CLASS_VAR_INIT(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_CLASS_VAR_INIT(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_CLASS_VAR_INIT(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_CLASS_VAR_INIT(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_CLASS_VAR_INIT(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_CLASS_VAR_INIT(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_CLASS_VAR_INIT(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_CLASS_VAR_INIT(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 170:
      HASH_GET_CLASS_VAR_INIT(0x67E31D42F2DFE4AALL, locale);
      break;
    case 173:
      HASH_GET_CLASS_VAR_INIT(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_CLASS_VAR_INIT(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_CLASS_VAR_INIT(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_CLASS_VAR_INIT(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_CLASS_VAR_INIT(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_CLASS_VAR_INIT(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_CLASS_VAR_INIT(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_CLASS_VAR_INIT(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 208:
      HASH_GET_CLASS_VAR_INIT(0x3C122DF8859C72D0LL, memcache);
      break;
    case 210:
      HASH_GET_CLASS_VAR_INIT(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_CLASS_VAR_INIT(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_CLASS_VAR_INIT(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_CLASS_VAR_INIT(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_CLASS_VAR_INIT(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_CLASS_VAR_INIT(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_CLASS_VAR_INIT(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_CLASS_VAR_INIT(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_CLASS_VAR_INIT(0x297174231D4912F4LL, domattr);
      break;
    case 247:
      HASH_GET_CLASS_VAR_INIT(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_CLASS_VAR_INIT(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_CLASS_VAR_INIT(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_CLASS_VAR_INIT(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Object create_builtin_object(const char *s, CArrRef params, bool init /* = true */,ObjectData* root /* = NULL*/) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_CREATE_OBJECT(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_CREATE_OBJECT(0x4365BE9E5A85E60BLL, domnotation);
      HASH_CREATE_OBJECT(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 18:
      HASH_CREATE_OBJECT(0x78B42582709BAF12LL, debuggerproxy);
      break;
    case 19:
      HASH_CREATE_OBJECT(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_CREATE_OBJECT(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_CREATE_OBJECT(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_CREATE_OBJECT(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_CREATE_OBJECT(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_CREATE_OBJECT(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_CREATE_OBJECT(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_CREATE_OBJECT(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_CREATE_OBJECT(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_CREATE_OBJECT(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_CREATE_OBJECT(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 61:
      HASH_CREATE_OBJECT(0x4C6991D3CF5CA03DLL, collator);
      break;
    case 62:
      HASH_CREATE_OBJECT(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_CREATE_OBJECT(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_CREATE_OBJECT(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_CREATE_OBJECT(0x196F76C9C527B946LL, domnamednodemap);
      HASH_CREATE_OBJECT(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_CREATE_OBJECT(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_CREATE_OBJECT(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_CREATE_OBJECT(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_CREATE_OBJECT(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_CREATE_OBJECT(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_CREATE_OBJECT(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_CREATE_OBJECT(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_CREATE_OBJECT(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_CREATE_OBJECT(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_CREATE_OBJECT(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_CREATE_OBJECT(0x70747A09B3523662LL, domnode);
      break;
    case 99:
      HASH_CREATE_OBJECT(0x7D1235273F521A63LL, debuggerclient);
      break;
    case 101:
      HASH_CREATE_OBJECT(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_CREATE_OBJECT(0x7E07B9C27FE59D68LL, domcomment);
      HASH_CREATE_OBJECT(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_CREATE_OBJECT(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_CREATE_OBJECT(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_CREATE_OBJECT(0x3D5870E53BF89873LL, arrayiterator);
      HASH_CREATE_OBJECT(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 117:
      HASH_CREATE_OBJECT(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_CREATE_OBJECT(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_CREATE_OBJECT(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_CREATE_OBJECT(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_CREATE_OBJECT(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_CREATE_OBJECT(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_CREATE_OBJECT(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_CREATE_OBJECT(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_CREATE_OBJECT(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_CREATE_OBJECT(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_CREATE_OBJECT(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_CREATE_OBJECT(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_CREATE_OBJECT(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_CREATE_OBJECT(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_CREATE_OBJECT(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_CREATE_OBJECT(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_CREATE_OBJECT(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_CREATE_OBJECT(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 170:
      HASH_CREATE_OBJECT(0x67E31D42F2DFE4AALL, locale);
      break;
    case 173:
      HASH_CREATE_OBJECT(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_CREATE_OBJECT(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_CREATE_OBJECT(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_CREATE_OBJECT(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_CREATE_OBJECT(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_CREATE_OBJECT(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_CREATE_OBJECT(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_CREATE_OBJECT(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 208:
      HASH_CREATE_OBJECT(0x3C122DF8859C72D0LL, memcache);
      break;
    case 210:
      HASH_CREATE_OBJECT(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_CREATE_OBJECT(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_CREATE_OBJECT(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_CREATE_OBJECT(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_CREATE_OBJECT(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_CREATE_OBJECT(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_CREATE_OBJECT(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_CREATE_OBJECT(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_CREATE_OBJECT(0x297174231D4912F4LL, domattr);
      break;
    case 247:
      HASH_CREATE_OBJECT(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_CREATE_OBJECT(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_CREATE_OBJECT(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_CREATE_OBJECT(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Variant invoke_builtin_static_method(const char *s, MethodIndex methodIndex, const char *method, CArrRef params, bool fatal) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_INVOKE_STATIC_METHOD(0x21EF70351574EC09LL, reflectionfunction, methodIndex);
      break;
    case 11:
      HASH_INVOKE_STATIC_METHOD(0x4365BE9E5A85E60BLL, domnotation, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x69EDCA1CC29CFE0BLL, errorexception, methodIndex);
      break;
    case 18:
      HASH_INVOKE_STATIC_METHOD(0x78B42582709BAF12LL, debuggerproxy, methodIndex);
      break;
    case 19:
      HASH_INVOKE_STATIC_METHOD(0x6A76B9AABB7CC713LL, simplexmlelement, methodIndex);
      break;
    case 21:
      HASH_INVOKE_STATIC_METHOD(0x32E5C767255D2515LL, soapfault, methodIndex);
      break;
    case 26:
      HASH_INVOKE_STATIC_METHOD(0x5CBA5B52C68B501ALL, domentityreference, methodIndex);
      break;
    case 29:
      HASH_INVOKE_STATIC_METHOD(0x35A44A5E6AE2E71DLL, reflectionclass, methodIndex);
      break;
    case 30:
      HASH_INVOKE_STATIC_METHOD(0x3DB8FB455A602A1ELL, datetime, methodIndex);
      break;
    case 43:
      HASH_INVOKE_STATIC_METHOD(0x7E66D362EAB5BF2BLL, simplexmlelementiterator, methodIndex);
      break;
    case 49:
      HASH_INVOKE_STATIC_METHOD(0x7A394042E7488231LL, filteriterator, methodIndex);
      break;
    case 50:
      HASH_INVOKE_STATIC_METHOD(0x365899865E2EAA32LL, recursiveiteratoriterator, methodIndex);
      break;
    case 53:
      HASH_INVOKE_STATIC_METHOD(0x7909270014376235LL, soapvar, methodIndex);
      break;
    case 55:
      HASH_INVOKE_STATIC_METHOD(0x7FF7A8442616EF37LL, domnodeiterator, methodIndex);
      break;
    case 56:
      HASH_INVOKE_STATIC_METHOD(0x672AD818DDE95538LL, reflectionexception, methodIndex);
      break;
    case 61:
      HASH_INVOKE_STATIC_METHOD(0x4C6991D3CF5CA03DLL, collator, methodIndex);
      break;
    case 62:
      HASH_INVOKE_STATIC_METHOD(0x49FC1A1F7B878C3ELL, soapserver, methodIndex);
      break;
    case 65:
      HASH_INVOKE_STATIC_METHOD(0x227C70ED5B143841LL, outofboundsexception, methodIndex);
      break;
    case 68:
      HASH_INVOKE_STATIC_METHOD(0x4253D8488B734244LL, pdostatement, methodIndex);
      break;
    case 70:
      HASH_INVOKE_STATIC_METHOD(0x196F76C9C527B946LL, domnamednodemap, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x66282FC8E4EF4E46LL, badfunctioncallexception, methodIndex);
      break;
    case 73:
      HASH_INVOKE_STATIC_METHOD(0x5AA2EE582E0D3849LL, unexpectedvalueexception, methodIndex);
      break;
    case 75:
      HASH_INVOKE_STATIC_METHOD(0x4860DC2F9B0E6D4BLL, logicexception, methodIndex);
      break;
    case 77:
      HASH_INVOKE_STATIC_METHOD(0x164F490DAC49174DLL, domtext, methodIndex);
      break;
    case 78:
      HASH_INVOKE_STATIC_METHOD(0x308D1D59986A3D4ELL, soapheader, methodIndex);
      break;
    case 79:
      HASH_INVOKE_STATIC_METHOD(0x5BA243B9FBA7A64FLL, splobjectstorage, methodIndex);
      break;
    case 80:
      HASH_INVOKE_STATIC_METHOD(0x52EA111229F87A50LL, normalizer, methodIndex);
      break;
    case 83:
      HASH_INVOKE_STATIC_METHOD(0x02239AA5D64B1453LL, domcharacterdata, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x6AF83706F76A9D53LL, rangeexception, methodIndex);
      break;
    case 94:
      HASH_INVOKE_STATIC_METHOD(0x7754323897E8A15ELL, directoryiterator, methodIndex);
      break;
    case 97:
      HASH_INVOKE_STATIC_METHOD(0x70EBB2CC1FBF9761LL, domdocumenttype, methodIndex);
      break;
    case 98:
      HASH_INVOKE_STATIC_METHOD(0x70747A09B3523662LL, domnode, methodIndex);
      break;
    case 99:
      HASH_INVOKE_STATIC_METHOD(0x7D1235273F521A63LL, debuggerclient, methodIndex);
      break;
    case 101:
      HASH_INVOKE_STATIC_METHOD(0x2FF1EF6EBB3DA065LL, xmlwriter, methodIndex);
      break;
    case 104:
      HASH_INVOKE_STATIC_METHOD(0x7E07B9C27FE59D68LL, domcomment, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x17A40D895C55D968LL, soapparam, methodIndex);
      break;
    case 106:
      HASH_INVOKE_STATIC_METHOD(0x6A5B99D5B1A4566ALL, domexception, methodIndex);
      break;
    case 107:
      HASH_INVOKE_STATIC_METHOD(0x3CAE91CFA2AAD16BLL, lengthexception, methodIndex);
      break;
    case 115:
      HASH_INVOKE_STATIC_METHOD(0x3D5870E53BF89873LL, arrayiterator, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x0B61E0BFCFA06573LL, reflectionextension, methodIndex);
      break;
    case 117:
      HASH_INVOKE_STATIC_METHOD(0x085A4F6FD393D475LL, invalidargumentexception, methodIndex);
      break;
    case 122:
      HASH_INVOKE_STATIC_METHOD(0x41A9F7D81254DD7ALL, reflectionobject, methodIndex);
      break;
    case 125:
      HASH_INVOKE_STATIC_METHOD(0x7AD161197633B87DLL, domdocumentfragment, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x2E899D2A2572EF7DLL, sqlite3result, methodIndex);
      break;
    case 128:
      HASH_INVOKE_STATIC_METHOD(0x59B3EFD1CD987F80LL, domprocessinginstruction, methodIndex);
      break;
    case 130:
      HASH_INVOKE_STATIC_METHOD(0x33BD46E935281082LL, reflectionfunctionabstract, methodIndex);
      break;
    case 131:
      HASH_INVOKE_STATIC_METHOD(0x24DE53FD7D3E8383LL, datetimezone, methodIndex);
      break;
    case 132:
      HASH_INVOKE_STATIC_METHOD(0x70D4A29DE6A7BA84LL, domainexception, methodIndex);
      break;
    case 143:
      HASH_INVOKE_STATIC_METHOD(0x34C95AF311506C8FLL, directory, methodIndex);
      break;
    case 144:
      HASH_INVOKE_STATIC_METHOD(0x06335FF83CDEA590LL, badmethodcallexception, methodIndex);
      break;
    case 147:
      HASH_INVOKE_STATIC_METHOD(0x2E7081C468A05993LL, reflectionparameter, methodIndex);
      break;
    case 148:
      HASH_INVOKE_STATIC_METHOD(0x6FFDF8DF15CABE94LL, domcdatasection, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x6576EACCCE24D694LL, __php_incomplete_class, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x47D93E6F80B66A94LL, exception, methodIndex);
      break;
    case 152:
      HASH_INVOKE_STATIC_METHOD(0x3CEBA108A1BAB998LL, pear_error, methodIndex);
      break;
    case 167:
      HASH_INVOKE_STATIC_METHOD(0x71089C29FE923FA7LL, splfileinfo, methodIndex);
      break;
    case 168:
      HASH_INVOKE_STATIC_METHOD(0x7D46DB2E09C6DBA8LL, domxpath, methodIndex);
      break;
    case 169:
      HASH_INVOKE_STATIC_METHOD(0x1D35C3EFD00E11A9LL, sqlite3, methodIndex);
      break;
    case 170:
      HASH_INVOKE_STATIC_METHOD(0x67E31D42F2DFE4AALL, locale, methodIndex);
      break;
    case 173:
      HASH_INVOKE_STATIC_METHOD(0x0A34015F67C804ADLL, pdo, methodIndex);
      break;
    case 175:
      HASH_INVOKE_STATIC_METHOD(0x2E650138BA043AAFLL, domdocument, methodIndex);
      break;
    case 176:
      HASH_INVOKE_STATIC_METHOD(0x43BBC8F6F28E44B0LL, reflectionmethod, methodIndex);
      break;
    case 177:
      HASH_INVOKE_STATIC_METHOD(0x6DD772FA3B20B8B1LL, domnodelist, methodIndex);
      break;
    case 189:
      HASH_INVOKE_STATIC_METHOD(0x5D8785ACD19F77BDLL, pdoexception, methodIndex);
      break;
    case 195:
      HASH_INVOKE_STATIC_METHOD(0x40B3C44077F5DDC3LL, domelement, methodIndex);
      break;
    case 200:
      HASH_INVOKE_STATIC_METHOD(0x2E363D51549781C8LL, appenditerator, methodIndex);
      break;
    case 203:
      HASH_INVOKE_STATIC_METHOD(0x253AC17234FC8CCBLL, libxmlerror, methodIndex);
      break;
    case 208:
      HASH_INVOKE_STATIC_METHOD(0x3C122DF8859C72D0LL, memcache, methodIndex);
      break;
    case 210:
      HASH_INVOKE_STATIC_METHOD(0x52E5CC58B841AED2LL, sqlite3stmt, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x297ECCC7A259EDD2LL, splfileobject, methodIndex);
      break;
    case 212:
      HASH_INVOKE_STATIC_METHOD(0x5E623FEAF7B068D4LL, underflowexception, methodIndex);
      break;
    case 216:
      HASH_INVOKE_STATIC_METHOD(0x464D3427431A6ED8LL, recursivedirectoryiterator, methodIndex);
      break;
    case 217:
      HASH_INVOKE_STATIC_METHOD(0x0E4CCE95F6A727D9LL, overflowexception, methodIndex);
      break;
    case 218:
      HASH_INVOKE_STATIC_METHOD(0x7A52EBE538182BDALL, soapclient, methodIndex);
      break;
    case 220:
      HASH_INVOKE_STATIC_METHOD(0x1078CB3118A8B3DCLL, runtimeexception, methodIndex);
      break;
    case 228:
      HASH_INVOKE_STATIC_METHOD(0x75AA2571BDB659E4LL, reflectionproperty, methodIndex);
      break;
    case 244:
      HASH_INVOKE_STATIC_METHOD(0x297174231D4912F4LL, domattr, methodIndex);
      break;
    case 247:
      HASH_INVOKE_STATIC_METHOD(0x3D69936178BA13F7LL, stdclass, methodIndex);
      break;
    case 252:
      HASH_INVOKE_STATIC_METHOD(0x622D4DF07E2A01FCLL, outofrangeexception, methodIndex);
      break;
    case 253:
      HASH_INVOKE_STATIC_METHOD(0x74419B70A46387FDLL, domimplementation, methodIndex);
      break;
    case 255:
      HASH_INVOKE_STATIC_METHOD(0x624835B2D74B86FFLL, domentity, methodIndex);
      break;
    default:
      break;
  }
  if (fatal) {
    return throw_missing_class(s);
  } else {
#ifdef FMCGEN
    method = methodIndexLookupReverse(methodIndex);
#endif
    raise_warning("call_user_func to non-existent class's method %s::%s", s, method);
    return false;
  }
}
Variant invoke_builtin_static_method_mil(const char *s, const char *method, CArrRef params, bool fatal) {
  bool foundClass = false;
  Variant r;
  if (eval_invoke_static_method_hook(r, s, method, params, foundClass)) return r;
  if (foundClass) return o_invoke_failed(s, method, fatal);
  MethodIndex methodIndex(MethodIndex::fail());
  if (RuntimeOption::FastMethodCall) {
    methodIndex = methodIndexExists(method);
    if (methodIndex.isFail()) {
      return o_invoke_failed(s, method, fatal);
    }
  }
  return invoke_builtin_static_method(s, methodIndex,method, params, fatal);
}
const ObjectStaticCallbacks * get_builtin_object_static_callbacks(const char *s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 18:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x78B42582709BAF12LL, debuggerproxy);
      break;
    case 19:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 61:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4C6991D3CF5CA03DLL, collator);
      break;
    case 62:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70747A09B3523662LL, domnode);
      break;
    case 99:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D1235273F521A63LL, debuggerclient);
      break;
    case 101:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 117:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 170:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x67E31D42F2DFE4AALL, locale);
      break;
    case 173:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 208:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3C122DF8859C72D0LL, memcache);
      break;
    case 210:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297174231D4912F4LL, domattr);
      break;
    case 247:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return NULL;
}
Variant get_builtin_static_property(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_get(prop, -1);
  }
  return null;
}
Variant *get_builtin_static_property_lv(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return &cwo->os_lval(prop, -1);
  }
  return NULL;
}
Variant get_builtin_class_constant(const char *s, const char *constant, bool fatal /* = true */) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_constant(constant);
  }
  if (fatal) {
    raise_error("Couldn't find constant %s::%s", s, constant);
  } else {
    raise_warning("Couldn't find constant %s::%s", s, constant);
  }
  return null;
}

///////////////////////////////////////////////////////////////////////////////
}
