#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.cpp.ttypes
import thrift.annotation.thrift.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyStruct', 'MyStructWithCustomDefault', 'StructLevelTerseStruct', 'FieldLevelTerseStruct', 'TerseStructWithCustomDefault', 'AdaptedFields', 'TerseException', 'MyInteger']

class MyEnum:
  ME0 = 0
  ME1 = 1

  _VALUES_TO_NAMES = {
    0: "ME0",
    1: "ME1",
  }

  _NAMES_TO_VALUES = {
    "ME0": 0,
    "ME1": 1,
  }

class MyStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class MyStructWithCustomDefault:
  """
  Attributes:
   - field1
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.field1 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructWithCustomDefault')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I64, 1)
      oprot.writeI64(self.field1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = long(json_obj['field1'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class StructLevelTerseStruct:
  """
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              self.list_field.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              self.list_field.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readI16()
              self.set_field.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readI16()
              self.set_field.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readI16()
              _val20 = iprot.readI16()
              self.map_field[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readI16()
              _val22 = iprot.readI16()
              self.map_field[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.struct_field = MyStruct()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructLevelTerseStruct')
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter23 in self.list_field:
        oprot.writeI16(iter23)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter24 in self.set_field:
        oprot.writeI16(iter24)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter25,viter26 in self.map_field.items():
        oprot.writeI16(kiter25)
        oprot.writeI16(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e27 in json_obj['list_field']:
        if _tmp_e27 > 0x7fff or _tmp_e27 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e27)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e28 in json_obj['set_field']:
        if _tmp_e28 > 0x7fff or _tmp_e28 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e28)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k29, _tmp_v30 in json_obj['map_field'].items():
        _tmp_kp31 = int(_tmp_k29)
        if _tmp_kp31 > 0x7fff or _tmp_kp31 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k29)
        if _tmp_v30 > 0x7fff or _tmp_v30 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp31] = _tmp_v30
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStruct()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructLevelTerseStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructLevelTerseStruct, self)

  def _to_py_deprecated(self):
    return self

class FieldLevelTerseStruct:
  """
  Attributes:
   - terse_bool_field
   - terse_byte_field
   - terse_short_field
   - terse_int_field
   - terse_long_field
   - terse_float_field
   - terse_double_field
   - terse_string_field
   - terse_binary_field
   - terse_enum_field
   - terse_list_field
   - terse_set_field
   - terse_map_field
   - terse_struct_field
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.terse_bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.terse_byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.terse_short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.terse_int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.terse_long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.terse_float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.terse_double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.terse_string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.terse_binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.terse_enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.terse_list_field = []
          (_etype35, _size32) = iprot.readListBegin()
          if _size32 >= 0:
            for _i36 in range(_size32):
              _elem37 = iprot.readI16()
              self.terse_list_field.append(_elem37)
          else: 
            while iprot.peekList():
              _elem38 = iprot.readI16()
              self.terse_list_field.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.terse_set_field = set()
          (_etype42, _size39) = iprot.readSetBegin()
          if _size39 >= 0:
            for _i43 in range(_size39):
              _elem44 = iprot.readI16()
              self.terse_set_field.add(_elem44)
          else: 
            while iprot.peekSet():
              _elem45 = iprot.readI16()
              self.terse_set_field.add(_elem45)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.terse_map_field = {}
          (_ktype47, _vtype48, _size46 ) = iprot.readMapBegin() 
          if _size46 >= 0:
            for _i50 in range(_size46):
              _key51 = iprot.readI16()
              _val52 = iprot.readI16()
              self.terse_map_field[_key51] = _val52
          else: 
            while iprot.peekMap():
              _key53 = iprot.readI16()
              _val54 = iprot.readI16()
              self.terse_map_field[_key53] = _val54
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.terse_struct_field = MyStruct()
          self.terse_struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype58, _size55) = iprot.readListBegin()
          if _size55 >= 0:
            for _i59 in range(_size55):
              _elem60 = iprot.readI16()
              self.list_field.append(_elem60)
          else: 
            while iprot.peekList():
              _elem61 = iprot.readI16()
              self.list_field.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype65, _size62) = iprot.readSetBegin()
          if _size62 >= 0:
            for _i66 in range(_size62):
              _elem67 = iprot.readI16()
              self.set_field.add(_elem67)
          else: 
            while iprot.peekSet():
              _elem68 = iprot.readI16()
              self.set_field.add(_elem68)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype70, _vtype71, _size69 ) = iprot.readMapBegin() 
          if _size69 >= 0:
            for _i73 in range(_size69):
              _key74 = iprot.readI16()
              _val75 = iprot.readI16()
              self.map_field[_key74] = _val75
          else: 
            while iprot.peekMap():
              _key76 = iprot.readI16()
              _val77 = iprot.readI16()
              self.map_field[_key76] = _val77
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.STRUCT:
          self.struct_field = MyStruct()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FieldLevelTerseStruct')
    if self.terse_bool_field != None:
      oprot.writeFieldBegin('terse_bool_field', TType.BOOL, 1)
      oprot.writeBool(self.terse_bool_field)
      oprot.writeFieldEnd()
    if self.terse_byte_field != None:
      oprot.writeFieldBegin('terse_byte_field', TType.BYTE, 2)
      oprot.writeByte(self.terse_byte_field)
      oprot.writeFieldEnd()
    if self.terse_short_field != None:
      oprot.writeFieldBegin('terse_short_field', TType.I16, 3)
      oprot.writeI16(self.terse_short_field)
      oprot.writeFieldEnd()
    if self.terse_int_field != None:
      oprot.writeFieldBegin('terse_int_field', TType.I32, 4)
      oprot.writeI32(self.terse_int_field)
      oprot.writeFieldEnd()
    if self.terse_long_field != None:
      oprot.writeFieldBegin('terse_long_field', TType.I64, 5)
      oprot.writeI64(self.terse_long_field)
      oprot.writeFieldEnd()
    if self.terse_float_field != None:
      oprot.writeFieldBegin('terse_float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.terse_float_field)
      oprot.writeFieldEnd()
    if self.terse_double_field != None:
      oprot.writeFieldBegin('terse_double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.terse_double_field)
      oprot.writeFieldEnd()
    if self.terse_string_field != None:
      oprot.writeFieldBegin('terse_string_field', TType.STRING, 8)
      oprot.writeString(self.terse_string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.terse_string_field, bytes) else oprot.writeString(self.terse_string_field)
      oprot.writeFieldEnd()
    if self.terse_binary_field != None:
      oprot.writeFieldBegin('terse_binary_field', TType.STRING, 9)
      oprot.writeString(self.terse_binary_field)
      oprot.writeFieldEnd()
    if self.terse_enum_field != None:
      oprot.writeFieldBegin('terse_enum_field', TType.I32, 10)
      oprot.writeI32(self.terse_enum_field)
      oprot.writeFieldEnd()
    if self.terse_list_field != None:
      oprot.writeFieldBegin('terse_list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.terse_list_field))
      for iter78 in self.terse_list_field:
        oprot.writeI16(iter78)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.terse_set_field != None:
      oprot.writeFieldBegin('terse_set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.terse_set_field))
      for iter79 in self.terse_set_field:
        oprot.writeI16(iter79)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.terse_map_field != None:
      oprot.writeFieldBegin('terse_map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.terse_map_field))
      for kiter80,viter81 in self.terse_map_field.items():
        oprot.writeI16(kiter80)
        oprot.writeI16(viter81)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.terse_struct_field != None:
      oprot.writeFieldBegin('terse_struct_field', TType.STRUCT, 14)
      self.terse_struct_field.write(oprot)
      oprot.writeFieldEnd()
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 15)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 16)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 17)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 18)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 19)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 20)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 21)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 22)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 23)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 24)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 25)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter82 in self.list_field:
        oprot.writeI16(iter82)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 26)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter83 in self.set_field:
        oprot.writeI16(iter83)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 27)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter84,viter85 in self.map_field.items():
        oprot.writeI16(kiter84)
        oprot.writeI16(viter85)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 28)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'terse_bool_field' in json_obj and json_obj['terse_bool_field'] is not None:
      self.terse_bool_field = json_obj['terse_bool_field']
    if 'terse_byte_field' in json_obj and json_obj['terse_byte_field'] is not None:
      self.terse_byte_field = json_obj['terse_byte_field']
      if self.terse_byte_field > 0x7f or self.terse_byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_short_field' in json_obj and json_obj['terse_short_field'] is not None:
      self.terse_short_field = json_obj['terse_short_field']
      if self.terse_short_field > 0x7fff or self.terse_short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_int_field' in json_obj and json_obj['terse_int_field'] is not None:
      self.terse_int_field = json_obj['terse_int_field']
      if self.terse_int_field > 0x7fffffff or self.terse_int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_long_field' in json_obj and json_obj['terse_long_field'] is not None:
      self.terse_long_field = long(json_obj['terse_long_field'])
    if 'terse_float_field' in json_obj and json_obj['terse_float_field'] is not None:
      self.terse_float_field = float(json_obj['terse_float_field'])
    if 'terse_double_field' in json_obj and json_obj['terse_double_field'] is not None:
      self.terse_double_field = float(json_obj['terse_double_field'])
    if 'terse_string_field' in json_obj and json_obj['terse_string_field'] is not None:
      self.terse_string_field = json_obj['terse_string_field']
    if 'terse_binary_field' in json_obj and json_obj['terse_binary_field'] is not None:
      self.terse_binary_field = json_obj['terse_binary_field']
    if 'terse_enum_field' in json_obj and json_obj['terse_enum_field'] is not None:
      self.terse_enum_field = json_obj['terse_enum_field']
      if not self.terse_enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.terse_enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'terse_list_field' in json_obj and json_obj['terse_list_field'] is not None:
      self.terse_list_field = []
      for _tmp_e86 in json_obj['terse_list_field']:
        if _tmp_e86 > 0x7fff or _tmp_e86 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_list_field.append(_tmp_e86)
    if 'terse_set_field' in json_obj and json_obj['terse_set_field'] is not None:
      self.terse_set_field = set_cls()
      for _tmp_e87 in json_obj['terse_set_field']:
        if _tmp_e87 > 0x7fff or _tmp_e87 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_set_field.add(_tmp_e87)
    if 'terse_map_field' in json_obj and json_obj['terse_map_field'] is not None:
      self.terse_map_field = dict_cls()
      for _tmp_k88, _tmp_v89 in json_obj['terse_map_field'].items():
        _tmp_kp90 = int(_tmp_k88)
        if _tmp_kp90 > 0x7fff or _tmp_kp90 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k88)
        if _tmp_v89 > 0x7fff or _tmp_v89 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_map_field[_tmp_kp90] = _tmp_v89
    if 'terse_struct_field' in json_obj and json_obj['terse_struct_field'] is not None:
      self.terse_struct_field = MyStruct()
      self.terse_struct_field.readFromJson(json_obj['terse_struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e91 in json_obj['list_field']:
        if _tmp_e91 > 0x7fff or _tmp_e91 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e91)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e92 in json_obj['set_field']:
        if _tmp_e92 > 0x7fff or _tmp_e92 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e92)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k93, _tmp_v94 in json_obj['map_field'].items():
        _tmp_kp95 = int(_tmp_k93)
        if _tmp_kp95 > 0x7fff or _tmp_kp95 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k93)
        if _tmp_v94 > 0x7fff or _tmp_v94 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp95] = _tmp_v94
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStruct()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.terse_bool_field is not None:
      value = pprint.pformat(self.terse_bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_bool_field=%s' % (value))
    if self.terse_byte_field is not None:
      value = pprint.pformat(self.terse_byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_byte_field=%s' % (value))
    if self.terse_short_field is not None:
      value = pprint.pformat(self.terse_short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_short_field=%s' % (value))
    if self.terse_int_field is not None:
      value = pprint.pformat(self.terse_int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_int_field=%s' % (value))
    if self.terse_long_field is not None:
      value = pprint.pformat(self.terse_long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_long_field=%s' % (value))
    if self.terse_float_field is not None:
      value = pprint.pformat(self.terse_float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_float_field=%s' % (value))
    if self.terse_double_field is not None:
      value = pprint.pformat(self.terse_double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_double_field=%s' % (value))
    if self.terse_string_field is not None:
      value = pprint.pformat(self.terse_string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_string_field=%s' % (value))
    if self.terse_binary_field is not None:
      value = pprint.pformat(self.terse_binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_binary_field=%s' % (value))
    if self.terse_enum_field is not None:
      value = pprint.pformat(self.terse_enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_enum_field=%s' % (value))
    if self.terse_list_field is not None:
      value = pprint.pformat(self.terse_list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_list_field=%s' % (value))
    if self.terse_set_field is not None:
      value = pprint.pformat(self.terse_set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_set_field=%s' % (value))
    if self.terse_map_field is not None:
      value = pprint.pformat(self.terse_map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_map_field=%s' % (value))
    if self.terse_struct_field is not None:
      value = pprint.pformat(self.terse_struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_struct_field=%s' % (value))
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'terse_bool_field',
      'terse_byte_field',
      'terse_short_field',
      'terse_int_field',
      'terse_long_field',
      'terse_float_field',
      'terse_double_field',
      'terse_string_field',
      'terse_binary_field',
      'terse_enum_field',
      'terse_list_field',
      'terse_set_field',
      'terse_map_field',
      'terse_struct_field',
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.FieldLevelTerseStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.FieldLevelTerseStruct, self)

  def _to_py_deprecated(self):
    return self

class TerseStructWithCustomDefault:
  """
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype99, _size96) = iprot.readListBegin()
          if _size96 >= 0:
            for _i100 in range(_size96):
              _elem101 = iprot.readI16()
              self.list_field.append(_elem101)
          else: 
            while iprot.peekList():
              _elem102 = iprot.readI16()
              self.list_field.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype106, _size103) = iprot.readSetBegin()
          if _size103 >= 0:
            for _i107 in range(_size103):
              _elem108 = iprot.readI16()
              self.set_field.add(_elem108)
          else: 
            while iprot.peekSet():
              _elem109 = iprot.readI16()
              self.set_field.add(_elem109)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype111, _vtype112, _size110 ) = iprot.readMapBegin() 
          if _size110 >= 0:
            for _i114 in range(_size110):
              _key115 = iprot.readI16()
              _val116 = iprot.readI16()
              self.map_field[_key115] = _val116
          else: 
            while iprot.peekMap():
              _key117 = iprot.readI16()
              _val118 = iprot.readI16()
              self.map_field[_key117] = _val118
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.struct_field = MyStructWithCustomDefault()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseStructWithCustomDefault')
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter119 in self.list_field:
        oprot.writeI16(iter119)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter120 in self.set_field:
        oprot.writeI16(iter120)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter121,viter122 in self.map_field.items():
        oprot.writeI16(kiter121)
        oprot.writeI16(viter122)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e123 in json_obj['list_field']:
        if _tmp_e123 > 0x7fff or _tmp_e123 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e123)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e124 in json_obj['set_field']:
        if _tmp_e124 > 0x7fff or _tmp_e124 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e124)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k125, _tmp_v126 in json_obj['map_field'].items():
        _tmp_kp127 = int(_tmp_k125)
        if _tmp_kp127 > 0x7fff or _tmp_kp127 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k125)
        if _tmp_v126 > 0x7fff or _tmp_v126 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp127] = _tmp_v126
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStructWithCustomDefault()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseStructWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseStructWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class AdaptedFields:
  """
  Attributes:
   - field1
   - field2
   - field3
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.field2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.field3 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptedFields')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I32, 1)
      oprot.writeI32(self.field1)
      oprot.writeFieldEnd()
    if self.field2 != None:
      oprot.writeFieldBegin('field2', TType.I32, 2)
      oprot.writeI32(self.field2)
      oprot.writeFieldEnd()
    if self.field3 != None:
      oprot.writeFieldBegin('field3', TType.I32, 3)
      oprot.writeI32(self.field3)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = json_obj['field1']
      if self.field1 > 0x7fffffff or self.field1 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'field2' in json_obj and json_obj['field2'] is not None:
      self.field2 = json_obj['field2']
      if self.field2 > 0x7fffffff or self.field2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'field3' in json_obj and json_obj['field3'] is not None:
      self.field3 = json_obj['field3']
      if self.field3 > 0x7fffffff or self.field3 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    if self.field2 is not None:
      value = pprint.pformat(self.field2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field2=%s' % (value))
    if self.field3 is not None:
      value = pprint.pformat(self.field3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field3=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
      'field2',
      'field3',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptedFields, self)

  def _to_py_deprecated(self):
    return self

class TerseException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseException')
    if self.msg != None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg.encode('utf-8')) if UTF8STRINGS and not isinstance(self.msg, bytes) else oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'msg' in json_obj and json_obj['msg'] is not None:
      self.msg = json_obj['msg']

  def __str__(self):
    if self.msg:
      return self.msg
    else:
      return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.msg is not None:
      value = pprint.pformat(self.msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    msg=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'msg',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseException, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseException, self)

  def _to_py_deprecated(self):
    return self

MyInteger = UnimplementedTypedef()
all_structs.append(MyStruct)
MyStruct.thrift_spec = (
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

all_structs.append(MyStructWithCustomDefault)
MyStructWithCustomDefault.thrift_spec = (
  None, # 0
  (1, TType.I64, 'field1', None, 1, 2, ), # 1
)

MyStructWithCustomDefault.thrift_struct_annotations = {
}
MyStructWithCustomDefault.thrift_field_annotations = {
}

def MyStructWithCustomDefault__init__(self, field1=MyStructWithCustomDefault.thrift_spec[1][4],):
  self.field1 = field1

MyStructWithCustomDefault.__init__ = MyStructWithCustomDefault__init__

def MyStructWithCustomDefault__setstate__(self, state):
  state.setdefault('field1', 1)
  self.__dict__ = state

MyStructWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
MyStructWithCustomDefault.__setstate__ = MyStructWithCustomDefault__setstate__

all_structs.append(StructLevelTerseStruct)
StructLevelTerseStruct.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'bool_field', None, None, 3, ), # 1
  (2, TType.BYTE, 'byte_field', None, None, 3, ), # 2
  (3, TType.I16, 'short_field', None, None, 3, ), # 3
  (4, TType.I32, 'int_field', None, None, 3, ), # 4
  (5, TType.I64, 'long_field', None, None, 3, ), # 5
  (6, TType.FLOAT, 'float_field', None, None, 3, ), # 6
  (7, TType.DOUBLE, 'double_field', None, None, 3, ), # 7
  (8, TType.STRING, 'string_field', True, None, 3, ), # 8
  (9, TType.STRING, 'binary_field', False, None, 3, ), # 9
  (10, TType.I32, 'enum_field', MyEnum, None, 3, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), None, 3, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), None, 3, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 3, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 3, ), # 14
)

StructLevelTerseStruct.thrift_struct_annotations = {
}
StructLevelTerseStruct.thrift_field_annotations = {
}

def StructLevelTerseStruct__init__(self, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None,):
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  self.list_field = list_field
  self.set_field = set_field
  self.map_field = map_field
  self.struct_field = struct_field

StructLevelTerseStruct.__init__ = StructLevelTerseStruct__init__

def StructLevelTerseStruct__setstate__(self, state):
  state.setdefault('bool_field', None)
  state.setdefault('byte_field', None)
  state.setdefault('short_field', None)
  state.setdefault('int_field', None)
  state.setdefault('long_field', None)
  state.setdefault('float_field', None)
  state.setdefault('double_field', None)
  state.setdefault('string_field', None)
  state.setdefault('binary_field', None)
  state.setdefault('enum_field', None)
  state.setdefault('list_field', None)
  state.setdefault('set_field', None)
  state.setdefault('map_field', None)
  state.setdefault('struct_field', None)
  self.__dict__ = state

StructLevelTerseStruct.__getstate__ = lambda self: self.__dict__.copy()
StructLevelTerseStruct.__setstate__ = StructLevelTerseStruct__setstate__

all_structs.append(FieldLevelTerseStruct)
FieldLevelTerseStruct.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'terse_bool_field', None, None, 3, ), # 1
  (2, TType.BYTE, 'terse_byte_field', None, None, 3, ), # 2
  (3, TType.I16, 'terse_short_field', None, None, 3, ), # 3
  (4, TType.I32, 'terse_int_field', None, None, 3, ), # 4
  (5, TType.I64, 'terse_long_field', None, None, 3, ), # 5
  (6, TType.FLOAT, 'terse_float_field', None, None, 3, ), # 6
  (7, TType.DOUBLE, 'terse_double_field', None, None, 3, ), # 7
  (8, TType.STRING, 'terse_string_field', True, None, 3, ), # 8
  (9, TType.STRING, 'terse_binary_field', False, None, 3, ), # 9
  (10, TType.I32, 'terse_enum_field', MyEnum, None, 3, ), # 10
  (11, TType.LIST, 'terse_list_field', (TType.I16,None), None, 3, ), # 11
  (12, TType.SET, 'terse_set_field', (TType.I16,None), None, 3, ), # 12
  (13, TType.MAP, 'terse_map_field', (TType.I16,None,TType.I16,None), None, 3, ), # 13
  (14, TType.STRUCT, 'terse_struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 3, ), # 14
  (15, TType.BOOL, 'bool_field', None, None, 2, ), # 15
  (16, TType.BYTE, 'byte_field', None, None, 2, ), # 16
  (17, TType.I16, 'short_field', None, None, 2, ), # 17
  (18, TType.I32, 'int_field', None, None, 2, ), # 18
  (19, TType.I64, 'long_field', None, None, 2, ), # 19
  (20, TType.FLOAT, 'float_field', None, None, 2, ), # 20
  (21, TType.DOUBLE, 'double_field', None, None, 2, ), # 21
  (22, TType.STRING, 'string_field', True, None, 2, ), # 22
  (23, TType.STRING, 'binary_field', False, None, 2, ), # 23
  (24, TType.I32, 'enum_field', MyEnum, None, 2, ), # 24
  (25, TType.LIST, 'list_field', (TType.I16,None), None, 2, ), # 25
  (26, TType.SET, 'set_field', (TType.I16,None), None, 2, ), # 26
  (27, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 2, ), # 27
  (28, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 28
)

FieldLevelTerseStruct.thrift_struct_annotations = {
}
FieldLevelTerseStruct.thrift_field_annotations = {
}

def FieldLevelTerseStruct__init__(self, terse_bool_field=None, terse_byte_field=None, terse_short_field=None, terse_int_field=None, terse_long_field=None, terse_float_field=None, terse_double_field=None, terse_string_field=None, terse_binary_field=None, terse_enum_field=None, terse_list_field=None, terse_set_field=None, terse_map_field=None, terse_struct_field=None, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None,):
  self.terse_bool_field = terse_bool_field
  self.terse_byte_field = terse_byte_field
  self.terse_short_field = terse_short_field
  self.terse_int_field = terse_int_field
  self.terse_long_field = terse_long_field
  self.terse_float_field = terse_float_field
  self.terse_double_field = terse_double_field
  self.terse_string_field = terse_string_field
  self.terse_binary_field = terse_binary_field
  self.terse_enum_field = terse_enum_field
  self.terse_list_field = terse_list_field
  self.terse_set_field = terse_set_field
  self.terse_map_field = terse_map_field
  self.terse_struct_field = terse_struct_field
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  self.list_field = list_field
  self.set_field = set_field
  self.map_field = map_field
  self.struct_field = struct_field

FieldLevelTerseStruct.__init__ = FieldLevelTerseStruct__init__

def FieldLevelTerseStruct__setstate__(self, state):
  state.setdefault('terse_bool_field', None)
  state.setdefault('terse_byte_field', None)
  state.setdefault('terse_short_field', None)
  state.setdefault('terse_int_field', None)
  state.setdefault('terse_long_field', None)
  state.setdefault('terse_float_field', None)
  state.setdefault('terse_double_field', None)
  state.setdefault('terse_string_field', None)
  state.setdefault('terse_binary_field', None)
  state.setdefault('terse_enum_field', None)
  state.setdefault('terse_list_field', None)
  state.setdefault('terse_set_field', None)
  state.setdefault('terse_map_field', None)
  state.setdefault('terse_struct_field', None)
  state.setdefault('bool_field', None)
  state.setdefault('byte_field', None)
  state.setdefault('short_field', None)
  state.setdefault('int_field', None)
  state.setdefault('long_field', None)
  state.setdefault('float_field', None)
  state.setdefault('double_field', None)
  state.setdefault('string_field', None)
  state.setdefault('binary_field', None)
  state.setdefault('enum_field', None)
  state.setdefault('list_field', None)
  state.setdefault('set_field', None)
  state.setdefault('map_field', None)
  state.setdefault('struct_field', None)
  self.__dict__ = state

FieldLevelTerseStruct.__getstate__ = lambda self: self.__dict__.copy()
FieldLevelTerseStruct.__setstate__ = FieldLevelTerseStruct__setstate__

all_structs.append(TerseStructWithCustomDefault)
TerseStructWithCustomDefault.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'bool_field', None, True, 3, ), # 1
  (2, TType.BYTE, 'byte_field', None, 1, 3, ), # 2
  (3, TType.I16, 'short_field', None, 2, 3, ), # 3
  (4, TType.I32, 'int_field', None, 3, 3, ), # 4
  (5, TType.I64, 'long_field', None, 4, 3, ), # 5
  (6, TType.FLOAT, 'float_field', None, 5.00000, 3, ), # 6
  (7, TType.DOUBLE, 'double_field', None, 6.00000, 3, ), # 7
  (8, TType.STRING, 'string_field', True, "7", 3, ), # 8
  (9, TType.STRING, 'binary_field', False, "8", 3, ), # 9
  (10, TType.I32, 'enum_field', MyEnum,   1, 3, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), [
    1,
  ], 3, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), set([
    1,
  ]), 3, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), {
    1 : 1,
  }, 3, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStructWithCustomDefault, MyStructWithCustomDefault.thrift_spec, False], None, 3, ), # 14
)

TerseStructWithCustomDefault.thrift_struct_annotations = {
}
TerseStructWithCustomDefault.thrift_field_annotations = {
}

def TerseStructWithCustomDefault__init__(self, bool_field=TerseStructWithCustomDefault.thrift_spec[1][4], byte_field=TerseStructWithCustomDefault.thrift_spec[2][4], short_field=TerseStructWithCustomDefault.thrift_spec[3][4], int_field=TerseStructWithCustomDefault.thrift_spec[4][4], long_field=TerseStructWithCustomDefault.thrift_spec[5][4], float_field=TerseStructWithCustomDefault.thrift_spec[6][4], double_field=TerseStructWithCustomDefault.thrift_spec[7][4], string_field=TerseStructWithCustomDefault.thrift_spec[8][4], binary_field=TerseStructWithCustomDefault.thrift_spec[9][4], enum_field=TerseStructWithCustomDefault.thrift_spec[10][4], list_field=TerseStructWithCustomDefault.thrift_spec[11][4], set_field=TerseStructWithCustomDefault.thrift_spec[12][4], map_field=TerseStructWithCustomDefault.thrift_spec[13][4], struct_field=None,):
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  if list_field is self.thrift_spec[11][4]:
    list_field = [
    1,
  ]
  self.list_field = list_field
  if set_field is self.thrift_spec[12][4]:
    set_field = set([
    1,
  ])
  self.set_field = set_field
  if map_field is self.thrift_spec[13][4]:
    map_field = {
    1 : 1,
  }
  self.map_field = map_field
  self.struct_field = struct_field

TerseStructWithCustomDefault.__init__ = TerseStructWithCustomDefault__init__

def TerseStructWithCustomDefault__setstate__(self, state):
  state.setdefault('bool_field', True)
  state.setdefault('byte_field', 1)
  state.setdefault('short_field', 2)
  state.setdefault('int_field', 3)
  state.setdefault('long_field', 4)
  state.setdefault('float_field', 5.00000)
  state.setdefault('double_field', 6.00000)
  state.setdefault('string_field', "7")
  state.setdefault('binary_field', "8")
  state.setdefault('enum_field',   1)
  state.setdefault('list_field', [
    1,
  ])
  state.setdefault('set_field', set([
    1,
  ]))
  state.setdefault('map_field', {
    1 : 1,
  })
  state.setdefault('struct_field', None)
  self.__dict__ = state

TerseStructWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
TerseStructWithCustomDefault.__setstate__ = TerseStructWithCustomDefault__setstate__

all_structs.append(AdaptedFields)
AdaptedFields.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field1', None, None, 3, ), # 1
  (2, TType.I32, 'field2', None, None, 3, ), # 2
  (3, TType.I32, 'field3', None, None, 3, ), # 3
)

AdaptedFields.thrift_struct_annotations = {
}
AdaptedFields.thrift_field_annotations = {
}

def AdaptedFields__init__(self, field1=None, field2=None, field3=None,):
  self.field1 = field1
  self.field2 = field2
  self.field3 = field3

AdaptedFields.__init__ = AdaptedFields__init__

def AdaptedFields__setstate__(self, state):
  state.setdefault('field1', None)
  state.setdefault('field2', None)
  state.setdefault('field3', None)
  self.__dict__ = state

AdaptedFields.__getstate__ = lambda self: self.__dict__.copy()
AdaptedFields.__setstate__ = AdaptedFields__setstate__

all_structs.append(TerseException)
TerseException.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'msg', True, None, 3, ), # 1
)

TerseException.thrift_struct_annotations = {
  "message": "msg",
}
TerseException.thrift_field_annotations = {
}

def TerseException__init__(self, msg=None,):
  self.msg = msg

TerseException.__init__ = TerseException__init__

def TerseException__setstate__(self, state):
  state.setdefault('msg', None)
  self.__dict__ = state

TerseException.__getstate__ = lambda self: self.__dict__.copy()
TerseException.__setstate__ = TerseException__setstate__

fix_spec(all_structs)
del all_structs
