{{!

  Copyright (c) Meta Platforms, Inc. and affiliates.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}{{!

  This template defines the processor type/functions for a thrift service.

}}
{{#import "common/type" as types}}

{{#let export partial func_rpc_name |func svc|}}{{!
}}{{#if svc.interaction?}}{{svc.name}}.{{/if svc.interaction?}}{{func.name}}{{!
}}{{/let partial}}

{{#let export partial server_func_stream |func svc| captures |types|}}{{!
}}func (p *procFunc{{svc.go_name}}{{func.go_name}}) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    {{#if func.params.fields?}}
    args := reqStruct.(*req{{svc.go_name}}{{func.go_name}})
    {{/if func.params.fields?}}
    firstResponse := newResp{{svc.go_name}}{{func.go_name}}()
    {{#if func.creates_interaction?}}fbthriftInteraction, {{/if func.creates_interaction?}}{{#if func.stream_has_first_response?}}retval, {{/if func.stream_has_first_response?}}elemProducerFunc, initialErr := p.handler.{{func.go_name}}({{!
        }}ctx{{#if func.params.fields?}}, {{/if}}{{!
        }}{{#each (array.enumerate func.params.fields with_last=true) as |index field last?|}}{{!
          }}args.{{field.go_name}}{{!
          }}{{#if (not last?)}}, {{/if (not last?)}}{{!
        }}{{/each}})
    if initialErr != nil {
        {{#if func.exceptions?}}
        switch v := initialErr.(type) {
        {{#each func.exceptions as |ex|}}
        case *{{#partial types.go_type type=ex.type}}:
            firstResponse.{{ex.go_name}} = v
            onFirstResponse(firstResponse)
        {{/each}}
        default:
            internalErr := fmt.Errorf("Internal error processing {{func.go_name}}: %w", initialErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onFirstResponse(x)
        }
        {{/if func.exceptions?}}
        {{#if (not func.exceptions?)}}
        internalErr := fmt.Errorf("Internal error processing {{func.go_name}}: %w", initialErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onFirstResponse(x)
        {{/if (not func.exceptions?)}}
        onStreamComplete()
        return
    }

    {{#if func.creates_interaction?}}
    thrift.SetInteractionCreateProcessor(ctx, fbthriftInteraction)
    {{/if func.creates_interaction?}}
    {{#if func.stream_has_first_response?}}
    firstResponse.{{func.retval_field_name}} = {{#if (not func.return_type.nilable?)}}&{{/if (not func.return_type.nilable?)}}retval
    {{/if func.stream_has_first_response?}}
    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan {{#if func.stream.elem_type.structured?}}*{{/if func.stream.elem_type.structured?}}{{#partial types.go_type type=func.stream.elem_type}}, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStream{{svc.go_name}}{{func.go_name}}()
            streamWrapStruct.{{func.retval_field_name}} = {{#if (not func.stream.elem_type.nilable?)}}&{{/if (not func.stream.elem_type.nilable?)}}elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        {{#if func.stream_exceptions?}}
        streamWrapStruct := newStream{{svc.go_name}}{{func.go_name}}()
        switch v := streamErr.(type) {
        {{#each func.stream.exceptions as |ex|}}
        case *{{#partial types.go_type type=ex.type}}:
            streamWrapStruct.{{ex.go_name}} = v
            onStreamNext(streamWrapStruct)
        {{/each}}
        default:
            internalErr := fmt.Errorf("Internal stream handler error {{func.go_name}}: %w", streamErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onStreamNext(x)
        }
        {{/if func.stream_exceptions?}}
        {{#if (not func.stream_exceptions?)}}
        internalErr := fmt.Errorf("Internal stream handler error {{func.go_name}}: %w", streamErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onStreamNext(x)
        {{/if (not func.stream_exceptions?)}}
    }
    onStreamComplete()
}{{!
}}{{/let partial}}

{{#let export partial server_func_response |func svc| captures |types|}}{{!
}}func (p *procFunc{{svc.go_name}}{{func.go_name}}) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    {{#if func.params.fields?}}
    args := reqStruct.(*req{{svc.go_name}}{{func.go_name}})
    {{/if func.params.fields?}}
    {{#if (not func.oneway?)}}
    result := newResp{{svc.go_name}}{{func.go_name}}()
    {{/if (not func.oneway?)}}
    {{#if func.creates_interaction?}}fbthriftInteraction, {{/if func.creates_interaction?}}{{#if (not func.return_type.void?)}}retval, {{/if (not func.return_type.void?)}}err := p.handler.{{func.go_name}}({{!
        }}ctx{{#if func.params.fields?}}, {{/if}}{{!
        }}{{#each (array.enumerate func.params.fields with_last=true) as |index field last?|}}{{!
          }}args.{{field.go_name}}{{!
          }}{{#if (not last?)}}, {{/if (not last?)}}{{!
        }}{{/each}})
    if err != nil {
        {{#if func.exceptions?}}
        switch v := err.(type) {
        {{#each func.exceptions as |ex|}}
        case *{{#partial types.go_type type=ex.type}}:
            result.{{ex.go_name}} = v
            return result, nil
        {{/each}}
        default:
            internalErr := fmt.Errorf("Internal error processing {{func.go_name}}: %w", err)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            return x, internalErr
        }
        {{/if func.exceptions?}}
        {{#if (not func.exceptions?)}}
        internalErr := fmt.Errorf("Internal error processing {{func.go_name}}: %w", err)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        return x, internalErr
        {{/if (not func.exceptions?)}}
    }

    {{#if func.creates_interaction?}}
    thrift.SetInteractionCreateProcessor(ctx, fbthriftInteraction)
    {{/if func.creates_interaction?}}
    {{#if (not func.return_type.void?)}}
    result.{{func.retval_field_name}} = {{#if (not func.return_type.nilable?)}}&{{/if (not func.return_type.nilable?)}}retval
    {{/if (not func.return_type.void?)}}
    {{#if func.oneway?}}
    return nil, nil
    {{/if func.oneway?}}
    {{#if (not func.oneway?)}}
    return result, nil
    {{/if (not func.oneway?)}}
}{{!
}}{{/let partial}}

{{#let export partial server_func_sink |func svc|}}{{!
}}func (p *procFunc{{svc.go_name}}{{func.go_name}}) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}{{!
}}{{/let partial}}

{{#let export partial processor_function |func svc| captures |server_func_stream server_func_response server_func_sink|}}{{!
}}type procFunc{{svc.go_name}}{{func.go_name}} struct {
    handler {{svc.go_name}}
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFunc{{svc.go_name}}{{func.go_name}})(nil)

func (p *procFunc{{svc.go_name}}{{func.go_name}}) NewReqArgs() thrift.ReadableStruct {
    return newReq{{svc.go_name}}{{func.go_name}}()
}

{{#if func.stream?}}
func (p *procFunc{{svc.go_name}}{{func.go_name}}) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

{{#partial server_func_stream func=func svc=svc}}
{{#else if func.sink?}}
func (p *procFunc{{svc.go_name}}{{func.go_name}}) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

{{#partial server_func_sink func=func svc=svc}}
{{#else}}
{{#partial server_func_response func=func svc=svc}}
{{/if func.stream?}}{{!
}}{{/let partial}}

{{#let export partial processor |svc| captures |func_rpc_name processor_function|}}{{!
}}type {{svc.go_name}}Processor struct {
    {{#if (and (not svc.interaction?) svc.extends)}}
    // Inherited/extended processor
    *{{svc.extends.go_qualified_name}}Processor
    {{#else}}
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler              {{svc.go_name}}
    {{/if (and (not svc.interaction?) svc.extends)}}
}

func New{{svc.go_name}}Processor(handler {{svc.go_name}}) *{{svc.go_name}}Processor {
    p := &{{svc.go_name}}Processor{
    {{#if (and (not svc.interaction?) svc.extends)}}
        {{svc.extends.go_package_alias_prefix}}New{{svc.extends.go_name}}Processor(handler),
    {{#else}}
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    {{/if (and (not svc.interaction?) svc.extends)}}
    }
    {{#each svc.functions as |func|}}
    {{#if func.go_server_supported?}}
    p.AddToProcessorFunctionMap("{{#partial func_rpc_name func=func svc=svc}}", &procFunc{{svc.go_name}}{{func.go_name}}{handler: handler})
    {{/if func.go_server_supported?}}
    {{/each}}
    {{#each svc.functions as |func|}}
    {{#if func.go_server_supported?}}
    p.AddToFunctionServiceMap("{{#partial func_rpc_name func=func svc=svc}}", "{{svc.go_name}}")
    {{/if func.go_server_supported?}}
    {{/each}}

    return p
}
{{#if (or svc.interaction? (not svc.extends))}}

func (p *{{svc.go_name}}Processor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *{{svc.go_name}}Processor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *{{svc.go_name}}Processor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *{{svc.go_name}}Processor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *{{svc.go_name}}Processor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *{{svc.go_name}}Processor) PackageName() string {
    return "{{svc.program.go_pkg_name}}"
}
{{/if (or svc.interaction? (not svc.extends))}}

func (p *{{svc.go_name}}Processor) GetInteractionProcessors() []thrift.Processor {
{{#if (and (not svc.interaction?) svc.interactions)}}
    return []thrift.Processor{
    {{#each svc.interactions as |interaction|}}
        New{{interaction.go_name}}Processor(nil),
    {{/each}}
    }
{{#else}}
    return []thrift.Processor{}
{{/if (and (not svc.interaction?) svc.interactions)}}
}

{{#if svc.program.gen_metadata?}}
func (p *{{svc.go_name}}Processor) GetThriftMetadata() *{{svc.program.metadata_qualifier}}ThriftMetadata {
    return GetThriftMetadataForService("{{svc.scoped_name}}")
}
{{/if svc.program.gen_metadata?}}

{{#each svc.functions as |func|}}
{{#if func.go_server_supported?}}

{{#partial processor_function func=func svc=svc}}

{{/if func.go_server_supported?}}
{{/each}}
{{#if svc.interaction?}}

func (p *{{svc.go_name}}Processor) OnTermination() {
    // If the underlying handler implements OnTermination()
    if terminable, ok := p.handler.(thrift.Terminable); ok {
        terminable.OnTermination()
    }
}
{{/if svc.interaction?}}
{{/let partial}}
