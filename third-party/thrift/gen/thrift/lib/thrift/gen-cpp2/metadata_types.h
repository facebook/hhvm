/**
 * Autogenerated by Thrift for /home/fbthrift/thrift/lib/thrift/metadata.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



namespace apache {
namespace thrift {
namespace tag {
struct name;
struct type;
struct fields;
struct cv_bool;
struct cv_integer;
struct cv_double;
struct cv_string;
struct cv_map;
struct cv_list;
struct cv_struct;
struct key;
struct value;
struct valueType;
struct valueType;
struct keyType;
struct valueType;
struct name;
struct name;
struct name;
struct underlyingType;
struct elemType;
struct initialResponseType;
struct elemType;
struct finalResponseType;
struct initialResponseType;
struct t_primitive;
struct t_list;
struct t_set;
struct t_map;
struct t_enum;
struct t_struct;
struct t_union;
struct t_typedef;
struct t_stream;
struct t_sink;
struct name;
struct elements;
struct structured_annotations;
struct id;
struct type;
struct name;
struct is_optional;
struct structured_annotations;
struct name;
struct fields;
struct is_union;
struct structured_annotations;
struct name;
struct fields;
struct structured_annotations;
struct name;
struct return_type;
struct arguments;
struct exceptions;
struct is_oneway;
struct structured_annotations;
struct name;
struct functions;
struct parent;
struct structured_annotations;
struct name;
struct service_info;
struct module;
struct enums;
struct structs;
struct exceptions;
struct services;
struct context;
struct metadata;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cv_bool
#define APACHE_THRIFT_ACCESSOR_cv_bool
APACHE_THRIFT_DEFINE_ACCESSOR(cv_bool);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cv_integer
#define APACHE_THRIFT_ACCESSOR_cv_integer
APACHE_THRIFT_DEFINE_ACCESSOR(cv_integer);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cv_double
#define APACHE_THRIFT_ACCESSOR_cv_double
APACHE_THRIFT_DEFINE_ACCESSOR(cv_double);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cv_string
#define APACHE_THRIFT_ACCESSOR_cv_string
APACHE_THRIFT_DEFINE_ACCESSOR(cv_string);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cv_map
#define APACHE_THRIFT_ACCESSOR_cv_map
APACHE_THRIFT_DEFINE_ACCESSOR(cv_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cv_list
#define APACHE_THRIFT_ACCESSOR_cv_list
APACHE_THRIFT_DEFINE_ACCESSOR(cv_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cv_struct
#define APACHE_THRIFT_ACCESSOR_cv_struct
APACHE_THRIFT_DEFINE_ACCESSOR(cv_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_valueType
#define APACHE_THRIFT_ACCESSOR_valueType
APACHE_THRIFT_DEFINE_ACCESSOR(valueType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_valueType
#define APACHE_THRIFT_ACCESSOR_valueType
APACHE_THRIFT_DEFINE_ACCESSOR(valueType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_keyType
#define APACHE_THRIFT_ACCESSOR_keyType
APACHE_THRIFT_DEFINE_ACCESSOR(keyType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_valueType
#define APACHE_THRIFT_ACCESSOR_valueType
APACHE_THRIFT_DEFINE_ACCESSOR(valueType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_underlyingType
#define APACHE_THRIFT_ACCESSOR_underlyingType
APACHE_THRIFT_DEFINE_ACCESSOR(underlyingType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_elemType
#define APACHE_THRIFT_ACCESSOR_elemType
APACHE_THRIFT_DEFINE_ACCESSOR(elemType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_initialResponseType
#define APACHE_THRIFT_ACCESSOR_initialResponseType
APACHE_THRIFT_DEFINE_ACCESSOR(initialResponseType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_elemType
#define APACHE_THRIFT_ACCESSOR_elemType
APACHE_THRIFT_DEFINE_ACCESSOR(elemType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_finalResponseType
#define APACHE_THRIFT_ACCESSOR_finalResponseType
APACHE_THRIFT_DEFINE_ACCESSOR(finalResponseType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_initialResponseType
#define APACHE_THRIFT_ACCESSOR_initialResponseType
APACHE_THRIFT_DEFINE_ACCESSOR(initialResponseType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_primitive
#define APACHE_THRIFT_ACCESSOR_t_primitive
APACHE_THRIFT_DEFINE_ACCESSOR(t_primitive);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_list
#define APACHE_THRIFT_ACCESSOR_t_list
APACHE_THRIFT_DEFINE_ACCESSOR(t_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_set
#define APACHE_THRIFT_ACCESSOR_t_set
APACHE_THRIFT_DEFINE_ACCESSOR(t_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_map
#define APACHE_THRIFT_ACCESSOR_t_map
APACHE_THRIFT_DEFINE_ACCESSOR(t_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_enum
#define APACHE_THRIFT_ACCESSOR_t_enum
APACHE_THRIFT_DEFINE_ACCESSOR(t_enum);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_struct
#define APACHE_THRIFT_ACCESSOR_t_struct
APACHE_THRIFT_DEFINE_ACCESSOR(t_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_union
#define APACHE_THRIFT_ACCESSOR_t_union
APACHE_THRIFT_DEFINE_ACCESSOR(t_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_typedef
#define APACHE_THRIFT_ACCESSOR_t_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(t_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_stream
#define APACHE_THRIFT_ACCESSOR_t_stream
APACHE_THRIFT_DEFINE_ACCESSOR(t_stream);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_sink
#define APACHE_THRIFT_ACCESSOR_t_sink
APACHE_THRIFT_DEFINE_ACCESSOR(t_sink);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_elements
#define APACHE_THRIFT_ACCESSOR_elements
APACHE_THRIFT_DEFINE_ACCESSOR(elements);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structured_annotations
#define APACHE_THRIFT_ACCESSOR_structured_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(structured_annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_optional
#define APACHE_THRIFT_ACCESSOR_is_optional
APACHE_THRIFT_DEFINE_ACCESSOR(is_optional);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structured_annotations
#define APACHE_THRIFT_ACCESSOR_structured_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(structured_annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_union
#define APACHE_THRIFT_ACCESSOR_is_union
APACHE_THRIFT_DEFINE_ACCESSOR(is_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structured_annotations
#define APACHE_THRIFT_ACCESSOR_structured_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(structured_annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structured_annotations
#define APACHE_THRIFT_ACCESSOR_structured_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(structured_annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_return_type
#define APACHE_THRIFT_ACCESSOR_return_type
APACHE_THRIFT_DEFINE_ACCESSOR(return_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_arguments
#define APACHE_THRIFT_ACCESSOR_arguments
APACHE_THRIFT_DEFINE_ACCESSOR(arguments);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exceptions
#define APACHE_THRIFT_ACCESSOR_exceptions
APACHE_THRIFT_DEFINE_ACCESSOR(exceptions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_oneway
#define APACHE_THRIFT_ACCESSOR_is_oneway
APACHE_THRIFT_DEFINE_ACCESSOR(is_oneway);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structured_annotations
#define APACHE_THRIFT_ACCESSOR_structured_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(structured_annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_functions
#define APACHE_THRIFT_ACCESSOR_functions
APACHE_THRIFT_DEFINE_ACCESSOR(functions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parent
#define APACHE_THRIFT_ACCESSOR_parent
APACHE_THRIFT_DEFINE_ACCESSOR(parent);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structured_annotations
#define APACHE_THRIFT_ACCESSOR_structured_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(structured_annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_service_info
#define APACHE_THRIFT_ACCESSOR_service_info
APACHE_THRIFT_DEFINE_ACCESSOR(service_info);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_module
#define APACHE_THRIFT_ACCESSOR_module
APACHE_THRIFT_DEFINE_ACCESSOR(module);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enums
#define APACHE_THRIFT_ACCESSOR_enums
APACHE_THRIFT_DEFINE_ACCESSOR(enums);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structs
#define APACHE_THRIFT_ACCESSOR_structs
APACHE_THRIFT_DEFINE_ACCESSOR(structs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exceptions
#define APACHE_THRIFT_ACCESSOR_exceptions
APACHE_THRIFT_DEFINE_ACCESSOR(exceptions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_services
#define APACHE_THRIFT_ACCESSOR_services
APACHE_THRIFT_DEFINE_ACCESSOR(services);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_context
#define APACHE_THRIFT_ACCESSOR_context
APACHE_THRIFT_DEFINE_ACCESSOR(context);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_metadata
#define APACHE_THRIFT_ACCESSOR_metadata
APACHE_THRIFT_DEFINE_ACCESSOR(metadata);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace apache { namespace thrift { namespace metadata {

enum class ThriftPrimitiveType {
  THRIFT_BOOL_TYPE = 1,
  THRIFT_BYTE_TYPE = 2,
  THRIFT_I16_TYPE = 3,
  THRIFT_I32_TYPE = 4,
  THRIFT_I64_TYPE = 5,
  THRIFT_FLOAT_TYPE = 6,
  THRIFT_DOUBLE_TYPE = 7,
  THRIFT_BINARY_TYPE = 8,
  THRIFT_STRING_TYPE = 9,
  THRIFT_VOID_TYPE = 10,
};




}}} // apache::thrift::metadata

namespace std {
template<> struct hash<::apache::thrift::metadata::ThriftPrimitiveType> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::metadata::ThriftPrimitiveType> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::apache::thrift::metadata::ThriftPrimitiveType>;

template <> struct TEnumTraits<::apache::thrift::metadata::ThriftPrimitiveType> {
  using type = ::apache::thrift::metadata::ThriftPrimitiveType;

  static constexpr std::size_t const size = 10;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::THRIFT_BOOL_TYPE; }
  static constexpr type max() { return type::THRIFT_VOID_TYPE; }
};


}} // apache::thrift

namespace apache { namespace thrift { namespace metadata {

using _ThriftPrimitiveType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ThriftPrimitiveType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ThriftPrimitiveType_EnumMapFactory::ValuesToNamesMapType _ThriftPrimitiveType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ThriftPrimitiveType_EnumMapFactory::NamesToValuesMapType _ThriftPrimitiveType_NAMES_TO_VALUES;

}}} // apache::thrift::metadata

// END declare_enums
// BEGIN forward_declare
namespace apache { namespace thrift { namespace metadata {
class ThriftStructType;
class ThriftConstStruct;
class ThriftConstValue;
class ThriftConstValuePair;
class ThriftListType;
class ThriftSetType;
class ThriftMapType;
class ThriftEnumType;
class ThriftUnionType;
class ThriftTypedefType;
class ThriftStreamType;
class ThriftSinkType;
class ThriftType;
class ThriftEnum;
class ThriftField;
class ThriftStruct;
class ThriftException;
class ThriftFunction;
class ThriftService;
class ThriftModuleContext;
class ThriftServiceContext;
class ThriftMetadata;
class ThriftServiceMetadataResponse;
}}} // apache::thrift::metadata
// END forward_declare
// BEGIN typedefs

// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
namespace apache { namespace thrift { namespace metadata {
class ThriftStructType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftStructType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftStructType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftStructType(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftStructType(ThriftStructType&&) = default;

  ThriftStructType(const ThriftStructType&) = default;


  ThriftStructType& operator=(ThriftStructType&&) = default;

  ThriftStructType& operator=(const ThriftStructType&) = default;
  void __clear();
 private:
  ::std::string name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftStructType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftStructType& __x, const ThriftStructType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftStructType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftStructType& __x, const ThriftStructType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftStructType& __x, const ThriftStructType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftStructType& __x, const ThriftStructType& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftStructType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftStructType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftStructType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftStructType >;
  friend void swap(ThriftStructType& a, ThriftStructType& b);
};

template <class Protocol_>
uint32_t ThriftStructType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftConstStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftConstStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftConstStruct() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftConstStruct(apache::thrift::FragileConstructor, ::apache::thrift::metadata::ThriftStructType type__arg, ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue> fields__arg);

  ThriftConstStruct(ThriftConstStruct&&) = default;

  ThriftConstStruct(const ThriftConstStruct&) = default;


  ThriftConstStruct& operator=(ThriftConstStruct&&) = default;

  ThriftConstStruct& operator=(const ThriftConstStruct&) = default;
  void __clear();
 private:
  ::apache::thrift::metadata::ThriftStructType type;
 private:
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue> fields;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool type;
    bool fields;
  } __isset = {};
  bool operator==(const ThriftConstStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftConstStruct& __x, const ThriftConstStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftConstStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftConstStruct& __x, const ThriftConstStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftConstStruct& __x, const ThriftConstStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftConstStruct& __x, const ThriftConstStruct& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }
  const ::apache::thrift::metadata::ThriftStructType& get_type() const&;
  ::apache::thrift::metadata::ThriftStructType get_type() &&;

  template <typename T_ThriftConstStruct_type_struct_setter = ::apache::thrift::metadata::ThriftStructType>
  ::apache::thrift::metadata::ThriftStructType& set_type(T_ThriftConstStruct_type_struct_setter&& type_) {
    type = std::forward<T_ThriftConstStruct_type_struct_setter>(type_);
    __isset.type = true;
    return type;
  }
  const ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue>& get_fields() const&;
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue> get_fields() &&;

  template <typename T_ThriftConstStruct_fields_struct_setter = ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue>>
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftConstValue>& set_fields(T_ThriftConstStruct_fields_struct_setter&& fields_) {
    fields = std::forward<T_ThriftConstStruct_fields_struct_setter>(fields_);
    __isset.fields = true;
    return fields;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftConstStruct >;
  friend void swap(ThriftConstStruct& a, ThriftConstStruct& b);
};

template <class Protocol_>
uint32_t ThriftConstStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftConstValue final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftConstValue;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    cv_bool = 1,
    cv_integer = 2,
    cv_double = 3,
    cv_string = 4,
    cv_map = 5,
    cv_list = 6,
    cv_struct = 7,
  } ;

  ThriftConstValue()
      : type_(Type::__EMPTY__) {}

  ThriftConstValue(ThriftConstValue&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::cv_bool:
      {
        set_cv_bool(std::move(rhs.value_.cv_bool));
        break;
      }
      case Type::cv_integer:
      {
        set_cv_integer(std::move(rhs.value_.cv_integer));
        break;
      }
      case Type::cv_double:
      {
        set_cv_double(std::move(rhs.value_.cv_double));
        break;
      }
      case Type::cv_string:
      {
        set_cv_string(std::move(rhs.value_.cv_string));
        break;
      }
      case Type::cv_map:
      {
        set_cv_map(std::move(rhs.value_.cv_map));
        break;
      }
      case Type::cv_list:
      {
        set_cv_list(std::move(rhs.value_.cv_list));
        break;
      }
      case Type::cv_struct:
      {
        set_cv_struct(std::move(rhs.value_.cv_struct));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ThriftConstValue(const ThriftConstValue& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::cv_bool:
      {
        set_cv_bool(rhs.value_.cv_bool);
        break;
      }
      case Type::cv_integer:
      {
        set_cv_integer(rhs.value_.cv_integer);
        break;
      }
      case Type::cv_double:
      {
        set_cv_double(rhs.value_.cv_double);
        break;
      }
      case Type::cv_string:
      {
        set_cv_string(rhs.value_.cv_string);
        break;
      }
      case Type::cv_map:
      {
        set_cv_map(rhs.value_.cv_map);
        break;
      }
      case Type::cv_list:
      {
        set_cv_list(rhs.value_.cv_list);
        break;
      }
      case Type::cv_struct:
      {
        set_cv_struct(rhs.value_.cv_struct);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ThriftConstValue& operator=(ThriftConstValue&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::cv_bool:
      {
        set_cv_bool(std::move(rhs.value_.cv_bool));
        break;
      }
      case Type::cv_integer:
      {
        set_cv_integer(std::move(rhs.value_.cv_integer));
        break;
      }
      case Type::cv_double:
      {
        set_cv_double(std::move(rhs.value_.cv_double));
        break;
      }
      case Type::cv_string:
      {
        set_cv_string(std::move(rhs.value_.cv_string));
        break;
      }
      case Type::cv_map:
      {
        set_cv_map(std::move(rhs.value_.cv_map));
        break;
      }
      case Type::cv_list:
      {
        set_cv_list(std::move(rhs.value_.cv_list));
        break;
      }
      case Type::cv_struct:
      {
        set_cv_struct(std::move(rhs.value_.cv_struct));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ThriftConstValue& operator=(const ThriftConstValue& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::cv_bool:
      {
        set_cv_bool(rhs.value_.cv_bool);
        break;
      }
      case Type::cv_integer:
      {
        set_cv_integer(rhs.value_.cv_integer);
        break;
      }
      case Type::cv_double:
      {
        set_cv_double(rhs.value_.cv_double);
        break;
      }
      case Type::cv_string:
      {
        set_cv_string(rhs.value_.cv_string);
        break;
      }
      case Type::cv_map:
      {
        set_cv_map(rhs.value_.cv_map);
        break;
      }
      case Type::cv_list:
      {
        set_cv_list(rhs.value_.cv_list);
        break;
      }
      case Type::cv_struct:
      {
        set_cv_struct(rhs.value_.cv_struct);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~ThriftConstValue() {
    __clear();
  }
  union storage_type {
    bool cv_bool;
    ::std::int64_t cv_integer;
    double cv_double;
    ::std::string cv_string;
    ::std::vector<::apache::thrift::metadata::ThriftConstValuePair> cv_map;
    ::std::vector<::apache::thrift::metadata::ThriftConstValue> cv_list;
    ::apache::thrift::metadata::ThriftConstStruct cv_struct;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const ThriftConstValue& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftConstValue& __x, const ThriftConstValue& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftConstValue& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftConstValue& __x, const ThriftConstValue& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftConstValue& __x, const ThriftConstValue& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftConstValue& __x, const ThriftConstValue& __y) {
    return !(__x < __y);
  }
#endif

  bool& set_cv_bool(bool t = bool()) {
    __clear();
    type_ = Type::cv_bool;
    ::new (std::addressof(value_.cv_bool)) bool(t);
    return value_.cv_bool;
  }

  ::std::int64_t& set_cv_integer(::std::int64_t t = ::std::int64_t()) {
    __clear();
    type_ = Type::cv_integer;
    ::new (std::addressof(value_.cv_integer)) ::std::int64_t(t);
    return value_.cv_integer;
  }

  double& set_cv_double(double t = double()) {
    __clear();
    type_ = Type::cv_double;
    ::new (std::addressof(value_.cv_double)) double(t);
    return value_.cv_double;
  }

  ::std::string& set_cv_string(::std::string const &t) {
    __clear();
    type_ = Type::cv_string;
    ::new (std::addressof(value_.cv_string)) ::std::string(t);
    return value_.cv_string;
  }

  ::std::string& set_cv_string(::std::string&& t) {
    __clear();
    type_ = Type::cv_string;
    ::new (std::addressof(value_.cv_string)) ::std::string(std::move(t));
    return value_.cv_string;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_cv_string(T&&... t) {
    __clear();
    type_ = Type::cv_string;
    ::new (std::addressof(value_.cv_string)) ::std::string(std::forward<T>(t)...);
    return value_.cv_string;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>& set_cv_map(::std::vector<::apache::thrift::metadata::ThriftConstValuePair> const &t) {
    __clear();
    type_ = Type::cv_map;
    ::new (std::addressof(value_.cv_map)) ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>(t);
    return value_.cv_map;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>& set_cv_map(::std::vector<::apache::thrift::metadata::ThriftConstValuePair>&& t) {
    __clear();
    type_ = Type::cv_map;
    ::new (std::addressof(value_.cv_map)) ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>(std::move(t));
    return value_.cv_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::apache::thrift::metadata::ThriftConstValuePair>, T...>> ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>& set_cv_map(T&&... t) {
    __clear();
    type_ = Type::cv_map;
    ::new (std::addressof(value_.cv_map)) ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>(std::forward<T>(t)...);
    return value_.cv_map;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValue>& set_cv_list(::std::vector<::apache::thrift::metadata::ThriftConstValue> const &t) {
    __clear();
    type_ = Type::cv_list;
    ::new (std::addressof(value_.cv_list)) ::std::vector<::apache::thrift::metadata::ThriftConstValue>(t);
    return value_.cv_list;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValue>& set_cv_list(::std::vector<::apache::thrift::metadata::ThriftConstValue>&& t) {
    __clear();
    type_ = Type::cv_list;
    ::new (std::addressof(value_.cv_list)) ::std::vector<::apache::thrift::metadata::ThriftConstValue>(std::move(t));
    return value_.cv_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::apache::thrift::metadata::ThriftConstValue>, T...>> ::std::vector<::apache::thrift::metadata::ThriftConstValue>& set_cv_list(T&&... t) {
    __clear();
    type_ = Type::cv_list;
    ::new (std::addressof(value_.cv_list)) ::std::vector<::apache::thrift::metadata::ThriftConstValue>(std::forward<T>(t)...);
    return value_.cv_list;
  }

  ::apache::thrift::metadata::ThriftConstStruct& set_cv_struct(::apache::thrift::metadata::ThriftConstStruct const &t) {
    __clear();
    type_ = Type::cv_struct;
    ::new (std::addressof(value_.cv_struct)) ::apache::thrift::metadata::ThriftConstStruct(t);
    return value_.cv_struct;
  }

  ::apache::thrift::metadata::ThriftConstStruct& set_cv_struct(::apache::thrift::metadata::ThriftConstStruct&& t) {
    __clear();
    type_ = Type::cv_struct;
    ::new (std::addressof(value_.cv_struct)) ::apache::thrift::metadata::ThriftConstStruct(std::move(t));
    return value_.cv_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftConstStruct, T...>> ::apache::thrift::metadata::ThriftConstStruct& set_cv_struct(T&&... t) {
    __clear();
    type_ = Type::cv_struct;
    ::new (std::addressof(value_.cv_struct)) ::apache::thrift::metadata::ThriftConstStruct(std::forward<T>(t)...);
    return value_.cv_struct;
  }

  bool const & get_cv_bool() const {
    assert(type_ == Type::cv_bool);
    return value_.cv_bool;
  }

  ::std::int64_t const & get_cv_integer() const {
    assert(type_ == Type::cv_integer);
    return value_.cv_integer;
  }

  double const & get_cv_double() const {
    assert(type_ == Type::cv_double);
    return value_.cv_double;
  }

  ::std::string const & get_cv_string() const {
    assert(type_ == Type::cv_string);
    return value_.cv_string;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValuePair> const & get_cv_map() const {
    assert(type_ == Type::cv_map);
    return value_.cv_map;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValue> const & get_cv_list() const {
    assert(type_ == Type::cv_list);
    return value_.cv_list;
  }

  ::apache::thrift::metadata::ThriftConstStruct const & get_cv_struct() const {
    assert(type_ == Type::cv_struct);
    return value_.cv_struct;
  }

  bool & mutable_cv_bool() {
    assert(type_ == Type::cv_bool);
    return value_.cv_bool;
  }

  ::std::int64_t & mutable_cv_integer() {
    assert(type_ == Type::cv_integer);
    return value_.cv_integer;
  }

  double & mutable_cv_double() {
    assert(type_ == Type::cv_double);
    return value_.cv_double;
  }

  ::std::string & mutable_cv_string() {
    assert(type_ == Type::cv_string);
    return value_.cv_string;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValuePair> & mutable_cv_map() {
    assert(type_ == Type::cv_map);
    return value_.cv_map;
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValue> & mutable_cv_list() {
    assert(type_ == Type::cv_list);
    return value_.cv_list;
  }

  ::apache::thrift::metadata::ThriftConstStruct & mutable_cv_struct() {
    assert(type_ == Type::cv_struct);
    return value_.cv_struct;
  }

  bool move_cv_bool() {
    assert(type_ == Type::cv_bool);
    return std::move(value_.cv_bool);
  }

  ::std::int64_t move_cv_integer() {
    assert(type_ == Type::cv_integer);
    return std::move(value_.cv_integer);
  }

  double move_cv_double() {
    assert(type_ == Type::cv_double);
    return std::move(value_.cv_double);
  }

  ::std::string move_cv_string() {
    assert(type_ == Type::cv_string);
    return std::move(value_.cv_string);
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValuePair> move_cv_map() {
    assert(type_ == Type::cv_map);
    return std::move(value_.cv_map);
  }

  ::std::vector<::apache::thrift::metadata::ThriftConstValue> move_cv_list() {
    assert(type_ == Type::cv_list);
    return std::move(value_.cv_list);
  }

  ::apache::thrift::metadata::ThriftConstStruct move_cv_struct() {
    assert(type_ == Type::cv_struct);
    return std::move(value_.cv_struct);
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cv_bool_ref() const& {
    return {value_.cv_bool, type_, cv_bool, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cv_bool_ref() const&& {
    return {std::move(value_.cv_bool), type_, cv_bool, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cv_bool_ref() & {
    return {value_.cv_bool, type_, cv_bool, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cv_bool_ref() && {
    return {std::move(value_.cv_bool), type_, cv_bool, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cv_integer_ref() const& {
    return {value_.cv_integer, type_, cv_integer, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cv_integer_ref() const&& {
    return {std::move(value_.cv_integer), type_, cv_integer, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cv_integer_ref() & {
    return {value_.cv_integer, type_, cv_integer, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cv_integer_ref() && {
    return {std::move(value_.cv_integer), type_, cv_integer, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cv_double_ref() const& {
    return {value_.cv_double, type_, cv_double, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cv_double_ref() const&& {
    return {std::move(value_.cv_double), type_, cv_double, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cv_double_ref() & {
    return {value_.cv_double, type_, cv_double, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cv_double_ref() && {
    return {std::move(value_.cv_double), type_, cv_double, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cv_string_ref() const& {
    return {value_.cv_string, type_, cv_string, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cv_string_ref() const&& {
    return {std::move(value_.cv_string), type_, cv_string, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cv_string_ref() & {
    return {value_.cv_string, type_, cv_string, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cv_string_ref() && {
    return {std::move(value_.cv_string), type_, cv_string, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cv_map_ref() const& {
    return {value_.cv_map, type_, cv_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cv_map_ref() const&& {
    return {std::move(value_.cv_map), type_, cv_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cv_map_ref() & {
    return {value_.cv_map, type_, cv_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValuePair>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cv_map_ref() && {
    return {std::move(value_.cv_map), type_, cv_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cv_list_ref() const& {
    return {value_.cv_list, type_, cv_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cv_list_ref() const&& {
    return {std::move(value_.cv_list), type_, cv_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cv_list_ref() & {
    return {value_.cv_list, type_, cv_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstValue>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cv_list_ref() && {
    return {std::move(value_.cv_list), type_, cv_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> cv_struct_ref() const& {
    return {value_.cv_struct, type_, cv_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> cv_struct_ref() const&& {
    return {std::move(value_.cv_struct), type_, cv_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> cv_struct_ref() & {
    return {value_.cv_struct, type_, cv_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> cv_struct_ref() && {
    return {std::move(value_.cv_struct), type_, cv_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftConstValue >;
  friend void swap(ThriftConstValue& a, ThriftConstValue& b);
};

template <class Protocol_>
uint32_t ThriftConstValue::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftConstValuePair final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftConstValuePair;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftConstValuePair() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftConstValuePair(apache::thrift::FragileConstructor, ::apache::thrift::metadata::ThriftConstValue key__arg, ::apache::thrift::metadata::ThriftConstValue value__arg);

  ThriftConstValuePair(ThriftConstValuePair&&) = default;

  ThriftConstValuePair(const ThriftConstValuePair&) = default;


  ThriftConstValuePair& operator=(ThriftConstValuePair&&) = default;

  ThriftConstValuePair& operator=(const ThriftConstValuePair&) = default;
  void __clear();
 private:
  ::apache::thrift::metadata::ThriftConstValue key;
 private:
  ::apache::thrift::metadata::ThriftConstValue value;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool key;
    bool value;
  } __isset = {};
  bool operator==(const ThriftConstValuePair& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftConstValuePair& __x, const ThriftConstValuePair& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftConstValuePair& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftConstValuePair& __x, const ThriftConstValuePair& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftConstValuePair& __x, const ThriftConstValuePair& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftConstValuePair& __x, const ThriftConstValuePair& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> key_ref() const& {
    return {this->key, __isset.key};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> key_ref() const&& {
    return {std::move(this->key), __isset.key};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> key_ref() & {
    return {this->key, __isset.key};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> key_ref() && {
    return {std::move(this->key), __isset.key};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> value_ref() const& {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> value_ref() const&& {
    return {std::move(this->value), __isset.value};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> value_ref() & {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftConstValue>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> value_ref() && {
    return {std::move(this->value), __isset.value};
  }
  const ::apache::thrift::metadata::ThriftConstValue& get_key() const&;
  ::apache::thrift::metadata::ThriftConstValue get_key() &&;

  template <typename T_ThriftConstValuePair_key_struct_setter = ::apache::thrift::metadata::ThriftConstValue>
  ::apache::thrift::metadata::ThriftConstValue& set_key(T_ThriftConstValuePair_key_struct_setter&& key_) {
    key = std::forward<T_ThriftConstValuePair_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }
  const ::apache::thrift::metadata::ThriftConstValue& get_value() const&;
  ::apache::thrift::metadata::ThriftConstValue get_value() &&;

  template <typename T_ThriftConstValuePair_value_struct_setter = ::apache::thrift::metadata::ThriftConstValue>
  ::apache::thrift::metadata::ThriftConstValue& set_value(T_ThriftConstValuePair_value_struct_setter&& value_) {
    value = std::forward<T_ThriftConstValuePair_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftConstValuePair >;
  friend void swap(ThriftConstValuePair& a, ThriftConstValuePair& b);
};

template <class Protocol_>
uint32_t ThriftConstValuePair::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftListType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftListType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftListType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftListType(apache::thrift::FragileConstructor, std::unique_ptr<::apache::thrift::metadata::ThriftType> valueType__arg);

  ThriftListType(ThriftListType&&) = default;
  ThriftListType(const ThriftListType& src);


  ThriftListType& operator=(ThriftListType&&) = default;
  ThriftListType& operator=(const ThriftListType& src);
  void __clear();
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> valueType;

 public:
  bool operator==(const ThriftListType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftListType& __x, const ThriftListType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftListType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftListType& __x, const ThriftListType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftListType& __x, const ThriftListType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftListType& __x, const ThriftListType& __y) {
    return !(__x < __y);
  }
#endif
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& valueType_ref() & { return valueType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& valueType_ref() const& { return valueType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& valueType_ref() && { return std::move(valueType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& valueType_ref() const&& { return std::move(valueType); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftListType >;
  friend void swap(ThriftListType& a, ThriftListType& b);
};

template <class Protocol_>
uint32_t ThriftListType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftSetType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftSetType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftSetType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftSetType(apache::thrift::FragileConstructor, std::unique_ptr<::apache::thrift::metadata::ThriftType> valueType__arg);

  ThriftSetType(ThriftSetType&&) = default;
  ThriftSetType(const ThriftSetType& src);


  ThriftSetType& operator=(ThriftSetType&&) = default;
  ThriftSetType& operator=(const ThriftSetType& src);
  void __clear();
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> valueType;

 public:
  bool operator==(const ThriftSetType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftSetType& __x, const ThriftSetType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftSetType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftSetType& __x, const ThriftSetType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftSetType& __x, const ThriftSetType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftSetType& __x, const ThriftSetType& __y) {
    return !(__x < __y);
  }
#endif
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& valueType_ref() & { return valueType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& valueType_ref() const& { return valueType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& valueType_ref() && { return std::move(valueType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& valueType_ref() const&& { return std::move(valueType); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftSetType >;
  friend void swap(ThriftSetType& a, ThriftSetType& b);
};

template <class Protocol_>
uint32_t ThriftSetType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftMapType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftMapType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftMapType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftMapType(apache::thrift::FragileConstructor, std::unique_ptr<::apache::thrift::metadata::ThriftType> keyType__arg, std::unique_ptr<::apache::thrift::metadata::ThriftType> valueType__arg);

  ThriftMapType(ThriftMapType&&) = default;
  ThriftMapType(const ThriftMapType& src);


  ThriftMapType& operator=(ThriftMapType&&) = default;
  ThriftMapType& operator=(const ThriftMapType& src);
  void __clear();
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> keyType;
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> valueType;

 public:
  bool operator==(const ThriftMapType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftMapType& __x, const ThriftMapType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftMapType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftMapType& __x, const ThriftMapType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftMapType& __x, const ThriftMapType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftMapType& __x, const ThriftMapType& __y) {
    return !(__x < __y);
  }
#endif
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& keyType_ref() & { return keyType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& keyType_ref() const& { return keyType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& keyType_ref() && { return std::move(keyType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& keyType_ref() const&& { return std::move(keyType); }
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& valueType_ref() & { return valueType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& valueType_ref() const& { return valueType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& valueType_ref() && { return std::move(valueType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& valueType_ref() const&& { return std::move(valueType); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftMapType >;
  friend void swap(ThriftMapType& a, ThriftMapType& b);
};

template <class Protocol_>
uint32_t ThriftMapType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftEnumType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftEnumType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftEnumType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftEnumType(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftEnumType(ThriftEnumType&&) = default;

  ThriftEnumType(const ThriftEnumType&) = default;


  ThriftEnumType& operator=(ThriftEnumType&&) = default;

  ThriftEnumType& operator=(const ThriftEnumType&) = default;
  void __clear();
 private:
  ::std::string name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftEnumType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftEnumType& __x, const ThriftEnumType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftEnumType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftEnumType& __x, const ThriftEnumType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftEnumType& __x, const ThriftEnumType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftEnumType& __x, const ThriftEnumType& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftEnumType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftEnumType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftEnumType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftEnumType >;
  friend void swap(ThriftEnumType& a, ThriftEnumType& b);
};

template <class Protocol_>
uint32_t ThriftEnumType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftUnionType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftUnionType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftUnionType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftUnionType(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftUnionType(ThriftUnionType&&) = default;

  ThriftUnionType(const ThriftUnionType&) = default;


  ThriftUnionType& operator=(ThriftUnionType&&) = default;

  ThriftUnionType& operator=(const ThriftUnionType&) = default;
  void __clear();
 private:
  ::std::string name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftUnionType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftUnionType& __x, const ThriftUnionType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftUnionType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftUnionType& __x, const ThriftUnionType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftUnionType& __x, const ThriftUnionType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftUnionType& __x, const ThriftUnionType& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftUnionType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftUnionType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftUnionType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftUnionType >;
  friend void swap(ThriftUnionType& a, ThriftUnionType& b);
};

template <class Protocol_>
uint32_t ThriftUnionType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftTypedefType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftTypedefType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftTypedefType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftTypedefType(apache::thrift::FragileConstructor, ::std::string name__arg, std::unique_ptr<::apache::thrift::metadata::ThriftType> underlyingType__arg);

  ThriftTypedefType(ThriftTypedefType&&) = default;
  ThriftTypedefType(const ThriftTypedefType& src);


  ThriftTypedefType& operator=(ThriftTypedefType&&) = default;
  ThriftTypedefType& operator=(const ThriftTypedefType& src);
  void __clear();
 private:
  ::std::string name;
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> underlyingType;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftTypedefType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftTypedefType& __x, const ThriftTypedefType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftTypedefType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftTypedefType& __x, const ThriftTypedefType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftTypedefType& __x, const ThriftTypedefType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftTypedefType& __x, const ThriftTypedefType& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& underlyingType_ref() & { return underlyingType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& underlyingType_ref() const& { return underlyingType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& underlyingType_ref() && { return std::move(underlyingType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& underlyingType_ref() const&& { return std::move(underlyingType); }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftTypedefType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftTypedefType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftTypedefType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftTypedefType >;
  friend void swap(ThriftTypedefType& a, ThriftTypedefType& b);
};

template <class Protocol_>
uint32_t ThriftTypedefType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftStreamType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftStreamType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftStreamType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftStreamType(apache::thrift::FragileConstructor, std::unique_ptr<::apache::thrift::metadata::ThriftType> elemType__arg, std::unique_ptr<::apache::thrift::metadata::ThriftType> initialResponseType__arg);

  ThriftStreamType(ThriftStreamType&&) = default;
  ThriftStreamType(const ThriftStreamType& src);


  ThriftStreamType& operator=(ThriftStreamType&&) = default;
  ThriftStreamType& operator=(const ThriftStreamType& src);
  void __clear();
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> elemType;
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> initialResponseType;

 public:
  bool operator==(const ThriftStreamType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftStreamType& __x, const ThriftStreamType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftStreamType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftStreamType& __x, const ThriftStreamType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftStreamType& __x, const ThriftStreamType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftStreamType& __x, const ThriftStreamType& __y) {
    return !(__x < __y);
  }
#endif
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& elemType_ref() & { return elemType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& elemType_ref() const& { return elemType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& elemType_ref() && { return std::move(elemType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& elemType_ref() const&& { return std::move(elemType); }
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& initialResponseType_ref() & { return initialResponseType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& initialResponseType_ref() const& { return initialResponseType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& initialResponseType_ref() && { return std::move(initialResponseType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& initialResponseType_ref() const&& { return std::move(initialResponseType); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftStreamType >;
  friend void swap(ThriftStreamType& a, ThriftStreamType& b);
};

template <class Protocol_>
uint32_t ThriftStreamType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftSinkType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftSinkType;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftSinkType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftSinkType(apache::thrift::FragileConstructor, std::unique_ptr<::apache::thrift::metadata::ThriftType> elemType__arg, std::unique_ptr<::apache::thrift::metadata::ThriftType> finalResponseType__arg, std::unique_ptr<::apache::thrift::metadata::ThriftType> initialResponseType__arg);

  ThriftSinkType(ThriftSinkType&&) = default;
  ThriftSinkType(const ThriftSinkType& src);


  ThriftSinkType& operator=(ThriftSinkType&&) = default;
  ThriftSinkType& operator=(const ThriftSinkType& src);
  void __clear();
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> elemType;
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> finalResponseType;
 public:
  std::unique_ptr<::apache::thrift::metadata::ThriftType> initialResponseType;

 public:
  bool operator==(const ThriftSinkType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftSinkType& __x, const ThriftSinkType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftSinkType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftSinkType& __x, const ThriftSinkType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftSinkType& __x, const ThriftSinkType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftSinkType& __x, const ThriftSinkType& __y) {
    return !(__x < __y);
  }
#endif
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& elemType_ref() & { return elemType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& elemType_ref() const& { return elemType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& elemType_ref() && { return std::move(elemType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& elemType_ref() const&& { return std::move(elemType); }
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& finalResponseType_ref() & { return finalResponseType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& finalResponseType_ref() const& { return finalResponseType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& finalResponseType_ref() && { return std::move(finalResponseType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& finalResponseType_ref() const&& { return std::move(finalResponseType); }
  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T& initialResponseType_ref() & { return initialResponseType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T& initialResponseType_ref() const& { return initialResponseType; }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE T&& initialResponseType_ref() && { return std::move(initialResponseType); }

  template <typename ..., typename T = std::unique_ptr<::apache::thrift::metadata::ThriftType>>
  FOLLY_ERASE const T&& initialResponseType_ref() const&& { return std::move(initialResponseType); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftSinkType >;
  friend void swap(ThriftSinkType& a, ThriftSinkType& b);
};

template <class Protocol_>
uint32_t ThriftSinkType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftType final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftType;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    t_primitive = 1,
    t_list = 2,
    t_set = 3,
    t_map = 4,
    t_enum = 5,
    t_struct = 6,
    t_union = 7,
    t_typedef = 8,
    t_stream = 9,
    t_sink = 10,
  } ;

  ThriftType()
      : type_(Type::__EMPTY__) {}

  ThriftType(ThriftType&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(std::move(rhs.value_.t_primitive));
        break;
      }
      case Type::t_list:
      {
        set_t_list(std::move(rhs.value_.t_list));
        break;
      }
      case Type::t_set:
      {
        set_t_set(std::move(rhs.value_.t_set));
        break;
      }
      case Type::t_map:
      {
        set_t_map(std::move(rhs.value_.t_map));
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(std::move(rhs.value_.t_enum));
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(std::move(rhs.value_.t_struct));
        break;
      }
      case Type::t_union:
      {
        set_t_union(std::move(rhs.value_.t_union));
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(std::move(rhs.value_.t_typedef));
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(std::move(rhs.value_.t_stream));
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(std::move(rhs.value_.t_sink));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ThriftType(const ThriftType& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(rhs.value_.t_primitive);
        break;
      }
      case Type::t_list:
      {
        set_t_list(rhs.value_.t_list);
        break;
      }
      case Type::t_set:
      {
        set_t_set(rhs.value_.t_set);
        break;
      }
      case Type::t_map:
      {
        set_t_map(rhs.value_.t_map);
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(rhs.value_.t_enum);
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(rhs.value_.t_struct);
        break;
      }
      case Type::t_union:
      {
        set_t_union(rhs.value_.t_union);
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(rhs.value_.t_typedef);
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(rhs.value_.t_stream);
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(rhs.value_.t_sink);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ThriftType& operator=(ThriftType&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(std::move(rhs.value_.t_primitive));
        break;
      }
      case Type::t_list:
      {
        set_t_list(std::move(rhs.value_.t_list));
        break;
      }
      case Type::t_set:
      {
        set_t_set(std::move(rhs.value_.t_set));
        break;
      }
      case Type::t_map:
      {
        set_t_map(std::move(rhs.value_.t_map));
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(std::move(rhs.value_.t_enum));
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(std::move(rhs.value_.t_struct));
        break;
      }
      case Type::t_union:
      {
        set_t_union(std::move(rhs.value_.t_union));
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(std::move(rhs.value_.t_typedef));
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(std::move(rhs.value_.t_stream));
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(std::move(rhs.value_.t_sink));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ThriftType& operator=(const ThriftType& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(rhs.value_.t_primitive);
        break;
      }
      case Type::t_list:
      {
        set_t_list(rhs.value_.t_list);
        break;
      }
      case Type::t_set:
      {
        set_t_set(rhs.value_.t_set);
        break;
      }
      case Type::t_map:
      {
        set_t_map(rhs.value_.t_map);
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(rhs.value_.t_enum);
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(rhs.value_.t_struct);
        break;
      }
      case Type::t_union:
      {
        set_t_union(rhs.value_.t_union);
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(rhs.value_.t_typedef);
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(rhs.value_.t_stream);
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(rhs.value_.t_sink);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~ThriftType() {
    __clear();
  }
  union storage_type {
    ::apache::thrift::metadata::ThriftPrimitiveType t_primitive;
    ::apache::thrift::metadata::ThriftListType t_list;
    ::apache::thrift::metadata::ThriftSetType t_set;
    ::apache::thrift::metadata::ThriftMapType t_map;
    ::apache::thrift::metadata::ThriftEnumType t_enum;
    ::apache::thrift::metadata::ThriftStructType t_struct;
    ::apache::thrift::metadata::ThriftUnionType t_union;
    ::apache::thrift::metadata::ThriftTypedefType t_typedef;
    ::apache::thrift::metadata::ThriftStreamType t_stream;
    ::apache::thrift::metadata::ThriftSinkType t_sink;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const ThriftType& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftType& __x, const ThriftType& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftType& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftType& __x, const ThriftType& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftType& __x, const ThriftType& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftType& __x, const ThriftType& __y) {
    return !(__x < __y);
  }
#endif

  ::apache::thrift::metadata::ThriftPrimitiveType& set_t_primitive(::apache::thrift::metadata::ThriftPrimitiveType t = ::apache::thrift::metadata::ThriftPrimitiveType()) {
    __clear();
    type_ = Type::t_primitive;
    ::new (std::addressof(value_.t_primitive)) ::apache::thrift::metadata::ThriftPrimitiveType(t);
    return value_.t_primitive;
  }

  ::apache::thrift::metadata::ThriftListType& set_t_list(::apache::thrift::metadata::ThriftListType const &t) {
    __clear();
    type_ = Type::t_list;
    ::new (std::addressof(value_.t_list)) ::apache::thrift::metadata::ThriftListType(t);
    return value_.t_list;
  }

  ::apache::thrift::metadata::ThriftListType& set_t_list(::apache::thrift::metadata::ThriftListType&& t) {
    __clear();
    type_ = Type::t_list;
    ::new (std::addressof(value_.t_list)) ::apache::thrift::metadata::ThriftListType(std::move(t));
    return value_.t_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftListType, T...>> ::apache::thrift::metadata::ThriftListType& set_t_list(T&&... t) {
    __clear();
    type_ = Type::t_list;
    ::new (std::addressof(value_.t_list)) ::apache::thrift::metadata::ThriftListType(std::forward<T>(t)...);
    return value_.t_list;
  }

  ::apache::thrift::metadata::ThriftSetType& set_t_set(::apache::thrift::metadata::ThriftSetType const &t) {
    __clear();
    type_ = Type::t_set;
    ::new (std::addressof(value_.t_set)) ::apache::thrift::metadata::ThriftSetType(t);
    return value_.t_set;
  }

  ::apache::thrift::metadata::ThriftSetType& set_t_set(::apache::thrift::metadata::ThriftSetType&& t) {
    __clear();
    type_ = Type::t_set;
    ::new (std::addressof(value_.t_set)) ::apache::thrift::metadata::ThriftSetType(std::move(t));
    return value_.t_set;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftSetType, T...>> ::apache::thrift::metadata::ThriftSetType& set_t_set(T&&... t) {
    __clear();
    type_ = Type::t_set;
    ::new (std::addressof(value_.t_set)) ::apache::thrift::metadata::ThriftSetType(std::forward<T>(t)...);
    return value_.t_set;
  }

  ::apache::thrift::metadata::ThriftMapType& set_t_map(::apache::thrift::metadata::ThriftMapType const &t) {
    __clear();
    type_ = Type::t_map;
    ::new (std::addressof(value_.t_map)) ::apache::thrift::metadata::ThriftMapType(t);
    return value_.t_map;
  }

  ::apache::thrift::metadata::ThriftMapType& set_t_map(::apache::thrift::metadata::ThriftMapType&& t) {
    __clear();
    type_ = Type::t_map;
    ::new (std::addressof(value_.t_map)) ::apache::thrift::metadata::ThriftMapType(std::move(t));
    return value_.t_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftMapType, T...>> ::apache::thrift::metadata::ThriftMapType& set_t_map(T&&... t) {
    __clear();
    type_ = Type::t_map;
    ::new (std::addressof(value_.t_map)) ::apache::thrift::metadata::ThriftMapType(std::forward<T>(t)...);
    return value_.t_map;
  }

  ::apache::thrift::metadata::ThriftEnumType& set_t_enum(::apache::thrift::metadata::ThriftEnumType const &t) {
    __clear();
    type_ = Type::t_enum;
    ::new (std::addressof(value_.t_enum)) ::apache::thrift::metadata::ThriftEnumType(t);
    return value_.t_enum;
  }

  ::apache::thrift::metadata::ThriftEnumType& set_t_enum(::apache::thrift::metadata::ThriftEnumType&& t) {
    __clear();
    type_ = Type::t_enum;
    ::new (std::addressof(value_.t_enum)) ::apache::thrift::metadata::ThriftEnumType(std::move(t));
    return value_.t_enum;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftEnumType, T...>> ::apache::thrift::metadata::ThriftEnumType& set_t_enum(T&&... t) {
    __clear();
    type_ = Type::t_enum;
    ::new (std::addressof(value_.t_enum)) ::apache::thrift::metadata::ThriftEnumType(std::forward<T>(t)...);
    return value_.t_enum;
  }

  ::apache::thrift::metadata::ThriftStructType& set_t_struct(::apache::thrift::metadata::ThriftStructType const &t) {
    __clear();
    type_ = Type::t_struct;
    ::new (std::addressof(value_.t_struct)) ::apache::thrift::metadata::ThriftStructType(t);
    return value_.t_struct;
  }

  ::apache::thrift::metadata::ThriftStructType& set_t_struct(::apache::thrift::metadata::ThriftStructType&& t) {
    __clear();
    type_ = Type::t_struct;
    ::new (std::addressof(value_.t_struct)) ::apache::thrift::metadata::ThriftStructType(std::move(t));
    return value_.t_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftStructType, T...>> ::apache::thrift::metadata::ThriftStructType& set_t_struct(T&&... t) {
    __clear();
    type_ = Type::t_struct;
    ::new (std::addressof(value_.t_struct)) ::apache::thrift::metadata::ThriftStructType(std::forward<T>(t)...);
    return value_.t_struct;
  }

  ::apache::thrift::metadata::ThriftUnionType& set_t_union(::apache::thrift::metadata::ThriftUnionType const &t) {
    __clear();
    type_ = Type::t_union;
    ::new (std::addressof(value_.t_union)) ::apache::thrift::metadata::ThriftUnionType(t);
    return value_.t_union;
  }

  ::apache::thrift::metadata::ThriftUnionType& set_t_union(::apache::thrift::metadata::ThriftUnionType&& t) {
    __clear();
    type_ = Type::t_union;
    ::new (std::addressof(value_.t_union)) ::apache::thrift::metadata::ThriftUnionType(std::move(t));
    return value_.t_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftUnionType, T...>> ::apache::thrift::metadata::ThriftUnionType& set_t_union(T&&... t) {
    __clear();
    type_ = Type::t_union;
    ::new (std::addressof(value_.t_union)) ::apache::thrift::metadata::ThriftUnionType(std::forward<T>(t)...);
    return value_.t_union;
  }

  ::apache::thrift::metadata::ThriftTypedefType& set_t_typedef(::apache::thrift::metadata::ThriftTypedefType const &t) {
    __clear();
    type_ = Type::t_typedef;
    ::new (std::addressof(value_.t_typedef)) ::apache::thrift::metadata::ThriftTypedefType(t);
    return value_.t_typedef;
  }

  ::apache::thrift::metadata::ThriftTypedefType& set_t_typedef(::apache::thrift::metadata::ThriftTypedefType&& t) {
    __clear();
    type_ = Type::t_typedef;
    ::new (std::addressof(value_.t_typedef)) ::apache::thrift::metadata::ThriftTypedefType(std::move(t));
    return value_.t_typedef;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftTypedefType, T...>> ::apache::thrift::metadata::ThriftTypedefType& set_t_typedef(T&&... t) {
    __clear();
    type_ = Type::t_typedef;
    ::new (std::addressof(value_.t_typedef)) ::apache::thrift::metadata::ThriftTypedefType(std::forward<T>(t)...);
    return value_.t_typedef;
  }

  ::apache::thrift::metadata::ThriftStreamType& set_t_stream(::apache::thrift::metadata::ThriftStreamType const &t) {
    __clear();
    type_ = Type::t_stream;
    ::new (std::addressof(value_.t_stream)) ::apache::thrift::metadata::ThriftStreamType(t);
    return value_.t_stream;
  }

  ::apache::thrift::metadata::ThriftStreamType& set_t_stream(::apache::thrift::metadata::ThriftStreamType&& t) {
    __clear();
    type_ = Type::t_stream;
    ::new (std::addressof(value_.t_stream)) ::apache::thrift::metadata::ThriftStreamType(std::move(t));
    return value_.t_stream;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftStreamType, T...>> ::apache::thrift::metadata::ThriftStreamType& set_t_stream(T&&... t) {
    __clear();
    type_ = Type::t_stream;
    ::new (std::addressof(value_.t_stream)) ::apache::thrift::metadata::ThriftStreamType(std::forward<T>(t)...);
    return value_.t_stream;
  }

  ::apache::thrift::metadata::ThriftSinkType& set_t_sink(::apache::thrift::metadata::ThriftSinkType const &t) {
    __clear();
    type_ = Type::t_sink;
    ::new (std::addressof(value_.t_sink)) ::apache::thrift::metadata::ThriftSinkType(t);
    return value_.t_sink;
  }

  ::apache::thrift::metadata::ThriftSinkType& set_t_sink(::apache::thrift::metadata::ThriftSinkType&& t) {
    __clear();
    type_ = Type::t_sink;
    ::new (std::addressof(value_.t_sink)) ::apache::thrift::metadata::ThriftSinkType(std::move(t));
    return value_.t_sink;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::metadata::ThriftSinkType, T...>> ::apache::thrift::metadata::ThriftSinkType& set_t_sink(T&&... t) {
    __clear();
    type_ = Type::t_sink;
    ::new (std::addressof(value_.t_sink)) ::apache::thrift::metadata::ThriftSinkType(std::forward<T>(t)...);
    return value_.t_sink;
  }

  ::apache::thrift::metadata::ThriftPrimitiveType const & get_t_primitive() const {
    assert(type_ == Type::t_primitive);
    return value_.t_primitive;
  }

  ::apache::thrift::metadata::ThriftListType const & get_t_list() const {
    assert(type_ == Type::t_list);
    return value_.t_list;
  }

  ::apache::thrift::metadata::ThriftSetType const & get_t_set() const {
    assert(type_ == Type::t_set);
    return value_.t_set;
  }

  ::apache::thrift::metadata::ThriftMapType const & get_t_map() const {
    assert(type_ == Type::t_map);
    return value_.t_map;
  }

  ::apache::thrift::metadata::ThriftEnumType const & get_t_enum() const {
    assert(type_ == Type::t_enum);
    return value_.t_enum;
  }

  ::apache::thrift::metadata::ThriftStructType const & get_t_struct() const {
    assert(type_ == Type::t_struct);
    return value_.t_struct;
  }

  ::apache::thrift::metadata::ThriftUnionType const & get_t_union() const {
    assert(type_ == Type::t_union);
    return value_.t_union;
  }

  ::apache::thrift::metadata::ThriftTypedefType const & get_t_typedef() const {
    assert(type_ == Type::t_typedef);
    return value_.t_typedef;
  }

  ::apache::thrift::metadata::ThriftStreamType const & get_t_stream() const {
    assert(type_ == Type::t_stream);
    return value_.t_stream;
  }

  ::apache::thrift::metadata::ThriftSinkType const & get_t_sink() const {
    assert(type_ == Type::t_sink);
    return value_.t_sink;
  }

  ::apache::thrift::metadata::ThriftPrimitiveType & mutable_t_primitive() {
    assert(type_ == Type::t_primitive);
    return value_.t_primitive;
  }

  ::apache::thrift::metadata::ThriftListType & mutable_t_list() {
    assert(type_ == Type::t_list);
    return value_.t_list;
  }

  ::apache::thrift::metadata::ThriftSetType & mutable_t_set() {
    assert(type_ == Type::t_set);
    return value_.t_set;
  }

  ::apache::thrift::metadata::ThriftMapType & mutable_t_map() {
    assert(type_ == Type::t_map);
    return value_.t_map;
  }

  ::apache::thrift::metadata::ThriftEnumType & mutable_t_enum() {
    assert(type_ == Type::t_enum);
    return value_.t_enum;
  }

  ::apache::thrift::metadata::ThriftStructType & mutable_t_struct() {
    assert(type_ == Type::t_struct);
    return value_.t_struct;
  }

  ::apache::thrift::metadata::ThriftUnionType & mutable_t_union() {
    assert(type_ == Type::t_union);
    return value_.t_union;
  }

  ::apache::thrift::metadata::ThriftTypedefType & mutable_t_typedef() {
    assert(type_ == Type::t_typedef);
    return value_.t_typedef;
  }

  ::apache::thrift::metadata::ThriftStreamType & mutable_t_stream() {
    assert(type_ == Type::t_stream);
    return value_.t_stream;
  }

  ::apache::thrift::metadata::ThriftSinkType & mutable_t_sink() {
    assert(type_ == Type::t_sink);
    return value_.t_sink;
  }

  ::apache::thrift::metadata::ThriftPrimitiveType move_t_primitive() {
    assert(type_ == Type::t_primitive);
    return std::move(value_.t_primitive);
  }

  ::apache::thrift::metadata::ThriftListType move_t_list() {
    assert(type_ == Type::t_list);
    return std::move(value_.t_list);
  }

  ::apache::thrift::metadata::ThriftSetType move_t_set() {
    assert(type_ == Type::t_set);
    return std::move(value_.t_set);
  }

  ::apache::thrift::metadata::ThriftMapType move_t_map() {
    assert(type_ == Type::t_map);
    return std::move(value_.t_map);
  }

  ::apache::thrift::metadata::ThriftEnumType move_t_enum() {
    assert(type_ == Type::t_enum);
    return std::move(value_.t_enum);
  }

  ::apache::thrift::metadata::ThriftStructType move_t_struct() {
    assert(type_ == Type::t_struct);
    return std::move(value_.t_struct);
  }

  ::apache::thrift::metadata::ThriftUnionType move_t_union() {
    assert(type_ == Type::t_union);
    return std::move(value_.t_union);
  }

  ::apache::thrift::metadata::ThriftTypedefType move_t_typedef() {
    assert(type_ == Type::t_typedef);
    return std::move(value_.t_typedef);
  }

  ::apache::thrift::metadata::ThriftStreamType move_t_stream() {
    assert(type_ == Type::t_stream);
    return std::move(value_.t_stream);
  }

  ::apache::thrift::metadata::ThriftSinkType move_t_sink() {
    assert(type_ == Type::t_sink);
    return std::move(value_.t_sink);
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftPrimitiveType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_primitive_ref() const& {
    return {value_.t_primitive, type_, t_primitive, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftPrimitiveType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_primitive_ref() const&& {
    return {std::move(value_.t_primitive), type_, t_primitive, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftPrimitiveType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_primitive_ref() & {
    return {value_.t_primitive, type_, t_primitive, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftPrimitiveType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_primitive_ref() && {
    return {std::move(value_.t_primitive), type_, t_primitive, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftListType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_list_ref() const& {
    return {value_.t_list, type_, t_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftListType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_list_ref() const&& {
    return {std::move(value_.t_list), type_, t_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftListType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_list_ref() & {
    return {value_.t_list, type_, t_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftListType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_list_ref() && {
    return {std::move(value_.t_list), type_, t_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftSetType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_set_ref() const& {
    return {value_.t_set, type_, t_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftSetType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_set_ref() const&& {
    return {std::move(value_.t_set), type_, t_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftSetType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_set_ref() & {
    return {value_.t_set, type_, t_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftSetType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_set_ref() && {
    return {std::move(value_.t_set), type_, t_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftMapType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_map_ref() const& {
    return {value_.t_map, type_, t_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftMapType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_map_ref() const&& {
    return {std::move(value_.t_map), type_, t_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftMapType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_map_ref() & {
    return {value_.t_map, type_, t_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftMapType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_map_ref() && {
    return {std::move(value_.t_map), type_, t_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftEnumType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_enum_ref() const& {
    return {value_.t_enum, type_, t_enum, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftEnumType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_enum_ref() const&& {
    return {std::move(value_.t_enum), type_, t_enum, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftEnumType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_enum_ref() & {
    return {value_.t_enum, type_, t_enum, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftEnumType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_enum_ref() && {
    return {std::move(value_.t_enum), type_, t_enum, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_struct_ref() const& {
    return {value_.t_struct, type_, t_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_struct_ref() const&& {
    return {std::move(value_.t_struct), type_, t_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_struct_ref() & {
    return {value_.t_struct, type_, t_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStructType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_struct_ref() && {
    return {std::move(value_.t_struct), type_, t_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftUnionType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_union_ref() const& {
    return {value_.t_union, type_, t_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftUnionType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_union_ref() const&& {
    return {std::move(value_.t_union), type_, t_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftUnionType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_union_ref() & {
    return {value_.t_union, type_, t_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftUnionType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_union_ref() && {
    return {std::move(value_.t_union), type_, t_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftTypedefType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_typedef_ref() const& {
    return {value_.t_typedef, type_, t_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftTypedefType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_typedef_ref() const&& {
    return {std::move(value_.t_typedef), type_, t_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftTypedefType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_typedef_ref() & {
    return {value_.t_typedef, type_, t_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftTypedefType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_typedef_ref() && {
    return {std::move(value_.t_typedef), type_, t_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftStreamType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_stream_ref() const& {
    return {value_.t_stream, type_, t_stream, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStreamType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_stream_ref() const&& {
    return {std::move(value_.t_stream), type_, t_stream, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStreamType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_stream_ref() & {
    return {value_.t_stream, type_, t_stream, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftStreamType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_stream_ref() && {
    return {std::move(value_.t_stream), type_, t_stream, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::metadata::ThriftSinkType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> t_sink_ref() const& {
    return {value_.t_sink, type_, t_sink, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftSinkType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> t_sink_ref() const&& {
    return {std::move(value_.t_sink), type_, t_sink, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftSinkType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> t_sink_ref() & {
    return {value_.t_sink, type_, t_sink, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftSinkType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> t_sink_ref() && {
    return {std::move(value_.t_sink), type_, t_sink, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftType >;
  friend void swap(ThriftType& a, ThriftType& b);
};

template <class Protocol_>
uint32_t ThriftType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftEnum final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftEnum;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftEnum() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftEnum(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::map<::std::int32_t, ::std::string> elements__arg, ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations__arg);

  ThriftEnum(ThriftEnum&&) = default;

  ThriftEnum(const ThriftEnum&) = default;


  ThriftEnum& operator=(ThriftEnum&&) = default;

  ThriftEnum& operator=(const ThriftEnum&) = default;
  void __clear();
 private:
  ::std::string name;
 private:
  ::std::map<::std::int32_t, ::std::string> elements;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool elements;
    bool structured_annotations;
  } __isset = {};
  bool operator==(const ThriftEnum& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftEnum& __x, const ThriftEnum& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftEnum& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftEnum& __x, const ThriftEnum& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftEnum& __x, const ThriftEnum& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftEnum& __x, const ThriftEnum& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> elements_ref() const& {
    return {this->elements, __isset.elements};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> elements_ref() const&& {
    return {std::move(this->elements), __isset.elements};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> elements_ref() & {
    return {this->elements, __isset.elements};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> elements_ref() && {
    return {std::move(this->elements), __isset.elements};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structured_annotations_ref() const& {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structured_annotations_ref() const&& {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structured_annotations_ref() & {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structured_annotations_ref() && {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftEnum_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftEnum_name_struct_setter&& name_) {
    name = std::forward<T_ThriftEnum_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::map<::std::int32_t, ::std::string>& get_elements() const&;
  ::std::map<::std::int32_t, ::std::string> get_elements() &&;

  template <typename T_ThriftEnum_elements_struct_setter = ::std::map<::std::int32_t, ::std::string>>
  ::std::map<::std::int32_t, ::std::string>& set_elements(T_ThriftEnum_elements_struct_setter&& elements_) {
    elements = std::forward<T_ThriftEnum_elements_struct_setter>(elements_);
    __isset.elements = true;
    return elements;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& get_structured_annotations() const&;
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> get_structured_annotations() &&;

  template <typename T_ThriftEnum_structured_annotations_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& set_structured_annotations(T_ThriftEnum_structured_annotations_struct_setter&& structured_annotations_) {
    structured_annotations = std::forward<T_ThriftEnum_structured_annotations_struct_setter>(structured_annotations_);
    __isset.structured_annotations = true;
    return structured_annotations;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftEnum >;
  friend void swap(ThriftEnum& a, ThriftEnum& b);
};

template <class Protocol_>
uint32_t ThriftEnum::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftField final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftField;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftField();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftField(apache::thrift::FragileConstructor, ::std::int32_t id__arg, ::apache::thrift::metadata::ThriftType type__arg, ::std::string name__arg, bool is_optional__arg, ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations__arg);

  ThriftField(ThriftField&&) = default;

  ThriftField(const ThriftField&) = default;


  ThriftField& operator=(ThriftField&&) = default;

  ThriftField& operator=(const ThriftField&) = default;
  void __clear();

  ~ThriftField();

 private:
  ::std::int32_t id;
 private:
  ::apache::thrift::metadata::ThriftType type;
 private:
  ::std::string name;
 private:
  bool is_optional;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool id;
    bool type;
    bool name;
    bool is_optional;
    bool structured_annotations;
  } __isset = {};
  bool operator==(const ThriftField& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftField& __x, const ThriftField& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftField& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftField& __x, const ThriftField& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftField& __x, const ThriftField& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftField& __x, const ThriftField& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_optional_ref() const& {
    return {this->is_optional, __isset.is_optional};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_optional_ref() const&& {
    return {std::move(this->is_optional), __isset.is_optional};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_optional_ref() & {
    return {this->is_optional, __isset.is_optional};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_optional_ref() && {
    return {std::move(this->is_optional), __isset.is_optional};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structured_annotations_ref() const& {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structured_annotations_ref() const&& {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structured_annotations_ref() & {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structured_annotations_ref() && {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  ::std::int32_t get_id() const {
    return id;
  }

  ::std::int32_t& set_id(::std::int32_t id_) {
    id = id_;
    __isset.id = true;
    return id;
  }
  const ::apache::thrift::metadata::ThriftType& get_type() const&;
  ::apache::thrift::metadata::ThriftType get_type() &&;

  template <typename T_ThriftField_type_struct_setter = ::apache::thrift::metadata::ThriftType>
  ::apache::thrift::metadata::ThriftType& set_type(T_ThriftField_type_struct_setter&& type_) {
    type = std::forward<T_ThriftField_type_struct_setter>(type_);
    __isset.type = true;
    return type;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftField_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftField_name_struct_setter&& name_) {
    name = std::forward<T_ThriftField_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  bool get_is_optional() const {
    return is_optional;
  }

  bool& set_is_optional(bool is_optional_) {
    is_optional = is_optional_;
    __isset.is_optional = true;
    return is_optional;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& get_structured_annotations() const&;
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> get_structured_annotations() &&;

  template <typename T_ThriftField_structured_annotations_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& set_structured_annotations(T_ThriftField_structured_annotations_struct_setter&& structured_annotations_) {
    structured_annotations = std::forward<T_ThriftField_structured_annotations_struct_setter>(structured_annotations_);
    __isset.structured_annotations = true;
    return structured_annotations;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftField >;
  friend void swap(ThriftField& a, ThriftField& b);
};

template <class Protocol_>
uint32_t ThriftField::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftStruct() :
      is_union(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftStruct(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::vector<::apache::thrift::metadata::ThriftField> fields__arg, bool is_union__arg, ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations__arg);

  ThriftStruct(ThriftStruct&&) = default;

  ThriftStruct(const ThriftStruct&) = default;


  ThriftStruct& operator=(ThriftStruct&&) = default;

  ThriftStruct& operator=(const ThriftStruct&) = default;
  void __clear();
 private:
  ::std::string name;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftField> fields;
 private:
  bool is_union;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool fields;
    bool is_union;
    bool structured_annotations;
  } __isset = {};
  bool operator==(const ThriftStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftStruct& __x, const ThriftStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftStruct& __x, const ThriftStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftStruct& __x, const ThriftStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftStruct& __x, const ThriftStruct& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_union_ref() const& {
    return {this->is_union, __isset.is_union};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_union_ref() const&& {
    return {std::move(this->is_union), __isset.is_union};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_union_ref() & {
    return {this->is_union, __isset.is_union};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_union_ref() && {
    return {std::move(this->is_union), __isset.is_union};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structured_annotations_ref() const& {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structured_annotations_ref() const&& {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structured_annotations_ref() & {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structured_annotations_ref() && {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftStruct_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftStruct_name_struct_setter&& name_) {
    name = std::forward<T_ThriftStruct_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftField>& get_fields() const&;
  ::std::vector<::apache::thrift::metadata::ThriftField> get_fields() &&;

  template <typename T_ThriftStruct_fields_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftField>>
  ::std::vector<::apache::thrift::metadata::ThriftField>& set_fields(T_ThriftStruct_fields_struct_setter&& fields_) {
    fields = std::forward<T_ThriftStruct_fields_struct_setter>(fields_);
    __isset.fields = true;
    return fields;
  }

  bool get_is_union() const {
    return is_union;
  }

  bool& set_is_union(bool is_union_) {
    is_union = is_union_;
    __isset.is_union = true;
    return is_union;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& get_structured_annotations() const&;
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> get_structured_annotations() &&;

  template <typename T_ThriftStruct_structured_annotations_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& set_structured_annotations(T_ThriftStruct_structured_annotations_struct_setter&& structured_annotations_) {
    structured_annotations = std::forward<T_ThriftStruct_structured_annotations_struct_setter>(structured_annotations_);
    __isset.structured_annotations = true;
    return structured_annotations;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftStruct >;
  friend void swap(ThriftStruct& a, ThriftStruct& b);
};

template <class Protocol_>
uint32_t ThriftStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftException final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftException(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::vector<::apache::thrift::metadata::ThriftField> fields__arg, ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations__arg);

  ThriftException(ThriftException&&) = default;

  ThriftException(const ThriftException&) = default;


  ThriftException& operator=(ThriftException&&) = default;

  ThriftException& operator=(const ThriftException&) = default;
  void __clear();
 private:
  ::std::string name;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftField> fields;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool fields;
    bool structured_annotations;
  } __isset = {};
  bool operator==(const ThriftException& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftException& __x, const ThriftException& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftException& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftException& __x, const ThriftException& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftException& __x, const ThriftException& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftException& __x, const ThriftException& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structured_annotations_ref() const& {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structured_annotations_ref() const&& {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structured_annotations_ref() & {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structured_annotations_ref() && {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftException_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftException_name_struct_setter&& name_) {
    name = std::forward<T_ThriftException_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftField>& get_fields() const&;
  ::std::vector<::apache::thrift::metadata::ThriftField> get_fields() &&;

  template <typename T_ThriftException_fields_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftField>>
  ::std::vector<::apache::thrift::metadata::ThriftField>& set_fields(T_ThriftException_fields_struct_setter&& fields_) {
    fields = std::forward<T_ThriftException_fields_struct_setter>(fields_);
    __isset.fields = true;
    return fields;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& get_structured_annotations() const&;
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> get_structured_annotations() &&;

  template <typename T_ThriftException_structured_annotations_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& set_structured_annotations(T_ThriftException_structured_annotations_struct_setter&& structured_annotations_) {
    structured_annotations = std::forward<T_ThriftException_structured_annotations_struct_setter>(structured_annotations_);
    __isset.structured_annotations = true;
    return structured_annotations;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftException >;
  friend void swap(ThriftException& a, ThriftException& b);
};

template <class Protocol_>
uint32_t ThriftException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftFunction final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftFunction;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftFunction();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftFunction(apache::thrift::FragileConstructor, ::std::string name__arg, ::apache::thrift::metadata::ThriftType return_type__arg, ::std::vector<::apache::thrift::metadata::ThriftField> arguments__arg, ::std::vector<::apache::thrift::metadata::ThriftField> exceptions__arg, bool is_oneway__arg, ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations__arg);

  ThriftFunction(ThriftFunction&&) = default;

  ThriftFunction(const ThriftFunction&) = default;


  ThriftFunction& operator=(ThriftFunction&&) = default;

  ThriftFunction& operator=(const ThriftFunction&) = default;
  void __clear();

  ~ThriftFunction();

 private:
  ::std::string name;
 private:
  ::apache::thrift::metadata::ThriftType return_type;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftField> arguments;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftField> exceptions;
 private:
  bool is_oneway;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool return_type;
    bool arguments;
    bool exceptions;
    bool is_oneway;
    bool structured_annotations;
  } __isset = {};
  bool operator==(const ThriftFunction& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftFunction& __x, const ThriftFunction& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftFunction& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftFunction& __x, const ThriftFunction& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftFunction& __x, const ThriftFunction& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftFunction& __x, const ThriftFunction& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> return_type_ref() const& {
    return {this->return_type, __isset.return_type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> return_type_ref() const&& {
    return {std::move(this->return_type), __isset.return_type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> return_type_ref() & {
    return {this->return_type, __isset.return_type};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> return_type_ref() && {
    return {std::move(this->return_type), __isset.return_type};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> arguments_ref() const& {
    return {this->arguments, __isset.arguments};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> arguments_ref() const&& {
    return {std::move(this->arguments), __isset.arguments};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> arguments_ref() & {
    return {this->arguments, __isset.arguments};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> arguments_ref() && {
    return {std::move(this->arguments), __isset.arguments};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exceptions_ref() const& {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exceptions_ref() const&& {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exceptions_ref() & {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exceptions_ref() && {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_oneway_ref() const& {
    return {this->is_oneway, __isset.is_oneway};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_oneway_ref() const&& {
    return {std::move(this->is_oneway), __isset.is_oneway};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_oneway_ref() & {
    return {this->is_oneway, __isset.is_oneway};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_oneway_ref() && {
    return {std::move(this->is_oneway), __isset.is_oneway};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structured_annotations_ref() const& {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structured_annotations_ref() const&& {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structured_annotations_ref() & {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structured_annotations_ref() && {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftFunction_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftFunction_name_struct_setter&& name_) {
    name = std::forward<T_ThriftFunction_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::apache::thrift::metadata::ThriftType& get_return_type() const&;
  ::apache::thrift::metadata::ThriftType get_return_type() &&;

  template <typename T_ThriftFunction_return_type_struct_setter = ::apache::thrift::metadata::ThriftType>
  ::apache::thrift::metadata::ThriftType& set_return_type(T_ThriftFunction_return_type_struct_setter&& return_type_) {
    return_type = std::forward<T_ThriftFunction_return_type_struct_setter>(return_type_);
    __isset.return_type = true;
    return return_type;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftField>& get_arguments() const&;
  ::std::vector<::apache::thrift::metadata::ThriftField> get_arguments() &&;

  template <typename T_ThriftFunction_arguments_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftField>>
  ::std::vector<::apache::thrift::metadata::ThriftField>& set_arguments(T_ThriftFunction_arguments_struct_setter&& arguments_) {
    arguments = std::forward<T_ThriftFunction_arguments_struct_setter>(arguments_);
    __isset.arguments = true;
    return arguments;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftField>& get_exceptions() const&;
  ::std::vector<::apache::thrift::metadata::ThriftField> get_exceptions() &&;

  template <typename T_ThriftFunction_exceptions_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftField>>
  ::std::vector<::apache::thrift::metadata::ThriftField>& set_exceptions(T_ThriftFunction_exceptions_struct_setter&& exceptions_) {
    exceptions = std::forward<T_ThriftFunction_exceptions_struct_setter>(exceptions_);
    __isset.exceptions = true;
    return exceptions;
  }

  bool get_is_oneway() const {
    return is_oneway;
  }

  bool& set_is_oneway(bool is_oneway_) {
    is_oneway = is_oneway_;
    __isset.is_oneway = true;
    return is_oneway;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& get_structured_annotations() const&;
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> get_structured_annotations() &&;

  template <typename T_ThriftFunction_structured_annotations_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& set_structured_annotations(T_ThriftFunction_structured_annotations_struct_setter&& structured_annotations_) {
    structured_annotations = std::forward<T_ThriftFunction_structured_annotations_struct_setter>(structured_annotations_);
    __isset.structured_annotations = true;
    return structured_annotations;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftFunction >;
  friend void swap(ThriftFunction& a, ThriftFunction& b);
};

template <class Protocol_>
uint32_t ThriftFunction::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftService final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftService;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftService() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftService(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::vector<::apache::thrift::metadata::ThriftFunction> functions__arg, ::std::string parent__arg, ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations__arg);

  ThriftService(ThriftService&&) = default;

  ThriftService(const ThriftService&) = default;


  ThriftService& operator=(ThriftService&&) = default;

  ThriftService& operator=(const ThriftService&) = default;
  void __clear();
 private:
  ::std::string name;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftFunction> functions;
 private:
  ::std::string parent;
 private:
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> structured_annotations;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
    bool functions;
    bool parent;
    bool structured_annotations;
  } __isset = {};
  bool operator==(const ThriftService& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftService& __x, const ThriftService& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftService& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftService& __x, const ThriftService& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftService& __x, const ThriftService& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftService& __x, const ThriftService& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> functions_ref() const& {
    return {this->functions, __isset.functions};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> functions_ref() const&& {
    return {std::move(this->functions), __isset.functions};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> functions_ref() & {
    return {this->functions, __isset.functions};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> functions_ref() && {
    return {std::move(this->functions), __isset.functions};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> parent_ref() const& {
    return {this->parent, __isset.parent};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> parent_ref() const&& {
    return {std::move(this->parent), __isset.parent};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> parent_ref() & {
    return {this->parent, __isset.parent};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> parent_ref() && {
    return {std::move(this->parent), __isset.parent};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structured_annotations_ref() const& {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structured_annotations_ref() const&& {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structured_annotations_ref() & {
    return {this->structured_annotations, __isset.structured_annotations};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structured_annotations_ref() && {
    return {std::move(this->structured_annotations), __isset.structured_annotations};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftService_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftService_name_struct_setter&& name_) {
    name = std::forward<T_ThriftService_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftFunction>& get_functions() const&;
  ::std::vector<::apache::thrift::metadata::ThriftFunction> get_functions() &&;

  template <typename T_ThriftService_functions_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftFunction>>
  ::std::vector<::apache::thrift::metadata::ThriftFunction>& set_functions(T_ThriftService_functions_struct_setter&& functions_) {
    functions = std::forward<T_ThriftService_functions_struct_setter>(functions_);
    __isset.functions = true;
    return functions;
  }

  const ::std::string* get_parent() const& {
    return parent_ref() ? std::addressof(parent) : nullptr;
  }

  ::std::string* get_parent() & {
    return parent_ref() ? std::addressof(parent) : nullptr;
  }
  ::std::string* get_parent() && = delete;

  template <typename T_ThriftService_parent_struct_setter = ::std::string>
  ::std::string& set_parent(T_ThriftService_parent_struct_setter&& parent_) {
    parent = std::forward<T_ThriftService_parent_struct_setter>(parent_);
    __isset.parent = true;
    return parent;
  }
  const ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& get_structured_annotations() const&;
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct> get_structured_annotations() &&;

  template <typename T_ThriftService_structured_annotations_struct_setter = ::std::vector<::apache::thrift::metadata::ThriftConstStruct>>
  ::std::vector<::apache::thrift::metadata::ThriftConstStruct>& set_structured_annotations(T_ThriftService_structured_annotations_struct_setter&& structured_annotations_) {
    structured_annotations = std::forward<T_ThriftService_structured_annotations_struct_setter>(structured_annotations_);
    __isset.structured_annotations = true;
    return structured_annotations;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftService >;
  friend void swap(ThriftService& a, ThriftService& b);
};

template <class Protocol_>
uint32_t ThriftService::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftModuleContext final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftModuleContext;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftModuleContext() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftModuleContext(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftModuleContext(ThriftModuleContext&&) = default;

  ThriftModuleContext(const ThriftModuleContext&) = default;


  ThriftModuleContext& operator=(ThriftModuleContext&&) = default;

  ThriftModuleContext& operator=(const ThriftModuleContext&) = default;
  void __clear();
 private:
  ::std::string name;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftModuleContext& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftModuleContext& __x, const ThriftModuleContext& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftModuleContext& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftModuleContext& __x, const ThriftModuleContext& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftModuleContext& __x, const ThriftModuleContext& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftModuleContext& __x, const ThriftModuleContext& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftModuleContext_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftModuleContext_name_struct_setter&& name_) {
    name = std::forward<T_ThriftModuleContext_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftModuleContext >;
  friend void swap(ThriftModuleContext& a, ThriftModuleContext& b);
};

template <class Protocol_>
uint32_t ThriftModuleContext::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftServiceContext final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftServiceContext;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftServiceContext() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftServiceContext(apache::thrift::FragileConstructor, ::apache::thrift::metadata::ThriftService service_info__arg, ::apache::thrift::metadata::ThriftModuleContext module__arg);

  ThriftServiceContext(ThriftServiceContext&&) = default;

  ThriftServiceContext(const ThriftServiceContext&) = default;


  ThriftServiceContext& operator=(ThriftServiceContext&&) = default;

  ThriftServiceContext& operator=(const ThriftServiceContext&) = default;
  void __clear();
 private:
  ::apache::thrift::metadata::ThriftService service_info;
 private:
  ::apache::thrift::metadata::ThriftModuleContext module;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool service_info;
    bool module;
  } __isset = {};
  bool operator==(const ThriftServiceContext& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftServiceContext& __x, const ThriftServiceContext& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftServiceContext& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftServiceContext& __x, const ThriftServiceContext& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftServiceContext& __x, const ThriftServiceContext& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftServiceContext& __x, const ThriftServiceContext& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> service_info_ref() const& {
    return {this->service_info, __isset.service_info};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> service_info_ref() const&& {
    return {std::move(this->service_info), __isset.service_info};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> service_info_ref() & {
    return {this->service_info, __isset.service_info};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> service_info_ref() && {
    return {std::move(this->service_info), __isset.service_info};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> module_ref() const& {
    return {this->module, __isset.module};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> module_ref() const&& {
    return {std::move(this->module), __isset.module};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> module_ref() & {
    return {this->module, __isset.module};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> module_ref() && {
    return {std::move(this->module), __isset.module};
  }
  const ::apache::thrift::metadata::ThriftService& get_service_info() const&;
  ::apache::thrift::metadata::ThriftService get_service_info() &&;

  template <typename T_ThriftServiceContext_service_info_struct_setter = ::apache::thrift::metadata::ThriftService>
  ::apache::thrift::metadata::ThriftService& set_service_info(T_ThriftServiceContext_service_info_struct_setter&& service_info_) {
    service_info = std::forward<T_ThriftServiceContext_service_info_struct_setter>(service_info_);
    __isset.service_info = true;
    return service_info;
  }
  const ::apache::thrift::metadata::ThriftModuleContext& get_module() const&;
  ::apache::thrift::metadata::ThriftModuleContext get_module() &&;

  template <typename T_ThriftServiceContext_module_struct_setter = ::apache::thrift::metadata::ThriftModuleContext>
  ::apache::thrift::metadata::ThriftModuleContext& set_module(T_ThriftServiceContext_module_struct_setter&& module_) {
    module = std::forward<T_ThriftServiceContext_module_struct_setter>(module_);
    __isset.module = true;
    return module;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftServiceContext >;
  friend void swap(ThriftServiceContext& a, ThriftServiceContext& b);
};

template <class Protocol_>
uint32_t ThriftServiceContext::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftMetadata(apache::thrift::FragileConstructor, ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum> enums__arg, ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct> structs__arg, ::std::map<::std::string, ::apache::thrift::metadata::ThriftException> exceptions__arg, ::std::map<::std::string, ::apache::thrift::metadata::ThriftService> services__arg);

  ThriftMetadata(ThriftMetadata&&) = default;

  ThriftMetadata(const ThriftMetadata&) = default;


  ThriftMetadata& operator=(ThriftMetadata&&) = default;

  ThriftMetadata& operator=(const ThriftMetadata&) = default;
  void __clear();
 private:
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum> enums;
 private:
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct> structs;
 private:
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftException> exceptions;
 private:
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftService> services;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool enums;
    bool structs;
    bool exceptions;
    bool services;
  } __isset = {};
  bool operator==(const ThriftMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftMetadata& __x, const ThriftMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftMetadata& __x, const ThriftMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftMetadata& __x, const ThriftMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftMetadata& __x, const ThriftMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enums_ref() const& {
    return {this->enums, __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enums_ref() const&& {
    return {std::move(this->enums), __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enums_ref() & {
    return {this->enums, __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enums_ref() && {
    return {std::move(this->enums), __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structs_ref() const& {
    return {this->structs, __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structs_ref() const&& {
    return {std::move(this->structs), __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structs_ref() & {
    return {this->structs, __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structs_ref() && {
    return {std::move(this->structs), __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exceptions_ref() const& {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exceptions_ref() const&& {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exceptions_ref() & {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exceptions_ref() && {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> services_ref() const& {
    return {this->services, __isset.services};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> services_ref() const&& {
    return {std::move(this->services), __isset.services};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> services_ref() & {
    return {this->services, __isset.services};
  }

  template <typename..., typename T = ::std::map<::std::string, ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> services_ref() && {
    return {std::move(this->services), __isset.services};
  }
  const ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum>& get_enums() const&;
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum> get_enums() &&;

  template <typename T_ThriftMetadata_enums_struct_setter = ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum>>
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftEnum>& set_enums(T_ThriftMetadata_enums_struct_setter&& enums_) {
    enums = std::forward<T_ThriftMetadata_enums_struct_setter>(enums_);
    __isset.enums = true;
    return enums;
  }
  const ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct>& get_structs() const&;
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct> get_structs() &&;

  template <typename T_ThriftMetadata_structs_struct_setter = ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct>>
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftStruct>& set_structs(T_ThriftMetadata_structs_struct_setter&& structs_) {
    structs = std::forward<T_ThriftMetadata_structs_struct_setter>(structs_);
    __isset.structs = true;
    return structs;
  }
  const ::std::map<::std::string, ::apache::thrift::metadata::ThriftException>& get_exceptions() const&;
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftException> get_exceptions() &&;

  template <typename T_ThriftMetadata_exceptions_struct_setter = ::std::map<::std::string, ::apache::thrift::metadata::ThriftException>>
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftException>& set_exceptions(T_ThriftMetadata_exceptions_struct_setter&& exceptions_) {
    exceptions = std::forward<T_ThriftMetadata_exceptions_struct_setter>(exceptions_);
    __isset.exceptions = true;
    return exceptions;
  }
  const ::std::map<::std::string, ::apache::thrift::metadata::ThriftService>& get_services() const&;
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftService> get_services() &&;

  template <typename T_ThriftMetadata_services_struct_setter = ::std::map<::std::string, ::apache::thrift::metadata::ThriftService>>
  ::std::map<::std::string, ::apache::thrift::metadata::ThriftService>& set_services(T_ThriftMetadata_services_struct_setter&& services_) {
    services = std::forward<T_ThriftMetadata_services_struct_setter>(services_);
    __isset.services = true;
    return services;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftMetadata >;
  friend void swap(ThriftMetadata& a, ThriftMetadata& b);
};

template <class Protocol_>
uint32_t ThriftMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftServiceMetadataResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ThriftServiceMetadataResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ThriftServiceMetadataResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftServiceMetadataResponse(apache::thrift::FragileConstructor, ::apache::thrift::metadata::ThriftServiceContext context__arg, ::apache::thrift::metadata::ThriftMetadata metadata__arg);

  ThriftServiceMetadataResponse(ThriftServiceMetadataResponse&&) = default;

  ThriftServiceMetadataResponse(const ThriftServiceMetadataResponse&) = default;


  ThriftServiceMetadataResponse& operator=(ThriftServiceMetadataResponse&&) = default;

  ThriftServiceMetadataResponse& operator=(const ThriftServiceMetadataResponse&) = default;
  void __clear();
 private:
  ::apache::thrift::metadata::ThriftServiceContext context;
 private:
  ::apache::thrift::metadata::ThriftMetadata metadata;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool context;
    bool metadata;
  } __isset = {};
  bool operator==(const ThriftServiceMetadataResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ThriftServiceMetadataResponse& __x, const ThriftServiceMetadataResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ThriftServiceMetadataResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const ThriftServiceMetadataResponse& __x, const ThriftServiceMetadataResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ThriftServiceMetadataResponse& __x, const ThriftServiceMetadataResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ThriftServiceMetadataResponse& __x, const ThriftServiceMetadataResponse& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> context_ref() const& {
    return {this->context, __isset.context};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> context_ref() const&& {
    return {std::move(this->context), __isset.context};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> context_ref() & {
    return {this->context, __isset.context};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> context_ref() && {
    return {std::move(this->context), __isset.context};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> metadata_ref() const& {
    return {this->metadata, __isset.metadata};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> metadata_ref() const&& {
    return {std::move(this->metadata), __isset.metadata};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> metadata_ref() & {
    return {this->metadata, __isset.metadata};
  }

  template <typename..., typename T = ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> metadata_ref() && {
    return {std::move(this->metadata), __isset.metadata};
  }
  const ::apache::thrift::metadata::ThriftServiceContext& get_context() const&;
  ::apache::thrift::metadata::ThriftServiceContext get_context() &&;

  template <typename T_ThriftServiceMetadataResponse_context_struct_setter = ::apache::thrift::metadata::ThriftServiceContext>
  ::apache::thrift::metadata::ThriftServiceContext& set_context(T_ThriftServiceMetadataResponse_context_struct_setter&& context_) {
    context = std::forward<T_ThriftServiceMetadataResponse_context_struct_setter>(context_);
    __isset.context = true;
    return context;
  }
  const ::apache::thrift::metadata::ThriftMetadata& get_metadata() const&;
  ::apache::thrift::metadata::ThriftMetadata get_metadata() &&;

  template <typename T_ThriftServiceMetadataResponse_metadata_struct_setter = ::apache::thrift::metadata::ThriftMetadata>
  ::apache::thrift::metadata::ThriftMetadata& set_metadata(T_ThriftServiceMetadataResponse_metadata_struct_setter&& metadata_) {
    metadata = std::forward<T_ThriftServiceMetadataResponse_metadata_struct_setter>(metadata_);
    __isset.metadata = true;
    return metadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftServiceMetadataResponse >;
  friend void swap(ThriftServiceMetadataResponse& a, ThriftServiceMetadataResponse& b);
};

template <class Protocol_>
uint32_t ThriftServiceMetadataResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
THRIFT_IGNORE_ISSET_USE_WARNING_END

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::apache::thrift::metadata::ThriftConstValue::Type>;

template <> struct TEnumTraits<::apache::thrift::metadata::ThriftConstValue::Type> {
  using type = ::apache::thrift::metadata::ThriftConstValue::Type;

  static constexpr std::size_t const size = 7;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::apache::thrift::metadata::ThriftType::Type>;

template <> struct TEnumTraits<::apache::thrift::metadata::ThriftType::Type> {
  using type = ::apache::thrift::metadata::ThriftType::Type;

  static constexpr std::size_t const size = 10;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
