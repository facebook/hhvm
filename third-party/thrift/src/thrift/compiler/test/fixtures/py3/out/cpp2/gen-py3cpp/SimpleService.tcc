/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/py3/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/SimpleService.h"

#include <thrift/lib/cpp2/gen/service_tcc.h>

namespace py3::simple {
typedef apache::thrift::ThriftPresult<false> SimpleService_get_five_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_get_five_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_add_five_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_add_five_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_do_nothing_pargs;
typedef apache::thrift::ThriftPresult<true> SimpleService_do_nothing_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::std::string*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_concat_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_concat_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::SimpleStruct*>> SimpleService_get_value_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_get_value_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, bool*>> SimpleService_negate_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, bool*>> SimpleService_negate_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int8_t*>> SimpleService_tiny_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int8_t*>> SimpleService_tiny_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_small_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_small_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int64_t*>> SimpleService_big_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int64_t*>> SimpleService_big_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::floating_point, double*>> SimpleService_two_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::floating_point, double*>> SimpleService_two_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_expected_exception_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::SimpleException>> SimpleService_expected_exception_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_unexpected_exception_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_unexpected_exception_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int16_t>*>> SimpleService_sum_i16_list_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_i16_list_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int32_t>*>> SimpleService_sum_i32_list_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_i32_list_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int64_t>*>> SimpleService_sum_i64_list_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_i64_list_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::string>, ::std::vector<::std::string>*>> SimpleService_concat_many_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_concat_many_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<::py3::simple::SimpleStruct>*>> SimpleService_count_structs_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_count_structs_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::set<::apache::thrift::type_class::integral>, ::std::set<::std::int32_t>*>> SimpleService_sum_set_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_set_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::set<::apache::thrift::type_class::string>, ::std::set<::std::string>*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_contains_word_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, bool*>> SimpleService_contains_word_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::string>, ::std::map<::std::string, ::std::string>*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_get_map_value_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_get_map_value_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>, ::std::map<::std::string, ::py3::simple::SimpleStruct>*>> SimpleService_map_length_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_map_length_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, ::std::int16_t>*>> SimpleService_sum_map_values_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_sum_map_values_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::ComplexStruct*>> SimpleService_complex_sum_i32_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_complex_sum_i32_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::ComplexStruct*>> SimpleService_repeat_name_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_repeat_name_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_get_struct_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::py3::simple::SimpleStruct*>> SimpleService_get_struct_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_fib_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int32_t>*>> SimpleService_fib_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::string>, ::std::vector<::std::string>*>> SimpleService_unique_words_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::string>, ::std::set<::std::string>*>> SimpleService_unique_words_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::string>, ::std::vector<::std::string>*>> SimpleService_words_count_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, ::std::int16_t>*>> SimpleService_words_count_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::enumeration, ::py3::simple::AnEnum*>> SimpleService_set_enum_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::enumeration, ::py3::simple::AnEnum*>> SimpleService_set_enum_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int16_t*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_list_of_lists_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, ::std::vector<::std::vector<::std::int32_t>>*>> SimpleService_list_of_lists_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_word_character_frequency_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>>, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>*>> SimpleService_word_character_frequency_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_list_of_sets_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::set<::apache::thrift::type_class::string>>, ::std::vector<::std::set<::std::string>>*>> SimpleService_list_of_sets_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>*>> SimpleService_nested_map_argument_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_nested_map_argument_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::string>>, ::std::vector<::std::vector<::std::string>>*>> SimpleService_make_sentence_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_make_sentence_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::set<::apache::thrift::type_class::integral>>, ::std::vector<::std::set<::std::int32_t>>*>> SimpleService_get_union_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::integral>, ::std::set<::std::int32_t>*>> SimpleService_get_union_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::string>>, ::std::vector<::std::map<::std::string, ::std::string>>*>> SimpleService_get_keys_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::string>, ::std::set<::std::string>*>> SimpleService_get_keys_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_lookup_double_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::floating_point, double*>> SimpleService_lookup_double_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::binary, ::std::string*>> SimpleService_retrieve_binary_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::binary, ::std::string*>> SimpleService_retrieve_binary_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>*>> SimpleService_contain_binary_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::binary>, ::std::set<::std::string>*>> SimpleService_contain_binary_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::enumeration>, ::std::vector<::py3::simple::AnEnum>*>> SimpleService_contain_enum_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::enumeration>, ::std::vector<::py3::simple::AnEnum>*>> SimpleService_contain_enum_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::variant, ::py3::simple::BinaryUnion*>> SimpleService_get_binary_union_struct_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::py3::simple::BinaryUnionStruct*>> SimpleService_get_binary_union_struct_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_get_struct_hidden_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::py3::simple::SimpleStruct*>> SimpleService_get_struct_hidden_presult;
//
// Service Methods
//

//
// Method 'get_five'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_five(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_five<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_five(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    SimpleService_get_five_pargs pargs() {
      SimpleService_get_five_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_five",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_five",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_five");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_five",
      /* .qualifiedMethodName =*/ "SimpleService.get_five"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_five};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_five<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_five<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_five.
  iface_->fbthrift_execute_decorators_before_get_five(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_five(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_five(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_five_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_five", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_five(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_five");
    return;
  }
}
//
// End of Method 'get_five'
//

//
// Method 'add_five'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_add_five(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_add_five<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_add_five(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int32_t uarg_num{0};
    SimpleService_add_five_pargs pargs() {
      SimpleService_add_five_pargs args;
      args.get<0>().value = &uarg_num;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_num)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.add_five",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "add_five",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "add_five");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "add_five",
      /* .qualifiedMethodName =*/ "SimpleService.add_five"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_add_five};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_add_five<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_add_five<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_add_five.
  iface_->fbthrift_execute_decorators_before_add_five(*serverRequest.requestContext(), args.uarg_num);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_add_five(std::move(cb), args.uarg_num);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_add_five(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_add_five_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("add_five", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_add_five(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "add_five");
    return;
  }
}
//
// End of Method 'add_five'
//

//
// Method 'do_nothing'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_do_nothing(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_do_nothing<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_do_nothing(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    SimpleService_do_nothing_pargs pargs() {
      SimpleService_do_nothing_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.do_nothing",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "do_nothing",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "do_nothing");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "do_nothing",
      /* .qualifiedMethodName =*/ "SimpleService.do_nothing"};
  apache::thrift::HandlerCallback<void>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_do_nothing};
 auto callback =
      apache::thrift::HandlerCallbackPtr<void>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_do_nothing<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_do_nothing<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_do_nothing.
  iface_->fbthrift_execute_decorators_before_do_nothing(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_do_nothing(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_do_nothing(
    apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_do_nothing_presult result;
  return serializeResponse("do_nothing", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_do_nothing(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "do_nothing");
    return;
  }
}
//
// End of Method 'do_nothing'
//

//
// Method 'concat'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_concat(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_concat<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_concat(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::string> uarg_first = std::make_unique<::std::string>();
    std::unique_ptr<::std::string> uarg_second = std::make_unique<::std::string>();
    SimpleService_concat_pargs pargs() {
      SimpleService_concat_pargs args;
      args.get<0>().value = uarg_first.get();
      args.get<1>().value = uarg_second.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_first),
        std::as_const(*uarg_second)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.concat",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "concat",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "concat");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "concat",
      /* .qualifiedMethodName =*/ "SimpleService.concat"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_concat};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_concat<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_concat<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_concat.
  iface_->fbthrift_execute_decorators_before_concat(*serverRequest.requestContext(), *args.uarg_first, *args.uarg_second);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_concat(std::move(cb), std::move(args.uarg_first), std::move(args.uarg_second));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_concat(
    apache::thrift::ContextStack* ctx,
    ::std::string const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_concat_presult result;
  result.get<0>().value = const_cast<::std::string*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("concat", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_concat(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "concat");
    return;
  }
}
//
// End of Method 'concat'
//

//
// Method 'get_value'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_value(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_value<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_value(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::py3::simple::SimpleStruct> uarg_simple_struct = std::make_unique<::py3::simple::SimpleStruct>();
    SimpleService_get_value_pargs pargs() {
      SimpleService_get_value_pargs args;
      args.get<0>().value = uarg_simple_struct.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_simple_struct)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_value",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_value",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_value");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_value",
      /* .qualifiedMethodName =*/ "SimpleService.get_value"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_value};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_value<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_value<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_value.
  iface_->fbthrift_execute_decorators_before_get_value(*serverRequest.requestContext(), *args.uarg_simple_struct);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_value(std::move(cb), std::move(args.uarg_simple_struct));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_value(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_value_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_value", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_value(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_value");
    return;
  }
}
//
// End of Method 'get_value'
//

//
// Method 'negate'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_negate(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_negate<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_negate(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    bool uarg_input{0};
    SimpleService_negate_pargs pargs() {
      SimpleService_negate_pargs args;
      args.get<0>().value = &uarg_input;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.negate",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "negate",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "negate");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "negate",
      /* .qualifiedMethodName =*/ "SimpleService.negate"};
  apache::thrift::HandlerCallback<bool>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_negate};
 auto callback =
      apache::thrift::HandlerCallbackPtr<bool>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_negate<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_negate<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_negate.
  iface_->fbthrift_execute_decorators_before_negate(*serverRequest.requestContext(), args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_negate(std::move(cb), args.uarg_input);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_negate(
    apache::thrift::ContextStack* ctx,
    bool const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_negate_presult result;
  result.get<0>().value = const_cast<bool*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("negate", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_negate(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "negate");
    return;
  }
}
//
// End of Method 'negate'
//

//
// Method 'tiny'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_tiny(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_tiny<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_tiny(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int8_t uarg_input{0};
    SimpleService_tiny_pargs pargs() {
      SimpleService_tiny_pargs args;
      args.get<0>().value = &uarg_input;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.tiny",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "tiny",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "tiny");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "tiny",
      /* .qualifiedMethodName =*/ "SimpleService.tiny"};
  apache::thrift::HandlerCallback<::std::int8_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_tiny};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int8_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_tiny<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_tiny<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_tiny.
  iface_->fbthrift_execute_decorators_before_tiny(*serverRequest.requestContext(), args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_tiny(std::move(cb), args.uarg_input);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_tiny(
    apache::thrift::ContextStack* ctx,
    ::std::int8_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_tiny_presult result;
  result.get<0>().value = const_cast<::std::int8_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("tiny", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_tiny(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "tiny");
    return;
  }
}
//
// End of Method 'tiny'
//

//
// Method 'small'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_small(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_small<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_small(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int16_t uarg_input{0};
    SimpleService_small_pargs pargs() {
      SimpleService_small_pargs args;
      args.get<0>().value = &uarg_input;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.small",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "small",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "small");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "small",
      /* .qualifiedMethodName =*/ "SimpleService.small"};
  apache::thrift::HandlerCallback<::std::int16_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_small};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int16_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_small<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_small<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_small.
  iface_->fbthrift_execute_decorators_before_small(*serverRequest.requestContext(), args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_small(std::move(cb), args.uarg_input);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_small(
    apache::thrift::ContextStack* ctx,
    ::std::int16_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_small_presult result;
  result.get<0>().value = const_cast<::std::int16_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("small", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_small(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "small");
    return;
  }
}
//
// End of Method 'small'
//

//
// Method 'big'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_big(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_big<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_big(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int64_t uarg_input{0};
    SimpleService_big_pargs pargs() {
      SimpleService_big_pargs args;
      args.get<0>().value = &uarg_input;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.big",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "big",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "big");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "big",
      /* .qualifiedMethodName =*/ "SimpleService.big"};
  apache::thrift::HandlerCallback<::std::int64_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_big};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int64_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_big<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_big<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_big.
  iface_->fbthrift_execute_decorators_before_big(*serverRequest.requestContext(), args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_big(std::move(cb), args.uarg_input);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_big(
    apache::thrift::ContextStack* ctx,
    ::std::int64_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_big_presult result;
  result.get<0>().value = const_cast<::std::int64_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("big", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_big(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "big");
    return;
  }
}
//
// End of Method 'big'
//

//
// Method 'two'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_two(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_two<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_two(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    double uarg_input{0};
    SimpleService_two_pargs pargs() {
      SimpleService_two_pargs args;
      args.get<0>().value = &uarg_input;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.two",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "two",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "two");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "two",
      /* .qualifiedMethodName =*/ "SimpleService.two"};
  apache::thrift::HandlerCallback<double>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_two};
 auto callback =
      apache::thrift::HandlerCallbackPtr<double>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_two<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_two<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_two.
  iface_->fbthrift_execute_decorators_before_two(*serverRequest.requestContext(), args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_two(std::move(cb), args.uarg_input);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_two(
    apache::thrift::ContextStack* ctx,
    double const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_two_presult result;
  result.get<0>().value = const_cast<double*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("two", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_two(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "two");
    return;
  }
}
//
// End of Method 'two'
//

//
// Method 'expected_exception'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_expected_exception(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_expected_exception<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_expected_exception(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    SimpleService_expected_exception_pargs pargs() {
      SimpleService_expected_exception_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.expected_exception",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "expected_exception",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "expected_exception");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "expected_exception",
      /* .qualifiedMethodName =*/ "SimpleService.expected_exception"};
  apache::thrift::HandlerCallback<void>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_expected_exception};
 auto callback =
      apache::thrift::HandlerCallbackPtr<void>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_expected_exception<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_expected_exception<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_expected_exception.
  iface_->fbthrift_execute_decorators_before_expected_exception(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_expected_exception(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_expected_exception(
    apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_expected_exception_presult result;
  return serializeResponse("expected_exception", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_expected_exception(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  ::py3::simple::SimpleService_expected_exception_presult result;
  constexpr bool kHasReturnType = false;
  if (!::apache::thrift::detail::ap::insert_exn<kHasReturnType>(result, ew, [&]<typename Ex>(Ex&){
    if (ctx) {
      ctx->userExceptionWrapped(true, ew);
    }
    ::apache::thrift::util::appendExceptionToHeader(ew, *reqCtx);
    ::apache::thrift::util::appendErrorClassificationToHeader<Ex>(ew, *reqCtx);
  })) {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "expected_exception");
    return;
  }
  ProtocolOut_ prot;
  auto response = serializeResponse("expected_exception", &prot, ctx, result);
  auto payload = std::move(response).extractPayload(
      req->includeEnvelope(),
      prot.protocolType(),
      protoSeqId,
      apache::thrift::MessageType::T_REPLY,
      "expected_exception");
  payload.transform(reqCtx->getHeader()->getWriteTransforms());
  return req->sendReply(std::move(payload));
}
//
// End of Method 'expected_exception'
//

//
// Method 'unexpected_exception'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_unexpected_exception(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_unexpected_exception<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_unexpected_exception(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    SimpleService_unexpected_exception_pargs pargs() {
      SimpleService_unexpected_exception_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.unexpected_exception",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "unexpected_exception",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "unexpected_exception");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "unexpected_exception",
      /* .qualifiedMethodName =*/ "SimpleService.unexpected_exception"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_unexpected_exception};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_unexpected_exception<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_unexpected_exception<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_unexpected_exception.
  iface_->fbthrift_execute_decorators_before_unexpected_exception(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_unexpected_exception(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_unexpected_exception(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_unexpected_exception_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("unexpected_exception", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_unexpected_exception(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "unexpected_exception");
    return;
  }
}
//
// End of Method 'unexpected_exception'
//

//
// Method 'sum_i16_list'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_sum_i16_list(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_sum_i16_list<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_sum_i16_list(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::int16_t>> uarg_numbers = std::make_unique<::std::vector<::std::int16_t>>();
    SimpleService_sum_i16_list_pargs pargs() {
      SimpleService_sum_i16_list_pargs args;
      args.get<0>().value = uarg_numbers.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_numbers)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.sum_i16_list",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "sum_i16_list",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "sum_i16_list");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "sum_i16_list",
      /* .qualifiedMethodName =*/ "SimpleService.sum_i16_list"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_sum_i16_list};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_sum_i16_list<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_sum_i16_list<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_sum_i16_list.
  iface_->fbthrift_execute_decorators_before_sum_i16_list(*serverRequest.requestContext(), *args.uarg_numbers);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_sum_i16_list(std::move(cb), std::move(args.uarg_numbers));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_sum_i16_list(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_sum_i16_list_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("sum_i16_list", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_sum_i16_list(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "sum_i16_list");
    return;
  }
}
//
// End of Method 'sum_i16_list'
//

//
// Method 'sum_i32_list'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_sum_i32_list(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_sum_i32_list<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_sum_i32_list(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::int32_t>> uarg_numbers = std::make_unique<::std::vector<::std::int32_t>>();
    SimpleService_sum_i32_list_pargs pargs() {
      SimpleService_sum_i32_list_pargs args;
      args.get<0>().value = uarg_numbers.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_numbers)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.sum_i32_list",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "sum_i32_list",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "sum_i32_list");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "sum_i32_list",
      /* .qualifiedMethodName =*/ "SimpleService.sum_i32_list"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_sum_i32_list};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_sum_i32_list<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_sum_i32_list<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_sum_i32_list.
  iface_->fbthrift_execute_decorators_before_sum_i32_list(*serverRequest.requestContext(), *args.uarg_numbers);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_sum_i32_list(std::move(cb), std::move(args.uarg_numbers));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_sum_i32_list(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_sum_i32_list_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("sum_i32_list", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_sum_i32_list(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "sum_i32_list");
    return;
  }
}
//
// End of Method 'sum_i32_list'
//

//
// Method 'sum_i64_list'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_sum_i64_list(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_sum_i64_list<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_sum_i64_list(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::int64_t>> uarg_numbers = std::make_unique<::std::vector<::std::int64_t>>();
    SimpleService_sum_i64_list_pargs pargs() {
      SimpleService_sum_i64_list_pargs args;
      args.get<0>().value = uarg_numbers.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_numbers)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.sum_i64_list",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "sum_i64_list",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "sum_i64_list");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "sum_i64_list",
      /* .qualifiedMethodName =*/ "SimpleService.sum_i64_list"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_sum_i64_list};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_sum_i64_list<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_sum_i64_list<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_sum_i64_list.
  iface_->fbthrift_execute_decorators_before_sum_i64_list(*serverRequest.requestContext(), *args.uarg_numbers);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_sum_i64_list(std::move(cb), std::move(args.uarg_numbers));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_sum_i64_list(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_sum_i64_list_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("sum_i64_list", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_sum_i64_list(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "sum_i64_list");
    return;
  }
}
//
// End of Method 'sum_i64_list'
//

//
// Method 'concat_many'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_concat_many(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_concat_many<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_concat_many(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::string>> uarg_words = std::make_unique<::std::vector<::std::string>>();
    SimpleService_concat_many_pargs pargs() {
      SimpleService_concat_many_pargs args;
      args.get<0>().value = uarg_words.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_words)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.concat_many",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "concat_many",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "concat_many");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "concat_many",
      /* .qualifiedMethodName =*/ "SimpleService.concat_many"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_concat_many};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_concat_many<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_concat_many<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_concat_many.
  iface_->fbthrift_execute_decorators_before_concat_many(*serverRequest.requestContext(), *args.uarg_words);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_concat_many(std::move(cb), std::move(args.uarg_words));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_concat_many(
    apache::thrift::ContextStack* ctx,
    ::std::string const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_concat_many_presult result;
  result.get<0>().value = const_cast<::std::string*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("concat_many", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_concat_many(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "concat_many");
    return;
  }
}
//
// End of Method 'concat_many'
//

//
// Method 'count_structs'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_count_structs(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_count_structs<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_count_structs(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> uarg_items = std::make_unique<::std::vector<::py3::simple::SimpleStruct>>();
    SimpleService_count_structs_pargs pargs() {
      SimpleService_count_structs_pargs args;
      args.get<0>().value = uarg_items.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_items)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.count_structs",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "count_structs",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "count_structs");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "count_structs",
      /* .qualifiedMethodName =*/ "SimpleService.count_structs"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_count_structs};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_count_structs<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_count_structs<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_count_structs.
  iface_->fbthrift_execute_decorators_before_count_structs(*serverRequest.requestContext(), *args.uarg_items);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_count_structs(std::move(cb), std::move(args.uarg_items));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_count_structs(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_count_structs_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("count_structs", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_count_structs(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "count_structs");
    return;
  }
}
//
// End of Method 'count_structs'
//

//
// Method 'sum_set'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_sum_set(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_sum_set<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_sum_set(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::set<::std::int32_t>> uarg_numbers = std::make_unique<::std::set<::std::int32_t>>();
    SimpleService_sum_set_pargs pargs() {
      SimpleService_sum_set_pargs args;
      args.get<0>().value = uarg_numbers.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_numbers)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.sum_set",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "sum_set",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "sum_set");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "sum_set",
      /* .qualifiedMethodName =*/ "SimpleService.sum_set"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_sum_set};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_sum_set<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_sum_set<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_sum_set.
  iface_->fbthrift_execute_decorators_before_sum_set(*serverRequest.requestContext(), *args.uarg_numbers);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_sum_set(std::move(cb), std::move(args.uarg_numbers));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_sum_set(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_sum_set_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("sum_set", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_sum_set(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "sum_set");
    return;
  }
}
//
// End of Method 'sum_set'
//

//
// Method 'contains_word'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_contains_word(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_contains_word<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_contains_word(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::set<::std::string>> uarg_words = std::make_unique<::std::set<::std::string>>();
    std::unique_ptr<::std::string> uarg_word = std::make_unique<::std::string>();
    SimpleService_contains_word_pargs pargs() {
      SimpleService_contains_word_pargs args;
      args.get<0>().value = uarg_words.get();
      args.get<1>().value = uarg_word.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_words),
        std::as_const(*uarg_word)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.contains_word",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "contains_word",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "contains_word");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "contains_word",
      /* .qualifiedMethodName =*/ "SimpleService.contains_word"};
  apache::thrift::HandlerCallback<bool>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_contains_word};
 auto callback =
      apache::thrift::HandlerCallbackPtr<bool>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_contains_word<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_contains_word<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_contains_word.
  iface_->fbthrift_execute_decorators_before_contains_word(*serverRequest.requestContext(), *args.uarg_words, *args.uarg_word);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_contains_word(std::move(cb), std::move(args.uarg_words), std::move(args.uarg_word));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_contains_word(
    apache::thrift::ContextStack* ctx,
    bool const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_contains_word_presult result;
  result.get<0>().value = const_cast<bool*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("contains_word", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_contains_word(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "contains_word");
    return;
  }
}
//
// End of Method 'contains_word'
//

//
// Method 'get_map_value'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_map_value(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_map_value<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_map_value(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::map<::std::string, ::std::string>> uarg_words = std::make_unique<::std::map<::std::string, ::std::string>>();
    std::unique_ptr<::std::string> uarg_key = std::make_unique<::std::string>();
    SimpleService_get_map_value_pargs pargs() {
      SimpleService_get_map_value_pargs args;
      args.get<0>().value = uarg_words.get();
      args.get<1>().value = uarg_key.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_words),
        std::as_const(*uarg_key)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_map_value",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_map_value",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_map_value");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_map_value",
      /* .qualifiedMethodName =*/ "SimpleService.get_map_value"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_map_value};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_map_value<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_map_value<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_map_value.
  iface_->fbthrift_execute_decorators_before_get_map_value(*serverRequest.requestContext(), *args.uarg_words, *args.uarg_key);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_map_value(std::move(cb), std::move(args.uarg_words), std::move(args.uarg_key));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_map_value(
    apache::thrift::ContextStack* ctx,
    ::std::string const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_map_value_presult result;
  result.get<0>().value = const_cast<::std::string*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_map_value", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_map_value(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_map_value");
    return;
  }
}
//
// End of Method 'get_map_value'
//

//
// Method 'map_length'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_map_length(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_map_length<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_map_length(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> uarg_items = std::make_unique<::std::map<::std::string, ::py3::simple::SimpleStruct>>();
    SimpleService_map_length_pargs pargs() {
      SimpleService_map_length_pargs args;
      args.get<0>().value = uarg_items.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_items)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.map_length",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "map_length",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "map_length");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "map_length",
      /* .qualifiedMethodName =*/ "SimpleService.map_length"};
  apache::thrift::HandlerCallback<::std::int16_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_map_length};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int16_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_map_length<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_map_length<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_map_length.
  iface_->fbthrift_execute_decorators_before_map_length(*serverRequest.requestContext(), *args.uarg_items);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_map_length(std::move(cb), std::move(args.uarg_items));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_map_length(
    apache::thrift::ContextStack* ctx,
    ::std::int16_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_map_length_presult result;
  result.get<0>().value = const_cast<::std::int16_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("map_length", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_map_length(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "map_length");
    return;
  }
}
//
// End of Method 'map_length'
//

//
// Method 'sum_map_values'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_sum_map_values(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_sum_map_values<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_sum_map_values(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::map<::std::string, ::std::int16_t>> uarg_items = std::make_unique<::std::map<::std::string, ::std::int16_t>>();
    SimpleService_sum_map_values_pargs pargs() {
      SimpleService_sum_map_values_pargs args;
      args.get<0>().value = uarg_items.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_items)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.sum_map_values",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "sum_map_values",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "sum_map_values");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "sum_map_values",
      /* .qualifiedMethodName =*/ "SimpleService.sum_map_values"};
  apache::thrift::HandlerCallback<::std::int16_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_sum_map_values};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int16_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_sum_map_values<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_sum_map_values<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_sum_map_values.
  iface_->fbthrift_execute_decorators_before_sum_map_values(*serverRequest.requestContext(), *args.uarg_items);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_sum_map_values(std::move(cb), std::move(args.uarg_items));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_sum_map_values(
    apache::thrift::ContextStack* ctx,
    ::std::int16_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_sum_map_values_presult result;
  result.get<0>().value = const_cast<::std::int16_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("sum_map_values", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_sum_map_values(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "sum_map_values");
    return;
  }
}
//
// End of Method 'sum_map_values'
//

//
// Method 'complex_sum_i32'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_complex_sum_i32(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_complex_sum_i32<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_complex_sum_i32(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::py3::simple::ComplexStruct> uarg_counter = std::make_unique<::py3::simple::ComplexStruct>();
    SimpleService_complex_sum_i32_pargs pargs() {
      SimpleService_complex_sum_i32_pargs args;
      args.get<0>().value = uarg_counter.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_counter)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.complex_sum_i32",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "complex_sum_i32",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "complex_sum_i32");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "complex_sum_i32",
      /* .qualifiedMethodName =*/ "SimpleService.complex_sum_i32"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_complex_sum_i32};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_complex_sum_i32<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_complex_sum_i32<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_complex_sum_i32.
  iface_->fbthrift_execute_decorators_before_complex_sum_i32(*serverRequest.requestContext(), *args.uarg_counter);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_complex_sum_i32(std::move(cb), std::move(args.uarg_counter));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_complex_sum_i32(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_complex_sum_i32_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("complex_sum_i32", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_complex_sum_i32(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "complex_sum_i32");
    return;
  }
}
//
// End of Method 'complex_sum_i32'
//

//
// Method 'repeat_name'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_repeat_name(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_repeat_name<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_repeat_name(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::py3::simple::ComplexStruct> uarg_counter = std::make_unique<::py3::simple::ComplexStruct>();
    SimpleService_repeat_name_pargs pargs() {
      SimpleService_repeat_name_pargs args;
      args.get<0>().value = uarg_counter.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_counter)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.repeat_name",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "repeat_name",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "repeat_name");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "repeat_name",
      /* .qualifiedMethodName =*/ "SimpleService.repeat_name"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_repeat_name};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_repeat_name<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_repeat_name<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_repeat_name.
  iface_->fbthrift_execute_decorators_before_repeat_name(*serverRequest.requestContext(), *args.uarg_counter);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_repeat_name(std::move(cb), std::move(args.uarg_counter));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_repeat_name(
    apache::thrift::ContextStack* ctx,
    ::std::string const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_repeat_name_presult result;
  result.get<0>().value = const_cast<::std::string*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("repeat_name", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_repeat_name(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "repeat_name");
    return;
  }
}
//
// End of Method 'repeat_name'
//

//
// Method 'get_struct'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_struct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_struct<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_struct(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    SimpleService_get_struct_pargs pargs() {
      SimpleService_get_struct_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_struct",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_struct",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_struct");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_struct",
      /* .qualifiedMethodName =*/ "SimpleService.get_struct"};
  apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::SimpleStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_struct};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::py3::simple::SimpleStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_struct<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_struct<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_struct.
  iface_->fbthrift_execute_decorators_before_get_struct(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_struct(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_struct(
    apache::thrift::ContextStack* ctx,
    ::py3::simple::SimpleStruct const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_struct_presult result;
  result.get<0>().value = const_cast<::py3::simple::SimpleStruct*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_struct", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_struct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_struct");
    return;
  }
}
//
// End of Method 'get_struct'
//

//
// Method 'fib'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_fib(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_fib<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_fib(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int16_t uarg_n{0};
    SimpleService_fib_pargs pargs() {
      SimpleService_fib_pargs args;
      args.get<0>().value = &uarg_n;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_n)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.fib",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "fib",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "fib");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "fib",
      /* .qualifiedMethodName =*/ "SimpleService.fib"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::int32_t>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_fib};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::vector<::std::int32_t>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_fib<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_fib<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_fib.
  iface_->fbthrift_execute_decorators_before_fib(*serverRequest.requestContext(), args.uarg_n);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_fib(std::move(cb), args.uarg_n);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_fib(
    apache::thrift::ContextStack* ctx,
    ::std::vector<::std::int32_t> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_fib_presult result;
  result.get<0>().value = const_cast<::std::vector<::std::int32_t>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("fib", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_fib(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "fib");
    return;
  }
}
//
// End of Method 'fib'
//

//
// Method 'unique_words'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_unique_words(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_unique_words<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_unique_words(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::string>> uarg_words = std::make_unique<::std::vector<::std::string>>();
    SimpleService_unique_words_pargs pargs() {
      SimpleService_unique_words_pargs args;
      args.get<0>().value = uarg_words.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_words)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.unique_words",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "unique_words",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "unique_words");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "unique_words",
      /* .qualifiedMethodName =*/ "SimpleService.unique_words"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_unique_words};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::set<::std::string>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_unique_words<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_unique_words<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_unique_words.
  iface_->fbthrift_execute_decorators_before_unique_words(*serverRequest.requestContext(), *args.uarg_words);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_unique_words(std::move(cb), std::move(args.uarg_words));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_unique_words(
    apache::thrift::ContextStack* ctx,
    ::std::set<::std::string> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_unique_words_presult result;
  result.get<0>().value = const_cast<::std::set<::std::string>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("unique_words", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_unique_words(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "unique_words");
    return;
  }
}
//
// End of Method 'unique_words'
//

//
// Method 'words_count'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_words_count(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_words_count<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_words_count(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::string>> uarg_words = std::make_unique<::std::vector<::std::string>>();
    SimpleService_words_count_pargs pargs() {
      SimpleService_words_count_pargs args;
      args.get<0>().value = uarg_words.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_words)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.words_count",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "words_count",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "words_count");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "words_count",
      /* .qualifiedMethodName =*/ "SimpleService.words_count"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_words_count};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_words_count<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_words_count<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_words_count.
  iface_->fbthrift_execute_decorators_before_words_count(*serverRequest.requestContext(), *args.uarg_words);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_words_count(std::move(cb), std::move(args.uarg_words));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_words_count(
    apache::thrift::ContextStack* ctx,
    ::std::map<::std::string, ::std::int16_t> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_words_count_presult result;
  result.get<0>().value = const_cast<::std::map<::std::string, ::std::int16_t>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("words_count", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_words_count(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "words_count");
    return;
  }
}
//
// End of Method 'words_count'
//

//
// Method 'set_enum'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_set_enum(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_set_enum<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_set_enum(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::py3::simple::AnEnum uarg_in_enum{static_cast<::py3::simple::AnEnum>(0)};
    SimpleService_set_enum_pargs pargs() {
      SimpleService_set_enum_pargs args;
      args.get<0>().value = &uarg_in_enum;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_in_enum)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.set_enum",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "set_enum",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "set_enum");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "set_enum",
      /* .qualifiedMethodName =*/ "SimpleService.set_enum"};
  apache::thrift::HandlerCallback<::py3::simple::AnEnum>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_set_enum};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::py3::simple::AnEnum>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_set_enum<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_set_enum<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_set_enum.
  iface_->fbthrift_execute_decorators_before_set_enum(*serverRequest.requestContext(), args.uarg_in_enum);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_set_enum(std::move(cb), args.uarg_in_enum);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_set_enum(
    apache::thrift::ContextStack* ctx,
    ::py3::simple::AnEnum const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_set_enum_presult result;
  result.get<0>().value = const_cast<::py3::simple::AnEnum*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("set_enum", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_set_enum(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "set_enum");
    return;
  }
}
//
// End of Method 'set_enum'
//

//
// Method 'list_of_lists'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_list_of_lists(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_list_of_lists<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_list_of_lists(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int16_t uarg_num_lists{0};
    ::std::int16_t uarg_num_items{0};
    SimpleService_list_of_lists_pargs pargs() {
      SimpleService_list_of_lists_pargs args;
      args.get<0>().value = &uarg_num_lists;
      args.get<1>().value = &uarg_num_items;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_num_lists),
        std::as_const(uarg_num_items)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.list_of_lists",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "list_of_lists",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "list_of_lists");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "list_of_lists",
      /* .qualifiedMethodName =*/ "SimpleService.list_of_lists"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_list_of_lists};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_list_of_lists<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_list_of_lists<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_list_of_lists.
  iface_->fbthrift_execute_decorators_before_list_of_lists(*serverRequest.requestContext(), args.uarg_num_lists, args.uarg_num_items);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_list_of_lists(std::move(cb), args.uarg_num_lists, args.uarg_num_items);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_list_of_lists(
    apache::thrift::ContextStack* ctx,
    ::std::vector<::std::vector<::std::int32_t>> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_list_of_lists_presult result;
  result.get<0>().value = const_cast<::std::vector<::std::vector<::std::int32_t>>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("list_of_lists", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_list_of_lists(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "list_of_lists");
    return;
  }
}
//
// End of Method 'list_of_lists'
//

//
// Method 'word_character_frequency'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_word_character_frequency(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_word_character_frequency<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_word_character_frequency(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::string> uarg_sentence = std::make_unique<::std::string>();
    SimpleService_word_character_frequency_pargs pargs() {
      SimpleService_word_character_frequency_pargs args;
      args.get<0>().value = uarg_sentence.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_sentence)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.word_character_frequency",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "word_character_frequency",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "word_character_frequency");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "word_character_frequency",
      /* .qualifiedMethodName =*/ "SimpleService.word_character_frequency"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_word_character_frequency};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_word_character_frequency<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_word_character_frequency<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_word_character_frequency.
  iface_->fbthrift_execute_decorators_before_word_character_frequency(*serverRequest.requestContext(), *args.uarg_sentence);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_word_character_frequency(std::move(cb), std::move(args.uarg_sentence));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_word_character_frequency(
    apache::thrift::ContextStack* ctx,
    ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_word_character_frequency_presult result;
  result.get<0>().value = const_cast<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("word_character_frequency", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_word_character_frequency(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "word_character_frequency");
    return;
  }
}
//
// End of Method 'word_character_frequency'
//

//
// Method 'list_of_sets'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_list_of_sets(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_list_of_sets<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_list_of_sets(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::string> uarg_some_words = std::make_unique<::std::string>();
    SimpleService_list_of_sets_pargs pargs() {
      SimpleService_list_of_sets_pargs args;
      args.get<0>().value = uarg_some_words.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_some_words)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.list_of_sets",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "list_of_sets",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "list_of_sets");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "list_of_sets",
      /* .qualifiedMethodName =*/ "SimpleService.list_of_sets"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::set<::std::string>>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_list_of_sets};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::vector<::std::set<::std::string>>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_list_of_sets<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_list_of_sets<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_list_of_sets.
  iface_->fbthrift_execute_decorators_before_list_of_sets(*serverRequest.requestContext(), *args.uarg_some_words);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_list_of_sets(std::move(cb), std::move(args.uarg_some_words));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_list_of_sets(
    apache::thrift::ContextStack* ctx,
    ::std::vector<::std::set<::std::string>> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_list_of_sets_presult result;
  result.get<0>().value = const_cast<::std::vector<::std::set<::std::string>>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("list_of_sets", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_list_of_sets(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "list_of_sets");
    return;
  }
}
//
// End of Method 'list_of_sets'
//

//
// Method 'nested_map_argument'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_nested_map_argument(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_nested_map_argument<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_nested_map_argument(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> uarg_struct_map = std::make_unique<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>>();
    SimpleService_nested_map_argument_pargs pargs() {
      SimpleService_nested_map_argument_pargs args;
      args.get<0>().value = uarg_struct_map.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_struct_map)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.nested_map_argument",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "nested_map_argument",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "nested_map_argument");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "nested_map_argument",
      /* .qualifiedMethodName =*/ "SimpleService.nested_map_argument"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_nested_map_argument};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_nested_map_argument<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_nested_map_argument<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_nested_map_argument.
  iface_->fbthrift_execute_decorators_before_nested_map_argument(*serverRequest.requestContext(), *args.uarg_struct_map);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_nested_map_argument(std::move(cb), std::move(args.uarg_struct_map));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_nested_map_argument(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_nested_map_argument_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("nested_map_argument", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_nested_map_argument(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "nested_map_argument");
    return;
  }
}
//
// End of Method 'nested_map_argument'
//

//
// Method 'make_sentence'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_make_sentence(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_make_sentence<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_make_sentence(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::vector<::std::string>>> uarg_word_chars = std::make_unique<::std::vector<::std::vector<::std::string>>>();
    SimpleService_make_sentence_pargs pargs() {
      SimpleService_make_sentence_pargs args;
      args.get<0>().value = uarg_word_chars.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_word_chars)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.make_sentence",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "make_sentence",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "make_sentence");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "make_sentence",
      /* .qualifiedMethodName =*/ "SimpleService.make_sentence"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_make_sentence};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_make_sentence<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_make_sentence<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_make_sentence.
  iface_->fbthrift_execute_decorators_before_make_sentence(*serverRequest.requestContext(), *args.uarg_word_chars);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_make_sentence(std::move(cb), std::move(args.uarg_word_chars));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_make_sentence(
    apache::thrift::ContextStack* ctx,
    ::std::string const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_make_sentence_presult result;
  result.get<0>().value = const_cast<::std::string*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("make_sentence", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_make_sentence(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "make_sentence");
    return;
  }
}
//
// End of Method 'make_sentence'
//

//
// Method 'get_union'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_union(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_union<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_union(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> uarg_sets = std::make_unique<::std::vector<::std::set<::std::int32_t>>>();
    SimpleService_get_union_pargs pargs() {
      SimpleService_get_union_pargs args;
      args.get<0>().value = uarg_sets.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_sets)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_union",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_union",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_union");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_union",
      /* .qualifiedMethodName =*/ "SimpleService.get_union"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::int32_t>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_union};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::set<::std::int32_t>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_union<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_union<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_union.
  iface_->fbthrift_execute_decorators_before_get_union(*serverRequest.requestContext(), *args.uarg_sets);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_union(std::move(cb), std::move(args.uarg_sets));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_union(
    apache::thrift::ContextStack* ctx,
    ::std::set<::std::int32_t> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_union_presult result;
  result.get<0>().value = const_cast<::std::set<::std::int32_t>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_union", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_union(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_union");
    return;
  }
}
//
// End of Method 'get_union'
//

//
// Method 'get_keys'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_keys(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_keys<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_keys(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> uarg_string_map = std::make_unique<::std::vector<::std::map<::std::string, ::std::string>>>();
    SimpleService_get_keys_pargs pargs() {
      SimpleService_get_keys_pargs args;
      args.get<0>().value = uarg_string_map.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_string_map)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_keys",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_keys",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_keys");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_keys",
      /* .qualifiedMethodName =*/ "SimpleService.get_keys"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_keys};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::set<::std::string>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_keys<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_keys<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_keys.
  iface_->fbthrift_execute_decorators_before_get_keys(*serverRequest.requestContext(), *args.uarg_string_map);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_keys(std::move(cb), std::move(args.uarg_string_map));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_keys(
    apache::thrift::ContextStack* ctx,
    ::std::set<::std::string> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_keys_presult result;
  result.get<0>().value = const_cast<::std::set<::std::string>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_keys", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_keys(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_keys");
    return;
  }
}
//
// End of Method 'get_keys'
//

//
// Method 'lookup_double'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_lookup_double(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_lookup_double<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_lookup_double(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int32_t uarg_key{0};
    SimpleService_lookup_double_pargs pargs() {
      SimpleService_lookup_double_pargs args;
      args.get<0>().value = &uarg_key;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_key)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.lookup_double",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "lookup_double",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "lookup_double");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "lookup_double",
      /* .qualifiedMethodName =*/ "SimpleService.lookup_double"};
  apache::thrift::HandlerCallback<double>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_lookup_double};
 auto callback =
      apache::thrift::HandlerCallbackPtr<double>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_lookup_double<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_lookup_double<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_lookup_double.
  iface_->fbthrift_execute_decorators_before_lookup_double(*serverRequest.requestContext(), args.uarg_key);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_lookup_double(std::move(cb), args.uarg_key);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_lookup_double(
    apache::thrift::ContextStack* ctx,
    double const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_lookup_double_presult result;
  result.get<0>().value = const_cast<double*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("lookup_double", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_lookup_double(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "lookup_double");
    return;
  }
}
//
// End of Method 'lookup_double'
//

//
// Method 'retrieve_binary'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_retrieve_binary(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_retrieve_binary<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_retrieve_binary(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::string> uarg_something = std::make_unique<::std::string>();
    SimpleService_retrieve_binary_pargs pargs() {
      SimpleService_retrieve_binary_pargs args;
      args.get<0>().value = uarg_something.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_something)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.retrieve_binary",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "retrieve_binary",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "retrieve_binary");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "retrieve_binary",
      /* .qualifiedMethodName =*/ "SimpleService.retrieve_binary"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_retrieve_binary};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_retrieve_binary<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_retrieve_binary<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_retrieve_binary.
  iface_->fbthrift_execute_decorators_before_retrieve_binary(*serverRequest.requestContext(), *args.uarg_something);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_retrieve_binary(std::move(cb), std::move(args.uarg_something));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_retrieve_binary(
    apache::thrift::ContextStack* ctx,
    ::std::string const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_retrieve_binary_presult result;
  result.get<0>().value = const_cast<::std::string*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("retrieve_binary", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_retrieve_binary(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "retrieve_binary");
    return;
  }
}
//
// End of Method 'retrieve_binary'
//

//
// Method 'contain_binary'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_contain_binary(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_contain_binary<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_contain_binary(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::std::string>> uarg_binaries = std::make_unique<::std::vector<::std::string>>();
    SimpleService_contain_binary_pargs pargs() {
      SimpleService_contain_binary_pargs args;
      args.get<0>().value = uarg_binaries.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_binaries)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.contain_binary",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "contain_binary",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "contain_binary");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "contain_binary",
      /* .qualifiedMethodName =*/ "SimpleService.contain_binary"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_contain_binary};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::set<::std::string>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_contain_binary<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_contain_binary<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_contain_binary.
  iface_->fbthrift_execute_decorators_before_contain_binary(*serverRequest.requestContext(), *args.uarg_binaries);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_contain_binary(std::move(cb), std::move(args.uarg_binaries));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_contain_binary(
    apache::thrift::ContextStack* ctx,
    ::std::set<::std::string> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_contain_binary_presult result;
  result.get<0>().value = const_cast<::std::set<::std::string>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("contain_binary", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_contain_binary(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "contain_binary");
    return;
  }
}
//
// End of Method 'contain_binary'
//

//
// Method 'contain_enum'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_contain_enum(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_contain_enum<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_contain_enum(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::py3::simple::AnEnum>> uarg_the_enum = std::make_unique<::std::vector<::py3::simple::AnEnum>>();
    SimpleService_contain_enum_pargs pargs() {
      SimpleService_contain_enum_pargs args;
      args.get<0>().value = uarg_the_enum.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_the_enum)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.contain_enum",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "contain_enum",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "contain_enum");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "contain_enum",
      /* .qualifiedMethodName =*/ "SimpleService.contain_enum"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_contain_enum};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_contain_enum<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_contain_enum<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_contain_enum.
  iface_->fbthrift_execute_decorators_before_contain_enum(*serverRequest.requestContext(), *args.uarg_the_enum);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_contain_enum(std::move(cb), std::move(args.uarg_the_enum));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_contain_enum(
    apache::thrift::ContextStack* ctx,
    ::std::vector<::py3::simple::AnEnum> const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_contain_enum_presult result;
  result.get<0>().value = const_cast<::std::vector<::py3::simple::AnEnum>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("contain_enum", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_contain_enum(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "contain_enum");
    return;
  }
}
//
// End of Method 'contain_enum'
//

//
// Method 'get_binary_union_struct'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_binary_union_struct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_binary_union_struct<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_binary_union_struct(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::py3::simple::BinaryUnion> uarg_u = std::make_unique<::py3::simple::BinaryUnion>();
    SimpleService_get_binary_union_struct_pargs pargs() {
      SimpleService_get_binary_union_struct_pargs args;
      args.get<0>().value = uarg_u.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_u)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_binary_union_struct",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_binary_union_struct",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_binary_union_struct");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_binary_union_struct",
      /* .qualifiedMethodName =*/ "SimpleService.get_binary_union_struct"};
  apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::BinaryUnionStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_binary_union_struct};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::py3::simple::BinaryUnionStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_binary_union_struct<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_binary_union_struct<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_binary_union_struct.
  iface_->fbthrift_execute_decorators_before_get_binary_union_struct(*serverRequest.requestContext(), *args.uarg_u);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_binary_union_struct(std::move(cb), std::move(args.uarg_u));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_binary_union_struct(
    apache::thrift::ContextStack* ctx,
    ::py3::simple::BinaryUnionStruct const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_binary_union_struct_presult result;
  result.get<0>().value = const_cast<::py3::simple::BinaryUnionStruct*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_binary_union_struct", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_binary_union_struct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_binary_union_struct");
    return;
  }
}
//
// End of Method 'get_binary_union_struct'
//

//
// Method 'get_struct_hidden'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::setUpAndProcess_get_struct_hidden(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &SimpleServiceAsyncProcessor::
          executeRequest_get_struct_hidden<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void SimpleServiceAsyncProcessor::executeRequest_get_struct_hidden(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    SimpleService_get_struct_hidden_pargs pargs() {
      SimpleService_get_struct_hidden_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "SimpleService.get_struct_hidden",
      serverRequest.requestContext());
  apache::thrift::SerializedRequest serializedRequest{nullptr};
  try {
    auto pargs = args.pargs();
    serializedRequest = apache::thrift::detail::ServerRequestHelper::compressedRequest(
        std::move(serverRequest)).uncompress();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "get_struct_hidden",
        serializedRequest,
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "get_struct_hidden");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "SimpleService",
      /* .methodName =*/ "get_struct_hidden",
      /* .qualifiedMethodName =*/ "SimpleService.get_struct_hidden"};
  apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::SimpleStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fbthrift_invoke_decorator_after_get_struct_hidden};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::py3::simple::SimpleStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_get_struct_hidden<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_get_struct_hidden<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_get_struct_hidden.
  iface_->fbthrift_execute_decorators_before_get_struct_hidden(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_get_struct_hidden(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](
        auto callback,
        auto executeHandler,
        ArgsState args,
        const apache::thrift::SerializedRequest&& serializedRequest
    ) -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(argRefs),
          std::forward<const apache::thrift::SerializedRequest>(serializedRequest));
      executeHandler(std::move(callback), std::move(args));
    }(
        std::move(callback),
        makeExecuteHandler(),
        std::move(args),
        std::move(serializedRequest))
      .scheduleOn(apache::thrift::detail::ServerRequestHelper::executor(serverRequest))
      .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse SimpleServiceAsyncProcessor::return_get_struct_hidden(
    apache::thrift::ContextStack* ctx,
    ::py3::simple::SimpleStruct const& _return) {
  ProtocolOut_ prot;
  ::py3::simple::SimpleService_get_struct_hidden_presult result;
  result.get<0>().value = const_cast<::py3::simple::SimpleStruct*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("get_struct_hidden", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void SimpleServiceAsyncProcessor::throw_wrapped_get_struct_hidden(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "get_struct_hidden");
    return;
  }
}
//
// End of Method 'get_struct_hidden'
//

//
// End of Service Methods
//

} // namespace py3::simple
