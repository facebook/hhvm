#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/py3/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
from libc.stdint cimport (
    int8_t as cint8_t,
    int16_t as cint16_t,
    int32_t as cint32_t,
    int64_t as cint64_t,
)
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libcpp.vector cimport vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from libcpp.utility cimport move as cmove
from cython.operator cimport dereference as deref, typeid
from cpython.ref cimport PyObject
from thrift.py3.client cimport cRequestChannel_ptr, makeClientWrapper, cClientWrapper
from thrift.py3.exceptions cimport try_make_shared_exception
from thrift.python.exceptions cimport create_py_exception
from folly cimport cFollyTry, cFollyUnit, c_unit
from folly.cast cimport down_cast_ptr
from libcpp.typeinfo cimport type_info
import thrift.py3.types
cimport thrift.py3.types
from thrift.py3.types cimport make_unique
import thrift.py3.client
cimport thrift.py3.client
from thrift.python.common cimport (
    RpcOptions as __RpcOptions,
    cThriftServiceMetadataResponse as __fbthrift_cThriftServiceMetadataResponse,
    ServiceMetadata,
    MetadataBox as __MetadataBox,
)

from folly.futures cimport bridgeFutureWith
from folly.executor cimport get_executor
cimport folly.iobuf as _fbthrift_iobuf
import folly.iobuf as _fbthrift_iobuf
from folly.iobuf cimport move as move_iobuf
cimport cython

import sys
import types as _py_types
from asyncio import get_event_loop as asyncio_get_event_loop, shield as asyncio_shield, InvalidStateError as asyncio_InvalidStateError

cimport module.types as _module_types
cimport module.cbindings as _module_cbindings
import module.types as _module_types

cimport module.services_interface as _fbthrift_services_interface

from module.clients_wrapper cimport cSimpleServiceAsyncClient, cSimpleServiceClientWrapper
from module.clients_wrapper cimport cDerivedServiceAsyncClient, cDerivedServiceClientWrapper
from module.clients_wrapper cimport cRederivedServiceAsyncClient, cRederivedServiceClientWrapper


cdef void SimpleService_get_five_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_add_five_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_do_nothing_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_concat_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value().data().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_get_value_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_negate_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_tiny_callback(
    cFollyTry[cint8_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_small_callback(
    cFollyTry[cint16_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_big_callback(
    cFollyTry[cint64_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_two_callback(
    cFollyTry[double]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_expected_exception_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException[_module_cbindings.cSimpleException]():
        try:
            exc = _module_types.SimpleException._create_FBTHRIFT_ONLY_DO_NOT_USE(try_make_shared_exception[_module_cbindings.cSimpleException](result.exception()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))
        else:
            pyfuture.set_exception(exc)
    elif result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_unexpected_exception_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_sum_i16_list_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_sum_i32_list_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_sum_i64_list_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_concat_many_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value().data().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_count_structs_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_sum_set_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_contains_word_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_get_map_value_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value().data().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_map_length_callback(
    cFollyTry[cint16_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_sum_map_values_callback(
    cFollyTry[cint16_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_complex_sum_i32_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_repeat_name_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value().data().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_get_struct_callback(
    cFollyTry[_module_cbindings.cSimpleStruct]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.SimpleStruct._create_FBTHRIFT_ONLY_DO_NOT_USE(make_shared[_module_cbindings.cSimpleStruct](cmove(result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_fib_callback(
    cFollyTry[vector[cint32_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__i32__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_unique_words_callback(
    cFollyTry[cset[string]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Set__string__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_words_count_callback(
    cFollyTry[cmap[string,cint16_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Map__string_i16__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_set_enum_callback(
    cFollyTry[_module_cbindings.cAnEnum]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.AnEnum(<int> result.value()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_list_of_lists_callback(
    cFollyTry[vector[vector[cint32_t]]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__List__i32__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_word_character_frequency_callback(
    cFollyTry[cmap[string,cmap[string,cint32_t]]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Map__string_Map__string_i32__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_list_of_sets_callback(
    cFollyTry[vector[cset[string]]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__Set__string__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_nested_map_argument_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_make_sentence_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value().data().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_get_union_callback(
    cFollyTry[cset[cint32_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Set__i32__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_get_keys_callback(
    cFollyTry[cset[string]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Set__string__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_lookup_double_callback(
    cFollyTry[double]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_retrieve_binary_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_contain_binary_callback(
    cFollyTry[cset[string]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Set__binary__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_contain_enum_callback(
    cFollyTry[vector[_module_cbindings.cAnEnum]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__AnEnum__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void SimpleService_get_binary_union_struct_callback(
    cFollyTry[_module_cbindings.cBinaryUnionStruct]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.BinaryUnionStruct._create_FBTHRIFT_ONLY_DO_NOT_USE(make_shared[_module_cbindings.cBinaryUnionStruct](cmove(result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void DerivedService_get_six_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void RederivedService_get_seven_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))


cdef object _SimpleService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class SimpleService(thrift.py3.client.Client):
    annotations = _SimpleService_annotations

    cdef const type_info* _typeid(SimpleService self):
        return &typeid(cSimpleServiceAsyncClient)

    cdef bind_client(SimpleService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cSimpleServiceAsyncClient, cSimpleServiceClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_get_five = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def get_five(
            SimpleService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).get_five(rpc_options._cpp_obj, 
            ),
            SimpleService_get_five_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_add_five = {
        'return': 'int',
        'num': 'int', 
    }

    @cython.always_allow_keywords(True)
    def add_five(
            SimpleService self,
            num not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(num, int):
            raise TypeError(f'num is not a {int !r}.')
        else:
            num = <cint32_t> num
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).add_five(rpc_options._cpp_obj, 
                num,
            ),
            SimpleService_add_five_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_do_nothing = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def do_nothing(
            SimpleService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).do_nothing(rpc_options._cpp_obj, 
            ),
            SimpleService_do_nothing_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_concat = {
        'return': 'str',
        'first': 'str', 'second': 'str', 
    }

    @cython.always_allow_keywords(True)
    def concat(
            SimpleService self,
            str first not None,
            str second not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).concat(rpc_options._cpp_obj, 
                first.encode('UTF-8'),
                second.encode('UTF-8'),
            ),
            SimpleService_concat_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_get_value = {
        'return': 'int',
        'simple_struct': 'module.types.SimpleStruct', 
    }

    @cython.always_allow_keywords(True)
    def get_value(
            SimpleService self,
            _module_types.SimpleStruct simple_struct not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).get_value(rpc_options._cpp_obj, 
                deref((<_module_types.SimpleStruct>simple_struct)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
            ),
            SimpleService_get_value_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_negate = {
        'return': 'bool',
        'input': 'bool', 
    }

    @cython.always_allow_keywords(True)
    def negate(
            SimpleService self,
            pbool input not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).negate(rpc_options._cpp_obj, 
                input,
            ),
            SimpleService_negate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_tiny = {
        'return': 'int',
        'input': 'int', 
    }

    @cython.always_allow_keywords(True)
    def tiny(
            SimpleService self,
            input not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(input, int):
            raise TypeError(f'input is not a {int !r}.')
        else:
            input = <cint8_t> input
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint8_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).tiny(rpc_options._cpp_obj, 
                input,
            ),
            SimpleService_tiny_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_small = {
        'return': 'int',
        'input': 'int', 
    }

    @cython.always_allow_keywords(True)
    def small(
            SimpleService self,
            input not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(input, int):
            raise TypeError(f'input is not a {int !r}.')
        else:
            input = <cint16_t> input
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint16_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).small(rpc_options._cpp_obj, 
                input,
            ),
            SimpleService_small_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_big = {
        'return': 'int',
        'input': 'int', 
    }

    @cython.always_allow_keywords(True)
    def big(
            SimpleService self,
            input not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(input, int):
            raise TypeError(f'input is not a {int !r}.')
        else:
            input = <cint64_t> input
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint64_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).big(rpc_options._cpp_obj, 
                input,
            ),
            SimpleService_big_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_two = {
        'return': 'float',
        'input': 'float', 
    }

    @cython.always_allow_keywords(True)
    def two(
            SimpleService self,
            double input,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[double](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).two(rpc_options._cpp_obj, 
                input,
            ),
            SimpleService_two_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_expected_exception = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def expected_exception(
            SimpleService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).expected_exception(rpc_options._cpp_obj, 
            ),
            SimpleService_expected_exception_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_unexpected_exception = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def unexpected_exception(
            SimpleService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).unexpected_exception(rpc_options._cpp_obj, 
            ),
            SimpleService_unexpected_exception_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_sum_i16_list = {
        'return': 'int',
        'numbers': '_typing.Sequence[int]', 
    }

    @cython.always_allow_keywords(True)
    def sum_i16_list(
            SimpleService self,
            numbers not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(numbers, _module_types.List__i16):
            numbers = _module_types.List__i16(numbers)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).sum_i16_list(rpc_options._cpp_obj, 
                _module_types.List__i16__make_instance(numbers),
            ),
            SimpleService_sum_i16_list_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_sum_i32_list = {
        'return': 'int',
        'numbers': '_typing.Sequence[int]', 
    }

    @cython.always_allow_keywords(True)
    def sum_i32_list(
            SimpleService self,
            numbers not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(numbers, _module_types.List__i32):
            numbers = _module_types.List__i32(numbers)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).sum_i32_list(rpc_options._cpp_obj, 
                _module_types.List__i32__make_instance(numbers),
            ),
            SimpleService_sum_i32_list_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_sum_i64_list = {
        'return': 'int',
        'numbers': '_typing.Sequence[int]', 
    }

    @cython.always_allow_keywords(True)
    def sum_i64_list(
            SimpleService self,
            numbers not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(numbers, _module_types.List__i64):
            numbers = _module_types.List__i64(numbers)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).sum_i64_list(rpc_options._cpp_obj, 
                _module_types.List__i64__make_instance(numbers),
            ),
            SimpleService_sum_i64_list_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_concat_many = {
        'return': 'str',
        'words': '_typing.Sequence[str]', 
    }

    @cython.always_allow_keywords(True)
    def concat_many(
            SimpleService self,
            words not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(words, _module_types.List__string):
            words = _module_types.List__string(words)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).concat_many(rpc_options._cpp_obj, 
                _module_types.List__string__make_instance(words),
            ),
            SimpleService_concat_many_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_count_structs = {
        'return': 'int',
        'items': '_typing.Sequence[module.types.SimpleStruct]', 
    }

    @cython.always_allow_keywords(True)
    def count_structs(
            SimpleService self,
            items not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(items, _module_types.List__SimpleStruct):
            items = _module_types.List__SimpleStruct(items)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).count_structs(rpc_options._cpp_obj, 
                _module_types.List__SimpleStruct__make_instance(items),
            ),
            SimpleService_count_structs_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_sum_set = {
        'return': 'int',
        'numbers': '_typing.AbstractSet[int]', 
    }

    @cython.always_allow_keywords(True)
    def sum_set(
            SimpleService self,
            numbers not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(numbers, _module_types.Set__i32):
            numbers = _module_types.Set__i32(numbers)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).sum_set(rpc_options._cpp_obj, 
                _module_types.Set__i32__make_instance(numbers),
            ),
            SimpleService_sum_set_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_contains_word = {
        'return': 'bool',
        'words': '_typing.AbstractSet[str]', 'word': 'str', 
    }

    @cython.always_allow_keywords(True)
    def contains_word(
            SimpleService self,
            words not None,
            str word not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(words, _module_types.Set__string):
            words = _module_types.Set__string(words)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).contains_word(rpc_options._cpp_obj, 
                _module_types.Set__string__make_instance(words),
                word.encode('UTF-8'),
            ),
            SimpleService_contains_word_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_get_map_value = {
        'return': 'str',
        'words': '_typing.Mapping[str, str]', 'key': 'str', 
    }

    @cython.always_allow_keywords(True)
    def get_map_value(
            SimpleService self,
            words not None,
            str key not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(words, _module_types.Map__string_string):
            words = _module_types.Map__string_string(words)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).get_map_value(rpc_options._cpp_obj, 
                _module_types.Map__string_string__make_instance(words),
                key.encode('UTF-8'),
            ),
            SimpleService_get_map_value_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_map_length = {
        'return': 'int',
        'items': '_typing.Mapping[str, module.types.SimpleStruct]', 
    }

    @cython.always_allow_keywords(True)
    def map_length(
            SimpleService self,
            items not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(items, _module_types.Map__string_SimpleStruct):
            items = _module_types.Map__string_SimpleStruct(items)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint16_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).map_length(rpc_options._cpp_obj, 
                _module_types.Map__string_SimpleStruct__make_instance(items),
            ),
            SimpleService_map_length_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_sum_map_values = {
        'return': 'int',
        'items': '_typing.Mapping[str, int]', 
    }

    @cython.always_allow_keywords(True)
    def sum_map_values(
            SimpleService self,
            items not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(items, _module_types.Map__string_i16):
            items = _module_types.Map__string_i16(items)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint16_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).sum_map_values(rpc_options._cpp_obj, 
                _module_types.Map__string_i16__make_instance(items),
            ),
            SimpleService_sum_map_values_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_complex_sum_i32 = {
        'return': 'int',
        'counter': 'module.types.ComplexStruct', 
    }

    @cython.always_allow_keywords(True)
    def complex_sum_i32(
            SimpleService self,
            _module_types.ComplexStruct counter not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).complex_sum_i32(rpc_options._cpp_obj, 
                deref((<_module_types.ComplexStruct>counter)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
            ),
            SimpleService_complex_sum_i32_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_repeat_name = {
        'return': 'str',
        'counter': 'module.types.ComplexStruct', 
    }

    @cython.always_allow_keywords(True)
    def repeat_name(
            SimpleService self,
            _module_types.ComplexStruct counter not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).repeat_name(rpc_options._cpp_obj, 
                deref((<_module_types.ComplexStruct>counter)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
            ),
            SimpleService_repeat_name_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_get_struct = {
        'return': 'module.types.SimpleStruct',
        
    }

    @cython.always_allow_keywords(True)
    def get_struct(
            SimpleService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cSimpleStruct](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).get_struct(rpc_options._cpp_obj, 
            ),
            SimpleService_get_struct_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_fib = {
        'return': '_typing.Sequence[int]',
        'n': 'int', 
    }

    @cython.always_allow_keywords(True)
    def fib(
            SimpleService self,
            n not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(n, int):
            raise TypeError(f'n is not a {int !r}.')
        else:
            n = <cint16_t> n
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[cint32_t]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).fib(rpc_options._cpp_obj, 
                n,
            ),
            SimpleService_fib_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_unique_words = {
        'return': '_typing.AbstractSet[str]',
        'words': '_typing.Sequence[str]', 
    }

    @cython.always_allow_keywords(True)
    def unique_words(
            SimpleService self,
            words not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(words, _module_types.List__string):
            words = _module_types.List__string(words)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[string]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).unique_words(rpc_options._cpp_obj, 
                _module_types.List__string__make_instance(words),
            ),
            SimpleService_unique_words_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_words_count = {
        'return': '_typing.Mapping[str, int]',
        'words': '_typing.Sequence[str]', 
    }

    @cython.always_allow_keywords(True)
    def words_count(
            SimpleService self,
            words not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(words, _module_types.List__string):
            words = _module_types.List__string(words)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[string,cint16_t]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).words_count(rpc_options._cpp_obj, 
                _module_types.List__string__make_instance(words),
            ),
            SimpleService_words_count_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_set_enum = {
        'return': 'module.types.AnEnum',
        'in_enum': 'module.types.AnEnum', 
    }

    @cython.always_allow_keywords(True)
    def set_enum(
            SimpleService self,
            object in_enum not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cAnEnum](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).set_enum(rpc_options._cpp_obj, 
                <_module_cbindings.cAnEnum><int>in_enum,
            ),
            SimpleService_set_enum_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_list_of_lists = {
        'return': '_typing.Sequence[_typing.Sequence[int]]',
        'num_lists': 'int', 'num_items': 'int', 
    }

    @cython.always_allow_keywords(True)
    def list_of_lists(
            SimpleService self,
            num_lists not None,
            num_items not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(num_lists, int):
            raise TypeError(f'num_lists is not a {int !r}.')
        else:
            num_lists = <cint16_t> num_lists
        if not isinstance(num_items, int):
            raise TypeError(f'num_items is not a {int !r}.')
        else:
            num_items = <cint16_t> num_items
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[vector[cint32_t]]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).list_of_lists(rpc_options._cpp_obj, 
                num_lists,
                num_items,
            ),
            SimpleService_list_of_lists_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_word_character_frequency = {
        'return': '_typing.Mapping[str, _typing.Mapping[str, int]]',
        'sentence': 'str', 
    }

    @cython.always_allow_keywords(True)
    def word_character_frequency(
            SimpleService self,
            str sentence not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[string,cmap[string,cint32_t]]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).word_character_frequency(rpc_options._cpp_obj, 
                sentence.encode('UTF-8'),
            ),
            SimpleService_word_character_frequency_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_list_of_sets = {
        'return': '_typing.Sequence[_typing.AbstractSet[str]]',
        'some_words': 'str', 
    }

    @cython.always_allow_keywords(True)
    def list_of_sets(
            SimpleService self,
            str some_words not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[cset[string]]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).list_of_sets(rpc_options._cpp_obj, 
                some_words.encode('UTF-8'),
            ),
            SimpleService_list_of_sets_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_nested_map_argument = {
        'return': 'int',
        'struct_map': '_typing.Mapping[str, _typing.Sequence[module.types.SimpleStruct]]', 
    }

    @cython.always_allow_keywords(True)
    def nested_map_argument(
            SimpleService self,
            struct_map not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(struct_map, _module_types.Map__string_List__SimpleStruct):
            struct_map = _module_types.Map__string_List__SimpleStruct(struct_map)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).nested_map_argument(rpc_options._cpp_obj, 
                _module_types.Map__string_List__SimpleStruct__make_instance(struct_map),
            ),
            SimpleService_nested_map_argument_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_make_sentence = {
        'return': 'str',
        'word_chars': '_typing.Sequence[_typing.Sequence[str]]', 
    }

    @cython.always_allow_keywords(True)
    def make_sentence(
            SimpleService self,
            word_chars not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(word_chars, _module_types.List__List__string):
            word_chars = _module_types.List__List__string(word_chars)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).make_sentence(rpc_options._cpp_obj, 
                _module_types.List__List__string__make_instance(word_chars),
            ),
            SimpleService_make_sentence_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_get_union = {
        'return': '_typing.AbstractSet[int]',
        'sets': '_typing.Sequence[_typing.AbstractSet[int]]', 
    }

    @cython.always_allow_keywords(True)
    def get_union(
            SimpleService self,
            sets not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(sets, _module_types.List__Set__i32):
            sets = _module_types.List__Set__i32(sets)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[cint32_t]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).get_union(rpc_options._cpp_obj, 
                _module_types.List__Set__i32__make_instance(sets),
            ),
            SimpleService_get_union_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_get_keys = {
        'return': '_typing.AbstractSet[str]',
        'string_map': '_typing.Sequence[_typing.Mapping[str, str]]', 
    }

    @cython.always_allow_keywords(True)
    def get_keys(
            SimpleService self,
            string_map not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(string_map, _module_types.List__Map__string_string):
            string_map = _module_types.List__Map__string_string(string_map)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[string]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).get_keys(rpc_options._cpp_obj, 
                _module_types.List__Map__string_string__make_instance(string_map),
            ),
            SimpleService_get_keys_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_lookup_double = {
        'return': 'float',
        'key': 'int', 
    }

    @cython.always_allow_keywords(True)
    def lookup_double(
            SimpleService self,
            key not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(key, int):
            raise TypeError(f'key is not a {int !r}.')
        else:
            key = <cint32_t> key
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[double](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).lookup_double(rpc_options._cpp_obj, 
                key,
            ),
            SimpleService_lookup_double_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_retrieve_binary = {
        'return': 'bytes',
        'something': 'bytes', 
    }

    @cython.always_allow_keywords(True)
    def retrieve_binary(
            SimpleService self,
            bytes something not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).retrieve_binary(rpc_options._cpp_obj, 
                something,
            ),
            SimpleService_retrieve_binary_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_contain_binary = {
        'return': '_typing.AbstractSet[bytes]',
        'binaries': '_typing.Sequence[bytes]', 
    }

    @cython.always_allow_keywords(True)
    def contain_binary(
            SimpleService self,
            binaries not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(binaries, _module_types.List__binary):
            binaries = _module_types.List__binary(binaries)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[string]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).contain_binary(rpc_options._cpp_obj, 
                _module_types.List__binary__make_instance(binaries),
            ),
            SimpleService_contain_binary_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_contain_enum = {
        'return': '_typing.Sequence[module.types.AnEnum]',
        'the_enum': '_typing.Sequence[module.types.AnEnum]', 
    }

    @cython.always_allow_keywords(True)
    def contain_enum(
            SimpleService self,
            the_enum not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(the_enum, _module_types.List__AnEnum):
            the_enum = _module_types.List__AnEnum(the_enum)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_cbindings.cAnEnum]](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).contain_enum(rpc_options._cpp_obj, 
                _module_types.List__AnEnum__make_instance(the_enum),
            ),
            SimpleService_contain_enum_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_get_binary_union_struct = {
        'return': 'module.types.BinaryUnionStruct',
        'u': 'module.types.BinaryUnion', 
    }

    @cython.always_allow_keywords(True)
    def get_binary_union_struct(
            SimpleService self,
            _module_types.BinaryUnion u not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cBinaryUnionStruct](
            self._executor,
            down_cast_ptr[cSimpleServiceClientWrapper, cClientWrapper](self._client.get()).get_binary_union_struct(rpc_options._cpp_obj, 
                deref((<_module_types.BinaryUnion>u)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
            ),
            SimpleService_get_binary_union_struct_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cSimpleServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.SimpleService"

cdef object _DerivedService_annotations = _py_types.MappingProxyType({
    """bar""": """1""",    """foo""": """\"\"\"""",
})


@cython.auto_pickle(False)
cdef class DerivedService(SimpleService):
    annotations = _DerivedService_annotations

    cdef const type_info* _typeid(DerivedService self):
        return &typeid(cDerivedServiceAsyncClient)

    cdef bind_client(DerivedService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cDerivedServiceAsyncClient, cDerivedServiceClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_get_six = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def get_six(
            DerivedService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cDerivedServiceClientWrapper, cClientWrapper](self._client.get()).get_six(rpc_options._cpp_obj, 
            ),
            DerivedService_get_six_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cDerivedServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.DerivedService"

cdef object _RederivedService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class RederivedService(DerivedService):
    annotations = _RederivedService_annotations

    cdef const type_info* _typeid(RederivedService self):
        return &typeid(cRederivedServiceAsyncClient)

    cdef bind_client(RederivedService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cRederivedServiceAsyncClient, cRederivedServiceClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_get_seven = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def get_seven(
            RederivedService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cRederivedServiceClientWrapper, cClientWrapper](self._client.get()).get_seven(rpc_options._cpp_obj, 
            ),
            RederivedService_get_seven_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cRederivedServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.RederivedService"

