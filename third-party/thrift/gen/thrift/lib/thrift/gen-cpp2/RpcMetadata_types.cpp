/**
 * Autogenerated by Thrift for RpcMetadata.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "RpcMetadata_types.h"
#include "RpcMetadata_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "RpcMetadata_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ProtocolId>::size;
folly::Range<::apache::thrift::ProtocolId const*> const TEnumTraits<::apache::thrift::ProtocolId>::values = folly::range(TEnumDataStorage<::apache::thrift::ProtocolId>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ProtocolId>::names = folly::range(TEnumDataStorage<::apache::thrift::ProtocolId>::names);

char const* TEnumTraits<::apache::thrift::ProtocolId>::findName(type value) {
  using factory = ::apache::thrift::_ProtocolId_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ProtocolId>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ProtocolId_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ProtocolId_EnumMapFactory::ValuesToNamesMapType _ProtocolId_VALUES_TO_NAMES = _ProtocolId_EnumMapFactory::makeValuesToNamesMap();
const _ProtocolId_EnumMapFactory::NamesToValuesMapType _ProtocolId_NAMES_TO_VALUES = _ProtocolId_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RpcKind>::size;
folly::Range<::apache::thrift::RpcKind const*> const TEnumTraits<::apache::thrift::RpcKind>::values = folly::range(TEnumDataStorage<::apache::thrift::RpcKind>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RpcKind>::names = folly::range(TEnumDataStorage<::apache::thrift::RpcKind>::names);

char const* TEnumTraits<::apache::thrift::RpcKind>::findName(type value) {
  using factory = ::apache::thrift::_RpcKind_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RpcKind>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RpcKind_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RpcKind_EnumMapFactory::ValuesToNamesMapType _RpcKind_VALUES_TO_NAMES = _RpcKind_EnumMapFactory::makeValuesToNamesMap();
const _RpcKind_EnumMapFactory::NamesToValuesMapType _RpcKind_NAMES_TO_VALUES = _RpcKind_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RpcPriority>::size;
folly::Range<::apache::thrift::RpcPriority const*> const TEnumTraits<::apache::thrift::RpcPriority>::values = folly::range(TEnumDataStorage<::apache::thrift::RpcPriority>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RpcPriority>::names = folly::range(TEnumDataStorage<::apache::thrift::RpcPriority>::names);

char const* TEnumTraits<::apache::thrift::RpcPriority>::findName(type value) {
  using factory = ::apache::thrift::_RpcPriority_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RpcPriority>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RpcPriority_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RpcPriority_EnumMapFactory::ValuesToNamesMapType _RpcPriority_VALUES_TO_NAMES = _RpcPriority_EnumMapFactory::makeValuesToNamesMap();
const _RpcPriority_EnumMapFactory::NamesToValuesMapType _RpcPriority_NAMES_TO_VALUES = _RpcPriority_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::CompressionAlgorithm>::size;
folly::Range<::apache::thrift::CompressionAlgorithm const*> const TEnumTraits<::apache::thrift::CompressionAlgorithm>::values = folly::range(TEnumDataStorage<::apache::thrift::CompressionAlgorithm>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::CompressionAlgorithm>::names = folly::range(TEnumDataStorage<::apache::thrift::CompressionAlgorithm>::names);

char const* TEnumTraits<::apache::thrift::CompressionAlgorithm>::findName(type value) {
  using factory = ::apache::thrift::_CompressionAlgorithm_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::CompressionAlgorithm>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_CompressionAlgorithm_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _CompressionAlgorithm_EnumMapFactory::ValuesToNamesMapType _CompressionAlgorithm_VALUES_TO_NAMES = _CompressionAlgorithm_EnumMapFactory::makeValuesToNamesMap();
const _CompressionAlgorithm_EnumMapFactory::NamesToValuesMapType _CompressionAlgorithm_NAMES_TO_VALUES = _CompressionAlgorithm_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ErrorKind>::size;
folly::Range<::apache::thrift::ErrorKind const*> const TEnumTraits<::apache::thrift::ErrorKind>::values = folly::range(TEnumDataStorage<::apache::thrift::ErrorKind>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ErrorKind>::names = folly::range(TEnumDataStorage<::apache::thrift::ErrorKind>::names);

char const* TEnumTraits<::apache::thrift::ErrorKind>::findName(type value) {
  using factory = ::apache::thrift::_ErrorKind_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ErrorKind>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ErrorKind_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ErrorKind_EnumMapFactory::ValuesToNamesMapType _ErrorKind_VALUES_TO_NAMES = _ErrorKind_EnumMapFactory::makeValuesToNamesMap();
const _ErrorKind_EnumMapFactory::NamesToValuesMapType _ErrorKind_NAMES_TO_VALUES = _ErrorKind_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ErrorBlame>::size;
folly::Range<::apache::thrift::ErrorBlame const*> const TEnumTraits<::apache::thrift::ErrorBlame>::values = folly::range(TEnumDataStorage<::apache::thrift::ErrorBlame>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ErrorBlame>::names = folly::range(TEnumDataStorage<::apache::thrift::ErrorBlame>::names);

char const* TEnumTraits<::apache::thrift::ErrorBlame>::findName(type value) {
  using factory = ::apache::thrift::_ErrorBlame_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ErrorBlame>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ErrorBlame_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ErrorBlame_EnumMapFactory::ValuesToNamesMapType _ErrorBlame_VALUES_TO_NAMES = _ErrorBlame_EnumMapFactory::makeValuesToNamesMap();
const _ErrorBlame_EnumMapFactory::NamesToValuesMapType _ErrorBlame_NAMES_TO_VALUES = _ErrorBlame_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ErrorSafety>::size;
folly::Range<::apache::thrift::ErrorSafety const*> const TEnumTraits<::apache::thrift::ErrorSafety>::values = folly::range(TEnumDataStorage<::apache::thrift::ErrorSafety>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ErrorSafety>::names = folly::range(TEnumDataStorage<::apache::thrift::ErrorSafety>::names);

char const* TEnumTraits<::apache::thrift::ErrorSafety>::findName(type value) {
  using factory = ::apache::thrift::_ErrorSafety_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ErrorSafety>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ErrorSafety_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ErrorSafety_EnumMapFactory::ValuesToNamesMapType _ErrorSafety_VALUES_TO_NAMES = _ErrorSafety_EnumMapFactory::makeValuesToNamesMap();
const _ErrorSafety_EnumMapFactory::NamesToValuesMapType _ErrorSafety_NAMES_TO_VALUES = _ErrorSafety_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::FunctionQualifier>::size;
folly::Range<::apache::thrift::FunctionQualifier const*> const TEnumTraits<::apache::thrift::FunctionQualifier>::values = folly::range(TEnumDataStorage<::apache::thrift::FunctionQualifier>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::FunctionQualifier>::names = folly::range(TEnumDataStorage<::apache::thrift::FunctionQualifier>::names);

char const* TEnumTraits<::apache::thrift::FunctionQualifier>::findName(type value) {
  using factory = ::apache::thrift::_FunctionQualifier_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::FunctionQualifier>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_FunctionQualifier_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _FunctionQualifier_EnumMapFactory::ValuesToNamesMapType _FunctionQualifier_VALUES_TO_NAMES = _FunctionQualifier_EnumMapFactory::makeValuesToNamesMap();
const _FunctionQualifier_EnumMapFactory::NamesToValuesMapType _FunctionQualifier_NAMES_TO_VALUES = _FunctionQualifier_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::size;
folly::Range<::apache::thrift::ResponseRpcErrorCategory const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::values = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCategory>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::names = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCategory>::names);

char const* TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::findName(type value) {
  using factory = ::apache::thrift::_ResponseRpcErrorCategory_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ResponseRpcErrorCategory_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ResponseRpcErrorCategory_EnumMapFactory::ValuesToNamesMapType _ResponseRpcErrorCategory_VALUES_TO_NAMES = _ResponseRpcErrorCategory_EnumMapFactory::makeValuesToNamesMap();
const _ResponseRpcErrorCategory_EnumMapFactory::NamesToValuesMapType _ResponseRpcErrorCategory_NAMES_TO_VALUES = _ResponseRpcErrorCategory_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::size;
folly::Range<::apache::thrift::ResponseRpcErrorCode const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::values = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCode>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::names = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCode>::names);

char const* TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::findName(type value) {
  using factory = ::apache::thrift::_ResponseRpcErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ResponseRpcErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ResponseRpcErrorCode_EnumMapFactory::ValuesToNamesMapType _ResponseRpcErrorCode_VALUES_TO_NAMES = _ResponseRpcErrorCode_EnumMapFactory::makeValuesToNamesMap();
const _ResponseRpcErrorCode_EnumMapFactory::NamesToValuesMapType _ResponseRpcErrorCode_NAMES_TO_VALUES = _ResponseRpcErrorCode_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::StreamRpcErrorCode>::size;
folly::Range<::apache::thrift::StreamRpcErrorCode const*> const TEnumTraits<::apache::thrift::StreamRpcErrorCode>::values = folly::range(TEnumDataStorage<::apache::thrift::StreamRpcErrorCode>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::StreamRpcErrorCode>::names = folly::range(TEnumDataStorage<::apache::thrift::StreamRpcErrorCode>::names);

char const* TEnumTraits<::apache::thrift::StreamRpcErrorCode>::findName(type value) {
  using factory = ::apache::thrift::_StreamRpcErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::StreamRpcErrorCode>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_StreamRpcErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _StreamRpcErrorCode_EnumMapFactory::ValuesToNamesMapType _StreamRpcErrorCode_VALUES_TO_NAMES = _StreamRpcErrorCode_EnumMapFactory::makeValuesToNamesMap();
const _StreamRpcErrorCode_EnumMapFactory::NamesToValuesMapType _StreamRpcErrorCode_NAMES_TO_VALUES = _StreamRpcErrorCode_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::InterfaceKind>::size;
folly::Range<::apache::thrift::InterfaceKind const*> const TEnumTraits<::apache::thrift::InterfaceKind>::values = folly::range(TEnumDataStorage<::apache::thrift::InterfaceKind>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::InterfaceKind>::names = folly::range(TEnumDataStorage<::apache::thrift::InterfaceKind>::names);

char const* TEnumTraits<::apache::thrift::InterfaceKind>::findName(type value) {
  using factory = ::apache::thrift::_InterfaceKind_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::InterfaceKind>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_InterfaceKind_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _InterfaceKind_EnumMapFactory::ValuesToNamesMapType _InterfaceKind_VALUES_TO_NAMES = _InterfaceKind_EnumMapFactory::makeValuesToNamesMap();
const _InterfaceKind_EnumMapFactory::NamesToValuesMapType _InterfaceKind_NAMES_TO_VALUES = _InterfaceKind_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::DrainCompleteCode>::size;
folly::Range<::apache::thrift::DrainCompleteCode const*> const TEnumTraits<::apache::thrift::DrainCompleteCode>::values = folly::range(TEnumDataStorage<::apache::thrift::DrainCompleteCode>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::DrainCompleteCode>::names = folly::range(TEnumDataStorage<::apache::thrift::DrainCompleteCode>::names);

char const* TEnumTraits<::apache::thrift::DrainCompleteCode>::findName(type value) {
  using factory = ::apache::thrift::_DrainCompleteCode_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::DrainCompleteCode>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_DrainCompleteCode_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _DrainCompleteCode_EnumMapFactory::ValuesToNamesMapType _DrainCompleteCode_VALUES_TO_NAMES = _DrainCompleteCode_EnumMapFactory::makeValuesToNamesMap();
const _DrainCompleteCode_EnumMapFactory::NamesToValuesMapType _DrainCompleteCode_NAMES_TO_VALUES = _DrainCompleteCode_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ZlibCompressionCodecConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ZlibCompressionCodecConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ZlibCompressionCodecConfig::ZlibCompressionCodecConfig(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void ZlibCompressionCodecConfig::__clear() {
  // clear all fields
}

bool ZlibCompressionCodecConfig::operator==(const ZlibCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ZlibCompressionCodecConfig::operator<(const ZlibCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ZlibCompressionCodecConfig& a, ZlibCompressionCodecConfig& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ZlibCompressionCodecConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ZlibCompressionCodecConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ZlibCompressionCodecConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ZlibCompressionCodecConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ZlibCompressionCodecConfig::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ZlibCompressionCodecConfig::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ZstdCompressionCodecConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ZstdCompressionCodecConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ZstdCompressionCodecConfig::ZstdCompressionCodecConfig(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void ZstdCompressionCodecConfig::__clear() {
  // clear all fields
}

bool ZstdCompressionCodecConfig::operator==(const ZstdCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ZstdCompressionCodecConfig::operator<(const ZstdCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ZstdCompressionCodecConfig& a, ZstdCompressionCodecConfig& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ZstdCompressionCodecConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ZstdCompressionCodecConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ZstdCompressionCodecConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ZstdCompressionCodecConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ZstdCompressionCodecConfig::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ZstdCompressionCodecConfig::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::CodecConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::CodecConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::CodecConfig::Type>::size;
folly::Range<::apache::thrift::CodecConfig::Type const*> const TEnumTraits<::apache::thrift::CodecConfig::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::CodecConfig::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::CodecConfig::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::CodecConfig::Type>::names);

char const* TEnumTraits<::apache::thrift::CodecConfig::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::CodecConfig::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::CodecConfig::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::CodecConfig::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void CodecConfig::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::zlibConfig:
      destruct(value_.zlibConfig);
      break;
    case Type::zstdConfig:
      destruct(value_.zstdConfig);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool CodecConfig::operator==(const CodecConfig& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::zlibConfig:
      return value_.zlibConfig == rhs.value_.zlibConfig;
    case Type::zstdConfig:
      return value_.zstdConfig == rhs.value_.zstdConfig;
    default:
      return true;
  }
}

bool CodecConfig::operator<(const CodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::zlibConfig:
      return lhs.value_.zlibConfig < rhs.value_.zlibConfig;
    case Type::zstdConfig:
      return lhs.value_.zstdConfig < rhs.value_.zstdConfig;
    default:
      return false;
  }
}

void swap(CodecConfig& a, CodecConfig& b) {
  CodecConfig temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void CodecConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CodecConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CodecConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CodecConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CodecConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CodecConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CodecConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CodecConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void CodecConfig::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t CodecConfig::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t CodecConfig::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t CodecConfig::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CodecConfig,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ZlibCompressionCodecConfig>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CodecConfig,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ZstdCompressionCodecConfig>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CodecConfig,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ZlibCompressionCodecConfig>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CodecConfig,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ZstdCompressionCodecConfig>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::CompressionConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::CompressionConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CompressionConfig::CompressionConfig(const CompressionConfig&) = default;
CompressionConfig& CompressionConfig::operator=(const CompressionConfig&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CompressionConfig::CompressionConfig(CompressionConfig&& other) noexcept  :
    codecConfig(std::move(other.codecConfig)),
    compressionSizeLimit(std::move(other.compressionSizeLimit)),
    __isset(other.__isset) {}
CompressionConfig& CompressionConfig::operator=(FOLLY_MAYBE_UNUSED CompressionConfig&& other) noexcept {
    this->codecConfig = std::move(other.codecConfig);
    this->compressionSizeLimit = std::move(other.compressionSizeLimit);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CompressionConfig::CompressionConfig(apache::thrift::FragileConstructor, ::apache::thrift::CodecConfig codecConfig__arg, ::std::int64_t compressionSizeLimit__arg) :
    codecConfig(std::move(codecConfig__arg)),
    compressionSizeLimit(std::move(compressionSizeLimit__arg)) {
  __isset.codecConfig = true;
  __isset.compressionSizeLimit = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void CompressionConfig::__clear() {
  // clear all fields
  this->codecConfig.__clear();
  this->compressionSizeLimit = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CompressionConfig::operator==(const CompressionConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.codecConfig_ref() != rhs.codecConfig_ref()) {
    return false;
  }
  if (lhs.compressionSizeLimit_ref() != rhs.compressionSizeLimit_ref()) {
    return false;
  }
  return true;
}

bool CompressionConfig::operator<(const CompressionConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.codecConfig_ref() != rhs.codecConfig_ref()) {
    return lhs.codecConfig_ref() < rhs.codecConfig_ref();
  }
  if (lhs.compressionSizeLimit_ref() != rhs.compressionSizeLimit_ref()) {
    return lhs.compressionSizeLimit_ref() < rhs.compressionSizeLimit_ref();
  }
  return false;
}

const ::apache::thrift::CodecConfig* CompressionConfig::get_codecConfig() const& {
  return codecConfig_ref().has_value() ? std::addressof(codecConfig) : nullptr;
}

::apache::thrift::CodecConfig* CompressionConfig::get_codecConfig() & {
  return codecConfig_ref().has_value() ? std::addressof(codecConfig) : nullptr;
}


void swap(CompressionConfig& a, CompressionConfig& b) {
  using ::std::swap;
  swap(a.codecConfig_ref().value_unchecked(), b.codecConfig_ref().value_unchecked());
  swap(a.compressionSizeLimit_ref().value_unchecked(), b.compressionSizeLimit_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CompressionConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CompressionConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CompressionConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CompressionConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CompressionConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CompressionConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CompressionConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CompressionConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void CompressionConfig::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t CompressionConfig::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t CompressionConfig::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t CompressionConfig::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CompressionConfig,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::CodecConfig>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CompressionConfig,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::CodecConfig>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::NegotiationParameters>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::NegotiationParameters>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NegotiationParameters::NegotiationParameters(apache::thrift::FragileConstructor, std::uint64_t compressionAlgos__arg, bool useStopTLS__arg) :
    compressionAlgos(std::move(compressionAlgos__arg)),
    useStopTLS(std::move(useStopTLS__arg)) {
  __isset.compressionAlgos = true;
  __isset.useStopTLS = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void NegotiationParameters::__clear() {
  // clear all fields
  this->compressionAlgos = 0;
  this->useStopTLS = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NegotiationParameters::operator==(const NegotiationParameters& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compressionAlgos_ref() != rhs.compressionAlgos_ref()) {
    return false;
  }
  if (lhs.useStopTLS_ref() != rhs.useStopTLS_ref()) {
    return false;
  }
  return true;
}

bool NegotiationParameters::operator<(const NegotiationParameters& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compressionAlgos_ref() != rhs.compressionAlgos_ref()) {
    return lhs.compressionAlgos_ref() < rhs.compressionAlgos_ref();
  }
  if (lhs.useStopTLS_ref() != rhs.useStopTLS_ref()) {
    return lhs.useStopTLS_ref() < rhs.useStopTLS_ref();
  }
  return false;
}


void swap(NegotiationParameters& a, NegotiationParameters& b) {
  using ::std::swap;
  swap(a.compressionAlgos_ref().value_unchecked(), b.compressionAlgos_ref().value_unchecked());
  swap(a.useStopTLS_ref().value_unchecked(), b.useStopTLS_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NegotiationParameters::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NegotiationParameters::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NegotiationParameters::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NegotiationParameters::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NegotiationParameters::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NegotiationParameters::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NegotiationParameters::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NegotiationParameters::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void NegotiationParameters::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t NegotiationParameters::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t NegotiationParameters::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t NegotiationParameters::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::InteractionCreate>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::InteractionCreate>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
InteractionCreate::InteractionCreate(const InteractionCreate&) = default;
InteractionCreate& InteractionCreate::operator=(const InteractionCreate&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
InteractionCreate::InteractionCreate(InteractionCreate&& other) noexcept  :
    interactionId(std::move(other.interactionId)),
    interactionName(std::move(other.interactionName)),
    __isset(other.__isset) {}
InteractionCreate& InteractionCreate::operator=(FOLLY_MAYBE_UNUSED InteractionCreate&& other) noexcept {
    this->interactionId = std::move(other.interactionId);
    this->interactionName = std::move(other.interactionName);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
InteractionCreate::InteractionCreate(apache::thrift::FragileConstructor, ::std::int64_t interactionId__arg, ::apache::thrift::ManagedStringViewField interactionName__arg) :
    interactionId(std::move(interactionId__arg)),
    interactionName(std::move(interactionName__arg)) {
  __isset.interactionId = true;
  __isset.interactionName = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void InteractionCreate::__clear() {
  // clear all fields
  this->interactionId = 0;
  this->interactionName = apache::thrift::StringTraits<::apache::thrift::ManagedStringViewWithConversions>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool InteractionCreate::operator==(const InteractionCreate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return false;
  }
  if (!(lhs.interactionName == rhs.interactionName)) {
    return false;
  }
  return true;
}

bool InteractionCreate::operator<(const InteractionCreate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return lhs.interactionId < rhs.interactionId;
  }
  if (!(lhs.interactionName == rhs.interactionName)) {
    return lhs.interactionName < rhs.interactionName;
  }
  return false;
}


void swap(InteractionCreate& a, InteractionCreate& b) {
  using ::std::swap;
  swap(a.interactionId_ref().value(), b.interactionId_ref().value());
  swap(a.interactionName_ref().value(), b.interactionName_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void InteractionCreate::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t InteractionCreate::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t InteractionCreate::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t InteractionCreate::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void InteractionCreate::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t InteractionCreate::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t InteractionCreate::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t InteractionCreate::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void InteractionCreate::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t InteractionCreate::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t InteractionCreate::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t InteractionCreate::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::InteractionTerminate>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::InteractionTerminate>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
InteractionTerminate::InteractionTerminate(apache::thrift::FragileConstructor, ::std::int64_t interactionId__arg) :
    interactionId(std::move(interactionId__arg)) {
  __isset.interactionId = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void InteractionTerminate::__clear() {
  // clear all fields
  this->interactionId = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool InteractionTerminate::operator==(const InteractionTerminate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return false;
  }
  return true;
}

bool InteractionTerminate::operator<(const InteractionTerminate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return lhs.interactionId < rhs.interactionId;
  }
  return false;
}


void swap(InteractionTerminate& a, InteractionTerminate& b) {
  using ::std::swap;
  swap(a.interactionId_ref().value(), b.interactionId_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void InteractionTerminate::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t InteractionTerminate::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t InteractionTerminate::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t InteractionTerminate::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void InteractionTerminate::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t InteractionTerminate::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t InteractionTerminate::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t InteractionTerminate::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void InteractionTerminate::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t InteractionTerminate::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t InteractionTerminate::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t InteractionTerminate::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::RequestRpcMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::RequestRpcMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestRpcMetadata::RequestRpcMetadata(const RequestRpcMetadata&) = default;
RequestRpcMetadata& RequestRpcMetadata::operator=(const RequestRpcMetadata&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestRpcMetadata::RequestRpcMetadata() :
      protocol( ::apache::thrift::ProtocolId::BINARY),
      kind( ::apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE),
      seqId(0),
      clientTimeoutMs(0),
      queueTimeoutMs(0),
      priority( ::apache::thrift::RpcPriority::HIGH_IMPORTANT),
      crc32c(0),
      compression( ::apache::thrift::CompressionAlgorithm::NONE),
      interactionId(0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

RequestRpcMetadata::~RequestRpcMetadata() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestRpcMetadata::RequestRpcMetadata(RequestRpcMetadata&& other) noexcept  :
    protocol(std::move(other.protocol)),
    name(std::move(other.name)),
    kind(std::move(other.kind)),
    seqId(std::move(other.seqId)),
    clientTimeoutMs(std::move(other.clientTimeoutMs)),
    queueTimeoutMs(std::move(other.queueTimeoutMs)),
    priority(std::move(other.priority)),
    otherMetadata(std::move(other.otherMetadata)),
    crc32c(std::move(other.crc32c)),
    loadMetric(std::move(other.loadMetric)),
    compression(std::move(other.compression)),
    compressionConfig(std::move(other.compressionConfig)),
    interactionId(std::move(other.interactionId)),
    interactionCreate(std::move(other.interactionCreate)),
    clientId(std::move(other.clientId)),
    serviceTraceMeta(std::move(other.serviceTraceMeta)),
    __isset(other.__isset) {}
RequestRpcMetadata& RequestRpcMetadata::operator=(FOLLY_MAYBE_UNUSED RequestRpcMetadata&& other) noexcept {
    this->protocol = std::move(other.protocol);
    this->name = std::move(other.name);
    this->kind = std::move(other.kind);
    this->seqId = std::move(other.seqId);
    this->clientTimeoutMs = std::move(other.clientTimeoutMs);
    this->queueTimeoutMs = std::move(other.queueTimeoutMs);
    this->priority = std::move(other.priority);
    this->otherMetadata = std::move(other.otherMetadata);
    this->crc32c = std::move(other.crc32c);
    this->loadMetric = std::move(other.loadMetric);
    this->compression = std::move(other.compression);
    this->compressionConfig = std::move(other.compressionConfig);
    this->interactionId = std::move(other.interactionId);
    this->interactionCreate = std::move(other.interactionCreate);
    this->clientId = std::move(other.clientId);
    this->serviceTraceMeta = std::move(other.serviceTraceMeta);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestRpcMetadata::RequestRpcMetadata(apache::thrift::FragileConstructor, ::apache::thrift::ProtocolId protocol__arg, ::apache::thrift::ManagedStringViewField name__arg, ::apache::thrift::RpcKind kind__arg, ::std::int32_t seqId__arg, ::std::int32_t clientTimeoutMs__arg, ::std::int32_t queueTimeoutMs__arg, ::apache::thrift::RpcPriority priority__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, std::uint32_t crc32c__arg, ::std::string loadMetric__arg, ::apache::thrift::CompressionAlgorithm compression__arg, ::apache::thrift::CompressionConfig compressionConfig__arg, ::std::int64_t interactionId__arg, ::apache::thrift::InteractionCreate interactionCreate__arg, ::std::string clientId__arg, ::std::string serviceTraceMeta__arg) :
    protocol(std::move(protocol__arg)),
    name(std::move(name__arg)),
    kind(std::move(kind__arg)),
    seqId(std::move(seqId__arg)),
    clientTimeoutMs(std::move(clientTimeoutMs__arg)),
    queueTimeoutMs(std::move(queueTimeoutMs__arg)),
    priority(std::move(priority__arg)),
    otherMetadata(std::move(otherMetadata__arg)),
    crc32c(std::move(crc32c__arg)),
    loadMetric(std::move(loadMetric__arg)),
    compression(std::move(compression__arg)),
    compressionConfig(std::move(compressionConfig__arg)),
    interactionId(std::move(interactionId__arg)),
    interactionCreate(std::move(interactionCreate__arg)),
    clientId(std::move(clientId__arg)),
    serviceTraceMeta(std::move(serviceTraceMeta__arg)) {
  __isset.protocol = true;
  __isset.name = true;
  __isset.kind = true;
  __isset.seqId = true;
  __isset.clientTimeoutMs = true;
  __isset.queueTimeoutMs = true;
  __isset.priority = true;
  __isset.otherMetadata = true;
  __isset.crc32c = true;
  __isset.loadMetric = true;
  __isset.compression = true;
  __isset.compressionConfig = true;
  __isset.interactionId = true;
  __isset.interactionCreate = true;
  __isset.clientId = true;
  __isset.serviceTraceMeta = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void RequestRpcMetadata::__clear() {
  // clear all fields
  this->protocol =  ::apache::thrift::ProtocolId::BINARY;
  this->name = apache::thrift::StringTraits<::apache::thrift::ManagedStringViewWithConversions>::fromStringLiteral("");
  this->kind =  ::apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE;
  this->seqId = 0;
  this->clientTimeoutMs = 0;
  this->queueTimeoutMs = 0;
  this->priority =  ::apache::thrift::RpcPriority::HIGH_IMPORTANT;
  this->otherMetadata.clear();
  this->crc32c = 0;
  this->loadMetric = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  this->compressionConfig.__clear();
  this->interactionId = 0;
  this->interactionCreate.__clear();
  this->clientId = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->serviceTraceMeta = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RequestRpcMetadata::operator==(const RequestRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return false;
  }
  if (lhs.name_ref() != rhs.name_ref()) {
    return false;
  }
  if (lhs.kind_ref() != rhs.kind_ref()) {
    return false;
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return false;
  }
  if (lhs.clientTimeoutMs_ref() != rhs.clientTimeoutMs_ref()) {
    return false;
  }
  if (lhs.queueTimeoutMs_ref() != rhs.queueTimeoutMs_ref()) {
    return false;
  }
  if (lhs.priority_ref() != rhs.priority_ref()) {
    return false;
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return false;
  }
  if (lhs.loadMetric_ref() != rhs.loadMetric_ref()) {
    return false;
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  if (lhs.compressionConfig_ref() != rhs.compressionConfig_ref()) {
    return false;
  }
  if (lhs.interactionId_ref() != rhs.interactionId_ref()) {
    return false;
  }
  if (lhs.interactionCreate_ref() != rhs.interactionCreate_ref()) {
    return false;
  }
  if (lhs.clientId_ref() != rhs.clientId_ref()) {
    return false;
  }
  if (lhs.serviceTraceMeta_ref() != rhs.serviceTraceMeta_ref()) {
    return false;
  }
  return true;
}

bool RequestRpcMetadata::operator<(const RequestRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return lhs.protocol_ref() < rhs.protocol_ref();
  }
  if (lhs.name_ref() != rhs.name_ref()) {
    return lhs.name_ref() < rhs.name_ref();
  }
  if (lhs.kind_ref() != rhs.kind_ref()) {
    return lhs.kind_ref() < rhs.kind_ref();
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return lhs.seqId_ref() < rhs.seqId_ref();
  }
  if (lhs.clientTimeoutMs_ref() != rhs.clientTimeoutMs_ref()) {
    return lhs.clientTimeoutMs_ref() < rhs.clientTimeoutMs_ref();
  }
  if (lhs.queueTimeoutMs_ref() != rhs.queueTimeoutMs_ref()) {
    return lhs.queueTimeoutMs_ref() < rhs.queueTimeoutMs_ref();
  }
  if (lhs.priority_ref() != rhs.priority_ref()) {
    return lhs.priority_ref() < rhs.priority_ref();
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return lhs.crc32c_ref() < rhs.crc32c_ref();
  }
  if (lhs.loadMetric_ref() != rhs.loadMetric_ref()) {
    return lhs.loadMetric_ref() < rhs.loadMetric_ref();
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  if (lhs.compressionConfig_ref() != rhs.compressionConfig_ref()) {
    return lhs.compressionConfig_ref() < rhs.compressionConfig_ref();
  }
  if (lhs.interactionId_ref() != rhs.interactionId_ref()) {
    return lhs.interactionId_ref() < rhs.interactionId_ref();
  }
  if (lhs.interactionCreate_ref() != rhs.interactionCreate_ref()) {
    return lhs.interactionCreate_ref() < rhs.interactionCreate_ref();
  }
  if (lhs.clientId_ref() != rhs.clientId_ref()) {
    return lhs.clientId_ref() < rhs.clientId_ref();
  }
  if (lhs.serviceTraceMeta_ref() != rhs.serviceTraceMeta_ref()) {
    return lhs.serviceTraceMeta_ref() < rhs.serviceTraceMeta_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* RequestRpcMetadata::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* RequestRpcMetadata::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

const ::apache::thrift::CompressionConfig* RequestRpcMetadata::get_compressionConfig() const& {
  return compressionConfig_ref().has_value() ? std::addressof(compressionConfig) : nullptr;
}

::apache::thrift::CompressionConfig* RequestRpcMetadata::get_compressionConfig() & {
  return compressionConfig_ref().has_value() ? std::addressof(compressionConfig) : nullptr;
}

const ::apache::thrift::InteractionCreate* RequestRpcMetadata::get_interactionCreate() const& {
  return interactionCreate_ref().has_value() ? std::addressof(interactionCreate) : nullptr;
}

::apache::thrift::InteractionCreate* RequestRpcMetadata::get_interactionCreate() & {
  return interactionCreate_ref().has_value() ? std::addressof(interactionCreate) : nullptr;
}


void swap(RequestRpcMetadata& a, RequestRpcMetadata& b) {
  using ::std::swap;
  swap(a.protocol_ref().value_unchecked(), b.protocol_ref().value_unchecked());
  swap(a.name_ref().value_unchecked(), b.name_ref().value_unchecked());
  swap(a.kind_ref().value_unchecked(), b.kind_ref().value_unchecked());
  swap(a.seqId_ref().value_unchecked(), b.seqId_ref().value_unchecked());
  swap(a.clientTimeoutMs_ref().value_unchecked(), b.clientTimeoutMs_ref().value_unchecked());
  swap(a.queueTimeoutMs_ref().value_unchecked(), b.queueTimeoutMs_ref().value_unchecked());
  swap(a.priority_ref().value_unchecked(), b.priority_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.crc32c_ref().value_unchecked(), b.crc32c_ref().value_unchecked());
  swap(a.loadMetric_ref().value_unchecked(), b.loadMetric_ref().value_unchecked());
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.compressionConfig_ref().value_unchecked(), b.compressionConfig_ref().value_unchecked());
  swap(a.interactionId_ref().value_unchecked(), b.interactionId_ref().value_unchecked());
  swap(a.interactionCreate_ref().value_unchecked(), b.interactionCreate_ref().value_unchecked());
  swap(a.clientId_ref().value_unchecked(), b.clientId_ref().value_unchecked());
  swap(a.serviceTraceMeta_ref().value_unchecked(), b.serviceTraceMeta_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RequestRpcMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RequestRpcMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RequestRpcMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RequestRpcMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RequestRpcMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RequestRpcMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RequestRpcMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RequestRpcMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void RequestRpcMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t RequestRpcMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t RequestRpcMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t RequestRpcMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::CompressionConfig>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::InteractionCreate>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::CompressionConfig>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::InteractionCreate>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ErrorClassification>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ErrorClassification>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ErrorClassification::ErrorClassification(apache::thrift::FragileConstructor, ::apache::thrift::ErrorKind kind__arg, ::apache::thrift::ErrorBlame blame__arg, ::apache::thrift::ErrorSafety safety__arg) :
    kind(std::move(kind__arg)),
    blame(std::move(blame__arg)),
    safety(std::move(safety__arg)) {
  __isset.kind = true;
  __isset.blame = true;
  __isset.safety = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void ErrorClassification::__clear() {
  // clear all fields
  this->kind =  ::apache::thrift::ErrorKind::UNSPECIFIED;
  this->blame =  ::apache::thrift::ErrorBlame::UNSPECIFIED;
  this->safety =  ::apache::thrift::ErrorSafety::UNSPECIFIED;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ErrorClassification::operator==(const ErrorClassification& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.kind_ref() != rhs.kind_ref()) {
    return false;
  }
  if (lhs.blame_ref() != rhs.blame_ref()) {
    return false;
  }
  if (lhs.safety_ref() != rhs.safety_ref()) {
    return false;
  }
  return true;
}

bool ErrorClassification::operator<(const ErrorClassification& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.kind_ref() != rhs.kind_ref()) {
    return lhs.kind_ref() < rhs.kind_ref();
  }
  if (lhs.blame_ref() != rhs.blame_ref()) {
    return lhs.blame_ref() < rhs.blame_ref();
  }
  if (lhs.safety_ref() != rhs.safety_ref()) {
    return lhs.safety_ref() < rhs.safety_ref();
  }
  return false;
}


void swap(ErrorClassification& a, ErrorClassification& b) {
  using ::std::swap;
  swap(a.kind_ref().value_unchecked(), b.kind_ref().value_unchecked());
  swap(a.blame_ref().value_unchecked(), b.blame_ref().value_unchecked());
  swap(a.safety_ref().value_unchecked(), b.safety_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ErrorClassification::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ErrorClassification::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ErrorClassification::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ErrorClassification::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ErrorClassification::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ErrorClassification::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ErrorClassification::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ErrorClassification::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ErrorClassification::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ErrorClassification::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ErrorClassification::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ErrorClassification::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadResponseMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadResponseMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadResponseMetadata::PayloadResponseMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadResponseMetadata::__clear() {
  // clear all fields
}

bool PayloadResponseMetadata::operator==(const PayloadResponseMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadResponseMetadata::operator<(const PayloadResponseMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadResponseMetadata& a, PayloadResponseMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadResponseMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadResponseMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadResponseMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadResponseMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadResponseMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadResponseMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadResponseMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadResponseMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadResponseMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadResponseMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadResponseMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadResponseMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadDeclaredExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadDeclaredExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadDeclaredExceptionMetadata::PayloadDeclaredExceptionMetadata(apache::thrift::FragileConstructor, ::apache::thrift::ErrorClassification errorClassification__arg) :
    errorClassification(std::move(errorClassification__arg)) {
  __isset.errorClassification = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadDeclaredExceptionMetadata::__clear() {
  // clear all fields
  this->errorClassification.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PayloadDeclaredExceptionMetadata::operator==(const PayloadDeclaredExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.errorClassification_ref() != rhs.errorClassification_ref()) {
    return false;
  }
  return true;
}

bool PayloadDeclaredExceptionMetadata::operator<(const PayloadDeclaredExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.errorClassification_ref() != rhs.errorClassification_ref()) {
    return lhs.errorClassification_ref() < rhs.errorClassification_ref();
  }
  return false;
}

const ::apache::thrift::ErrorClassification* PayloadDeclaredExceptionMetadata::get_errorClassification() const& {
  return errorClassification_ref().has_value() ? std::addressof(errorClassification) : nullptr;
}

::apache::thrift::ErrorClassification* PayloadDeclaredExceptionMetadata::get_errorClassification() & {
  return errorClassification_ref().has_value() ? std::addressof(errorClassification) : nullptr;
}


void swap(PayloadDeclaredExceptionMetadata& a, PayloadDeclaredExceptionMetadata& b) {
  using ::std::swap;
  swap(a.errorClassification_ref().value_unchecked(), b.errorClassification_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PayloadDeclaredExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadDeclaredExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadDeclaredExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadDeclaredExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadDeclaredExceptionMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadDeclaredExceptionMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadDeclaredExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ErrorClassification>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadDeclaredExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ErrorClassification>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadProxyExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadProxyExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadProxyExceptionMetadata::PayloadProxyExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadProxyExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadProxyExceptionMetadata::operator==(const PayloadProxyExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadProxyExceptionMetadata::operator<(const PayloadProxyExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadProxyExceptionMetadata& a, PayloadProxyExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadProxyExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadProxyExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadProxyExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadProxyExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadProxyExceptionMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadProxyExceptionMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadProxiedExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadProxiedExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadProxiedExceptionMetadata::PayloadProxiedExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadProxiedExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadProxiedExceptionMetadata::operator==(const PayloadProxiedExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadProxiedExceptionMetadata::operator<(const PayloadProxiedExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadProxiedExceptionMetadata& a, PayloadProxiedExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadProxiedExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadProxiedExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadProxiedExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadProxiedExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadProxiedExceptionMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadProxiedExceptionMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadAppClientExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadAppClientExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadAppClientExceptionMetadata::PayloadAppClientExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadAppClientExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadAppClientExceptionMetadata::operator==(const PayloadAppClientExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadAppClientExceptionMetadata::operator<(const PayloadAppClientExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadAppClientExceptionMetadata& a, PayloadAppClientExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadAppClientExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadAppClientExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadAppClientExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadAppClientExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadAppClientExceptionMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadAppClientExceptionMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadAppServerExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadAppServerExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadAppServerExceptionMetadata::PayloadAppServerExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadAppServerExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadAppServerExceptionMetadata::operator==(const PayloadAppServerExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadAppServerExceptionMetadata::operator<(const PayloadAppServerExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadAppServerExceptionMetadata& a, PayloadAppServerExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadAppServerExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadAppServerExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadAppServerExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadAppServerExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadAppServerExceptionMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadAppServerExceptionMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadAppUnknownExceptionMetdata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadAppUnknownExceptionMetdata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadAppUnknownExceptionMetdata::PayloadAppUnknownExceptionMetdata(apache::thrift::FragileConstructor, ::apache::thrift::ErrorClassification errorClassification__arg) :
    errorClassification(std::move(errorClassification__arg)) {
  __isset.errorClassification = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadAppUnknownExceptionMetdata::__clear() {
  // clear all fields
  this->errorClassification.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PayloadAppUnknownExceptionMetdata::operator==(const PayloadAppUnknownExceptionMetdata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.errorClassification_ref() != rhs.errorClassification_ref()) {
    return false;
  }
  return true;
}

bool PayloadAppUnknownExceptionMetdata::operator<(const PayloadAppUnknownExceptionMetdata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.errorClassification_ref() != rhs.errorClassification_ref()) {
    return lhs.errorClassification_ref() < rhs.errorClassification_ref();
  }
  return false;
}

const ::apache::thrift::ErrorClassification* PayloadAppUnknownExceptionMetdata::get_errorClassification() const& {
  return errorClassification_ref().has_value() ? std::addressof(errorClassification) : nullptr;
}

::apache::thrift::ErrorClassification* PayloadAppUnknownExceptionMetdata::get_errorClassification() & {
  return errorClassification_ref().has_value() ? std::addressof(errorClassification) : nullptr;
}


void swap(PayloadAppUnknownExceptionMetdata& a, PayloadAppUnknownExceptionMetdata& b) {
  using ::std::swap;
  swap(a.errorClassification_ref().value_unchecked(), b.errorClassification_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PayloadAppUnknownExceptionMetdata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadAppUnknownExceptionMetdata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadAppUnknownExceptionMetdata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadAppUnknownExceptionMetdata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadAppUnknownExceptionMetdata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadAppUnknownExceptionMetdata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadAppUnknownExceptionMetdata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadAppUnknownExceptionMetdata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadAppUnknownExceptionMetdata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadAppUnknownExceptionMetdata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadAppUnknownExceptionMetdata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadAppUnknownExceptionMetdata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadAppUnknownExceptionMetdata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ErrorClassification>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadAppUnknownExceptionMetdata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ErrorClassification>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::size;
folly::Range<::apache::thrift::PayloadExceptionMetadata::Type const*> const TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::PayloadExceptionMetadata::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::PayloadExceptionMetadata::Type>::names);

char const* TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadExceptionMetadata::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadExceptionMetadata::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void PayloadExceptionMetadata::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::declaredException:
      destruct(value_.declaredException);
      break;
    case Type::proxyException:
      destruct(value_.proxyException);
      break;
    case Type::DEPRECATED_proxiedException:
      destruct(value_.DEPRECATED_proxiedException);
      break;
    case Type::DEPRECATED_appClientException:
      destruct(value_.DEPRECATED_appClientException);
      break;
    case Type::DEPRECATED_appServerException:
      destruct(value_.DEPRECATED_appServerException);
      break;
    case Type::appUnknownException:
      destruct(value_.appUnknownException);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool PayloadExceptionMetadata::operator==(const PayloadExceptionMetadata& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::declaredException:
      return value_.declaredException == rhs.value_.declaredException;
    case Type::proxyException:
      return value_.proxyException == rhs.value_.proxyException;
    case Type::DEPRECATED_proxiedException:
      return value_.DEPRECATED_proxiedException == rhs.value_.DEPRECATED_proxiedException;
    case Type::DEPRECATED_appClientException:
      return value_.DEPRECATED_appClientException == rhs.value_.DEPRECATED_appClientException;
    case Type::DEPRECATED_appServerException:
      return value_.DEPRECATED_appServerException == rhs.value_.DEPRECATED_appServerException;
    case Type::appUnknownException:
      return value_.appUnknownException == rhs.value_.appUnknownException;
    default:
      return true;
  }
}

bool PayloadExceptionMetadata::operator<(const PayloadExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::declaredException:
      return lhs.value_.declaredException < rhs.value_.declaredException;
    case Type::proxyException:
      return lhs.value_.proxyException < rhs.value_.proxyException;
    case Type::DEPRECATED_proxiedException:
      return lhs.value_.DEPRECATED_proxiedException < rhs.value_.DEPRECATED_proxiedException;
    case Type::DEPRECATED_appClientException:
      return lhs.value_.DEPRECATED_appClientException < rhs.value_.DEPRECATED_appClientException;
    case Type::DEPRECATED_appServerException:
      return lhs.value_.DEPRECATED_appServerException < rhs.value_.DEPRECATED_appServerException;
    case Type::appUnknownException:
      return lhs.value_.appUnknownException < rhs.value_.appUnknownException;
    default:
      return false;
  }
}

void swap(PayloadExceptionMetadata& a, PayloadExceptionMetadata& b) {
  PayloadExceptionMetadata temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void PayloadExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadExceptionMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadExceptionMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadExceptionMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadDeclaredExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadProxyExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadProxiedExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadAppClientExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadAppServerExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadAppUnknownExceptionMetdata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadDeclaredExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadProxyExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadProxiedExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadAppClientExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadAppServerExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadAppUnknownExceptionMetdata>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadExceptionMetadataBase>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadExceptionMetadataBase>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadExceptionMetadataBase::PayloadExceptionMetadataBase(const PayloadExceptionMetadataBase&) = default;
PayloadExceptionMetadataBase& PayloadExceptionMetadataBase::operator=(const PayloadExceptionMetadataBase&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadExceptionMetadataBase::PayloadExceptionMetadataBase(PayloadExceptionMetadataBase&& other) noexcept  :
    name_utf8(std::move(other.name_utf8)),
    what_utf8(std::move(other.what_utf8)),
    metadata(std::move(other.metadata)),
    __isset(other.__isset) {}
PayloadExceptionMetadataBase& PayloadExceptionMetadataBase::operator=(FOLLY_MAYBE_UNUSED PayloadExceptionMetadataBase&& other) noexcept {
    this->name_utf8 = std::move(other.name_utf8);
    this->what_utf8 = std::move(other.what_utf8);
    this->metadata = std::move(other.metadata);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadExceptionMetadataBase::PayloadExceptionMetadataBase(apache::thrift::FragileConstructor, ::std::string name_utf8__arg, ::std::string what_utf8__arg, ::apache::thrift::PayloadExceptionMetadata metadata__arg) :
    name_utf8(std::move(name_utf8__arg)),
    what_utf8(std::move(what_utf8__arg)),
    metadata(std::move(metadata__arg)) {
  __isset.name_utf8 = true;
  __isset.what_utf8 = true;
  __isset.metadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void PayloadExceptionMetadataBase::__clear() {
  // clear all fields
  this->name_utf8 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->what_utf8 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->metadata.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PayloadExceptionMetadataBase::operator==(const PayloadExceptionMetadataBase& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return false;
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return false;
  }
  if (lhs.metadata_ref() != rhs.metadata_ref()) {
    return false;
  }
  return true;
}

bool PayloadExceptionMetadataBase::operator<(const PayloadExceptionMetadataBase& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return lhs.name_utf8_ref() < rhs.name_utf8_ref();
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return lhs.what_utf8_ref() < rhs.what_utf8_ref();
  }
  if (lhs.metadata_ref() != rhs.metadata_ref()) {
    return lhs.metadata_ref() < rhs.metadata_ref();
  }
  return false;
}

const ::apache::thrift::PayloadExceptionMetadata* PayloadExceptionMetadataBase::get_metadata() const& {
  return metadata_ref().has_value() ? std::addressof(metadata) : nullptr;
}

::apache::thrift::PayloadExceptionMetadata* PayloadExceptionMetadataBase::get_metadata() & {
  return metadata_ref().has_value() ? std::addressof(metadata) : nullptr;
}


void swap(PayloadExceptionMetadataBase& a, PayloadExceptionMetadataBase& b) {
  using ::std::swap;
  swap(a.name_utf8_ref().value_unchecked(), b.name_utf8_ref().value_unchecked());
  swap(a.what_utf8_ref().value_unchecked(), b.what_utf8_ref().value_unchecked());
  swap(a.metadata_ref().value_unchecked(), b.metadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PayloadExceptionMetadataBase::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadExceptionMetadataBase::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadExceptionMetadataBase::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadExceptionMetadataBase::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadExceptionMetadataBase::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadExceptionMetadataBase::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadataBase,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::PayloadExceptionMetadata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadataBase,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::PayloadExceptionMetadata>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::PayloadMetadata::Type>::size;
folly::Range<::apache::thrift::PayloadMetadata::Type const*> const TEnumTraits<::apache::thrift::PayloadMetadata::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::PayloadMetadata::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::PayloadMetadata::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::PayloadMetadata::Type>::names);

char const* TEnumTraits<::apache::thrift::PayloadMetadata::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadMetadata::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::PayloadMetadata::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadMetadata::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void PayloadMetadata::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::responseMetadata:
      destruct(value_.responseMetadata);
      break;
    case Type::exceptionMetadata:
      destruct(value_.exceptionMetadata);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool PayloadMetadata::operator==(const PayloadMetadata& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::responseMetadata:
      return value_.responseMetadata == rhs.value_.responseMetadata;
    case Type::exceptionMetadata:
      return value_.exceptionMetadata == rhs.value_.exceptionMetadata;
    default:
      return true;
  }
}

bool PayloadMetadata::operator<(const PayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::responseMetadata:
      return lhs.value_.responseMetadata < rhs.value_.responseMetadata;
    case Type::exceptionMetadata:
      return lhs.value_.exceptionMetadata < rhs.value_.exceptionMetadata;
    default:
      return false;
  }
}

void swap(PayloadMetadata& a, PayloadMetadata& b) {
  PayloadMetadata temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void PayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void PayloadMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t PayloadMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t PayloadMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t PayloadMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadResponseMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadExceptionMetadataBase>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadResponseMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::PayloadExceptionMetadataBase>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ProxiedPayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ProxiedPayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ProxiedPayloadMetadata::ProxiedPayloadMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void ProxiedPayloadMetadata::__clear() {
  // clear all fields
}

bool ProxiedPayloadMetadata::operator==(const ProxiedPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ProxiedPayloadMetadata::operator<(const ProxiedPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ProxiedPayloadMetadata& a, ProxiedPayloadMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ProxiedPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ProxiedPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ProxiedPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ProxiedPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ProxiedPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ProxiedPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ProxiedPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ProxiedPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ProxiedPayloadMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ProxiedPayloadMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ProxiedPayloadMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ProxiedPayloadMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ResponseRpcMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ResponseRpcMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcMetadata::ResponseRpcMetadata(const ResponseRpcMetadata&) = default;
ResponseRpcMetadata& ResponseRpcMetadata::operator=(const ResponseRpcMetadata&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcMetadata::ResponseRpcMetadata() :
      protocol( ::apache::thrift::ProtocolId::BINARY),
      seqId(0),
      load(0),
      crc32c(0),
      compression( ::apache::thrift::CompressionAlgorithm::NONE),
      streamId(0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

ResponseRpcMetadata::~ResponseRpcMetadata() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcMetadata::ResponseRpcMetadata(ResponseRpcMetadata&& other) noexcept  :
    protocol(std::move(other.protocol)),
    seqId(std::move(other.seqId)),
    otherMetadata(std::move(other.otherMetadata)),
    load(std::move(other.load)),
    crc32c(std::move(other.crc32c)),
    compression(std::move(other.compression)),
    payloadMetadata(std::move(other.payloadMetadata)),
    proxiedPayloadMetadata(std::move(other.proxiedPayloadMetadata)),
    streamId(std::move(other.streamId)),
    __isset(other.__isset) {}
ResponseRpcMetadata& ResponseRpcMetadata::operator=(FOLLY_MAYBE_UNUSED ResponseRpcMetadata&& other) noexcept {
    this->protocol = std::move(other.protocol);
    this->seqId = std::move(other.seqId);
    this->otherMetadata = std::move(other.otherMetadata);
    this->load = std::move(other.load);
    this->crc32c = std::move(other.crc32c);
    this->compression = std::move(other.compression);
    this->payloadMetadata = std::move(other.payloadMetadata);
    this->proxiedPayloadMetadata = std::move(other.proxiedPayloadMetadata);
    this->streamId = std::move(other.streamId);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcMetadata::ResponseRpcMetadata(apache::thrift::FragileConstructor, ::apache::thrift::ProtocolId protocol__arg, ::std::int32_t seqId__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, ::std::int64_t load__arg, std::uint32_t crc32c__arg, ::apache::thrift::CompressionAlgorithm compression__arg, ::apache::thrift::PayloadMetadata payloadMetadata__arg, ::apache::thrift::ProxiedPayloadMetadata proxiedPayloadMetadata__arg, ::std::int32_t streamId__arg) :
    protocol(std::move(protocol__arg)),
    seqId(std::move(seqId__arg)),
    otherMetadata(std::move(otherMetadata__arg)),
    load(std::move(load__arg)),
    crc32c(std::move(crc32c__arg)),
    compression(std::move(compression__arg)),
    payloadMetadata(std::move(payloadMetadata__arg)),
    proxiedPayloadMetadata(std::move(proxiedPayloadMetadata__arg)),
    streamId(std::move(streamId__arg)) {
  __isset.protocol = true;
  __isset.seqId = true;
  __isset.otherMetadata = true;
  __isset.load = true;
  __isset.crc32c = true;
  __isset.compression = true;
  __isset.payloadMetadata = true;
  __isset.proxiedPayloadMetadata = true;
  __isset.streamId = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void ResponseRpcMetadata::__clear() {
  // clear all fields
  this->protocol =  ::apache::thrift::ProtocolId::BINARY;
  this->seqId = 0;
  this->otherMetadata.clear();
  this->load = 0;
  this->crc32c = 0;
  this->compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  this->payloadMetadata.__clear();
  this->streamId = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ResponseRpcMetadata::operator==(const ResponseRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return false;
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return false;
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return false;
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return false;
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  if (lhs.payloadMetadata_ref() != rhs.payloadMetadata_ref()) {
    return false;
  }
  if (lhs.proxiedPayloadMetadata_ref() != rhs.proxiedPayloadMetadata_ref()) {
    return false;
  }
  if (lhs.streamId_ref() != rhs.streamId_ref()) {
    return false;
  }
  return true;
}

bool ResponseRpcMetadata::operator<(const ResponseRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return lhs.protocol_ref() < rhs.protocol_ref();
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return lhs.seqId_ref() < rhs.seqId_ref();
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return lhs.load_ref() < rhs.load_ref();
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return lhs.crc32c_ref() < rhs.crc32c_ref();
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  if (lhs.payloadMetadata_ref() != rhs.payloadMetadata_ref()) {
    return lhs.payloadMetadata_ref() < rhs.payloadMetadata_ref();
  }
  if (lhs.proxiedPayloadMetadata_ref() != rhs.proxiedPayloadMetadata_ref()) {
    return lhs.proxiedPayloadMetadata_ref() < rhs.proxiedPayloadMetadata_ref();
  }
  if (lhs.streamId_ref() != rhs.streamId_ref()) {
    return lhs.streamId_ref() < rhs.streamId_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* ResponseRpcMetadata::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* ResponseRpcMetadata::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

const ::apache::thrift::PayloadMetadata* ResponseRpcMetadata::get_payloadMetadata() const& {
  return payloadMetadata_ref().has_value() ? std::addressof(payloadMetadata) : nullptr;
}

::apache::thrift::PayloadMetadata* ResponseRpcMetadata::get_payloadMetadata() & {
  return payloadMetadata_ref().has_value() ? std::addressof(payloadMetadata) : nullptr;
}

const ::apache::thrift::ProxiedPayloadMetadata* ResponseRpcMetadata::get_proxiedPayloadMetadata() const& {
  return proxiedPayloadMetadata_ref().has_value() ? std::addressof(proxiedPayloadMetadata) : nullptr;
}

::apache::thrift::ProxiedPayloadMetadata* ResponseRpcMetadata::get_proxiedPayloadMetadata() & {
  return proxiedPayloadMetadata_ref().has_value() ? std::addressof(proxiedPayloadMetadata) : nullptr;
}


void swap(ResponseRpcMetadata& a, ResponseRpcMetadata& b) {
  using ::std::swap;
  swap(a.protocol_ref().value_unchecked(), b.protocol_ref().value_unchecked());
  swap(a.seqId_ref().value_unchecked(), b.seqId_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.load_ref().value_unchecked(), b.load_ref().value_unchecked());
  swap(a.crc32c_ref().value_unchecked(), b.crc32c_ref().value_unchecked());
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.payloadMetadata_ref().value_unchecked(), b.payloadMetadata_ref().value_unchecked());
  swap(a.proxiedPayloadMetadata_ref().value_unchecked(), b.proxiedPayloadMetadata_ref().value_unchecked());
  swap(a.streamId_ref().value_unchecked(), b.streamId_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ResponseRpcMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ResponseRpcMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ResponseRpcMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ResponseRpcMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ResponseRpcMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ResponseRpcMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ResponseRpcMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ResponseRpcMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ResponseRpcMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ResponseRpcMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ResponseRpcMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ResponseRpcMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::PayloadMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ProxiedPayloadMetadata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::PayloadMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ProxiedPayloadMetadata>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ResponseRpcError>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ResponseRpcError>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcError::ResponseRpcError(const ResponseRpcError&) = default;
ResponseRpcError& ResponseRpcError::operator=(const ResponseRpcError&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcError::ResponseRpcError() :
      category( ::apache::thrift::ResponseRpcErrorCategory::INTERNAL_ERROR),
      code( ::apache::thrift::ResponseRpcErrorCode::UNKNOWN),
      load(0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

ResponseRpcError::~ResponseRpcError() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcError::ResponseRpcError(ResponseRpcError&& other) noexcept  :
    name_utf8(std::move(other.name_utf8)),
    what_utf8(std::move(other.what_utf8)),
    category(std::move(other.category)),
    code(std::move(other.code)),
    load(std::move(other.load)),
    __isset(other.__isset) {}
ResponseRpcError& ResponseRpcError::operator=(FOLLY_MAYBE_UNUSED ResponseRpcError&& other) noexcept {
    this->name_utf8 = std::move(other.name_utf8);
    this->what_utf8 = std::move(other.what_utf8);
    this->category = std::move(other.category);
    this->code = std::move(other.code);
    this->load = std::move(other.load);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcError::ResponseRpcError(apache::thrift::FragileConstructor, ::std::string name_utf8__arg, ::std::string what_utf8__arg, ::apache::thrift::ResponseRpcErrorCategory category__arg, ::apache::thrift::ResponseRpcErrorCode code__arg, ::std::int64_t load__arg) :
    name_utf8(std::move(name_utf8__arg)),
    what_utf8(std::move(what_utf8__arg)),
    category(std::move(category__arg)),
    code(std::move(code__arg)),
    load(std::move(load__arg)) {
  __isset.name_utf8 = true;
  __isset.what_utf8 = true;
  __isset.category = true;
  __isset.code = true;
  __isset.load = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void ResponseRpcError::__clear() {
  // clear all fields
  this->name_utf8 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->what_utf8 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->category =  ::apache::thrift::ResponseRpcErrorCategory::INTERNAL_ERROR;
  this->code =  ::apache::thrift::ResponseRpcErrorCode::UNKNOWN;
  this->load = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ResponseRpcError::operator==(const ResponseRpcError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return false;
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return false;
  }
  if (lhs.category_ref() != rhs.category_ref()) {
    return false;
  }
  if (lhs.code_ref() != rhs.code_ref()) {
    return false;
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return false;
  }
  return true;
}

bool ResponseRpcError::operator<(const ResponseRpcError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return lhs.name_utf8_ref() < rhs.name_utf8_ref();
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return lhs.what_utf8_ref() < rhs.what_utf8_ref();
  }
  if (lhs.category_ref() != rhs.category_ref()) {
    return lhs.category_ref() < rhs.category_ref();
  }
  if (lhs.code_ref() != rhs.code_ref()) {
    return lhs.code_ref() < rhs.code_ref();
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return lhs.load_ref() < rhs.load_ref();
  }
  return false;
}


void swap(ResponseRpcError& a, ResponseRpcError& b) {
  using ::std::swap;
  swap(a.name_utf8_ref().value_unchecked(), b.name_utf8_ref().value_unchecked());
  swap(a.what_utf8_ref().value_unchecked(), b.what_utf8_ref().value_unchecked());
  swap(a.category_ref().value_unchecked(), b.category_ref().value_unchecked());
  swap(a.code_ref().value_unchecked(), b.code_ref().value_unchecked());
  swap(a.load_ref().value_unchecked(), b.load_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ResponseRpcError::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ResponseRpcError::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ResponseRpcError::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ResponseRpcError::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ResponseRpcError::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ResponseRpcError::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ResponseRpcError::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ResponseRpcError::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ResponseRpcError::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ResponseRpcError::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ResponseRpcError::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ResponseRpcError::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::StreamRpcError>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::StreamRpcError>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamRpcError::StreamRpcError(const StreamRpcError&) = default;
StreamRpcError& StreamRpcError::operator=(const StreamRpcError&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamRpcError::StreamRpcError(StreamRpcError&& other) noexcept  :
    name_utf8(std::move(other.name_utf8)),
    what_utf8(std::move(other.what_utf8)),
    code(std::move(other.code)),
    __isset(other.__isset) {}
StreamRpcError& StreamRpcError::operator=(FOLLY_MAYBE_UNUSED StreamRpcError&& other) noexcept {
    this->name_utf8 = std::move(other.name_utf8);
    this->what_utf8 = std::move(other.what_utf8);
    this->code = std::move(other.code);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamRpcError::StreamRpcError(apache::thrift::FragileConstructor, ::std::string name_utf8__arg, ::std::string what_utf8__arg, ::apache::thrift::StreamRpcErrorCode code__arg) :
    name_utf8(std::move(name_utf8__arg)),
    what_utf8(std::move(what_utf8__arg)),
    code(std::move(code__arg)) {
  __isset.name_utf8 = true;
  __isset.what_utf8 = true;
  __isset.code = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void StreamRpcError::__clear() {
  // clear all fields
  this->name_utf8 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->what_utf8 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->code =  ::apache::thrift::StreamRpcErrorCode::UNKNOWN;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StreamRpcError::operator==(const StreamRpcError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return false;
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return false;
  }
  if (lhs.code_ref() != rhs.code_ref()) {
    return false;
  }
  return true;
}

bool StreamRpcError::operator<(const StreamRpcError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return lhs.name_utf8_ref() < rhs.name_utf8_ref();
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return lhs.what_utf8_ref() < rhs.what_utf8_ref();
  }
  if (lhs.code_ref() != rhs.code_ref()) {
    return lhs.code_ref() < rhs.code_ref();
  }
  return false;
}


void swap(StreamRpcError& a, StreamRpcError& b) {
  using ::std::swap;
  swap(a.name_utf8_ref().value_unchecked(), b.name_utf8_ref().value_unchecked());
  swap(a.what_utf8_ref().value_unchecked(), b.what_utf8_ref().value_unchecked());
  swap(a.code_ref().value_unchecked(), b.code_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StreamRpcError::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StreamRpcError::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StreamRpcError::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StreamRpcError::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StreamRpcError::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StreamRpcError::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StreamRpcError::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StreamRpcError::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void StreamRpcError::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t StreamRpcError::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t StreamRpcError::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t StreamRpcError::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::StreamPayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::StreamPayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamPayloadMetadata::StreamPayloadMetadata(const StreamPayloadMetadata&) = default;
StreamPayloadMetadata& StreamPayloadMetadata::operator=(const StreamPayloadMetadata&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamPayloadMetadata::StreamPayloadMetadata(StreamPayloadMetadata&& other) noexcept  :
    compression(std::move(other.compression)),
    otherMetadata(std::move(other.otherMetadata)),
    payloadMetadata(std::move(other.payloadMetadata)),
    __isset(other.__isset) {}
StreamPayloadMetadata& StreamPayloadMetadata::operator=(FOLLY_MAYBE_UNUSED StreamPayloadMetadata&& other) noexcept {
    this->compression = std::move(other.compression);
    this->otherMetadata = std::move(other.otherMetadata);
    this->payloadMetadata = std::move(other.payloadMetadata);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamPayloadMetadata::StreamPayloadMetadata(apache::thrift::FragileConstructor, ::apache::thrift::CompressionAlgorithm compression__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, ::apache::thrift::PayloadMetadata payloadMetadata__arg) :
    compression(std::move(compression__arg)),
    otherMetadata(std::move(otherMetadata__arg)),
    payloadMetadata(std::move(payloadMetadata__arg)) {
  __isset.compression = true;
  __isset.otherMetadata = true;
  __isset.payloadMetadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void StreamPayloadMetadata::__clear() {
  // clear all fields
  this->compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  this->otherMetadata.clear();
  this->payloadMetadata.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StreamPayloadMetadata::operator==(const StreamPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  if (lhs.payloadMetadata_ref() != rhs.payloadMetadata_ref()) {
    return false;
  }
  return true;
}

bool StreamPayloadMetadata::operator<(const StreamPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  if (lhs.payloadMetadata_ref() != rhs.payloadMetadata_ref()) {
    return lhs.payloadMetadata_ref() < rhs.payloadMetadata_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* StreamPayloadMetadata::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* StreamPayloadMetadata::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

const ::apache::thrift::PayloadMetadata* StreamPayloadMetadata::get_payloadMetadata() const& {
  return payloadMetadata_ref().has_value() ? std::addressof(payloadMetadata) : nullptr;
}

::apache::thrift::PayloadMetadata* StreamPayloadMetadata::get_payloadMetadata() & {
  return payloadMetadata_ref().has_value() ? std::addressof(payloadMetadata) : nullptr;
}


void swap(StreamPayloadMetadata& a, StreamPayloadMetadata& b) {
  using ::std::swap;
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.payloadMetadata_ref().value_unchecked(), b.payloadMetadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StreamPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StreamPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StreamPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StreamPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StreamPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StreamPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StreamPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StreamPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void StreamPayloadMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t StreamPayloadMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t StreamPayloadMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t StreamPayloadMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StreamPayloadMetadata,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::PayloadMetadata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StreamPayloadMetadata,
        ::apache::thrift::type_class::variant,
        ::apache::thrift::PayloadMetadata>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ClientMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ClientMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ClientMetadata::ClientMetadata(const ClientMetadata&) = default;
ClientMetadata& ClientMetadata::operator=(const ClientMetadata&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ClientMetadata::ClientMetadata(ClientMetadata&& other) noexcept  :
    agent(std::move(other.agent)),
    hostname(std::move(other.hostname)),
    otherMetadata(std::move(other.otherMetadata)),
    __isset(other.__isset) {}
ClientMetadata& ClientMetadata::operator=(FOLLY_MAYBE_UNUSED ClientMetadata&& other) noexcept {
    this->agent = std::move(other.agent);
    this->hostname = std::move(other.hostname);
    this->otherMetadata = std::move(other.otherMetadata);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ClientMetadata::ClientMetadata(apache::thrift::FragileConstructor, ::std::string agent__arg, ::std::string hostname__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg) :
    agent(std::move(agent__arg)),
    hostname(std::move(hostname__arg)),
    otherMetadata(std::move(otherMetadata__arg)) {
  __isset.agent = true;
  __isset.hostname = true;
  __isset.otherMetadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void ClientMetadata::__clear() {
  // clear all fields
  this->agent = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->hostname = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->otherMetadata.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ClientMetadata::operator==(const ClientMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.agent_ref() != rhs.agent_ref()) {
    return false;
  }
  if (lhs.hostname_ref() != rhs.hostname_ref()) {
    return false;
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  return true;
}

bool ClientMetadata::operator<(const ClientMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.agent_ref() != rhs.agent_ref()) {
    return lhs.agent_ref() < rhs.agent_ref();
  }
  if (lhs.hostname_ref() != rhs.hostname_ref()) {
    return lhs.hostname_ref() < rhs.hostname_ref();
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* ClientMetadata::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* ClientMetadata::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}


void swap(ClientMetadata& a, ClientMetadata& b) {
  using ::std::swap;
  swap(a.agent_ref().value_unchecked(), b.agent_ref().value_unchecked());
  swap(a.hostname_ref().value_unchecked(), b.hostname_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ClientMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ClientMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ClientMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ClientMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ClientMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ClientMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ClientMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ClientMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ClientMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ClientMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ClientMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ClientMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::RequestSetupMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::RequestSetupMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestSetupMetadata::RequestSetupMetadata(const RequestSetupMetadata&) = default;
RequestSetupMetadata& RequestSetupMetadata::operator=(const RequestSetupMetadata&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestSetupMetadata::RequestSetupMetadata() :
      interfaceKind( ::apache::thrift::InterfaceKind::USER),
      minVersion(0),
      maxVersion(0),
      dscpToReflect(0),
      markToReflect(0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

RequestSetupMetadata::~RequestSetupMetadata() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestSetupMetadata::RequestSetupMetadata(RequestSetupMetadata&& other) noexcept  :
    opaque(std::move(other.opaque)),
    interfaceKind(std::move(other.interfaceKind)),
    minVersion(std::move(other.minVersion)),
    maxVersion(std::move(other.maxVersion)),
    dscpToReflect(std::move(other.dscpToReflect)),
    markToReflect(std::move(other.markToReflect)),
    clientMetadata(std::move(other.clientMetadata)),
    __isset(other.__isset) {}
RequestSetupMetadata& RequestSetupMetadata::operator=(FOLLY_MAYBE_UNUSED RequestSetupMetadata&& other) noexcept {
    this->opaque = std::move(other.opaque);
    this->interfaceKind = std::move(other.interfaceKind);
    this->minVersion = std::move(other.minVersion);
    this->maxVersion = std::move(other.maxVersion);
    this->dscpToReflect = std::move(other.dscpToReflect);
    this->markToReflect = std::move(other.markToReflect);
    this->clientMetadata = std::move(other.clientMetadata);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestSetupMetadata::RequestSetupMetadata(apache::thrift::FragileConstructor, apache::thrift::MetadataOpaqueMap<::std::string, ::std::string> opaque__arg, ::apache::thrift::InterfaceKind interfaceKind__arg, ::std::int32_t minVersion__arg, ::std::int32_t maxVersion__arg, ::std::int32_t dscpToReflect__arg, ::std::int32_t markToReflect__arg, ::apache::thrift::ClientMetadata clientMetadata__arg) :
    opaque(std::move(opaque__arg)),
    interfaceKind(std::move(interfaceKind__arg)),
    minVersion(std::move(minVersion__arg)),
    maxVersion(std::move(maxVersion__arg)),
    dscpToReflect(std::move(dscpToReflect__arg)),
    markToReflect(std::move(markToReflect__arg)),
    clientMetadata(std::move(clientMetadata__arg)) {
  __isset.opaque = true;
  __isset.interfaceKind = true;
  __isset.minVersion = true;
  __isset.maxVersion = true;
  __isset.dscpToReflect = true;
  __isset.markToReflect = true;
  __isset.clientMetadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void RequestSetupMetadata::__clear() {
  // clear all fields
  this->opaque.clear();
  this->interfaceKind =  ::apache::thrift::InterfaceKind::USER;
  this->minVersion = 0;
  this->maxVersion = 0;
  this->dscpToReflect = 0;
  this->markToReflect = 0;
  this->clientMetadata.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RequestSetupMetadata::operator==(const RequestSetupMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.opaque_ref() != rhs.opaque_ref()) {
    return false;
  }
  if (lhs.interfaceKind_ref() != rhs.interfaceKind_ref()) {
    return false;
  }
  if (lhs.minVersion_ref() != rhs.minVersion_ref()) {
    return false;
  }
  if (lhs.maxVersion_ref() != rhs.maxVersion_ref()) {
    return false;
  }
  if (lhs.dscpToReflect_ref() != rhs.dscpToReflect_ref()) {
    return false;
  }
  if (lhs.markToReflect_ref() != rhs.markToReflect_ref()) {
    return false;
  }
  if (lhs.clientMetadata_ref() != rhs.clientMetadata_ref()) {
    return false;
  }
  return true;
}

const apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* RequestSetupMetadata::get_opaque() const& {
  return opaque_ref().has_value() ? std::addressof(opaque) : nullptr;
}

apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* RequestSetupMetadata::get_opaque() & {
  return opaque_ref().has_value() ? std::addressof(opaque) : nullptr;
}

const ::apache::thrift::ClientMetadata* RequestSetupMetadata::get_clientMetadata() const& {
  return clientMetadata_ref().has_value() ? std::addressof(clientMetadata) : nullptr;
}

::apache::thrift::ClientMetadata* RequestSetupMetadata::get_clientMetadata() & {
  return clientMetadata_ref().has_value() ? std::addressof(clientMetadata) : nullptr;
}


void swap(RequestSetupMetadata& a, RequestSetupMetadata& b) {
  using ::std::swap;
  swap(a.opaque_ref().value_unchecked(), b.opaque_ref().value_unchecked());
  swap(a.interfaceKind_ref().value_unchecked(), b.interfaceKind_ref().value_unchecked());
  swap(a.minVersion_ref().value_unchecked(), b.minVersion_ref().value_unchecked());
  swap(a.maxVersion_ref().value_unchecked(), b.maxVersion_ref().value_unchecked());
  swap(a.dscpToReflect_ref().value_unchecked(), b.dscpToReflect_ref().value_unchecked());
  swap(a.markToReflect_ref().value_unchecked(), b.markToReflect_ref().value_unchecked());
  swap(a.clientMetadata_ref().value_unchecked(), b.clientMetadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RequestSetupMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RequestSetupMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RequestSetupMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RequestSetupMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RequestSetupMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RequestSetupMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RequestSetupMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RequestSetupMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void RequestSetupMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t RequestSetupMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t RequestSetupMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t RequestSetupMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RequestSetupMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ClientMetadata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RequestSetupMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::ClientMetadata>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::SetupResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::SetupResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SetupResponse::SetupResponse(apache::thrift::FragileConstructor, ::std::int32_t version__arg) :
    version(std::move(version__arg)) {
  __isset.version = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void SetupResponse::__clear() {
  // clear all fields
  this->version = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SetupResponse::operator==(const SetupResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.version_ref() != rhs.version_ref()) {
    return false;
  }
  return true;
}

bool SetupResponse::operator<(const SetupResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.version_ref() != rhs.version_ref()) {
    return lhs.version_ref() < rhs.version_ref();
  }
  return false;
}


void swap(SetupResponse& a, SetupResponse& b) {
  using ::std::swap;
  swap(a.version_ref().value_unchecked(), b.version_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SetupResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SetupResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SetupResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SetupResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SetupResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SetupResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SetupResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SetupResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void SetupResponse::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t SetupResponse::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t SetupResponse::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t SetupResponse::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::HeadersPayloadContent>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::HeadersPayloadContent>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HeadersPayloadContent::HeadersPayloadContent(const HeadersPayloadContent&) = default;
HeadersPayloadContent& HeadersPayloadContent::operator=(const HeadersPayloadContent&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HeadersPayloadContent::HeadersPayloadContent(HeadersPayloadContent&& other) noexcept  :
    otherMetadata(std::move(other.otherMetadata)),
    __isset(other.__isset) {}
HeadersPayloadContent& HeadersPayloadContent::operator=(FOLLY_MAYBE_UNUSED HeadersPayloadContent&& other) noexcept {
    this->otherMetadata = std::move(other.otherMetadata);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HeadersPayloadContent::HeadersPayloadContent(apache::thrift::FragileConstructor, ::std::map<::std::string, ::std::string> otherMetadata__arg) :
    otherMetadata(std::move(otherMetadata__arg)) {
  __isset.otherMetadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void HeadersPayloadContent::__clear() {
  // clear all fields
  this->otherMetadata.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HeadersPayloadContent::operator==(const HeadersPayloadContent& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  return true;
}

bool HeadersPayloadContent::operator<(const HeadersPayloadContent& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* HeadersPayloadContent::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* HeadersPayloadContent::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}


void swap(HeadersPayloadContent& a, HeadersPayloadContent& b) {
  using ::std::swap;
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HeadersPayloadContent::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HeadersPayloadContent::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HeadersPayloadContent::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HeadersPayloadContent::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HeadersPayloadContent::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HeadersPayloadContent::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HeadersPayloadContent::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HeadersPayloadContent::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void HeadersPayloadContent::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t HeadersPayloadContent::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t HeadersPayloadContent::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t HeadersPayloadContent::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::StreamHeadersPush>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::StreamHeadersPush>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamHeadersPush::StreamHeadersPush(const StreamHeadersPush&) = default;
StreamHeadersPush& StreamHeadersPush::operator=(const StreamHeadersPush&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamHeadersPush::StreamHeadersPush(StreamHeadersPush&& other) noexcept  :
    streamId(std::move(other.streamId)),
    headersPayloadContent(std::move(other.headersPayloadContent)),
    __isset(other.__isset) {}
StreamHeadersPush& StreamHeadersPush::operator=(FOLLY_MAYBE_UNUSED StreamHeadersPush&& other) noexcept {
    this->streamId = std::move(other.streamId);
    this->headersPayloadContent = std::move(other.headersPayloadContent);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamHeadersPush::StreamHeadersPush(apache::thrift::FragileConstructor, ::std::int32_t streamId__arg, ::apache::thrift::HeadersPayloadContent headersPayloadContent__arg) :
    streamId(std::move(streamId__arg)),
    headersPayloadContent(std::move(headersPayloadContent__arg)) {
  __isset.streamId = true;
  __isset.headersPayloadContent = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void StreamHeadersPush::__clear() {
  // clear all fields
  this->streamId = 0;
  this->headersPayloadContent.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StreamHeadersPush::operator==(const StreamHeadersPush& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.streamId_ref() != rhs.streamId_ref()) {
    return false;
  }
  if (lhs.headersPayloadContent_ref() != rhs.headersPayloadContent_ref()) {
    return false;
  }
  return true;
}

bool StreamHeadersPush::operator<(const StreamHeadersPush& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.streamId_ref() != rhs.streamId_ref()) {
    return lhs.streamId_ref() < rhs.streamId_ref();
  }
  if (lhs.headersPayloadContent_ref() != rhs.headersPayloadContent_ref()) {
    return lhs.headersPayloadContent_ref() < rhs.headersPayloadContent_ref();
  }
  return false;
}

const ::apache::thrift::HeadersPayloadContent* StreamHeadersPush::get_headersPayloadContent() const& {
  return headersPayloadContent_ref().has_value() ? std::addressof(headersPayloadContent) : nullptr;
}

::apache::thrift::HeadersPayloadContent* StreamHeadersPush::get_headersPayloadContent() & {
  return headersPayloadContent_ref().has_value() ? std::addressof(headersPayloadContent) : nullptr;
}


void swap(StreamHeadersPush& a, StreamHeadersPush& b) {
  using ::std::swap;
  swap(a.streamId_ref().value_unchecked(), b.streamId_ref().value_unchecked());
  swap(a.headersPayloadContent_ref().value_unchecked(), b.headersPayloadContent_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StreamHeadersPush::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StreamHeadersPush::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StreamHeadersPush::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StreamHeadersPush::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StreamHeadersPush::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StreamHeadersPush::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StreamHeadersPush::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StreamHeadersPush::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void StreamHeadersPush::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t StreamHeadersPush::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t StreamHeadersPush::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t StreamHeadersPush::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StreamHeadersPush,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::HeadersPayloadContent>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StreamHeadersPush,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::HeadersPayloadContent>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::DrainCompletePush>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::DrainCompletePush>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
DrainCompletePush::DrainCompletePush(apache::thrift::FragileConstructor, ::apache::thrift::DrainCompleteCode drainCompleteCode__arg) :
    drainCompleteCode(std::move(drainCompleteCode__arg)) {
  __isset.drainCompleteCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void DrainCompletePush::__clear() {
  // clear all fields
  this->drainCompleteCode = static_cast< ::apache::thrift::DrainCompleteCode>(0);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool DrainCompletePush::operator==(const DrainCompletePush& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.drainCompleteCode_ref() != rhs.drainCompleteCode_ref()) {
    return false;
  }
  return true;
}

bool DrainCompletePush::operator<(const DrainCompletePush& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.drainCompleteCode_ref() != rhs.drainCompleteCode_ref()) {
    return lhs.drainCompleteCode_ref() < rhs.drainCompleteCode_ref();
  }
  return false;
}


void swap(DrainCompletePush& a, DrainCompletePush& b) {
  using ::std::swap;
  swap(a.drainCompleteCode_ref().value_unchecked(), b.drainCompleteCode_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void DrainCompletePush::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t DrainCompletePush::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t DrainCompletePush::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t DrainCompletePush::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void DrainCompletePush::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t DrainCompletePush::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t DrainCompletePush::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t DrainCompletePush::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void DrainCompletePush::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t DrainCompletePush::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t DrainCompletePush::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t DrainCompletePush::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ServerPushMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ServerPushMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ServerPushMetadata::Type>::size;
folly::Range<::apache::thrift::ServerPushMetadata::Type const*> const TEnumTraits<::apache::thrift::ServerPushMetadata::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::ServerPushMetadata::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ServerPushMetadata::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::ServerPushMetadata::Type>::names);

char const* TEnumTraits<::apache::thrift::ServerPushMetadata::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::ServerPushMetadata::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ServerPushMetadata::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::ServerPushMetadata::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void ServerPushMetadata::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::setupResponse:
      destruct(value_.setupResponse);
      break;
    case Type::streamHeadersPush:
      destruct(value_.streamHeadersPush);
      break;
    case Type::drainCompletePush:
      destruct(value_.drainCompletePush);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool ServerPushMetadata::operator==(const ServerPushMetadata& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::setupResponse:
      return value_.setupResponse == rhs.value_.setupResponse;
    case Type::streamHeadersPush:
      return value_.streamHeadersPush == rhs.value_.streamHeadersPush;
    case Type::drainCompletePush:
      return value_.drainCompletePush == rhs.value_.drainCompletePush;
    default:
      return true;
  }
}

bool ServerPushMetadata::operator<(const ServerPushMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::setupResponse:
      return lhs.value_.setupResponse < rhs.value_.setupResponse;
    case Type::streamHeadersPush:
      return lhs.value_.streamHeadersPush < rhs.value_.streamHeadersPush;
    case Type::drainCompletePush:
      return lhs.value_.drainCompletePush < rhs.value_.drainCompletePush;
    default:
      return false;
  }
}

void swap(ServerPushMetadata& a, ServerPushMetadata& b) {
  ServerPushMetadata temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void ServerPushMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ServerPushMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ServerPushMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ServerPushMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ServerPushMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ServerPushMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ServerPushMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ServerPushMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ServerPushMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ServerPushMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ServerPushMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ServerPushMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ServerPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::SetupResponse>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ServerPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::StreamHeadersPush>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ServerPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::DrainCompletePush>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ServerPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::SetupResponse>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ServerPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::StreamHeadersPush>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ServerPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::DrainCompletePush>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ClientPushMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ClientPushMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ClientPushMetadata::Type>::size;
folly::Range<::apache::thrift::ClientPushMetadata::Type const*> const TEnumTraits<::apache::thrift::ClientPushMetadata::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::ClientPushMetadata::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ClientPushMetadata::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::ClientPushMetadata::Type>::names);

char const* TEnumTraits<::apache::thrift::ClientPushMetadata::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::ClientPushMetadata::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ClientPushMetadata::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::ClientPushMetadata::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void ClientPushMetadata::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::interactionTerminate:
      destruct(value_.interactionTerminate);
      break;
    case Type::streamHeadersPush:
      destruct(value_.streamHeadersPush);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool ClientPushMetadata::operator==(const ClientPushMetadata& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::interactionTerminate:
      return value_.interactionTerminate == rhs.value_.interactionTerminate;
    case Type::streamHeadersPush:
      return value_.streamHeadersPush == rhs.value_.streamHeadersPush;
    default:
      return true;
  }
}

bool ClientPushMetadata::operator<(const ClientPushMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::interactionTerminate:
      return lhs.value_.interactionTerminate < rhs.value_.interactionTerminate;
    case Type::streamHeadersPush:
      return lhs.value_.streamHeadersPush < rhs.value_.streamHeadersPush;
    default:
      return false;
  }
}

void swap(ClientPushMetadata& a, ClientPushMetadata& b) {
  ClientPushMetadata temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void ClientPushMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ClientPushMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ClientPushMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ClientPushMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ClientPushMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ClientPushMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ClientPushMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ClientPushMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ClientPushMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ClientPushMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ClientPushMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ClientPushMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ClientPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::InteractionTerminate>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ClientPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::StreamHeadersPush>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ClientPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::InteractionTerminate>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ClientPushMetadata,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::StreamHeadersPush>,
    "inconsistent use of nimble option");

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::HeadersPayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::HeadersPayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HeadersPayloadMetadata::HeadersPayloadMetadata(apache::thrift::FragileConstructor, ::apache::thrift::CompressionAlgorithm compression__arg) :
    compression(std::move(compression__arg)) {
  __isset.compression = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void HeadersPayloadMetadata::__clear() {
  // clear all fields
  this->compression =  ::apache::thrift::CompressionAlgorithm::NONE;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HeadersPayloadMetadata::operator==(const HeadersPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  return true;
}

bool HeadersPayloadMetadata::operator<(const HeadersPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  return false;
}


void swap(HeadersPayloadMetadata& a, HeadersPayloadMetadata& b) {
  using ::std::swap;
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HeadersPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HeadersPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HeadersPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HeadersPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HeadersPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HeadersPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HeadersPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HeadersPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void HeadersPayloadMetadata::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t HeadersPayloadMetadata::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t HeadersPayloadMetadata::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t HeadersPayloadMetadata::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}} // apache::thrift
