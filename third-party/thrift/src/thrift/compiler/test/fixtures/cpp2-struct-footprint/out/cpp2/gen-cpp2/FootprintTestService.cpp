/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/cpp2-struct-footprint/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#include "thrift/compiler/test/fixtures/cpp2-struct-footprint/gen-cpp2/FootprintTestService.h"
#include "thrift/compiler/test/fixtures/cpp2-struct-footprint/gen-cpp2/FootprintTestService.tcc"
#include "thrift/compiler/test/fixtures/cpp2-struct-footprint/gen-cpp2/module_metadata.h"
#include <thrift/lib/cpp2/gen/service_cpp.h>

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getProcessor() {
  return std::make_unique<::cpp2_struct_footprint::FootprintTestServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::cpp2_struct_footprint::FootprintTestServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::cpp2_struct_footprint::FootprintTestServiceServiceInfoHolder apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::__fbthrift_serviceInfoHolder;

//
// Service Methods
//

//
// Method 'processIOBuf'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::processIOBuf(std::unique_ptr<::cpp2_struct_footprint::IOBuf> /*buf*/, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> /*ptr*/, ::cpp2_struct_footprint::I32Alias /*alias*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("processIOBuf");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_processIOBuf(std::unique_ptr<::cpp2_struct_footprint::IOBuf> p_buf, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> p_ptr, ::cpp2_struct_footprint::I32Alias p_alias) {
  return processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias);
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_processIOBuf(std::unique_ptr<::cpp2_struct_footprint::IOBuf> p_buf, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> p_ptr, ::cpp2_struct_footprint::I32Alias p_alias) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_processIOBuf.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias);
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_processIOBuf(std::unique_ptr<::cpp2_struct_footprint::IOBuf> p_buf, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> p_ptr, ::cpp2_struct_footprint::I32Alias p_alias) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_processIOBuf.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_processIOBuf(std::unique_ptr<::cpp2_struct_footprint::IOBuf> p_buf, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> p_ptr, ::cpp2_struct_footprint::I32Alias p_alias) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_processIOBuf.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::cpp2_struct_footprint::IOBuf> /*buf*/, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> /*ptr*/, ::cpp2_struct_footprint::I32Alias /*alias*/>(std::move(p_buf), std::move(p_ptr), p_alias));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_processIOBuf(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::cpp2_struct_footprint::IOBuf> p_buf, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> p_ptr, ::cpp2_struct_footprint::I32Alias p_alias) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_processIOBuf.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_processIOBuf(
    apache::thrift::HandlerCallbackPtr<void> callback, std::unique_ptr<::cpp2_struct_footprint::IOBuf> p_buf, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> p_ptr, ::cpp2_struct_footprint::I32Alias p_alias) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_processIOBuf.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_processIOBuf.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_processIOBuf(params, std::move(p_buf), std::move(p_ptr), p_alias);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_processIOBuf.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias);
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias);
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_processIOBuf(params, std::move(p_buf), std::move(p_ptr), p_alias);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_processIOBuf(std::move(p_buf), std::move(p_ptr), p_alias);
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_buf, p_ptr, p_alias) = std::move(ex).restoreArgs<std::unique_ptr<::cpp2_struct_footprint::IOBuf> /*buf*/, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> /*ptr*/, ::cpp2_struct_footprint::I32Alias /*alias*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'processIOBuf'
//

//
// Method 'getStruct'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getStruct(::cpp2_struct_footprint::SimpleStruct& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getStruct");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_getStruct(::cpp2_struct_footprint::SimpleStruct& _return) {
  return getStruct(_return);
}

folly::SemiFuture<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_getStruct() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2_struct_footprint::SimpleStruct>();
  sync_getStruct(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_getStruct() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_getStruct(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getStruct() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_getStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getStruct(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_getStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_getStruct();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_getStruct(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_getStruct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getStruct(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_getStruct();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_getStruct();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getStruct(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_getStruct();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2_struct_footprint::SimpleStruct _return;
        sync_getStruct(_return);
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'getStruct'
//

//
// Method 'setStruct'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::setStruct(std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("setStruct");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_setStruct(std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> p_input) {
  return setStruct(std::move(p_input));
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_setStruct(std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_setStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_setStruct(std::move(p_input));
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_setStruct(std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_setStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_setStruct(std::move(p_input)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_setStruct(std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_setStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> /*input*/>(std::move(p_input)));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_setStruct(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_setStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_setStruct(std::move(p_input));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_setStruct(
    apache::thrift::HandlerCallbackPtr<void> callback, std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_setStruct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_setStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_setStruct(params, std::move(p_input));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_setStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_setStruct(std::move(p_input));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_setStruct(std::move(p_input));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_setStruct(params, std::move(p_input));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_setStruct(std::move(p_input));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_setStruct(std::move(p_input));
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'setStruct'
//

//
// Method 'setStructList'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::setStructList(std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> /*items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("setStructList");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_setStructList(std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> p_items) {
  return setStructList(std::move(p_items));
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_setStructList(std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_setStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_setStructList(std::move(p_items));
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_setStructList(std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_setStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_setStructList(std::move(p_items)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_setStructList(std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_setStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> /*items*/>(std::move(p_items)));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_setStructList(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_setStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_setStructList(std::move(p_items));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_setStructList(
    apache::thrift::HandlerCallbackPtr<void> callback, std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> p_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_setStructList.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_setStructList.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_setStructList(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_setStructList.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_setStructList(std::move(p_items));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_setStructList(std::move(p_items));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_setStructList(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_setStructList(std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_setStructList(std::move(p_items));
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_items) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> /*items*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'setStructList'
//

//
// Method 'getStructList'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getStructList(::std::vector<::cpp2_struct_footprint::SimpleStruct>& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getStructList");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_getStructList(::std::vector<::cpp2_struct_footprint::SimpleStruct>& _return) {
  return getStructList(_return);
}

folly::SemiFuture<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_getStructList() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::cpp2_struct_footprint::SimpleStruct>>();
  sync_getStructList(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_getStructList() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_getStructList(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getStructList() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_getStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getStructList(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_getStructList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_getStructList();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_getStructList(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_getStructList.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getStructList.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getStructList(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getStructList.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_getStructList();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_getStructList();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getStructList(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_getStructList();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::std::vector<::cpp2_struct_footprint::SimpleStruct> _return;
        sync_getStructList(_return);
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'getStructList'
//

//
// Method 'getNestedContainer'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getNestedContainer(::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getNestedContainer");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_getNestedContainer(::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>& _return) {
  return getNestedContainer(_return);
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_getNestedContainer() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getNestedContainer.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>();
  sync_getNestedContainer(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_getNestedContainer() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getNestedContainer.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_getNestedContainer(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getNestedContainer() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_getNestedContainer.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getNestedContainer(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_getNestedContainer.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_getNestedContainer();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_getNestedContainer(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_getNestedContainer.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getNestedContainer.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getNestedContainer(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getNestedContainer.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_getNestedContainer();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_getNestedContainer();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getNestedContainer(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_getNestedContainer();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>> _return;
        sync_getNestedContainer(_return);
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'getNestedContainer'
//

//
// Method 'getTypedefStruct'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getTypedefStruct(::cpp2_struct_footprint::MyStruct& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getTypedefStruct");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_getTypedefStruct(::cpp2_struct_footprint::MyStruct& _return) {
  return getTypedefStruct(_return);
}

folly::SemiFuture<std::unique_ptr<::cpp2_struct_footprint::MyStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_getTypedefStruct() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getTypedefStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2_struct_footprint::MyStruct>();
  sync_getTypedefStruct(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2_struct_footprint::MyStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_getTypedefStruct() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getTypedefStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_getTypedefStruct(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::MyStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getTypedefStruct() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_getTypedefStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::MyStruct>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getTypedefStruct(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_getTypedefStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_getTypedefStruct();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_getTypedefStruct(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::MyStruct>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_getTypedefStruct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getTypedefStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getTypedefStruct(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getTypedefStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_getTypedefStruct();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_getTypedefStruct();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getTypedefStruct(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_getTypedefStruct();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2_struct_footprint::MyStruct _return;
        sync_getTypedefStruct(_return);
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'getTypedefStruct'
//

//
// Method 'getTypedefList'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getTypedefList(::cpp2_struct_footprint::StructList& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getTypedefList");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_getTypedefList(::cpp2_struct_footprint::StructList& _return) {
  return getTypedefList(_return);
}

folly::SemiFuture<std::unique_ptr<::cpp2_struct_footprint::StructList>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_getTypedefList() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getTypedefList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2_struct_footprint::StructList>();
  sync_getTypedefList(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2_struct_footprint::StructList>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_getTypedefList() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getTypedefList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_getTypedefList(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::StructList>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getTypedefList() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_getTypedefList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::StructList>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getTypedefList(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_getTypedefList.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_getTypedefList();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_getTypedefList(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::StructList>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_getTypedefList.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getTypedefList.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getTypedefList(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getTypedefList.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_getTypedefList();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_getTypedefList();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getTypedefList(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_getTypedefList();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2_struct_footprint::StructList _return;
        sync_getTypedefList(_return);
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'getTypedefList'
//

//
// Method 'getUnion'
//

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getUnion(::cpp2_struct_footprint::TestUnion& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getUnion");
}

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_getUnion(::cpp2_struct_footprint::TestUnion& _return) {
  return getUnion(_return);
}

folly::SemiFuture<std::unique_ptr<::cpp2_struct_footprint::TestUnion>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_getUnion() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getUnion.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2_struct_footprint::TestUnion>();
  sync_getUnion(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2_struct_footprint::TestUnion>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_getUnion() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getUnion.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_getUnion(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::TestUnion>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getUnion() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_getUnion.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::cpp2_struct_footprint::TestUnion>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getUnion(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_getUnion.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_getUnion();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_getUnion(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::TestUnion>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_getUnion.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getUnion.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getUnion(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getUnion.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_getUnion();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_getUnion();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getUnion(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_getUnion();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2_struct_footprint::TestUnion _return;
        sync_getUnion(_return);
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'getUnion'
//

//
// Method 'getCalculator'
//

apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::getCalculator() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getCalculator");
}

apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_getCalculator() {
  return getCalculator();
}

folly::SemiFuture<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_getCalculator() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getCalculator.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_getCalculator();
}

folly::Future<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_getCalculator() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getCalculator.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_getCalculator(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getCalculator() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_getCalculator.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_getCalculator(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_getCalculator.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_getCalculator();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_getCalculator(
    apache::thrift::HandlerCallbackPtr<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_getCalculator.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getCalculator.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getCalculator(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_getCalculator.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_getCalculator();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_getCalculator();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_getCalculator(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_getCalculator();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_getCalculator());
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'getCalculator'
//

//
// Method 'streamStructs'
//

::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::streamStructs() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("streamStructs");
}

::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_streamStructs() {
  return streamStructs();
}

folly::SemiFuture<::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_streamStructs() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_streamStructs.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_streamStructs();
}

folly::Future<::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_streamStructs() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_streamStructs.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_streamStructs(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_streamStructs() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_streamStructs.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_streamStructs(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_streamStructs.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_streamStructs();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_streamStructs(
    apache::thrift::HandlerCallbackPtr<::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_streamStructs.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_streamStructs.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_streamStructs(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_streamStructs.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_streamStructs();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_streamStructs();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_streamStructs(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_streamStructs();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_streamStructs());
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'streamStructs'
//

//
// Method 'streamWithSinkInitial'
//

::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::streamWithSinkInitial(::std::int32_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("streamWithSinkInitial");
}

::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_streamWithSinkInitial(::std::int32_t p_input) {
  return streamWithSinkInitial(p_input);
}

folly::SemiFuture<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_streamWithSinkInitial(::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_streamWithSinkInitial.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_streamWithSinkInitial(p_input);
}

folly::Future<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_streamWithSinkInitial(::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_streamWithSinkInitial.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_streamWithSinkInitial(p_input),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_streamWithSinkInitial(::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_streamWithSinkInitial.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<::std::int32_t /*input*/>(p_input));
}

folly::coro::Task<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_streamWithSinkInitial(
    apache::thrift::RequestParams /* params */, ::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_streamWithSinkInitial.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_streamWithSinkInitial(p_input);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_streamWithSinkInitial(
    apache::thrift::HandlerCallbackPtr<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>> callback, ::std::int32_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_streamWithSinkInitial.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_streamWithSinkInitial.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_streamWithSinkInitial(params, p_input);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_streamWithSinkInitial.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_streamWithSinkInitial(p_input);
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_streamWithSinkInitial(p_input);
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_streamWithSinkInitial(params, p_input);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_streamWithSinkInitial(p_input);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_streamWithSinkInitial(p_input));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<::std::int32_t /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'streamWithSinkInitial'
//

//
// Method 'streamWithSinkException'
//

::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::streamWithSinkException(::std::int32_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("streamWithSinkException");
}

::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::sync_streamWithSinkException(::std::int32_t p_input) {
  return streamWithSinkException(p_input);
}

folly::SemiFuture<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::semifuture_streamWithSinkException(::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_streamWithSinkException.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_streamWithSinkException(p_input);
}

folly::Future<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::future_streamWithSinkException(::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_streamWithSinkException.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_streamWithSinkException(p_input),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_streamWithSinkException(::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_streamWithSinkException.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<::std::int32_t /*input*/>(p_input));
}

folly::coro::Task<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::co_streamWithSinkException(
    apache::thrift::RequestParams /* params */, ::std::int32_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_streamWithSinkException.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_streamWithSinkException(p_input);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::async_tm_streamWithSinkException(
    apache::thrift::HandlerCallbackPtr<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>> callback, ::std::int32_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_streamWithSinkException.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_streamWithSinkException.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_streamWithSinkException(params, p_input);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_streamWithSinkException.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_streamWithSinkException(p_input);
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_streamWithSinkException(p_input);
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_streamWithSinkException(params, p_input);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_streamWithSinkException(p_input);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_streamWithSinkException(p_input));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<::std::int32_t /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'streamWithSinkException'
//

//
// End of Service Methods
//

//
// Service Methods
//

//
// Method 'add'
//

::std::int32_t apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf::add(::std::int32_t /*a*/, ::std::int32_t /*b*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("add");
}

::std::int32_t apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf::sync_add(::std::int32_t p_a, ::std::int32_t p_b) {
  return add(p_a, p_b);
}

folly::SemiFuture<::std::int32_t>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf::semifuture_add(::std::int32_t p_a, ::std::int32_t p_b) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_add.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_add(p_a, p_b);
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t>
apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf::co_add(::std::int32_t p_a, ::std::int32_t p_b) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_add.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<::std::int32_t /*a*/, ::std::int32_t /*b*/>(p_a, p_b));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf::co_add(
    apache::thrift::RequestParams /* params */, ::std::int32_t p_a, ::std::int32_t p_b) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_add.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_add(p_a, p_b);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf::async_tm_add(
    apache::thrift::HandlerCallbackPtr<::std::int32_t> callback, ::std::int32_t p_a, ::std::int32_t p_b) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_add.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_add.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_add(params, p_a, p_b);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_add.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::SemiFuture,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_add(p_a, p_b);
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_add(params, p_a, p_b);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_add(p_a, p_b);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_add(p_a, p_b));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_a, p_b) = std::move(ex).restoreArgs<::std::int32_t /*a*/, ::std::int32_t /*b*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'add'
//

//
// End of Service Methods
//

namespace cpp2_struct_footprint {

void FootprintTestServiceSvNull::processIOBuf(std::unique_ptr<::cpp2_struct_footprint::IOBuf> /*buf*/, std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> /*ptr*/, ::cpp2_struct_footprint::I32Alias /*alias*/) { 
}

void FootprintTestServiceSvNull::getStruct(::cpp2_struct_footprint::SimpleStruct& /*_return*/) {  }

void FootprintTestServiceSvNull::setStruct(std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> /*input*/) { 
}

void FootprintTestServiceSvNull::setStructList(std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> /*items*/) { 
}

void FootprintTestServiceSvNull::getStructList(::std::vector<::cpp2_struct_footprint::SimpleStruct>& /*_return*/) {  }

void FootprintTestServiceSvNull::getNestedContainer(::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>& /*_return*/) {  }

void FootprintTestServiceSvNull::getTypedefStruct(::cpp2_struct_footprint::MyStruct& /*_return*/) {  }

void FootprintTestServiceSvNull::getTypedefList(::cpp2_struct_footprint::StructList& /*_return*/) {  }

void FootprintTestServiceSvNull::getUnion(::cpp2_struct_footprint::TestUnion& /*_return*/) {  }


std::string_view FootprintTestServiceAsyncProcessor::getServiceName() {
  return "FootprintTestService";
}

void FootprintTestServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>>::gen(response);
}

void FootprintTestServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void FootprintTestServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const FootprintTestServiceAsyncProcessor::ProcessMap& FootprintTestServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const FootprintTestServiceAsyncProcessor::ProcessMap FootprintTestServiceAsyncProcessor::kOwnProcessMap_ {
  {"processIOBuf",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_processIOBuf<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_processIOBuf<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_processIOBuf<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_processIOBuf<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"getStruct",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_getStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_getStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"setStruct",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_setStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_setStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_setStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_setStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"setStructList",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_setStructList<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_setStructList<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_setStructList<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_setStructList<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"getStructList",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_getStructList<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_getStructList<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getStructList<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getStructList<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"getNestedContainer",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_getNestedContainer<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_getNestedContainer<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getNestedContainer<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getNestedContainer<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"getTypedefStruct",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_getTypedefStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_getTypedefStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getTypedefStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getTypedefStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"getTypedefList",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_getTypedefList<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_getTypedefList<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getTypedefList<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getTypedefList<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"getUnion",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_getUnion<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_getUnion<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getUnion<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getUnion<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"getCalculator",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_getCalculator<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_getCalculator<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getCalculator<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_getCalculator<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"streamStructs",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_streamStructs<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_streamStructs<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_streamStructs<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_streamStructs<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"streamWithSinkInitial",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_streamWithSinkInitial<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_streamWithSinkInitial<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_streamWithSinkInitial<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_streamWithSinkInitial<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"streamWithSinkException",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_streamWithSinkException<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_streamWithSinkException<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_streamWithSinkException<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_streamWithSinkException<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"Calculator.add",
    {&FootprintTestServiceAsyncProcessor::setUpAndProcess_Calculator_add<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::setUpAndProcess_Calculator_add<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_Calculator_add<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &FootprintTestServiceAsyncProcessor::executeRequest_Calculator_add<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& FootprintTestServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap FootprintTestServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"processIOBuf",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.processIOBuf",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"getStruct",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.getStruct",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"setStruct",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.setStruct",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"setStructList",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.setStructList",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"getStructList",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.getStructList",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"getNestedContainer",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.getNestedContainer",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"getTypedefStruct",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.getTypedefStruct",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"getTypedefList",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.getTypedefList",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"getUnion",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.getUnion",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"getCalculator",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.getCalculator",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     "Calculator"}},
  {"streamStructs",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
     "FootprintTestService.streamStructs",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"streamWithSinkInitial",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
     "FootprintTestService.streamWithSinkInitial",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"streamWithSinkException",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
     "FootprintTestService.streamWithSinkException",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"Calculator.add",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "FootprintTestService.Calculator.add",
     "Calculator",
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };

  return requestInfoMap;
}
const FootprintTestServiceAsyncProcessor::InteractionConstructorMap& FootprintTestServiceAsyncProcessor::getInteractionConstructorMap() {
  return interactionConstructorMap_;
}

const FootprintTestServiceAsyncProcessor::InteractionConstructorMap FootprintTestServiceAsyncProcessor::interactionConstructorMap_ {
};

std::unique_ptr<apache::thrift::Tile> FootprintTestServiceAsyncProcessor::createInteractionImpl(const std::string& name, int16_t) {
  auto fn = getInteractionConstructorMap().at(name);
  return (this->*fn)();
}} // namespace cpp2_struct_footprint

namespace apache::thrift::detail {
::folly::Range<const ::std::string_view*>(*TSchemaAssociation<::cpp2_struct_footprint::FootprintTestService, false>::bundle)() =
    nullptr;
}
