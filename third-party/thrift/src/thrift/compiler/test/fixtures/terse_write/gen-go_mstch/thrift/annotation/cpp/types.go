// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package cpp // [[[ program thrift source path ]]]

import (
    "fmt"

    scope "thrift/annotation/scope"
    thrift0 "thrift/annotation/thrift"
    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

var _ = scope.GoUnusedProtection__
var _ = thrift0.GoUnusedProtection__

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = thrift.ZERO


type RefType int32

const (
    RefType_Unique RefType = 0
    RefType_Shared RefType = 1
    RefType_SharedMutable RefType = 2
)

// Enum value maps for RefType
var (
    RefTypeToName = map[RefType]string {
        RefType_Unique: "Unique",
        RefType_Shared: "Shared",
        RefType_SharedMutable: "SharedMutable",
    }

    RefTypeToValue = map[string]RefType {
        "Unique": RefType_Unique,
        "Shared": RefType_Shared,
        "SharedMutable": RefType_SharedMutable,
    }

    RefTypeNames = []string{
        "Unique",
        "Shared",
        "SharedMutable",
    }

    RefTypeValues = []RefType{
        RefType_Unique,
        RefType_Shared,
        RefType_SharedMutable,
    }
)

func (x RefType) String() string {
    if v, ok := RefTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x RefType) Ptr() *RefType {
    return &x
}

// Deprecated: Use RefTypeToValue instead (e.g. `x, ok := RefTypeToValue["name"]`).
func RefTypeFromString(s string) (RefType, error) {
    if v, ok := RefTypeToValue[s]; ok {
        return v, nil
    }
    return RefType(0), fmt.Errorf("not a valid RefType string")
}

// Deprecated: Use RefType.Ptr() instead.
func RefTypePtr(v RefType) *RefType {
    return &v
}


type EnumUnderlyingType int32

const (
    EnumUnderlyingType_I8 EnumUnderlyingType = 0
    EnumUnderlyingType_U8 EnumUnderlyingType = 1
    EnumUnderlyingType_I16 EnumUnderlyingType = 2
    EnumUnderlyingType_U16 EnumUnderlyingType = 3
    EnumUnderlyingType_U32 EnumUnderlyingType = 4
)

// Enum value maps for EnumUnderlyingType
var (
    EnumUnderlyingTypeToName = map[EnumUnderlyingType]string {
        EnumUnderlyingType_I8: "I8",
        EnumUnderlyingType_U8: "U8",
        EnumUnderlyingType_I16: "I16",
        EnumUnderlyingType_U16: "U16",
        EnumUnderlyingType_U32: "U32",
    }

    EnumUnderlyingTypeToValue = map[string]EnumUnderlyingType {
        "I8": EnumUnderlyingType_I8,
        "U8": EnumUnderlyingType_U8,
        "I16": EnumUnderlyingType_I16,
        "U16": EnumUnderlyingType_U16,
        "U32": EnumUnderlyingType_U32,
    }

    EnumUnderlyingTypeNames = []string{
        "I8",
        "U8",
        "I16",
        "U16",
        "U32",
    }

    EnumUnderlyingTypeValues = []EnumUnderlyingType{
        EnumUnderlyingType_I8,
        EnumUnderlyingType_U8,
        EnumUnderlyingType_I16,
        EnumUnderlyingType_U16,
        EnumUnderlyingType_U32,
    }
)

func (x EnumUnderlyingType) String() string {
    if v, ok := EnumUnderlyingTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x EnumUnderlyingType) Ptr() *EnumUnderlyingType {
    return &x
}

// Deprecated: Use EnumUnderlyingTypeToValue instead (e.g. `x, ok := EnumUnderlyingTypeToValue["name"]`).
func EnumUnderlyingTypeFromString(s string) (EnumUnderlyingType, error) {
    if v, ok := EnumUnderlyingTypeToValue[s]; ok {
        return v, nil
    }
    return EnumUnderlyingType(0), fmt.Errorf("not a valid EnumUnderlyingType string")
}

// Deprecated: Use EnumUnderlyingType.Ptr() instead.
func EnumUnderlyingTypePtr(v EnumUnderlyingType) *EnumUnderlyingType {
    return &v
}


type Ref struct {
    Type RefType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Ref{}

func NewRef() *Ref {
    return (&Ref{})
}

func (x *Ref) GetTypeNonCompat() RefType {
    return x.Type
}

func (x *Ref) GetType() RefType {
    return x.Type
}

func (x *Ref) SetType(value RefType) *Ref {
    x.Type = value
    return x
}


func (x *Ref) writeField1(p thrift.Protocol) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTypeNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Ref) readField1(p thrift.Protocol) error {  // Type
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := RefType(enumResult)

    x.SetType(result)
    return nil
}

func (x *Ref) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use Ref.Set* methods instead or set the fields directly.
type RefBuilder struct {
    obj *Ref
}

func NewRefBuilder() *RefBuilder {
    return &RefBuilder{
        obj: NewRef(),
    }
}

func (x *RefBuilder) Type(value RefType) *RefBuilder {
    x.obj.Type = value
    return x
}

func (x *RefBuilder) Emit() *Ref {
    var objCopy Ref = *x.obj
    return &objCopy
}
func (x *Ref) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Ref"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Ref) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // type
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type Lazy struct {
    Ref bool `thrift:"ref,1" json:"ref" db:"ref"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Lazy{}

func NewLazy() *Lazy {
    return (&Lazy{}).
        SetRef(false)
}

func (x *Lazy) GetRefNonCompat() bool {
    return x.Ref
}

func (x *Lazy) GetRef() bool {
    return x.Ref
}

func (x *Lazy) SetRef(value bool) *Lazy {
    x.Ref = value
    return x
}


func (x *Lazy) writeField1(p thrift.Protocol) error {  // Ref
    if err := p.WriteFieldBegin("ref", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetRefNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Lazy) readField1(p thrift.Protocol) error {  // Ref
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetRef(result)
    return nil
}

func (x *Lazy) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use Lazy.Set* methods instead or set the fields directly.
type LazyBuilder struct {
    obj *Lazy
}

func NewLazyBuilder() *LazyBuilder {
    return &LazyBuilder{
        obj: NewLazy(),
    }
}

func (x *LazyBuilder) Ref(value bool) *LazyBuilder {
    x.obj.Ref = value
    return x
}

func (x *LazyBuilder) Emit() *Lazy {
    var objCopy Lazy = *x.obj
    return &objCopy
}
func (x *Lazy) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Lazy"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Lazy) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // ref
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type DisableLazyChecksum struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &DisableLazyChecksum{}

func NewDisableLazyChecksum() *DisableLazyChecksum {
    return (&DisableLazyChecksum{})
}

func (x *DisableLazyChecksum) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use DisableLazyChecksum.Set* methods instead or set the fields directly.
type DisableLazyChecksumBuilder struct {
    obj *DisableLazyChecksum
}

func NewDisableLazyChecksumBuilder() *DisableLazyChecksumBuilder {
    return &DisableLazyChecksumBuilder{
        obj: NewDisableLazyChecksum(),
    }
}

func (x *DisableLazyChecksumBuilder) Emit() *DisableLazyChecksum {
    var objCopy DisableLazyChecksum = *x.obj
    return &objCopy
}
func (x *DisableLazyChecksum) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DisableLazyChecksum"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DisableLazyChecksum) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type Adapter struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    AdaptedType string `thrift:"adaptedType,2" json:"adaptedType" db:"adaptedType"`
    UnderlyingName string `thrift:"underlyingName,3" json:"underlyingName" db:"underlyingName"`
    ExtraNamespace string `thrift:"extraNamespace,4" json:"extraNamespace" db:"extraNamespace"`
    MoveOnly bool `thrift:"moveOnly,5" json:"moveOnly" db:"moveOnly"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Adapter{}

func NewAdapter() *Adapter {
    return (&Adapter{})
}

func (x *Adapter) GetNameNonCompat() string {
    return x.Name
}

func (x *Adapter) GetName() string {
    return x.Name
}

func (x *Adapter) GetAdaptedTypeNonCompat() string {
    return x.AdaptedType
}

func (x *Adapter) GetAdaptedType() string {
    return x.AdaptedType
}

func (x *Adapter) GetUnderlyingNameNonCompat() string {
    return x.UnderlyingName
}

func (x *Adapter) GetUnderlyingName() string {
    return x.UnderlyingName
}

func (x *Adapter) GetExtraNamespaceNonCompat() string {
    return x.ExtraNamespace
}

func (x *Adapter) GetExtraNamespace() string {
    return x.ExtraNamespace
}

func (x *Adapter) GetMoveOnlyNonCompat() bool {
    return x.MoveOnly
}

func (x *Adapter) GetMoveOnly() bool {
    return x.MoveOnly
}

func (x *Adapter) SetName(value string) *Adapter {
    x.Name = value
    return x
}

func (x *Adapter) SetAdaptedType(value string) *Adapter {
    x.AdaptedType = value
    return x
}

func (x *Adapter) SetUnderlyingName(value string) *Adapter {
    x.UnderlyingName = value
    return x
}

func (x *Adapter) SetExtraNamespace(value string) *Adapter {
    x.ExtraNamespace = value
    return x
}

func (x *Adapter) SetMoveOnly(value bool) *Adapter {
    x.MoveOnly = value
    return x
}






func (x *Adapter) writeField1(p thrift.Protocol) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNameNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField2(p thrift.Protocol) error {  // AdaptedType
    if err := p.WriteFieldBegin("adaptedType", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAdaptedTypeNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField3(p thrift.Protocol) error {  // UnderlyingName
    if err := p.WriteFieldBegin("underlyingName", thrift.STRING, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetUnderlyingNameNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField4(p thrift.Protocol) error {  // ExtraNamespace
    if err := p.WriteFieldBegin("extraNamespace", thrift.STRING, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetExtraNamespaceNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField5(p thrift.Protocol) error {  // MoveOnly
    if err := p.WriteFieldBegin("moveOnly", thrift.BOOL, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMoveOnlyNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) readField1(p thrift.Protocol) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetName(result)
    return nil
}

func (x *Adapter) readField2(p thrift.Protocol) error {  // AdaptedType
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAdaptedType(result)
    return nil
}

func (x *Adapter) readField3(p thrift.Protocol) error {  // UnderlyingName
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetUnderlyingName(result)
    return nil
}

func (x *Adapter) readField4(p thrift.Protocol) error {  // ExtraNamespace
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetExtraNamespace(result)
    return nil
}

func (x *Adapter) readField5(p thrift.Protocol) error {  // MoveOnly
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetMoveOnly(result)
    return nil
}

func (x *Adapter) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use Adapter.Set* methods instead or set the fields directly.
type AdapterBuilder struct {
    obj *Adapter
}

func NewAdapterBuilder() *AdapterBuilder {
    return &AdapterBuilder{
        obj: NewAdapter(),
    }
}

func (x *AdapterBuilder) Name(value string) *AdapterBuilder {
    x.obj.Name = value
    return x
}

func (x *AdapterBuilder) AdaptedType(value string) *AdapterBuilder {
    x.obj.AdaptedType = value
    return x
}

func (x *AdapterBuilder) UnderlyingName(value string) *AdapterBuilder {
    x.obj.UnderlyingName = value
    return x
}

func (x *AdapterBuilder) ExtraNamespace(value string) *AdapterBuilder {
    x.obj.ExtraNamespace = value
    return x
}

func (x *AdapterBuilder) MoveOnly(value bool) *AdapterBuilder {
    x.obj.MoveOnly = value
    return x
}

func (x *AdapterBuilder) Emit() *Adapter {
    var objCopy Adapter = *x.obj
    return &objCopy
}
func (x *Adapter) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Adapter"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Adapter) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // name
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // adaptedType
            if err := x.readField2(p); err != nil {
                return err
            }
        case 3:  // underlyingName
            if err := x.readField3(p); err != nil {
                return err
            }
        case 4:  // extraNamespace
            if err := x.readField4(p); err != nil {
                return err
            }
        case 5:  // moveOnly
            if err := x.readField5(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type PackIsset struct {
    Atomic bool `thrift:"atomic,1" json:"atomic" db:"atomic"`
}
// Compile time interface enforcer
var _ thrift.Struct = &PackIsset{}

func NewPackIsset() *PackIsset {
    return (&PackIsset{}).
        SetAtomic(true)
}

func (x *PackIsset) GetAtomicNonCompat() bool {
    return x.Atomic
}

func (x *PackIsset) GetAtomic() bool {
    return x.Atomic
}

func (x *PackIsset) SetAtomic(value bool) *PackIsset {
    x.Atomic = value
    return x
}


func (x *PackIsset) writeField1(p thrift.Protocol) error {  // Atomic
    if err := p.WriteFieldBegin("atomic", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAtomicNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) readField1(p thrift.Protocol) error {  // Atomic
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetAtomic(result)
    return nil
}

func (x *PackIsset) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use PackIsset.Set* methods instead or set the fields directly.
type PackIssetBuilder struct {
    obj *PackIsset
}

func NewPackIssetBuilder() *PackIssetBuilder {
    return &PackIssetBuilder{
        obj: NewPackIsset(),
    }
}

func (x *PackIssetBuilder) Atomic(value bool) *PackIssetBuilder {
    x.obj.Atomic = value
    return x
}

func (x *PackIssetBuilder) Emit() *PackIsset {
    var objCopy PackIsset = *x.obj
    return &objCopy
}
func (x *PackIsset) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("PackIsset"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // atomic
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type MinimizePadding struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &MinimizePadding{}

func NewMinimizePadding() *MinimizePadding {
    return (&MinimizePadding{})
}

func (x *MinimizePadding) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use MinimizePadding.Set* methods instead or set the fields directly.
type MinimizePaddingBuilder struct {
    obj *MinimizePadding
}

func NewMinimizePaddingBuilder() *MinimizePaddingBuilder {
    return &MinimizePaddingBuilder{
        obj: NewMinimizePadding(),
    }
}

func (x *MinimizePaddingBuilder) Emit() *MinimizePadding {
    var objCopy MinimizePadding = *x.obj
    return &objCopy
}
func (x *MinimizePadding) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MinimizePadding"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinimizePadding) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type TriviallyRelocatable struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &TriviallyRelocatable{}

func NewTriviallyRelocatable() *TriviallyRelocatable {
    return (&TriviallyRelocatable{})
}

func (x *TriviallyRelocatable) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use TriviallyRelocatable.Set* methods instead or set the fields directly.
type TriviallyRelocatableBuilder struct {
    obj *TriviallyRelocatable
}

func NewTriviallyRelocatableBuilder() *TriviallyRelocatableBuilder {
    return &TriviallyRelocatableBuilder{
        obj: NewTriviallyRelocatable(),
    }
}

func (x *TriviallyRelocatableBuilder) Emit() *TriviallyRelocatable {
    var objCopy TriviallyRelocatable = *x.obj
    return &objCopy
}
func (x *TriviallyRelocatable) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TriviallyRelocatable"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TriviallyRelocatable) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type ScopedEnumAsUnionType struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &ScopedEnumAsUnionType{}

func NewScopedEnumAsUnionType() *ScopedEnumAsUnionType {
    return (&ScopedEnumAsUnionType{})
}

func (x *ScopedEnumAsUnionType) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use ScopedEnumAsUnionType.Set* methods instead or set the fields directly.
type ScopedEnumAsUnionTypeBuilder struct {
    obj *ScopedEnumAsUnionType
}

func NewScopedEnumAsUnionTypeBuilder() *ScopedEnumAsUnionTypeBuilder {
    return &ScopedEnumAsUnionTypeBuilder{
        obj: NewScopedEnumAsUnionType(),
    }
}

func (x *ScopedEnumAsUnionTypeBuilder) Emit() *ScopedEnumAsUnionType {
    var objCopy ScopedEnumAsUnionType = *x.obj
    return &objCopy
}
func (x *ScopedEnumAsUnionType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ScopedEnumAsUnionType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ScopedEnumAsUnionType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type StrongType struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &StrongType{}

func NewStrongType() *StrongType {
    return (&StrongType{})
}

func (x *StrongType) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use StrongType.Set* methods instead or set the fields directly.
type StrongTypeBuilder struct {
    obj *StrongType
}

func NewStrongTypeBuilder() *StrongTypeBuilder {
    return &StrongTypeBuilder{
        obj: NewStrongType(),
    }
}

func (x *StrongTypeBuilder) Emit() *StrongType {
    var objCopy StrongType = *x.obj
    return &objCopy
}
func (x *StrongType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("StrongType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *StrongType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type FieldInterceptor struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    Noinline bool `thrift:"noinline,2" json:"noinline" db:"noinline"`
}
// Compile time interface enforcer
var _ thrift.Struct = &FieldInterceptor{}

func NewFieldInterceptor() *FieldInterceptor {
    return (&FieldInterceptor{})
}

func (x *FieldInterceptor) GetNameNonCompat() string {
    return x.Name
}

func (x *FieldInterceptor) GetName() string {
    return x.Name
}

func (x *FieldInterceptor) GetNoinlineNonCompat() bool {
    return x.Noinline
}

func (x *FieldInterceptor) GetNoinline() bool {
    return x.Noinline
}

func (x *FieldInterceptor) SetName(value string) *FieldInterceptor {
    x.Name = value
    return x
}

func (x *FieldInterceptor) SetNoinline(value bool) *FieldInterceptor {
    x.Noinline = value
    return x
}



func (x *FieldInterceptor) writeField1(p thrift.Protocol) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNameNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) writeField2(p thrift.Protocol) error {  // Noinline
    if err := p.WriteFieldBegin("noinline", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNoinlineNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) readField1(p thrift.Protocol) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetName(result)
    return nil
}

func (x *FieldInterceptor) readField2(p thrift.Protocol) error {  // Noinline
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetNoinline(result)
    return nil
}

func (x *FieldInterceptor) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use FieldInterceptor.Set* methods instead or set the fields directly.
type FieldInterceptorBuilder struct {
    obj *FieldInterceptor
}

func NewFieldInterceptorBuilder() *FieldInterceptorBuilder {
    return &FieldInterceptorBuilder{
        obj: NewFieldInterceptor(),
    }
}

func (x *FieldInterceptorBuilder) Name(value string) *FieldInterceptorBuilder {
    x.obj.Name = value
    return x
}

func (x *FieldInterceptorBuilder) Noinline(value bool) *FieldInterceptorBuilder {
    x.obj.Noinline = value
    return x
}

func (x *FieldInterceptorBuilder) Emit() *FieldInterceptor {
    var objCopy FieldInterceptor = *x.obj
    return &objCopy
}
func (x *FieldInterceptor) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("FieldInterceptor"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // name
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // noinline
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type UseOpEncode struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &UseOpEncode{}

func NewUseOpEncode() *UseOpEncode {
    return (&UseOpEncode{})
}

func (x *UseOpEncode) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use UseOpEncode.Set* methods instead or set the fields directly.
type UseOpEncodeBuilder struct {
    obj *UseOpEncode
}

func NewUseOpEncodeBuilder() *UseOpEncodeBuilder {
    return &UseOpEncodeBuilder{
        obj: NewUseOpEncode(),
    }
}

func (x *UseOpEncodeBuilder) Emit() *UseOpEncode {
    var objCopy UseOpEncode = *x.obj
    return &objCopy
}
func (x *UseOpEncode) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("UseOpEncode"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *UseOpEncode) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

type EnumType struct {
    Type EnumUnderlyingType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = &EnumType{}

func NewEnumType() *EnumType {
    return (&EnumType{})
}

func (x *EnumType) GetTypeNonCompat() EnumUnderlyingType {
    return x.Type
}

func (x *EnumType) GetType() EnumUnderlyingType {
    return x.Type
}

func (x *EnumType) SetType(value EnumUnderlyingType) *EnumType {
    x.Type = value
    return x
}


func (x *EnumType) writeField1(p thrift.Protocol) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTypeNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *EnumType) readField1(p thrift.Protocol) error {  // Type
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := EnumUnderlyingType(enumResult)

    x.SetType(result)
    return nil
}

func (x *EnumType) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use EnumType.Set* methods instead or set the fields directly.
type EnumTypeBuilder struct {
    obj *EnumType
}

func NewEnumTypeBuilder() *EnumTypeBuilder {
    return &EnumTypeBuilder{
        obj: NewEnumType(),
    }
}

func (x *EnumTypeBuilder) Type(value EnumUnderlyingType) *EnumTypeBuilder {
    x.obj.Type = value
    return x
}

func (x *EnumTypeBuilder) Emit() *EnumType {
    var objCopy EnumType = *x.obj
    return &objCopy
}
func (x *EnumType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("EnumType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *EnumType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // type
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}
