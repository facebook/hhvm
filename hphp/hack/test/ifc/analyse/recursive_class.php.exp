Analyzing __construct:
* pc: pc
* This: \R<\R, lump'1>
* Return: <ret>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: { $prop -> <$prop>; $r -> \R<\R'1, lump'2> }
* Final environment:
  Deps: {}
  Locals:
    lvars: { $prop -> <$prop>; $r -> \R<\R'1, lump'2> }
Constraints:
  [\R < lump'1, pc < lump'1, $prop < lump'1, \R < lump'1, pc < lump'1,
   lump'2 = lump'1, \R'1 < lump'1]

Analyzing recursiveGet:
* pc: pc
* This: \R<\R, lump'1>
* Return: <ret>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: {}
* Final environment:
  Deps: {}
  Locals:
    lvars: {}
Constraints:
  [lump'1 < .r, \R < .r, lump'1 < .r'1, .r < .r'1, lump'1 < .r'2,
   .r'1 < .r'2, lump'1 < .prop, .r'2 < .prop, .prop < ret]

Analyzing recursiveWrite:
* pc: pc
* This: \R<\R, lump'1>
* Return: <ret>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: {}
* Final environment:
  Deps: {}
  Locals:
    lvars: {}
Constraints:
  [lump'1 < .r, \R < .r, lump'1 < .r'1, .r < .r'1, lump'1 < .r'2,
   .r'1 < .r'2, .r'2 < lump'1, pc < lump'1, lit < lump'1]

