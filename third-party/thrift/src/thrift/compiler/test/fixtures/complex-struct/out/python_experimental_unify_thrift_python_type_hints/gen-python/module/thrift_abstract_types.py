
# EXPERIMENTAL - DO NOT USE !!!
# See `experimental_unify_thrift_python_type_hints` documentation in thrift compiler

#
# Autogenerated by Thrift
#
# DO NOT EDIT
#  @generated
#

from __future__ import annotations

import abc as _abc
import typing as _typing

import folly.iobuf as _fbthrift_iobuf

class MyEnum:
    pass


class MyStructFloatFieldThrowExp(_abc.ABC):
    @property
    @_abc.abstractmethod
    def myLongField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def MyByteField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def myStringField(self) -> str: ...
    @property
    @_abc.abstractmethod
    def myFloatField(self) -> float: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[int, int, str, float]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.MyStructFloatFieldThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.MyStructFloatFieldThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.MyStructFloatFieldThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.MyStructFloatFieldThrowExp": ...  # type: ignore

class MyStructMapFloatThrowExp(_abc.ABC):
    @property
    @_abc.abstractmethod
    def myLongField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def mapListOfFloats(self) -> _typing.Mapping[int, _typing.Sequence[_typing.Sequence[float]]]: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[int, _typing.Mapping[int, _typing.Sequence[_typing.Sequence[float]]]]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.MyStructMapFloatThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.MyStructMapFloatThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.MyStructMapFloatThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.MyStructMapFloatThrowExp": ...  # type: ignore

class MyStruct(_abc.ABC):
    @property
    @_abc.abstractmethod
    def MyIntField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def MyStringField(self) -> str: ...
    @property
    @_abc.abstractmethod
    def MyDataField(self) -> MyDataItem: ...
    @property
    @_abc.abstractmethod
    def myEnum(self) -> MyEnum: ...
    @property
    @_abc.abstractmethod
    def MyBoolField(self) -> bool: ...
    @property
    @_abc.abstractmethod
    def MyByteField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def MyShortField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def MyLongField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def MyDoubleField(self) -> float: ...
    @property
    @_abc.abstractmethod
    def lDouble(self) -> _typing.Sequence[float]: ...
    @property
    @_abc.abstractmethod
    def lShort(self) -> _typing.Sequence[int]: ...
    @property
    @_abc.abstractmethod
    def lInteger(self) -> _typing.Sequence[int]: ...
    @property
    @_abc.abstractmethod
    def lLong(self) -> _typing.Sequence[int]: ...
    @property
    @_abc.abstractmethod
    def lString(self) -> _typing.Sequence[str]: ...
    @property
    @_abc.abstractmethod
    def lBool(self) -> _typing.Sequence[bool]: ...
    @property
    @_abc.abstractmethod
    def lByte(self) -> _typing.Sequence[int]: ...
    @property
    @_abc.abstractmethod
    def mShortString(self) -> _typing.Mapping[int, str]: ...
    @property
    @_abc.abstractmethod
    def mIntegerString(self) -> _typing.Mapping[int, str]: ...
    @property
    @_abc.abstractmethod
    def mStringMyStruct(self) -> _typing.Mapping[str, MyStruct]: ...
    @property
    @_abc.abstractmethod
    def mStringBool(self) -> _typing.Mapping[str, bool]: ...
    @property
    @_abc.abstractmethod
    def mIntegerInteger(self) -> _typing.Mapping[int, int]: ...
    @property
    @_abc.abstractmethod
    def mIntegerBool(self) -> _typing.Mapping[int, bool]: ...
    @property
    @_abc.abstractmethod
    def sShort(self) -> _typing.AbstractSet[int]: ...
    @property
    @_abc.abstractmethod
    def sMyStruct(self) -> _typing.AbstractSet[MyStruct]: ...
    @property
    @_abc.abstractmethod
    def sLong(self) -> _typing.AbstractSet[int]: ...
    @property
    @_abc.abstractmethod
    def sString(self) -> _typing.AbstractSet[str]: ...
    @property
    @_abc.abstractmethod
    def sByte(self) -> _typing.AbstractSet[int]: ...
    @property
    @_abc.abstractmethod
    def mListList(self) -> _typing.Mapping[_typing.Sequence[int], _typing.Sequence[int]]: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[int, str, MyDataItem, MyEnum, bool, int, int, int, float, _typing.Sequence[float], _typing.Sequence[int], _typing.Sequence[int], _typing.Sequence[int], _typing.Sequence[str], _typing.Sequence[bool], _typing.Sequence[int], _typing.Mapping[int, str], _typing.Mapping[int, str], _typing.Mapping[str, MyStruct], _typing.Mapping[str, bool], _typing.Mapping[int, int], _typing.Mapping[int, bool], _typing.AbstractSet[int], _typing.AbstractSet[MyStruct], _typing.AbstractSet[int], _typing.AbstractSet[str], _typing.AbstractSet[int], _typing.Mapping[_typing.Sequence[int], _typing.Sequence[int]]]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.MyStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.MyStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.MyStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.MyStruct": ...  # type: ignore

class SimpleStruct(_abc.ABC):
    @property
    @_abc.abstractmethod
    def age(self) -> int: ...
    @property
    @_abc.abstractmethod
    def name(self) -> str: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[int, str]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.SimpleStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.SimpleStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.SimpleStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.SimpleStruct": ...  # type: ignore

class defaultStruct(_abc.ABC):
    @property
    @_abc.abstractmethod
    def myLongDFset(self) -> int: ...
    @property
    @_abc.abstractmethod
    def myLongDF(self) -> int: ...
    @property
    @_abc.abstractmethod
    def portDFset(self) -> int: ...
    @property
    @_abc.abstractmethod
    def portNum(self) -> int: ...
    @property
    @_abc.abstractmethod
    def myBinaryDFset(self) -> bytes: ...
    @property
    @_abc.abstractmethod
    def myBinary(self) -> bytes: ...
    @property
    @_abc.abstractmethod
    def myByteDFSet(self) -> int: ...
    @property
    @_abc.abstractmethod
    def myByte(self) -> int: ...
    @property
    @_abc.abstractmethod
    def myDoubleDFset(self) -> float: ...
    @property
    @_abc.abstractmethod
    def myDoubleDFZero(self) -> float: ...
    @property
    @_abc.abstractmethod
    def myDouble(self) -> float: ...
    @property
    @_abc.abstractmethod
    def field3(self) -> _typing.Mapping[int, str]: ...
    @property
    @_abc.abstractmethod
    def myList(self) -> _typing.Sequence[MyEnum]: ...
    @property
    @_abc.abstractmethod
    def mySet(self) -> _typing.AbstractSet[str]: ...
    @property
    @_abc.abstractmethod
    def simpleStruct(self) -> SimpleStruct: ...
    @property
    @_abc.abstractmethod
    def listStructDFset(self) -> _typing.Sequence[SimpleStruct]: ...
    @property
    @_abc.abstractmethod
    def myUnion(self) -> MyUnion: ...
    @property
    @_abc.abstractmethod
    def listUnionDFset(self) -> _typing.Sequence[MyUnion]: ...
    @property
    @_abc.abstractmethod
    def mapNestlistStructDfSet(self) -> _typing.Mapping[int, _typing.Sequence[SimpleStruct]]: ...
    @property
    @_abc.abstractmethod
    def mapJavaTypeDFset(self) -> _typing.Mapping[int, str]: ...
    @property
    @_abc.abstractmethod
    def emptyMap(self) -> _typing.Mapping[int, int]: ...
    @property
    @_abc.abstractmethod
    def enumMapDFset(self) -> _typing.Mapping[str, _typing.Mapping[int, MyEnum]]: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[int, int, int, int, bytes, bytes, int, int, float, float, float, _typing.Mapping[int, str], _typing.Sequence[MyEnum], _typing.AbstractSet[str], SimpleStruct, _typing.Sequence[SimpleStruct], MyUnion, _typing.Sequence[MyUnion], _typing.Mapping[int, _typing.Sequence[SimpleStruct]], _typing.Mapping[int, str], _typing.Mapping[int, int], _typing.Mapping[str, _typing.Mapping[int, MyEnum]]]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.defaultStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.defaultStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.defaultStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.defaultStruct": ...  # type: ignore

class MyStructTypeDef(_abc.ABC):
    @property
    @_abc.abstractmethod
    def myLongField(self) -> int: ...
    @property
    @_abc.abstractmethod
    def myLongTypeDef(self) -> int: ...
    @property
    @_abc.abstractmethod
    def myStringField(self) -> str: ...
    @property
    @_abc.abstractmethod
    def myStringTypedef(self) -> str: ...
    @property
    @_abc.abstractmethod
    def myMapField(self) -> _typing.Mapping[int, str]: ...
    @property
    @_abc.abstractmethod
    def myMapTypedef(self) -> _typing.Mapping[int, str]: ...
    @property
    @_abc.abstractmethod
    def myListField(self) -> _typing.Sequence[float]: ...
    @property
    @_abc.abstractmethod
    def myListTypedef(self) -> _typing.Sequence[float]: ...
    @property
    @_abc.abstractmethod
    def myMapListOfTypeDef(self) -> _typing.Mapping[int, _typing.Sequence[_typing.Sequence[float]]]: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[int, int, str, str, _typing.Mapping[int, str], _typing.Mapping[int, str], _typing.Sequence[float], _typing.Sequence[float], _typing.Mapping[int, _typing.Sequence[_typing.Sequence[float]]]]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.MyStructTypeDef": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.MyStructTypeDef": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.MyStructTypeDef": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.MyStructTypeDef": ...  # type: ignore

class MyDataItem(_abc.ABC):
    pass
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.MyDataItem": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.MyDataItem": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.MyDataItem": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.MyDataItem": ...  # type: ignore

class MyUnion(_abc.ABC):
    @property
    @_abc.abstractmethod
    def myEnum(self) -> MyEnum: ...
    @property
    @_abc.abstractmethod
    def myStruct(self) -> MyStruct: ...
    @property
    @_abc.abstractmethod
    def myDataItem(self) -> MyDataItem: ...
    @property
    @_abc.abstractmethod
    def complexNestedStruct(self) -> ComplexNestedStruct: ...
    @property
    @_abc.abstractmethod
    def longValue(self) -> int: ...
    @property
    @_abc.abstractmethod
    def intValue(self) -> int: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.MyUnion": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.MyUnion": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.MyUnion": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.MyUnion": ...  # type: ignore

class MyUnionFloatFieldThrowExp(_abc.ABC):
    @property
    @_abc.abstractmethod
    def myEnum(self) -> MyEnum: ...
    @property
    @_abc.abstractmethod
    def setFloat(self) -> _typing.Sequence[_typing.Sequence[float]]: ...
    @property
    @_abc.abstractmethod
    def myDataItem(self) -> MyDataItem: ...
    @property
    @_abc.abstractmethod
    def complexNestedStruct(self) -> ComplexNestedStruct: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.MyUnionFloatFieldThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.MyUnionFloatFieldThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.MyUnionFloatFieldThrowExp": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.MyUnionFloatFieldThrowExp": ...  # type: ignore

class ComplexNestedStruct(_abc.ABC):
    @property
    @_abc.abstractmethod
    def setOfSetOfInt(self) -> _typing.AbstractSet[_typing.AbstractSet[int]]: ...
    @property
    @_abc.abstractmethod
    def listofListOfListOfListOfEnum(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[MyEnum]]]]: ...
    @property
    @_abc.abstractmethod
    def listOfListOfMyStruct(self) -> _typing.Sequence[_typing.Sequence[MyStruct]]: ...
    @property
    @_abc.abstractmethod
    def setOfListOfListOfLong(self) -> _typing.AbstractSet[_typing.Sequence[_typing.Sequence[int]]]: ...
    @property
    @_abc.abstractmethod
    def setOfSetOfsetOfLong(self) -> _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[int]]]: ...
    @property
    @_abc.abstractmethod
    def mapStructListOfListOfLong(self) -> _typing.Mapping[int, _typing.Sequence[_typing.Sequence[MyStruct]]]: ...
    @property
    @_abc.abstractmethod
    def mKeyStructValInt(self) -> _typing.Mapping[MyStruct, int]: ...
    @property
    @_abc.abstractmethod
    def listOfMapKeyIntValInt(self) -> _typing.Sequence[_typing.Mapping[int, int]]: ...
    @property
    @_abc.abstractmethod
    def listOfMapKeyStrValList(self) -> _typing.Sequence[_typing.Mapping[str, _typing.Sequence[MyStruct]]]: ...
    @property
    @_abc.abstractmethod
    def mapKeySetValLong(self) -> _typing.Mapping[_typing.AbstractSet[int], int]: ...
    @property
    @_abc.abstractmethod
    def mapKeyListValLong(self) -> _typing.Mapping[_typing.Sequence[str], int]: ...
    @property
    @_abc.abstractmethod
    def mapKeyMapValMap(self) -> _typing.Mapping[_typing.Mapping[int, str], _typing.Mapping[int, str]]: ...
    @property
    @_abc.abstractmethod
    def mapKeySetValMap(self) -> _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...
    @property
    @_abc.abstractmethod
    def NestedMaps(self) -> _typing.Mapping[_typing.Mapping[_typing.Mapping[int, str], str], _typing.Mapping[int, str]]: ...
    @property
    @_abc.abstractmethod
    def mapKeyIntValList(self) -> _typing.Mapping[int, _typing.Sequence[MyStruct]]: ...
    @property
    @_abc.abstractmethod
    def mapKeyIntValSet(self) -> _typing.Mapping[int, _typing.AbstractSet[bool]]: ...
    @property
    @_abc.abstractmethod
    def mapKeySetValInt(self) -> _typing.Mapping[_typing.AbstractSet[bool], MyEnum]: ...
    @property
    @_abc.abstractmethod
    def mapKeyListValSet(self) -> _typing.Mapping[_typing.Sequence[int], _typing.AbstractSet[_typing.Mapping[float, str]]]: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[_typing.AbstractSet[_typing.AbstractSet[int]], _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[MyEnum]]]], _typing.Sequence[_typing.Sequence[MyStruct]], _typing.AbstractSet[_typing.Sequence[_typing.Sequence[int]]], _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[int]]], _typing.Mapping[int, _typing.Sequence[_typing.Sequence[MyStruct]]], _typing.Mapping[MyStruct, int], _typing.Sequence[_typing.Mapping[int, int]], _typing.Sequence[_typing.Mapping[str, _typing.Sequence[MyStruct]]], _typing.Mapping[_typing.AbstractSet[int], int], _typing.Mapping[_typing.Sequence[str], int], _typing.Mapping[_typing.Mapping[int, str], _typing.Mapping[int, str]], _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]], _typing.Mapping[_typing.Mapping[_typing.Mapping[int, str], str], _typing.Mapping[int, str]], _typing.Mapping[int, _typing.Sequence[MyStruct]], _typing.Mapping[int, _typing.AbstractSet[bool]], _typing.Mapping[_typing.AbstractSet[bool], MyEnum], _typing.Mapping[_typing.Sequence[int], _typing.AbstractSet[_typing.Mapping[float, str]]]]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.ComplexNestedStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.ComplexNestedStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.ComplexNestedStruct": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.ComplexNestedStruct": ...  # type: ignore

class TypeRemapped(_abc.ABC):
    @property
    @_abc.abstractmethod
    def lsMap(self) -> _typing.Mapping[int, str]: ...
    @property
    @_abc.abstractmethod
    def ioMap(self) -> _typing.Mapping[int, _typing.Mapping[int, int]]: ...
    @property
    @_abc.abstractmethod
    def BigInteger(self) -> int: ...
    @property
    @_abc.abstractmethod
    def binaryTestBuffer(self) -> bytes: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[_typing.Mapping[int, str], _typing.Mapping[int, _typing.Mapping[int, int]], int, bytes]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.TypeRemapped": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.TypeRemapped": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.TypeRemapped": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.TypeRemapped": ...  # type: ignore

class emptyXcep(_abc.ABC):
    pass
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.emptyXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.emptyXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.emptyXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.emptyXcep": ...  # type: ignore

class reqXcep(_abc.ABC):
    @property
    @_abc.abstractmethod
    def message(self) -> str: ...
    @property
    @_abc.abstractmethod
    def errorCode(self) -> int: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[str, int]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.reqXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.reqXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.reqXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.reqXcep": ...  # type: ignore

class optXcep(_abc.ABC):
    @property
    @_abc.abstractmethod
    def message(self) -> _typing.Optional[str]: ...
    @property
    @_abc.abstractmethod
    def errorCode(self) -> _typing.Optional[int]: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[str, int]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.optXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.optXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.optXcep": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.optXcep": ...  # type: ignore

class complexException(_abc.ABC):
    @property
    @_abc.abstractmethod
    def message(self) -> str: ...
    @property
    @_abc.abstractmethod
    def listStrings(self) -> _typing.Sequence[str]: ...
    @property
    @_abc.abstractmethod
    def errorEnum(self) -> MyEnum: ...
    @property
    @_abc.abstractmethod
    def unionError(self) -> _typing.Optional[MyUnion]: ...
    @property
    @_abc.abstractmethod
    def structError(self) -> MyStruct: ...
    @property
    @_abc.abstractmethod
    def lsMap(self) -> _typing.Mapping[int, str]: ...
#    @_abc.abstractmethod
#    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[str, _typing.Sequence[str], MyEnum, MyUnion, MyStruct, _typing.Mapping[int, str]]]]: ...
#    @_abc.abstractmethod
#    def _to_mutable_python(self) -> "module.thrift_mutable_types.complexException": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_python(self) -> "module.thrift_types.complexException": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py3(self) -> "module.types.complexException": ...  # type: ignore
#    @_abc.abstractmethod
#    def _to_py_deprecated(self) -> "module.ttypes.complexException": ...  # type: ignore

stringTypedef = str
longTypeDef = int
mapTypedef = _typing.Mapping[int, str]
listTypedef = _typing.Sequence[float]
floatTypedef = float
FMap = _typing.Mapping[int, int]
binary_4918 = bytes
i32_1194 = int
map_i32_FMap_6797 = _typing.Mapping[int, _typing.Mapping[int, int]]
map_i64_string_5732 = _typing.Mapping[int, str]
