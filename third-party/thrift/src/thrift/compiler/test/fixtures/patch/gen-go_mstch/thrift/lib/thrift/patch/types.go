// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package patch // [[[ program thrift source path ]]]

import (
    "fmt"

    thrift0 "thrift/annotation/thrift"
    scope "thrift/annotation/scope"
    cpp "thrift/annotation/cpp"
    standard "thrift/lib/thrift/standard"
    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

var _ = thrift0.GoUnusedProtection__
var _ = scope.GoUnusedProtection__
var _ = cpp.GoUnusedProtection__
var _ = standard.GoUnusedProtection__

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = thrift.ZERO


type ListPatchIndex = int32

func NewListPatchIndex() ListPatchIndex {
  return 0
}

func WriteListPatchIndex(item ListPatchIndex, p thrift.Protocol) error {
  if err := p.WriteI32(item); err != nil {
    return err
}
  return nil
}

func ReadListPatchIndex(p thrift.Protocol) (ListPatchIndex, error) {
  var decodeResult ListPatchIndex
  decodeErr := func() error {
    result, err := p.ReadI32()
if err != nil {
    return err
}
    decodeResult = result
    return nil
  }()
  return decodeResult, decodeErr
}

type PatchOp int32

const (
    PatchOp_Assign PatchOp = 1
    PatchOp_Clear PatchOp = 2
    PatchOp_PatchPrior PatchOp = 3
    PatchOp_EnsureUnion PatchOp = 4
    PatchOp_EnsureStruct PatchOp = 5
    PatchOp_PatchAfter PatchOp = 6
    PatchOp_Remove PatchOp = 7
    PatchOp_Add PatchOp = 8
    PatchOp_Put PatchOp = 9
    PatchOp_Unspecified PatchOp = 0
)

// Enum value maps for PatchOp
var (
    PatchOpToName = map[PatchOp]string {
        PatchOp_Assign: "Assign",
        PatchOp_Clear: "Clear",
        PatchOp_PatchPrior: "PatchPrior",
        PatchOp_EnsureUnion: "EnsureUnion",
        PatchOp_EnsureStruct: "EnsureStruct",
        PatchOp_PatchAfter: "PatchAfter",
        PatchOp_Remove: "Remove",
        PatchOp_Add: "Add",
        PatchOp_Put: "Put",
        PatchOp_Unspecified: "Unspecified",
    }

    PatchOpToValue = map[string]PatchOp {
        "Assign": PatchOp_Assign,
        "Clear": PatchOp_Clear,
        "PatchPrior": PatchOp_PatchPrior,
        "EnsureUnion": PatchOp_EnsureUnion,
        "EnsureStruct": PatchOp_EnsureStruct,
        "PatchAfter": PatchOp_PatchAfter,
        "Remove": PatchOp_Remove,
        "Add": PatchOp_Add,
        "Put": PatchOp_Put,
        "Unspecified": PatchOp_Unspecified,
    }

    PatchOpNames = []string{
        "Assign",
        "Clear",
        "PatchPrior",
        "EnsureUnion",
        "EnsureStruct",
        "PatchAfter",
        "Remove",
        "Add",
        "Put",
        "Unspecified",
    }

    PatchOpValues = []PatchOp{
        PatchOp_Assign,
        PatchOp_Clear,
        PatchOp_PatchPrior,
        PatchOp_EnsureUnion,
        PatchOp_EnsureStruct,
        PatchOp_PatchAfter,
        PatchOp_Remove,
        PatchOp_Add,
        PatchOp_Put,
        PatchOp_Unspecified,
    }
)

func (x PatchOp) String() string {
    if v, ok := PatchOpToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x PatchOp) Ptr() *PatchOp {
    return &x
}

// Deprecated: Use PatchOpToValue instead (e.g. `x, ok := PatchOpToValue["name"]`).
func PatchOpFromString(s string) (PatchOp, error) {
    if v, ok := PatchOpToValue[s]; ok {
        return v, nil
    }
    return PatchOp(0), fmt.Errorf("not a valid PatchOp string")
}

// Deprecated: Use PatchOp.Ptr() instead.
func PatchOpPtr(v PatchOp) *PatchOp {
    return &v
}


type GeneratePatch struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &GeneratePatch{}


func NewGeneratePatch() *GeneratePatch {
    return (&GeneratePatch{})
}

func (x *GeneratePatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use GeneratePatch.Set* methods instead or set the fields directly.
type GeneratePatchBuilder struct {
    obj *GeneratePatch
}

func NewGeneratePatchBuilder() *GeneratePatchBuilder {
    return &GeneratePatchBuilder{
        obj: NewGeneratePatch(),
    }
}

func (x *GeneratePatchBuilder) Emit() *GeneratePatch {
    var objCopy GeneratePatch = *x.obj
    return &objCopy
}

func (x *GeneratePatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("GeneratePatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *GeneratePatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type AssignOnlyPatch struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &AssignOnlyPatch{}


func NewAssignOnlyPatch() *AssignOnlyPatch {
    return (&AssignOnlyPatch{})
}

func (x *AssignOnlyPatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use AssignOnlyPatch.Set* methods instead or set the fields directly.
type AssignOnlyPatchBuilder struct {
    obj *AssignOnlyPatch
}

func NewAssignOnlyPatchBuilder() *AssignOnlyPatchBuilder {
    return &AssignOnlyPatchBuilder{
        obj: NewAssignOnlyPatch(),
    }
}

func (x *AssignOnlyPatchBuilder) Emit() *AssignOnlyPatch {
    var objCopy AssignOnlyPatch = *x.obj
    return &objCopy
}

func (x *AssignOnlyPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AssignOnlyPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AssignOnlyPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type BoolPatch struct {
    Assign *bool `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Invert bool `thrift:"invert,9" json:"invert" db:"invert"`
}
// Compile time interface enforcer
var _ thrift.Struct = &BoolPatch{}


func NewBoolPatch() *BoolPatch {
    return (&BoolPatch{})
}

// Deprecated: Use NewBoolPatch().Assign instead.
var BoolPatch_Assign_DEFAULT = NewBoolPatch().Assign

func (x *BoolPatch) GetAssignNonCompat() *bool {
    return x.Assign
}

func (x *BoolPatch) GetAssign() bool {
    if !x.IsSetAssign() {
      return false
    }

    return *x.Assign
}

func (x *BoolPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *BoolPatch) GetClear() bool {
    return x.Clear
}

func (x *BoolPatch) GetInvertNonCompat() bool {
    return x.Invert
}

func (x *BoolPatch) GetInvert() bool {
    return x.Invert
}

func (x *BoolPatch) SetAssign(value bool) *BoolPatch {
    x.Assign = &value
    return x
}

func (x *BoolPatch) SetClear(value bool) *BoolPatch {
    x.Clear = value
    return x
}

func (x *BoolPatch) SetInvert(value bool) *BoolPatch {
    x.Invert = value
    return x
}

func (x *BoolPatch) IsSetAssign() bool {
    return x.Assign != nil
}



func (x *BoolPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) writeField9(p thrift.Protocol) error {  // Invert
    if err := p.WriteFieldBegin("invert", thrift.BOOL, 9); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetInvertNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *BoolPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *BoolPatch) readField9(p thrift.Protocol) error {  // Invert
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetInvert(result)
    return nil
}

func (x *BoolPatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use BoolPatch.Set* methods instead or set the fields directly.
type BoolPatchBuilder struct {
    obj *BoolPatch
}

func NewBoolPatchBuilder() *BoolPatchBuilder {
    return &BoolPatchBuilder{
        obj: NewBoolPatch(),
    }
}

func (x *BoolPatchBuilder) Assign(value *bool) *BoolPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *BoolPatchBuilder) Clear(value bool) *BoolPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *BoolPatchBuilder) Invert(value bool) *BoolPatchBuilder {
    x.obj.Invert = value
    return x
}

func (x *BoolPatchBuilder) Emit() *BoolPatch {
    var objCopy BoolPatch = *x.obj
    return &objCopy
}

func (x *BoolPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("BoolPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField9(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 9:  // invert
            if err := x.readField9(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type BytePatch struct {
    Assign *byte `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add byte `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &BytePatch{}


func NewBytePatch() *BytePatch {
    return (&BytePatch{})
}

// Deprecated: Use NewBytePatch().Assign instead.
var BytePatch_Assign_DEFAULT = NewBytePatch().Assign

func (x *BytePatch) GetAssignNonCompat() *byte {
    return x.Assign
}

func (x *BytePatch) GetAssign() byte {
    if !x.IsSetAssign() {
      return 0
    }

    return *x.Assign
}

func (x *BytePatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *BytePatch) GetClear() bool {
    return x.Clear
}

func (x *BytePatch) GetAddNonCompat() byte {
    return x.Add
}

func (x *BytePatch) GetAdd() byte {
    return x.Add
}

func (x *BytePatch) SetAssign(value byte) *BytePatch {
    x.Assign = &value
    return x
}

func (x *BytePatch) SetClear(value bool) *BytePatch {
    x.Clear = value
    return x
}

func (x *BytePatch) SetAdd(value byte) *BytePatch {
    x.Add = value
    return x
}

func (x *BytePatch) IsSetAssign() bool {
    return x.Assign != nil
}



func (x *BytePatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteByte(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.BYTE, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteByte(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadByte()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *BytePatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *BytePatch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadByte()
if err != nil {
    return err
}

    x.SetAdd(result)
    return nil
}

func (x *BytePatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use BytePatch.Set* methods instead or set the fields directly.
type BytePatchBuilder struct {
    obj *BytePatch
}

func NewBytePatchBuilder() *BytePatchBuilder {
    return &BytePatchBuilder{
        obj: NewBytePatch(),
    }
}

func (x *BytePatchBuilder) Assign(value *byte) *BytePatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *BytePatchBuilder) Clear(value bool) *BytePatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *BytePatchBuilder) Add(value byte) *BytePatchBuilder {
    x.obj.Add = value
    return x
}

func (x *BytePatchBuilder) Emit() *BytePatch {
    var objCopy BytePatch = *x.obj
    return &objCopy
}

func (x *BytePatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("BytePatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type I16Patch struct {
    Assign *int16 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add int16 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &I16Patch{}


func NewI16Patch() *I16Patch {
    return (&I16Patch{})
}

// Deprecated: Use NewI16Patch().Assign instead.
var I16Patch_Assign_DEFAULT = NewI16Patch().Assign

func (x *I16Patch) GetAssignNonCompat() *int16 {
    return x.Assign
}

func (x *I16Patch) GetAssign() int16 {
    if !x.IsSetAssign() {
      return 0
    }

    return *x.Assign
}

func (x *I16Patch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *I16Patch) GetClear() bool {
    return x.Clear
}

func (x *I16Patch) GetAddNonCompat() int16 {
    return x.Add
}

func (x *I16Patch) GetAdd() int16 {
    return x.Add
}

func (x *I16Patch) SetAssign(value int16) *I16Patch {
    x.Assign = &value
    return x
}

func (x *I16Patch) SetClear(value bool) *I16Patch {
    x.Clear = value
    return x
}

func (x *I16Patch) SetAdd(value int16) *I16Patch {
    x.Add = value
    return x
}

func (x *I16Patch) IsSetAssign() bool {
    return x.Assign != nil
}



func (x *I16Patch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.I16, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.I16, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *I16Patch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *I16Patch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetAdd(result)
    return nil
}

func (x *I16Patch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use I16Patch.Set* methods instead or set the fields directly.
type I16PatchBuilder struct {
    obj *I16Patch
}

func NewI16PatchBuilder() *I16PatchBuilder {
    return &I16PatchBuilder{
        obj: NewI16Patch(),
    }
}

func (x *I16PatchBuilder) Assign(value *int16) *I16PatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *I16PatchBuilder) Clear(value bool) *I16PatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *I16PatchBuilder) Add(value int16) *I16PatchBuilder {
    x.obj.Add = value
    return x
}

func (x *I16PatchBuilder) Emit() *I16Patch {
    var objCopy I16Patch = *x.obj
    return &objCopy
}

func (x *I16Patch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("I16Patch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type I32Patch struct {
    Assign *int32 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add int32 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &I32Patch{}


func NewI32Patch() *I32Patch {
    return (&I32Patch{})
}

// Deprecated: Use NewI32Patch().Assign instead.
var I32Patch_Assign_DEFAULT = NewI32Patch().Assign

func (x *I32Patch) GetAssignNonCompat() *int32 {
    return x.Assign
}

func (x *I32Patch) GetAssign() int32 {
    if !x.IsSetAssign() {
      return 0
    }

    return *x.Assign
}

func (x *I32Patch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *I32Patch) GetClear() bool {
    return x.Clear
}

func (x *I32Patch) GetAddNonCompat() int32 {
    return x.Add
}

func (x *I32Patch) GetAdd() int32 {
    return x.Add
}

func (x *I32Patch) SetAssign(value int32) *I32Patch {
    x.Assign = &value
    return x
}

func (x *I32Patch) SetClear(value bool) *I32Patch {
    x.Clear = value
    return x
}

func (x *I32Patch) SetAdd(value int32) *I32Patch {
    x.Add = value
    return x
}

func (x *I32Patch) IsSetAssign() bool {
    return x.Assign != nil
}



func (x *I32Patch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.I32, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *I32Patch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *I32Patch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAdd(result)
    return nil
}

func (x *I32Patch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use I32Patch.Set* methods instead or set the fields directly.
type I32PatchBuilder struct {
    obj *I32Patch
}

func NewI32PatchBuilder() *I32PatchBuilder {
    return &I32PatchBuilder{
        obj: NewI32Patch(),
    }
}

func (x *I32PatchBuilder) Assign(value *int32) *I32PatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *I32PatchBuilder) Clear(value bool) *I32PatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *I32PatchBuilder) Add(value int32) *I32PatchBuilder {
    x.obj.Add = value
    return x
}

func (x *I32PatchBuilder) Emit() *I32Patch {
    var objCopy I32Patch = *x.obj
    return &objCopy
}

func (x *I32Patch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("I32Patch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type I64Patch struct {
    Assign *int64 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add int64 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &I64Patch{}


func NewI64Patch() *I64Patch {
    return (&I64Patch{})
}

// Deprecated: Use NewI64Patch().Assign instead.
var I64Patch_Assign_DEFAULT = NewI64Patch().Assign

func (x *I64Patch) GetAssignNonCompat() *int64 {
    return x.Assign
}

func (x *I64Patch) GetAssign() int64 {
    if !x.IsSetAssign() {
      return 0
    }

    return *x.Assign
}

func (x *I64Patch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *I64Patch) GetClear() bool {
    return x.Clear
}

func (x *I64Patch) GetAddNonCompat() int64 {
    return x.Add
}

func (x *I64Patch) GetAdd() int64 {
    return x.Add
}

func (x *I64Patch) SetAssign(value int64) *I64Patch {
    x.Assign = &value
    return x
}

func (x *I64Patch) SetClear(value bool) *I64Patch {
    x.Clear = value
    return x
}

func (x *I64Patch) SetAdd(value int64) *I64Patch {
    x.Add = value
    return x
}

func (x *I64Patch) IsSetAssign() bool {
    return x.Assign != nil
}



func (x *I64Patch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.I64, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *I64Patch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *I64Patch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetAdd(result)
    return nil
}

func (x *I64Patch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use I64Patch.Set* methods instead or set the fields directly.
type I64PatchBuilder struct {
    obj *I64Patch
}

func NewI64PatchBuilder() *I64PatchBuilder {
    return &I64PatchBuilder{
        obj: NewI64Patch(),
    }
}

func (x *I64PatchBuilder) Assign(value *int64) *I64PatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *I64PatchBuilder) Clear(value bool) *I64PatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *I64PatchBuilder) Add(value int64) *I64PatchBuilder {
    x.obj.Add = value
    return x
}

func (x *I64PatchBuilder) Emit() *I64Patch {
    var objCopy I64Patch = *x.obj
    return &objCopy
}

func (x *I64Patch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("I64Patch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type FloatPatch struct {
    Assign *float32 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add float32 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &FloatPatch{}


func NewFloatPatch() *FloatPatch {
    return (&FloatPatch{})
}

// Deprecated: Use NewFloatPatch().Assign instead.
var FloatPatch_Assign_DEFAULT = NewFloatPatch().Assign

func (x *FloatPatch) GetAssignNonCompat() *float32 {
    return x.Assign
}

func (x *FloatPatch) GetAssign() float32 {
    if !x.IsSetAssign() {
      return 0.0
    }

    return *x.Assign
}

func (x *FloatPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *FloatPatch) GetClear() bool {
    return x.Clear
}

func (x *FloatPatch) GetAddNonCompat() float32 {
    return x.Add
}

func (x *FloatPatch) GetAdd() float32 {
    return x.Add
}

func (x *FloatPatch) SetAssign(value float32) *FloatPatch {
    x.Assign = &value
    return x
}

func (x *FloatPatch) SetClear(value bool) *FloatPatch {
    x.Clear = value
    return x
}

func (x *FloatPatch) SetAdd(value float32) *FloatPatch {
    x.Add = value
    return x
}

func (x *FloatPatch) IsSetAssign() bool {
    return x.Assign != nil
}



func (x *FloatPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.FLOAT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteFloat(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.FLOAT, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteFloat(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadFloat()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *FloatPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *FloatPatch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadFloat()
if err != nil {
    return err
}

    x.SetAdd(result)
    return nil
}

func (x *FloatPatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use FloatPatch.Set* methods instead or set the fields directly.
type FloatPatchBuilder struct {
    obj *FloatPatch
}

func NewFloatPatchBuilder() *FloatPatchBuilder {
    return &FloatPatchBuilder{
        obj: NewFloatPatch(),
    }
}

func (x *FloatPatchBuilder) Assign(value *float32) *FloatPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *FloatPatchBuilder) Clear(value bool) *FloatPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *FloatPatchBuilder) Add(value float32) *FloatPatchBuilder {
    x.obj.Add = value
    return x
}

func (x *FloatPatchBuilder) Emit() *FloatPatch {
    var objCopy FloatPatch = *x.obj
    return &objCopy
}

func (x *FloatPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("FloatPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type DoublePatch struct {
    Assign *float64 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add float64 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DoublePatch{}


func NewDoublePatch() *DoublePatch {
    return (&DoublePatch{})
}

// Deprecated: Use NewDoublePatch().Assign instead.
var DoublePatch_Assign_DEFAULT = NewDoublePatch().Assign

func (x *DoublePatch) GetAssignNonCompat() *float64 {
    return x.Assign
}

func (x *DoublePatch) GetAssign() float64 {
    if !x.IsSetAssign() {
      return 0.0
    }

    return *x.Assign
}

func (x *DoublePatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *DoublePatch) GetClear() bool {
    return x.Clear
}

func (x *DoublePatch) GetAddNonCompat() float64 {
    return x.Add
}

func (x *DoublePatch) GetAdd() float64 {
    return x.Add
}

func (x *DoublePatch) SetAssign(value float64) *DoublePatch {
    x.Assign = &value
    return x
}

func (x *DoublePatch) SetClear(value bool) *DoublePatch {
    x.Clear = value
    return x
}

func (x *DoublePatch) SetAdd(value float64) *DoublePatch {
    x.Add = value
    return x
}

func (x *DoublePatch) IsSetAssign() bool {
    return x.Assign != nil
}



func (x *DoublePatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.DOUBLE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteDouble(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.DOUBLE, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteDouble(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadDouble()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *DoublePatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *DoublePatch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadDouble()
if err != nil {
    return err
}

    x.SetAdd(result)
    return nil
}

func (x *DoublePatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use DoublePatch.Set* methods instead or set the fields directly.
type DoublePatchBuilder struct {
    obj *DoublePatch
}

func NewDoublePatchBuilder() *DoublePatchBuilder {
    return &DoublePatchBuilder{
        obj: NewDoublePatch(),
    }
}

func (x *DoublePatchBuilder) Assign(value *float64) *DoublePatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *DoublePatchBuilder) Clear(value bool) *DoublePatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *DoublePatchBuilder) Add(value float64) *DoublePatchBuilder {
    x.obj.Add = value
    return x
}

func (x *DoublePatchBuilder) Emit() *DoublePatch {
    var objCopy DoublePatch = *x.obj
    return &objCopy
}

func (x *DoublePatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DoublePatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type StringPatch struct {
    Assign *string `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Prepend string `thrift:"prepend,8" json:"prepend" db:"prepend"`
    Append string `thrift:"append,9" json:"append" db:"append"`
}
// Compile time interface enforcer
var _ thrift.Struct = &StringPatch{}


func NewStringPatch() *StringPatch {
    return (&StringPatch{})
}

// Deprecated: Use NewStringPatch().Assign instead.
var StringPatch_Assign_DEFAULT = NewStringPatch().Assign

func (x *StringPatch) GetAssignNonCompat() *string {
    return x.Assign
}

func (x *StringPatch) GetAssign() string {
    if !x.IsSetAssign() {
      return ""
    }

    return *x.Assign
}

func (x *StringPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *StringPatch) GetClear() bool {
    return x.Clear
}

func (x *StringPatch) GetPrependNonCompat() string {
    return x.Prepend
}

func (x *StringPatch) GetPrepend() string {
    return x.Prepend
}

func (x *StringPatch) GetAppendNonCompat() string {
    return x.Append
}

func (x *StringPatch) GetAppend() string {
    return x.Append
}

func (x *StringPatch) SetAssign(value string) *StringPatch {
    x.Assign = &value
    return x
}

func (x *StringPatch) SetClear(value bool) *StringPatch {
    x.Clear = value
    return x
}

func (x *StringPatch) SetPrepend(value string) *StringPatch {
    x.Prepend = value
    return x
}

func (x *StringPatch) SetAppend(value string) *StringPatch {
    x.Append = value
    return x
}

func (x *StringPatch) IsSetAssign() bool {
    return x.Assign != nil
}




func (x *StringPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) writeField8(p thrift.Protocol) error {  // Prepend
    if err := p.WriteFieldBegin("prepend", thrift.STRING, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetPrependNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) writeField9(p thrift.Protocol) error {  // Append
    if err := p.WriteFieldBegin("append", thrift.STRING, 9); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAppendNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *StringPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *StringPatch) readField8(p thrift.Protocol) error {  // Prepend
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetPrepend(result)
    return nil
}

func (x *StringPatch) readField9(p thrift.Protocol) error {  // Append
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAppend(result)
    return nil
}

func (x *StringPatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use StringPatch.Set* methods instead or set the fields directly.
type StringPatchBuilder struct {
    obj *StringPatch
}

func NewStringPatchBuilder() *StringPatchBuilder {
    return &StringPatchBuilder{
        obj: NewStringPatch(),
    }
}

func (x *StringPatchBuilder) Assign(value *string) *StringPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *StringPatchBuilder) Clear(value bool) *StringPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *StringPatchBuilder) Prepend(value string) *StringPatchBuilder {
    x.obj.Prepend = value
    return x
}

func (x *StringPatchBuilder) Append(value string) *StringPatchBuilder {
    x.obj.Append = value
    return x
}

func (x *StringPatchBuilder) Emit() *StringPatch {
    var objCopy StringPatch = *x.obj
    return &objCopy
}

func (x *StringPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("StringPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := x.writeField9(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // prepend
            if err := x.readField8(p); err != nil {
                return err
            }
        case 9:  // append
            if err := x.readField9(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type BinaryPatch struct {
    Assign standard.ByteBuffer `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Prepend standard.ByteBuffer `thrift:"prepend,8" json:"prepend" db:"prepend"`
    Append standard.ByteBuffer `thrift:"append,9" json:"append" db:"append"`
}
// Compile time interface enforcer
var _ thrift.Struct = &BinaryPatch{}


func NewBinaryPatch() *BinaryPatch {
    return (&BinaryPatch{})
}

func (x *BinaryPatch) GetAssignNonCompat() standard.ByteBuffer {
    return x.Assign
}

func (x *BinaryPatch) GetAssign() standard.ByteBuffer {
    if !x.IsSetAssign() {
      return standard.NewByteBuffer()
    }

    return x.Assign
}

func (x *BinaryPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *BinaryPatch) GetClear() bool {
    return x.Clear
}

func (x *BinaryPatch) GetPrependNonCompat() standard.ByteBuffer {
    return x.Prepend
}

func (x *BinaryPatch) GetPrepend() standard.ByteBuffer {
    if !x.IsSetPrepend() {
      return standard.NewByteBuffer()
    }

    return x.Prepend
}

func (x *BinaryPatch) GetAppendNonCompat() standard.ByteBuffer {
    return x.Append
}

func (x *BinaryPatch) GetAppend() standard.ByteBuffer {
    if !x.IsSetAppend() {
      return standard.NewByteBuffer()
    }

    return x.Append
}

func (x *BinaryPatch) SetAssign(value standard.ByteBuffer) *BinaryPatch {
    x.Assign = value
    return x
}

func (x *BinaryPatch) SetClear(value bool) *BinaryPatch {
    x.Clear = value
    return x
}

func (x *BinaryPatch) SetPrepend(value standard.ByteBuffer) *BinaryPatch {
    x.Prepend = value
    return x
}

func (x *BinaryPatch) SetAppend(value standard.ByteBuffer) *BinaryPatch {
    x.Append = value
    return x
}

func (x *BinaryPatch) IsSetAssign() bool {
    return x.Assign != nil
}


func (x *BinaryPatch) IsSetPrepend() bool {
    return x.Prepend != nil
}

func (x *BinaryPatch) IsSetAppend() bool {
    return x.Append != nil
}

func (x *BinaryPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.BINARY, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAssignNonCompat()
    err := standard.WriteByteBuffer(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) writeField8(p thrift.Protocol) error {  // Prepend
    if !x.IsSetPrepend() {
        return nil
    }

    if err := p.WriteFieldBegin("prepend", thrift.BINARY, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetPrependNonCompat()
    err := standard.WriteByteBuffer(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) writeField9(p thrift.Protocol) error {  // Append
    if !x.IsSetAppend() {
        return nil
    }

    if err := p.WriteFieldBegin("append", thrift.BINARY, 9); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAppendNonCompat()
    err := standard.WriteByteBuffer(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := standard.ReadByteBuffer(p)
if err != nil {
    return err
}

    x.SetAssign(result)
    return nil
}

func (x *BinaryPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClear(result)
    return nil
}

func (x *BinaryPatch) readField8(p thrift.Protocol) error {  // Prepend
    result, err := standard.ReadByteBuffer(p)
if err != nil {
    return err
}

    x.SetPrepend(result)
    return nil
}

func (x *BinaryPatch) readField9(p thrift.Protocol) error {  // Append
    result, err := standard.ReadByteBuffer(p)
if err != nil {
    return err
}

    x.SetAppend(result)
    return nil
}

func (x *BinaryPatch) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use BinaryPatch.Set* methods instead or set the fields directly.
type BinaryPatchBuilder struct {
    obj *BinaryPatch
}

func NewBinaryPatchBuilder() *BinaryPatchBuilder {
    return &BinaryPatchBuilder{
        obj: NewBinaryPatch(),
    }
}

func (x *BinaryPatchBuilder) Assign(value standard.ByteBuffer) *BinaryPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *BinaryPatchBuilder) Clear(value bool) *BinaryPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *BinaryPatchBuilder) Prepend(value standard.ByteBuffer) *BinaryPatchBuilder {
    x.obj.Prepend = value
    return x
}

func (x *BinaryPatchBuilder) Append(value standard.ByteBuffer) *BinaryPatchBuilder {
    x.obj.Append = value
    return x
}

func (x *BinaryPatchBuilder) Emit() *BinaryPatch {
    var objCopy BinaryPatch = *x.obj
    return &objCopy
}

func (x *BinaryPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("BinaryPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := x.writeField9(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // prepend
            if err := x.readField8(p); err != nil {
                return err
            }
        case 9:  // append
            if err := x.readField9(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

