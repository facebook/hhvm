/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/splfile.h>
#include <php/classes/splfile.fws.h>

// Dependencies
#include <php/classes/iterator.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
namespace hphp_impl_starter {}

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
extern CallInfo ci_;
/* preface finishes */
/* SRC: classes/splfile.php line 383 */
const int64 q_SplFileObject_DROP_NEW_LINE = 1LL;
const int64 q_SplFileObject_READ_AHEAD = 2LL;
const int64 q_SplFileObject_SKIP_EMPTY = 6LL;
const int64 q_SplFileObject_READ_CSV = 8LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SplFileObject
Variant c_SplFileObject::os_getInit(CStrRef s) {
  return c_SplFileInfo::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SplFileObject
Variant c_SplFileObject::os_get(CStrRef s) {
  return c_SplFileInfo::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SplFileObject
Variant &c_SplFileObject::os_lval(CStrRef s) {
  return c_SplFileInfo::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SplFileObject
void c_SplFileObject::o_getArray(Array &props, bool pubOnly) const {
  c_SplFileInfo::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SplFileObject
void c_SplFileObject::o_setArray(CArrRef props) {
  c_SplFileInfo::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SplFileObject
Variant * c_SplFileObject::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SplFileObject
Variant * c_SplFileObject::o_realPropPublic(CStrRef s, int flags) const {
  return c_SplFileInfo::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SplFileObject
Variant * c_SplFileObject::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SplFileObject
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SplFileObject
Variant c_SplFileObject::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_RETURN(0x54B2A676B563E232LL, q_SplFileObject_SKIP_EMPTY, "SKIP_EMPTY");
      break;
    case 3:
      HASH_RETURN(0x23519E830A6DEC13LL, q_SplFileObject_READ_CSV, "READ_CSV");
      break;
    case 4:
      HASH_RETURN(0x05ABC27224BDAC64LL, q_SplFileObject_DROP_NEW_LINE, "DROP_NEW_LINE");
      break;
    case 6:
      HASH_RETURN(0x6ABD9DCA7D94431ELL, q_SplFileObject_READ_AHEAD, "READ_AHEAD");
      break;
    default:
      break;
  }
  return c_SplFileInfo::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SplFileObject
IMPLEMENT_CLASS(SplFileObject)
bool c_SplFileObject::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 2:
      HASH_INSTANCEOF(0x297ECCC7A259EDD2LL, NAMSTR(s_sys_ss5d909898, "SplFileObject"));
      break;
    case 3:
      HASH_INSTANCEOF(0x191964700AF036D3LL, NAMSTR(s_sys_ss49963173, "RecursiveIterator"));
      HASH_INSTANCEOF(0x60C47E7FE145DC43LL, NAMSTR(s_sys_ssc1c38583, "SeekableIterator"));
      break;
    case 7:
      HASH_INSTANCEOF(0x71089C29FE923FA7LL, NAMSTR(s_sys_ss914a58e9, "SplFileInfo"));
      break;
    case 14:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_SplFileObject::cloneImpl() {
  c_SplFileObject *obj = NEWOBJ(c_SplFileObject)();
  c_SplFileObject::cloneSet(obj);
  return obj;
}
void c_SplFileObject::cloneSet(ObjectData *cl) {
  c_SplFileObject *clone = static_cast<c_SplFileObject*>(cl);
  c_SplFileInfo::cloneSet(clone);
}
Variant c_SplFileObject::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x09637D7CA2E33F00LL, NAMSTR(s_sys_sse27b119d, "fgetc")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x5ACCF9166CD9D043LL, NAMSTR(s_sys_ss8d73fd51, "ftruncate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        return (t_ftruncate(a0));
      }
      HASH_GUARD_LITSTR(0x794FAFD4412AEFC3LL, NAMSTR(s_sys_sse73b3a2c, "eof")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss9943cbf4, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x44CE4DB1CE7E9F86LL, NAMSTR(s_sys_ss4ccc4d04, "flock")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = ref(params[i]->refval(env));
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        return (t_flock(a0, ref(a1)));
      }
      break;
    case 9:
      HASH_GUARD_LITSTR(0x4282E0231F600049LL, NAMSTR(s_sys_ssbac40e3d, "fseek")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        return (t_fseek(a0, a1));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2FC3A6941D522E0ALL, NAMSTR(s_sys_ss1fa5c668, "setFlags")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        return (t_setflags(a0), null);
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7E978C38D741664ELL, NAMSTR(s_sys_ss15a9d310, "fgetcsv")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a2 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        if (count <= 0) return (t_fgetcsv());
        else if (count == 1) return (t_fgetcsv(a0));
        else if (count == 2) return (t_fgetcsv(a0, a1));
        else return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x732EC1BDA8EC520FLL, NAMSTR(s_sys_ss68d731f7, "getChildren")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x3A335010F905ACD0LL, NAMSTR(s_sys_ss7165f45b, "setCsvControl")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a2 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        if (count <= 0) return (t_setcsvcontrol(), null);
        else if (count == 1) return (t_setcsvcontrol(a0), null);
        else if (count == 2) return (t_setcsvcontrol(a0, a1), null);
        else return (t_setcsvcontrol(a0, a1, a2), null);
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x40044334DA397C15LL, NAMSTR(s_sys_ssf6be66f9, "hasChildren")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x25F68E7910FE9CDALL, NAMSTR(s_sys_sse8a6ad69, "getMaxLineLen")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      HASH_GUARD_LITSTR(0x2B7CAC006AF27F9ALL, NAMSTR(s_sys_ss96f7c57c, "fflush")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x5B33B55D4B7E339BLL, NAMSTR(s_sys_ss764ad06c, "fpassthru")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ssb3a5c1b3, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3E4E7C561D3A541ELL, NAMSTR(s_sys_ss6677e6df, "fgetss")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        return (t_fgetss(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a2 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a3 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x27E7DBA875AD17E1LL, NAMSTR(s_sys_ssa20217b5, "getFlags")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x6FE9F691E4A6D962LL, NAMSTR(s_sys_ss3bdd1f72, "getCsvControl")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x044B276686B77923LL, NAMSTR(s_sys_ss26e41480, "fscanf")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        Array vargs;
        for (; i != params.size(); ++i) {
          vargs.append(params[i]->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("SplFileObject::fscanf", count+1, 1);
        if (count <= 1) return (t_fscanf(count, a0));
        return (t_fscanf(count, a0,vargs));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x05D72365192CE465LL, NAMSTR(s_sys_ssf5eb6fb9, "fwrite")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        return (t_fwrite(a0, a1));
      }
      break;
    case 39:
      HASH_GUARD_LITSTR(0x7EF5445C77054C67LL, NAMSTR(s_sys_ss6a9626a3, "seek")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        return (t_seek(a0), null);
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss941ca25f, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind(), null);
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x1C1216F2B7C16CADLL, NAMSTR(s_sys_ssd0eae9b1, "ftell")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7AE1BE187F18FDF3LL, NAMSTR(s_sys_ssac2b8cd6, "fgets")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4CEC6AA30E43D437LL, NAMSTR(s_sys_ssb30ca8a5, "setMaxLineLen")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        return (t_setmaxlinelen(a0), null);
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next(), null);
      }
      HASH_GUARD_LITSTR(0x0890F9052322E838LL, NAMSTR(s_sys_ss6bb66679, "fstat")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    default:
      break;
  }
  return c_SplFileInfo::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SplFileObject::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_SplFileInfo::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SplFileObject::ci_fscanf((void*)&c_SplFileObject::i_fscanf, (void*)&c_SplFileObject::ifa_fscanf, 1, 5, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_next((void*)&c_SplFileObject::i_next, (void*)&c_SplFileObject::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fseek((void*)&c_SplFileObject::i_fseek, (void*)&c_SplFileObject::ifa_fseek, 2, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_key((void*)&c_SplFileObject::i_key, (void*)&c_SplFileObject::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fgetss((void*)&c_SplFileObject::i_fgetss, (void*)&c_SplFileObject::ifa_fgetss, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fgetcsv((void*)&c_SplFileObject::i_fgetcsv, (void*)&c_SplFileObject::ifa_fgetcsv, 3, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_valid((void*)&c_SplFileObject::i_valid, (void*)&c_SplFileObject::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_setcsvcontrol((void*)&c_SplFileObject::i_setcsvcontrol, (void*)&c_SplFileObject::ifa_setcsvcontrol, 3, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_getcsvcontrol((void*)&c_SplFileObject::i_getcsvcontrol, (void*)&c_SplFileObject::ifa_getcsvcontrol, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_setflags((void*)&c_SplFileObject::i_setflags, (void*)&c_SplFileObject::ifa_setflags, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci___construct((void*)&c_SplFileObject::i___construct, (void*)&c_SplFileObject::ifa___construct, 4, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_setmaxlinelen((void*)&c_SplFileObject::i_setmaxlinelen, (void*)&c_SplFileObject::ifa_setmaxlinelen, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_getmaxlinelen((void*)&c_SplFileObject::i_getmaxlinelen, (void*)&c_SplFileObject::ifa_getmaxlinelen, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_ftruncate((void*)&c_SplFileObject::i_ftruncate, (void*)&c_SplFileObject::ifa_ftruncate, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fflush((void*)&c_SplFileObject::i_fflush, (void*)&c_SplFileObject::ifa_fflush, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_eof((void*)&c_SplFileObject::i_eof, (void*)&c_SplFileObject::ifa_eof, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fgetc((void*)&c_SplFileObject::i_fgetc, (void*)&c_SplFileObject::ifa_fgetc, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fpassthru((void*)&c_SplFileObject::i_fpassthru, (void*)&c_SplFileObject::ifa_fpassthru, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_haschildren((void*)&c_SplFileObject::i_haschildren, (void*)&c_SplFileObject::ifa_haschildren, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fgets((void*)&c_SplFileObject::i_fgets, (void*)&c_SplFileObject::ifa_fgets, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_seek((void*)&c_SplFileObject::i_seek, (void*)&c_SplFileObject::ifa_seek, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_flock((void*)&c_SplFileObject::i_flock, (void*)&c_SplFileObject::ifa_flock, 2, 4, 0x0000000000000002LL);
CallInfo c_SplFileObject::ci_getflags((void*)&c_SplFileObject::i_getflags, (void*)&c_SplFileObject::ifa_getflags, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_getchildren((void*)&c_SplFileObject::i_getchildren, (void*)&c_SplFileObject::ifa_getchildren, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_current((void*)&c_SplFileObject::i_current, (void*)&c_SplFileObject::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fwrite((void*)&c_SplFileObject::i_fwrite, (void*)&c_SplFileObject::ifa_fwrite, 2, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_ftell((void*)&c_SplFileObject::i_ftell, (void*)&c_SplFileObject::ifa_ftell, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_fstat((void*)&c_SplFileObject::i_fstat, (void*)&c_SplFileObject::ifa_fstat, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileObject::ci_rewind((void*)&c_SplFileObject::i_rewind, (void*)&c_SplFileObject::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_SplFileObject::i_fscanf(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("SplFileObject::fscanf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    const Array &p(count > 1 ? params.slice(1, count - 1, false) : Array());
    return (self->t_fscanf(count, arg0, p));
  }
}
Variant c_SplFileObject::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_SplFileObject::i_fseek(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fseek(arg0, arg1));
  }
}
Variant c_SplFileObject::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
  return (self->t_key());
}
Variant c_SplFileObject::i_fgetss(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_fgetss(arg0));
  }
}
Variant c_SplFileObject::i_fgetcsv(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fgetcsv());
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_fgetcsv(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_fgetcsv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fgetcsv(arg0, arg1, arg2));
  }
}
Variant c_SplFileObject::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
  return (self->t_valid());
}
Variant c_SplFileObject::i_setcsvcontrol(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_setcsvcontrol(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setcsvcontrol(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_setcsvcontrol(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setcsvcontrol(arg0, arg1, arg2), null);
  }
}
Variant c_SplFileObject::i_getcsvcontrol(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
  return (self->t_getcsvcontrol());
}
Variant c_SplFileObject::i_setflags(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setflags(arg0), null);
  }
}
Variant c_SplFileObject::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3), null);
  }
}
Variant c_SplFileObject::i_setmaxlinelen(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setmaxlinelen(arg0), null);
  }
}
Variant c_SplFileObject::i_getmaxlinelen(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
  return (self->t_getmaxlinelen());
}
Variant c_SplFileObject::i_ftruncate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_ftruncate(arg0));
  }
}
Variant c_SplFileObject::i_fflush(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
  return (self->t_fflush());
}
Variant c_SplFileObject::i_eof(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
  return (self->t_eof());
}
Variant c_SplFileObject::i_fgetc(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
  return (self->t_fgetc());
}
Variant c_SplFileObject::i_fpassthru(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
  return (self->t_fpassthru());
}
Variant c_SplFileObject::i_haschildren(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
  return (self->t_haschildren());
}
Variant c_SplFileObject::i_fgets(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
  return (self->t_fgets());
}
Variant c_SplFileObject::i_seek(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_seek(arg0), null);
  }
}
Variant c_SplFileObject::i_flock(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (self->t_flock(arg0, arg1));
  }
}
Variant c_SplFileObject::i_getflags(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
  return (self->t_getflags());
}
Variant c_SplFileObject::i_getchildren(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
  return (self->t_getchildren());
}
Variant c_SplFileObject::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
  return (self->t_current());
}
Variant c_SplFileObject::i_fwrite(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fwrite(arg0, arg1));
  }
}
Variant c_SplFileObject::i_ftell(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
  return (self->t_ftell());
}
Variant c_SplFileObject::i_fstat(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
  return (self->t_fstat());
}
Variant c_SplFileObject::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_SplFileObject::ifa_fscanf(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("SplFileObject::fscanf", count+1, 1);
  CVarRef arg0((a0));
  Array p;
  if (count >= 2) p.append(a1);
  if (count >= 3) p.append(a2);
  if (count >= 4) p.append(a3);
  if (count >= 5) p.append(a4);
  if (count >= 6) p.append(a5);
  return (self->t_fscanf(count, arg0, p));
}
Variant c_SplFileObject::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_SplFileObject::ifa_fseek(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
  CVarRef arg0((a0));
  CVarRef arg1((a1));
  return (self->t_fseek(arg0, arg1));
}
Variant c_SplFileObject::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
  return (self->t_key());
}
Variant c_SplFileObject::ifa_fgetss(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_fgetss(arg0));
}
Variant c_SplFileObject::ifa_fgetcsv(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
  if (count <= 0) return (self->t_fgetcsv());
  CVarRef arg0((a0));
  if (count <= 1) return (self->t_fgetcsv(arg0));
  CVarRef arg1((a1));
  if (count <= 2) return (self->t_fgetcsv(arg0, arg1));
  CVarRef arg2((a2));
  return (self->t_fgetcsv(arg0, arg1, arg2));
}
Variant c_SplFileObject::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
  return (self->t_valid());
}
Variant c_SplFileObject::ifa_setcsvcontrol(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
  if (count <= 0) return (self->t_setcsvcontrol(), null);
  CVarRef arg0((a0));
  if (count <= 1) return (self->t_setcsvcontrol(arg0), null);
  CVarRef arg1((a1));
  if (count <= 2) return (self->t_setcsvcontrol(arg0, arg1), null);
  CVarRef arg2((a2));
  return (self->t_setcsvcontrol(arg0, arg1, arg2), null);
}
Variant c_SplFileObject::ifa_getcsvcontrol(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
  return (self->t_getcsvcontrol());
}
Variant c_SplFileObject::ifa_setflags(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_setflags(arg0), null);
}
Variant c_SplFileObject::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
  CVarRef arg0((a0));
  if (count <= 1) return (self->t___construct(arg0), null);
  CVarRef arg1((a1));
  if (count <= 2) return (self->t___construct(arg0, arg1), null);
  CVarRef arg2((a2));
  if (count <= 3) return (self->t___construct(arg0, arg1, arg2), null);
  CVarRef arg3((a3));
  return (self->t___construct(arg0, arg1, arg2, arg3), null);
}
Variant c_SplFileObject::ifa_setmaxlinelen(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_setmaxlinelen(arg0), null);
}
Variant c_SplFileObject::ifa_getmaxlinelen(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
  return (self->t_getmaxlinelen());
}
Variant c_SplFileObject::ifa_ftruncate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_ftruncate(arg0));
}
Variant c_SplFileObject::ifa_fflush(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
  return (self->t_fflush());
}
Variant c_SplFileObject::ifa_eof(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
  return (self->t_eof());
}
Variant c_SplFileObject::ifa_fgetc(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
  return (self->t_fgetc());
}
Variant c_SplFileObject::ifa_fpassthru(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
  return (self->t_fpassthru());
}
Variant c_SplFileObject::ifa_haschildren(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
  return (self->t_haschildren());
}
Variant c_SplFileObject::ifa_fgets(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
  return (self->t_fgets());
}
Variant c_SplFileObject::ifa_seek(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_seek(arg0), null);
}
Variant c_SplFileObject::ifa_flock(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
  CVarRef arg0((a0));
  CVarRef arg1(ref(a1));
  return (self->t_flock(arg0, arg1));
}
Variant c_SplFileObject::ifa_getflags(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
  return (self->t_getflags());
}
Variant c_SplFileObject::ifa_getchildren(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
  return (self->t_getchildren());
}
Variant c_SplFileObject::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
  return (self->t_current());
}
Variant c_SplFileObject::ifa_fwrite(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
  CVarRef arg0((a0));
  CVarRef arg1((a1));
  return (self->t_fwrite(arg0, arg1));
}
Variant c_SplFileObject::ifa_ftell(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
  return (self->t_ftell());
}
Variant c_SplFileObject::ifa_fstat(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
  return (self->t_fstat());
}
Variant c_SplFileObject::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileObject *self = NULL;
  p_SplFileObject pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileObject*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
  return (self->t_rewind(), null);
}
bool c_SplFileObject::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x09637D7CA2E33F00LL, NAMSTR(s_sys_sse27b119d, "fgetc")) {
        mcp.ci = &c_SplFileObject::ci_fgetc;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x5ACCF9166CD9D043LL, NAMSTR(s_sys_ss8d73fd51, "ftruncate")) {
        mcp.ci = &c_SplFileObject::ci_ftruncate;
        return true;
      }
      HASH_GUARD_LITSTR(0x794FAFD4412AEFC3LL, NAMSTR(s_sys_sse73b3a2c, "eof")) {
        mcp.ci = &c_SplFileObject::ci_eof;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss9943cbf4, "valid")) {
        mcp.ci = &c_SplFileObject::ci_valid;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x44CE4DB1CE7E9F86LL, NAMSTR(s_sys_ss4ccc4d04, "flock")) {
        mcp.ci = &c_SplFileObject::ci_flock;
        return true;
      }
      break;
    case 9:
      HASH_GUARD_LITSTR(0x4282E0231F600049LL, NAMSTR(s_sys_ssbac40e3d, "fseek")) {
        mcp.ci = &c_SplFileObject::ci_fseek;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2FC3A6941D522E0ALL, NAMSTR(s_sys_ss1fa5c668, "setFlags")) {
        mcp.ci = &c_SplFileObject::ci_setflags;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7E978C38D741664ELL, NAMSTR(s_sys_ss15a9d310, "fgetcsv")) {
        mcp.ci = &c_SplFileObject::ci_fgetcsv;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x732EC1BDA8EC520FLL, NAMSTR(s_sys_ss68d731f7, "getChildren")) {
        mcp.ci = &c_SplFileObject::ci_getchildren;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x3A335010F905ACD0LL, NAMSTR(s_sys_ss7165f45b, "setCsvControl")) {
        mcp.ci = &c_SplFileObject::ci_setcsvcontrol;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        mcp.ci = &c_SplFileObject::ci_key;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x40044334DA397C15LL, NAMSTR(s_sys_ssf6be66f9, "hasChildren")) {
        mcp.ci = &c_SplFileObject::ci_haschildren;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x25F68E7910FE9CDALL, NAMSTR(s_sys_sse8a6ad69, "getMaxLineLen")) {
        mcp.ci = &c_SplFileObject::ci_getmaxlinelen;
        return true;
      }
      HASH_GUARD_LITSTR(0x2B7CAC006AF27F9ALL, NAMSTR(s_sys_ss96f7c57c, "fflush")) {
        mcp.ci = &c_SplFileObject::ci_fflush;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x5B33B55D4B7E339BLL, NAMSTR(s_sys_ss764ad06c, "fpassthru")) {
        mcp.ci = &c_SplFileObject::ci_fpassthru;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ssb3a5c1b3, "current")) {
        mcp.ci = &c_SplFileObject::ci_current;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3E4E7C561D3A541ELL, NAMSTR(s_sys_ss6677e6df, "fgetss")) {
        mcp.ci = &c_SplFileObject::ci_fgetss;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        mcp.ci = &c_SplFileObject::ci___construct;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x27E7DBA875AD17E1LL, NAMSTR(s_sys_ssa20217b5, "getFlags")) {
        mcp.ci = &c_SplFileObject::ci_getflags;
        return true;
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x6FE9F691E4A6D962LL, NAMSTR(s_sys_ss3bdd1f72, "getCsvControl")) {
        mcp.ci = &c_SplFileObject::ci_getcsvcontrol;
        return true;
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x044B276686B77923LL, NAMSTR(s_sys_ss26e41480, "fscanf")) {
        mcp.ci = &c_SplFileObject::ci_fscanf;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x05D72365192CE465LL, NAMSTR(s_sys_ssf5eb6fb9, "fwrite")) {
        mcp.ci = &c_SplFileObject::ci_fwrite;
        return true;
      }
      break;
    case 39:
      HASH_GUARD_LITSTR(0x7EF5445C77054C67LL, NAMSTR(s_sys_ss6a9626a3, "seek")) {
        mcp.ci = &c_SplFileObject::ci_seek;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss941ca25f, "rewind")) {
        mcp.ci = &c_SplFileObject::ci_rewind;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x1C1216F2B7C16CADLL, NAMSTR(s_sys_ssd0eae9b1, "ftell")) {
        mcp.ci = &c_SplFileObject::ci_ftell;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7AE1BE187F18FDF3LL, NAMSTR(s_sys_ssac2b8cd6, "fgets")) {
        mcp.ci = &c_SplFileObject::ci_fgets;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4CEC6AA30E43D437LL, NAMSTR(s_sys_ssb30ca8a5, "setMaxLineLen")) {
        mcp.ci = &c_SplFileObject::ci_setmaxlinelen;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        mcp.ci = &c_SplFileObject::ci_next;
        return true;
      }
      HASH_GUARD_LITSTR(0x0890F9052322E838LL, NAMSTR(s_sys_ss6bb66679, "fstat")) {
        mcp.ci = &c_SplFileObject::ci_fstat;
        return true;
      }
      break;
    default:
      break;
  }
  return c_SplFileInfo::os_get_call_info(mcp, hash);
}
bool c_SplFileObject::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SplFileObject *c_SplFileObject::create(Variant v_filename, Variant v_open_mode //  = NAMSTR(s_sys_ss0d42ecf6, "r")
, Variant v_use_include_path //  = false
, Variant v_context //  = null
) {
  CountableHelper h(this);
  init();
  t___construct(v_filename, v_open_mode, v_use_include_path, v_context);
  return this;
}
void c_SplFileObject::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_SplFileObject::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SplFileObject::ci___construct;
  mcp.obj = this;
}
void c_SplFileObject::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  unsigned int i = 0;
  do {
    if (i == params.size()) break;
    a0 = params[i]->eval(env);
    i++;
    if (i == params.size()) break;
    a1 = params[i]->eval(env);
    i++;
    if (i == params.size()) break;
    a2 = params[i]->eval(env);
    i++;
    if (i == params.size()) break;
    a3 = params[i]->eval(env);
    i++;
  } while(false);
  for (; i != params.size(); ++i) {
    params[i]->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 1);
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
struct ObjectStaticCallbacks cw_SplFileObject = {
  c_SplFileObject::os_getInit,
  c_SplFileObject::os_get,
  c_SplFileObject::os_lval,
  c_SplFileObject::os_invoke,
  c_SplFileObject::os_constant,
  c_SplFileObject::os_get_call_info
};
void c_SplFileObject::init() {
  c_SplFileInfo::init();
}
/* SRC: classes/splfile.php line 391 */
void c_SplFileObject::t___construct(Variant v_filename, Variant v_open_mode //  = NAMSTR(s_sys_ss0d42ecf6, "r")
, Variant v_use_include_path //  = false
, Variant v_context //  = null
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::__construct);
  bool oldInCtor = gasInCtor(true);
  x_hphp_splfileobject___construct(GET_THIS_TYPED(SplFileObject), toString(v_filename), toString(v_open_mode), toBoolean(v_use_include_path), v_context);
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 409 */
Variant c_SplFileObject::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::current);
  return x_hphp_splfileobject_current(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 421 */
bool c_SplFileObject::t_eof() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::eof);
  return x_hphp_splfileobject_eof(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 433 */
bool c_SplFileObject::t_fflush() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fflush);
  return x_hphp_splfileobject_fflush(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 451 */
String c_SplFileObject::t_fgetc() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetc);
  return x_hphp_splfileobject_fgetc(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 481 */
Variant c_SplFileObject::t_fgetcsv(CVarRef v_delimiter //  = NAMSTR(s_sys_ssd332baa7, ",")
, CVarRef v_enclosure //  = NAMSTR(s_sys_ss7e5fc106, "\"")
, CVarRef v_escape //  = NAMSTR(s_sys_ssd59e789f, "\\")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetcsv);
  return x_hphp_splfileobject_fgetcsv(GET_THIS_TYPED(SplFileObject), toString(v_delimiter), toString(v_enclosure), toString(v_escape));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 496 */
String c_SplFileObject::t_fgets() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgets);
  return x_hphp_splfileobject_fgets(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 516 */
String c_SplFileObject::t_fgetss(CVarRef v_allowable_tags) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetss);
  return x_hphp_splfileobject_fgetss(GET_THIS_TYPED(SplFileObject), toString(v_allowable_tags));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 536 */
bool c_SplFileObject::t_flock(CVarRef v_operation, Variant v_wouldblock) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::flock);
  return x_hphp_splfileobject_flock(GET_THIS_TYPED(SplFileObject), ref(v_wouldblock));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 554 */
int64 c_SplFileObject::t_fpassthru() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fpassthru);
  return x_hphp_splfileobject_fpassthru(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 578 */
Variant c_SplFileObject::t_fscanf(int num_args, CVarRef v_format, Array args /* = Array() */) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fscanf);
  int v_argc = 0;
  Array v_argv;

  {
    int tmp0((num_args));
    v_argc = tmp0;
  }
  {
    const Array &tmp0((func_get_args(num_args, Array(ArrayInit(1, true).set(v_format).create()),args)));
    v_argv = tmp0;
  }
  return x_hphp_splfileobject_fscanf(toInt64(v_argc), GET_THIS_TYPED(SplFileObject), toString(v_format), VarNR(v_argv));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 606 */
int64 c_SplFileObject::t_fseek(CVarRef v_offset, CVarRef v_whence) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fseek);
  return x_hphp_splfileobject_fseek(GET_THIS_TYPED(SplFileObject), toInt64(v_offset), toInt64(v_whence));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 620 */
Variant c_SplFileObject::t_fstat() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fstat);
  return x_hphp_splfileobject_fstat(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 634 */
int64 c_SplFileObject::t_ftell() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::ftell);
  return x_hphp_splfileobject_ftell(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 654 */
bool c_SplFileObject::t_ftruncate(CVarRef v_size) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::ftruncate);
  return x_hphp_splfileobject_ftruncate(GET_THIS_TYPED(SplFileObject), toInt64(v_size));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 672 */
int64 c_SplFileObject::t_fwrite(CVarRef v_str, CVarRef v_length) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fwrite);
  return x_hphp_splfileobject_fwrite(GET_THIS_TYPED(SplFileObject), toString(v_str), toInt64(v_length));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 684 */
Variant c_SplFileObject::t_getchildren() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getChildren);
  return null;
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 698 */
Variant c_SplFileObject::t_getcsvcontrol() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getCsvControl);
  return x_hphp_splfileobject_getcvscontrol(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 710 */
int64 c_SplFileObject::t_getflags() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getFlags);
  return x_hphp_splfileobject_getflags(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 724 */
int64 c_SplFileObject::t_getmaxlinelen() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getMaxLineLen);
  return x_hphp_splfileobject_getmaxlinelen(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 737 */
bool c_SplFileObject::t_haschildren() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::hasChildren);
  return false;
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 753 */
int64 c_SplFileObject::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::key);
  return x_hphp_splfileobject_key(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 765 */
void c_SplFileObject::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::next);
  x_hphp_splfileobject_next(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 777 */
void c_SplFileObject::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::rewind);
  x_hphp_splfileobject_rewind(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 791 */
void c_SplFileObject::t_seek(CVarRef v_line_pos) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::seek);
  x_hphp_splfileobject_seek(GET_THIS_TYPED(SplFileObject), toInt64(v_line_pos));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 808 */
void c_SplFileObject::t_setcsvcontrol(CVarRef v_delimiter //  = NAMSTR(s_sys_ssd332baa7, ",")
, CVarRef v_enclosure //  = NAMSTR(s_sys_ss7e5fc106, "\"")
, CVarRef v_escape //  = NAMSTR(s_sys_ssd59e789f, "\\")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setCsvControl);
  x_hphp_splfileobject_setcsvcontrol(GET_THIS_TYPED(SplFileObject), toString(v_delimiter), toString(v_enclosure), toString(v_escape));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 824 */
void c_SplFileObject::t_setflags(CVarRef v_flags) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setFlags);
  x_hphp_splfileobject_setflags(GET_THIS_TYPED(SplFileObject), toInt64(v_flags));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 839 */
void c_SplFileObject::t_setmaxlinelen(CVarRef v_max_len) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setMaxLineLen);
  x_hphp_splfileobject_setmaxlinelen(GET_THIS_TYPED(SplFileObject), toInt64(v_max_len));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 851 */
bool c_SplFileObject::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::valid);
  return x_hphp_splfileobject_valid(GET_THIS_TYPED(SplFileObject));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 11 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SplFileInfo
Variant c_SplFileInfo::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SplFileInfo
Variant c_SplFileInfo::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SplFileInfo
Variant &c_SplFileInfo::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SplFileInfo
void c_SplFileInfo::o_getArray(Array &props, bool pubOnly) const {
  c_ObjectData::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SplFileInfo
void c_SplFileInfo::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SplFileInfo
Variant * c_SplFileInfo::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SplFileInfo
Variant * c_SplFileInfo::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SplFileInfo
Variant * c_SplFileInfo::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SplFileInfo
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SplFileInfo
Variant c_SplFileInfo::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SplFileInfo
IMPLEMENT_CLASS(SplFileInfo)
bool c_SplFileInfo::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_INSTANCEOF(0x71089C29FE923FA7LL, NAMSTR(s_sys_ss914a58e9, "SplFileInfo"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_SplFileInfo::cloneImpl() {
  c_SplFileInfo *obj = NEWOBJ(c_SplFileInfo)();
  c_SplFileInfo::cloneSet(obj);
  return obj;
}
void c_SplFileInfo::cloneSet(ObjectData *cl) {
  c_SplFileInfo *clone = static_cast<c_SplFileInfo*>(cl);
  ObjectData::cloneSet(clone);
}
Variant c_SplFileInfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 5:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss4db221b9, "setInfoClass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass(), null);
        else return (t_setinfoclass(a0), null);
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ssb122eff8, "getRealPath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ssfc2d4779, "getType")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss95821704, "isDir")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ssf578e813, "getInode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss077ab997, "getFilename")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss8b50e6c9, "getOwner")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss11bc49d2, "isReadable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6974a1cc, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ssea00c58c, "isLink")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss7d1afda2, "getBasename")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ssc09df55f, "isFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ssb1c4aa6f, "getATime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss9a04b6ca, "isWritable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5ef289b7, "setFileClass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass(), null);
        else return (t_setfileclass(a0), null);
      }
      break;
    case 39:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss135934b0, "getPathInfo")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss1863b3c7, "getGroup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss2a6293f6, "getSize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss90f68f81, "getLinkTarget")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss45739f33, "getCTime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss94213325, "getMTime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ssf99443fd, "openFile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a2 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss164363b4, "getPathname")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ssa9a8d951, "isExecutable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss49fef19f, "getPerms")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss0c3a6c4a, "getPath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss9fa37b08, "getFileInfo")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SplFileInfo::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SplFileInfo::ci_getperms((void*)&c_SplFileInfo::i_getperms, (void*)&c_SplFileInfo::ifa_getperms, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_iswritable((void*)&c_SplFileInfo::i_iswritable, (void*)&c_SplFileInfo::ifa_iswritable, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getbasename((void*)&c_SplFileInfo::i_getbasename, (void*)&c_SplFileInfo::ifa_getbasename, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getpathname((void*)&c_SplFileInfo::i_getpathname, (void*)&c_SplFileInfo::ifa_getpathname, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getgroup((void*)&c_SplFileInfo::i_getgroup, (void*)&c_SplFileInfo::ifa_getgroup, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_setfileclass((void*)&c_SplFileInfo::i_setfileclass, (void*)&c_SplFileInfo::ifa_setfileclass, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_setinfoclass((void*)&c_SplFileInfo::i_setinfoclass, (void*)&c_SplFileInfo::ifa_setinfoclass, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci___tostring((void*)&c_SplFileInfo::i___tostring, (void*)&c_SplFileInfo::ifa___tostring, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getlinktarget((void*)&c_SplFileInfo::i_getlinktarget, (void*)&c_SplFileInfo::ifa_getlinktarget, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_isreadable((void*)&c_SplFileInfo::i_isreadable, (void*)&c_SplFileInfo::ifa_isreadable, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getrealpath((void*)&c_SplFileInfo::i_getrealpath, (void*)&c_SplFileInfo::ifa_getrealpath, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci___construct((void*)&c_SplFileInfo::i___construct, (void*)&c_SplFileInfo::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getpathinfo((void*)&c_SplFileInfo::i_getpathinfo, (void*)&c_SplFileInfo::ifa_getpathinfo, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getctime((void*)&c_SplFileInfo::i_getctime, (void*)&c_SplFileInfo::ifa_getctime, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getpath((void*)&c_SplFileInfo::i_getpath, (void*)&c_SplFileInfo::ifa_getpath, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getinode((void*)&c_SplFileInfo::i_getinode, (void*)&c_SplFileInfo::ifa_getinode, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_islink((void*)&c_SplFileInfo::i_islink, (void*)&c_SplFileInfo::ifa_islink, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getsize((void*)&c_SplFileInfo::i_getsize, (void*)&c_SplFileInfo::ifa_getsize, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_isfile((void*)&c_SplFileInfo::i_isfile, (void*)&c_SplFileInfo::ifa_isfile, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getfilename((void*)&c_SplFileInfo::i_getfilename, (void*)&c_SplFileInfo::ifa_getfilename, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getowner((void*)&c_SplFileInfo::i_getowner, (void*)&c_SplFileInfo::ifa_getowner, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getmtime((void*)&c_SplFileInfo::i_getmtime, (void*)&c_SplFileInfo::ifa_getmtime, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_isdir((void*)&c_SplFileInfo::i_isdir, (void*)&c_SplFileInfo::ifa_isdir, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getfileinfo((void*)&c_SplFileInfo::i_getfileinfo, (void*)&c_SplFileInfo::ifa_getfileinfo, 1, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_isexecutable((void*)&c_SplFileInfo::i_isexecutable, (void*)&c_SplFileInfo::ifa_isexecutable, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_getatime((void*)&c_SplFileInfo::i_getatime, (void*)&c_SplFileInfo::ifa_getatime, 0, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_openfile((void*)&c_SplFileInfo::i_openfile, (void*)&c_SplFileInfo::ifa_openfile, 3, 4, 0x0000000000000000LL);
CallInfo c_SplFileInfo::ci_gettype((void*)&c_SplFileInfo::i_gettype, (void*)&c_SplFileInfo::ifa_gettype, 0, 4, 0x0000000000000000LL);
Variant c_SplFileInfo::i_getperms(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
  return (self->t_getperms());
}
Variant c_SplFileInfo::i_iswritable(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
  return (self->t_iswritable());
}
Variant c_SplFileInfo::i_getbasename(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getbasename());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getbasename(arg0));
  }
}
Variant c_SplFileInfo::i_getpathname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
  return (self->t_getpathname());
}
Variant c_SplFileInfo::i_getgroup(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
  return (self->t_getgroup());
}
Variant c_SplFileInfo::i_setfileclass(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_setfileclass(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setfileclass(arg0), null);
  }
}
Variant c_SplFileInfo::i_setinfoclass(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_setinfoclass(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setinfoclass(arg0), null);
  }
}
Variant c_SplFileInfo::i___tostring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
  return (self->t___tostring());
}
Variant c_SplFileInfo::i_getlinktarget(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
  return (self->t_getlinktarget());
}
Variant c_SplFileInfo::i_isreadable(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
  return (self->t_isreadable());
}
Variant c_SplFileInfo::i_getrealpath(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
  return (self->t_getrealpath());
}
Variant c_SplFileInfo::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_SplFileInfo::i_getpathinfo(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getpathinfo());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getpathinfo(arg0));
  }
}
Variant c_SplFileInfo::i_getctime(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
  return (self->t_getctime());
}
Variant c_SplFileInfo::i_getpath(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
  return (self->t_getpath());
}
Variant c_SplFileInfo::i_getinode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
  return (self->t_getinode());
}
Variant c_SplFileInfo::i_islink(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
  return (self->t_islink());
}
Variant c_SplFileInfo::i_getsize(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
  return (self->t_getsize());
}
Variant c_SplFileInfo::i_isfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
  return (self->t_isfile());
}
Variant c_SplFileInfo::i_getfilename(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
  return (self->t_getfilename());
}
Variant c_SplFileInfo::i_getowner(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
  return (self->t_getowner());
}
Variant c_SplFileInfo::i_getmtime(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
  return (self->t_getmtime());
}
Variant c_SplFileInfo::i_isdir(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
  return (self->t_isdir());
}
Variant c_SplFileInfo::i_getfileinfo(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getfileinfo());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getfileinfo(arg0));
  }
}
Variant c_SplFileInfo::i_isexecutable(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
  return (self->t_isexecutable());
}
Variant c_SplFileInfo::i_getatime(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
  return (self->t_getatime());
}
Variant c_SplFileInfo::i_openfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_openfile());
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_openfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_openfile(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_openfile(arg0, arg1, arg2));
  }
}
Variant c_SplFileInfo::i_gettype(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
  return (self->t_gettype());
}
Variant c_SplFileInfo::ifa_getperms(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
  return (self->t_getperms());
}
Variant c_SplFileInfo::ifa_iswritable(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
  return (self->t_iswritable());
}
Variant c_SplFileInfo::ifa_getbasename(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
  if (count <= 0) return (self->t_getbasename());
  CVarRef arg0((a0));
  return (self->t_getbasename(arg0));
}
Variant c_SplFileInfo::ifa_getpathname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
  return (self->t_getpathname());
}
Variant c_SplFileInfo::ifa_getgroup(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
  return (self->t_getgroup());
}
Variant c_SplFileInfo::ifa_setfileclass(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
  if (count <= 0) return (self->t_setfileclass(), null);
  CVarRef arg0((a0));
  return (self->t_setfileclass(arg0), null);
}
Variant c_SplFileInfo::ifa_setinfoclass(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
  if (count <= 0) return (self->t_setinfoclass(), null);
  CVarRef arg0((a0));
  return (self->t_setinfoclass(arg0), null);
}
Variant c_SplFileInfo::ifa___tostring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
  return (self->t___tostring());
}
Variant c_SplFileInfo::ifa_getlinktarget(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
  return (self->t_getlinktarget());
}
Variant c_SplFileInfo::ifa_isreadable(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
  return (self->t_isreadable());
}
Variant c_SplFileInfo::ifa_getrealpath(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
  return (self->t_getrealpath());
}
Variant c_SplFileInfo::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
  CVarRef arg0((a0));
  return (self->t___construct(arg0), null);
}
Variant c_SplFileInfo::ifa_getpathinfo(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
  if (count <= 0) return (self->t_getpathinfo());
  CVarRef arg0((a0));
  return (self->t_getpathinfo(arg0));
}
Variant c_SplFileInfo::ifa_getctime(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
  return (self->t_getctime());
}
Variant c_SplFileInfo::ifa_getpath(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
  return (self->t_getpath());
}
Variant c_SplFileInfo::ifa_getinode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
  return (self->t_getinode());
}
Variant c_SplFileInfo::ifa_islink(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
  return (self->t_islink());
}
Variant c_SplFileInfo::ifa_getsize(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
  return (self->t_getsize());
}
Variant c_SplFileInfo::ifa_isfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
  return (self->t_isfile());
}
Variant c_SplFileInfo::ifa_getfilename(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
  return (self->t_getfilename());
}
Variant c_SplFileInfo::ifa_getowner(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
  return (self->t_getowner());
}
Variant c_SplFileInfo::ifa_getmtime(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
  return (self->t_getmtime());
}
Variant c_SplFileInfo::ifa_isdir(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
  return (self->t_isdir());
}
Variant c_SplFileInfo::ifa_getfileinfo(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
  if (count <= 0) return (self->t_getfileinfo());
  CVarRef arg0((a0));
  return (self->t_getfileinfo(arg0));
}
Variant c_SplFileInfo::ifa_isexecutable(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
  return (self->t_isexecutable());
}
Variant c_SplFileInfo::ifa_getatime(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
  return (self->t_getatime());
}
Variant c_SplFileInfo::ifa_openfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
  if (count <= 0) return (self->t_openfile());
  CVarRef arg0((a0));
  if (count <= 1) return (self->t_openfile(arg0));
  CVarRef arg1((a1));
  if (count <= 2) return (self->t_openfile(arg0, arg1));
  CVarRef arg2((a2));
  return (self->t_openfile(arg0, arg1, arg2));
}
Variant c_SplFileInfo::ifa_gettype(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SplFileInfo *self = NULL;
  p_SplFileInfo pobj;
  if (mcp.obj) {
    self = static_cast<c_SplFileInfo*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
  return (self->t_gettype());
}
bool c_SplFileInfo::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 5:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss4db221b9, "setInfoClass")) {
        mcp.ci = &c_SplFileInfo::ci_setinfoclass;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ssb122eff8, "getRealPath")) {
        mcp.ci = &c_SplFileInfo::ci_getrealpath;
        return true;
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ssfc2d4779, "getType")) {
        mcp.ci = &c_SplFileInfo::ci_gettype;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss95821704, "isDir")) {
        mcp.ci = &c_SplFileInfo::ci_isdir;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ssf578e813, "getInode")) {
        mcp.ci = &c_SplFileInfo::ci_getinode;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss077ab997, "getFilename")) {
        mcp.ci = &c_SplFileInfo::ci_getfilename;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss8b50e6c9, "getOwner")) {
        mcp.ci = &c_SplFileInfo::ci_getowner;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss11bc49d2, "isReadable")) {
        mcp.ci = &c_SplFileInfo::ci_isreadable;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6974a1cc, "__toString")) {
        mcp.ci = &c_SplFileInfo::ci___tostring;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ssea00c58c, "isLink")) {
        mcp.ci = &c_SplFileInfo::ci_islink;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss7d1afda2, "getBasename")) {
        mcp.ci = &c_SplFileInfo::ci_getbasename;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ssc09df55f, "isFile")) {
        mcp.ci = &c_SplFileInfo::ci_isfile;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        mcp.ci = &c_SplFileInfo::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ssb1c4aa6f, "getATime")) {
        mcp.ci = &c_SplFileInfo::ci_getatime;
        return true;
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss9a04b6ca, "isWritable")) {
        mcp.ci = &c_SplFileInfo::ci_iswritable;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5ef289b7, "setFileClass")) {
        mcp.ci = &c_SplFileInfo::ci_setfileclass;
        return true;
      }
      break;
    case 39:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss135934b0, "getPathInfo")) {
        mcp.ci = &c_SplFileInfo::ci_getpathinfo;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss1863b3c7, "getGroup")) {
        mcp.ci = &c_SplFileInfo::ci_getgroup;
        return true;
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss2a6293f6, "getSize")) {
        mcp.ci = &c_SplFileInfo::ci_getsize;
        return true;
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss90f68f81, "getLinkTarget")) {
        mcp.ci = &c_SplFileInfo::ci_getlinktarget;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss45739f33, "getCTime")) {
        mcp.ci = &c_SplFileInfo::ci_getctime;
        return true;
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss94213325, "getMTime")) {
        mcp.ci = &c_SplFileInfo::ci_getmtime;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ssf99443fd, "openFile")) {
        mcp.ci = &c_SplFileInfo::ci_openfile;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss164363b4, "getPathname")) {
        mcp.ci = &c_SplFileInfo::ci_getpathname;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ssa9a8d951, "isExecutable")) {
        mcp.ci = &c_SplFileInfo::ci_isexecutable;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss49fef19f, "getPerms")) {
        mcp.ci = &c_SplFileInfo::ci_getperms;
        return true;
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss0c3a6c4a, "getPath")) {
        mcp.ci = &c_SplFileInfo::ci_getpath;
        return true;
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss9fa37b08, "getFileInfo")) {
        mcp.ci = &c_SplFileInfo::ci_getfileinfo;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SplFileInfo::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SplFileInfo *c_SplFileInfo::create(Variant v_file_name) {
  CountableHelper h(this);
  init();
  t___construct(v_file_name);
  return this;
}
void c_SplFileInfo::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_SplFileInfo::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SplFileInfo::ci___construct;
  mcp.obj = this;
}
void c_SplFileInfo::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  unsigned int i = 0;
  do {
    if (i == params.size()) break;
    a0 = params[i]->eval(env);
    i++;
  } while(false);
  for (; i != params.size(); ++i) {
    params[i]->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 1);
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_SplFileInfo = {
  c_SplFileInfo::os_getInit,
  c_SplFileInfo::os_get,
  c_SplFileInfo::os_lval,
  c_SplFileInfo::os_invoke,
  c_SplFileInfo::os_constant,
  c_SplFileInfo::os_get_call_info
};
void c_SplFileInfo::init() {
}
/* SRC: classes/splfile.php line 13 */
void c_SplFileInfo::t___construct(Variant v_file_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::__construct);
  bool oldInCtor = gasInCtor(true);
  x_hphp_splfileinfo___construct(GET_THIS_TYPED(SplFileInfo), toString(v_file_name));
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 26 */
String c_SplFileInfo::t_getpath() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPath);
  return x_hphp_splfileinfo_getpath(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 38 */
String c_SplFileInfo::t_getfilename() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getFilename);
  return x_hphp_splfileinfo_getfilename(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 52 */
Object c_SplFileInfo::t_getfileinfo(CVarRef v_class_name //  = NAMSTR(s_sys_ss00000000, "")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getFileInfo);
  return x_hphp_splfileinfo_getfileinfo(GET_THIS_TYPED(SplFileInfo), toString(v_class_name));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 67 */
String c_SplFileInfo::t_getbasename(CVarRef v_suffix //  = NAMSTR(s_sys_ss00000000, "")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getBasename);
  return x_hphp_splfileinfo_getbasename(GET_THIS_TYPED(SplFileInfo), toString(v_suffix));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 79 */
String c_SplFileInfo::t_getpathname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPathname);
  return x_hphp_splfileinfo_getpathname(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 94 */
Object c_SplFileInfo::t_getpathinfo(CVarRef v_class_name //  = NAMSTR(s_sys_ss00000000, "")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPathInfo);
  return x_hphp_splfileinfo_getpathinfo(GET_THIS_TYPED(SplFileInfo), toString(v_class_name));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 106 */
int64 c_SplFileInfo::t_getperms() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPerms);
  return x_hphp_splfileinfo_getperms(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 118 */
int64 c_SplFileInfo::t_getinode() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getInode);
  return x_hphp_splfileinfo_getinode(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 130 */
int64 c_SplFileInfo::t_getsize() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getSize);
  return x_hphp_splfileinfo_getsize(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 142 */
int64 c_SplFileInfo::t_getowner() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getOwner);
  return x_hphp_splfileinfo_getowner(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 154 */
int64 c_SplFileInfo::t_getgroup() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getGroup);
  return x_hphp_splfileinfo_getgroup(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 166 */
int64 c_SplFileInfo::t_getatime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getATime);
  return x_hphp_splfileinfo_getatime(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 180 */
int64 c_SplFileInfo::t_getmtime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getMTime);
  return x_hphp_splfileinfo_getmtime(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 193 */
int64 c_SplFileInfo::t_getctime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getCTime);
  return x_hphp_splfileinfo_getctime(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 206 */
String c_SplFileInfo::t_gettype() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getType);
  return x_hphp_splfileinfo_gettype(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 218 */
bool c_SplFileInfo::t_iswritable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isWritable);
  return x_hphp_splfileinfo_iswritable(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 230 */
bool c_SplFileInfo::t_isreadable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isReadable);
  return x_hphp_splfileinfo_isreadable(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 242 */
bool c_SplFileInfo::t_isexecutable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isExecutable);
  return x_hphp_splfileinfo_isexecutable(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 256 */
bool c_SplFileInfo::t_isfile() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isFile);
  return x_hphp_splfileinfo_isfile(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 268 */
bool c_SplFileInfo::t_isdir() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isDir);
  return x_hphp_splfileinfo_isdir(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 281 */
bool c_SplFileInfo::t_islink() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isLink);
  return x_hphp_splfileinfo_islink(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 296 */
String c_SplFileInfo::t_getlinktarget() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getLinkTarget);
  return x_hphp_splfileinfo_getlinktarget(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 309 */
Variant c_SplFileInfo::t_getrealpath() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getRealPath);
  return x_hphp_splfileinfo_getrealpath(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 313 */
String c_SplFileInfo::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::__toString);
  return x_hphp_splfileinfo___tostring(GET_THIS_TYPED(SplFileInfo));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 337 */
Object c_SplFileInfo::t_openfile(CVarRef v_mode //  = NAMSTR(s_sys_ss0d42ecf6, "r")
, CVarRef v_use_include_path //  = false
, CVarRef v_context //  = null_variant
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::openFile);
  return x_hphp_splfileinfo_openfile(GET_THIS_TYPED(SplFileInfo), toString(v_mode), toBoolean(v_use_include_path), v_context);
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 355 */
void c_SplFileInfo::t_setfileclass(CVarRef v_class_name //  = NAMSTR(s_sys_ss5d909898, "SplFileObject")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::setFileClass);
  x_hphp_splfileinfo_setfileclass(GET_THIS_TYPED(SplFileInfo), toString(v_class_name));
}
namespace hphp_impl_splitter {}
/* SRC: classes/splfile.php line 371 */
void c_SplFileInfo::t_setinfoclass(CVarRef v_class_name //  = NAMSTR(s_sys_ss914a58e9, "SplFileInfo")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::setInfoClass);
  x_hphp_splfileinfo_setinfoclass(GET_THIS_TYPED(SplFileInfo), toString(v_class_name));
}
namespace hphp_impl_splitter {}
Object co_SplFileObject(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_SplFileObject)())->dynCreate(params, init));
}
Object coo_SplFileObject() {
  Object r(NEWOBJ(c_SplFileObject)());
  r->init();
  return r;
}
Object co_SplFileInfo(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_SplFileInfo)())->dynCreate(params, init));
}
Object coo_SplFileInfo() {
  Object r(NEWOBJ(c_SplFileInfo)());
  r->init();
  return r;
}
Variant pm_php$classes$splfile_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */, Globals *globals /* = get_globals() */) {
  PSEUDOMAIN_INJECTION_BUILTIN(run_init::classes/splfile.php, pm_php$classes$splfile_php);
  LVariableTable *gVariables __attribute__((__unused__)) = (LVariableTable *)g;
  return true;
}
namespace hphp_impl_splitter {}

///////////////////////////////////////////////////////////////////////////////
}
