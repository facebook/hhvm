/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.facebook.thrift.type;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import com.facebook.thrift.*;
import com.facebook.thrift.annotations.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

/**
 * The "uri" of a Thrift type.
 */
@SuppressWarnings({ "unused", "serial", "unchecked" })
public class TypeUri extends TUnion<TypeUri> implements Comparable<TypeUri> {
  private static final TStruct STRUCT_DESC = new TStruct("TypeUri");
  private static final TField URI_FIELD_DESC = new TField("uri", TType.STRING, (short)1);
  private static final TField TYPE_HASH_PREFIX_SHA2_256_FIELD_DESC = new TField("typeHashPrefixSha2_256", TType.STRING, (short)2);
  private static final TField SCOPED_NAME_FIELD_DESC = new TField("scopedName", TType.STRING, (short)3);

  public static final int URI = 1;
  public static final int TYPEHASHPREFIXSHA2_256 = 2;
  public static final int SCOPEDNAME = 3;

  public static final Map<Integer, FieldMetaData> metaDataMap;

  static {
    Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
    tmpMetaDataMap.put(URI, new FieldMetaData("uri", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING)));
    tmpMetaDataMap.put(TYPEHASHPREFIXSHA2_256, new FieldMetaData("typeHashPrefixSha2_256", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING)));
    tmpMetaDataMap.put(SCOPEDNAME, new FieldMetaData("scopedName", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING)));
    metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
  }

  public TypeUri() {
    super();
  }

  public TypeUri(int setField, Object __value) {
    super(setField, __value);
  }

  public TypeUri(TypeUri other) {
    super(other);
  }

  public TypeUri deepCopy() {
    return new TypeUri(this);
  }

  public static TypeUri uri(String __value) {
    TypeUri x = new TypeUri();
    x.setUri(__value);
    return x;
  }

  public static TypeUri typeHashPrefixSha2_256(byte[] __value) {
    TypeUri x = new TypeUri();
    x.setTypeHashPrefixSha2_256(__value);
    return x;
  }

  public static TypeUri scopedName(String __value) {
    TypeUri x = new TypeUri();
    x.setScopedName(__value);
    return x;
  }


  @Override
  protected void checkType(short setField, Object __value) throws ClassCastException {
    switch (setField) {
      case URI:
        if (__value instanceof String) {
          break;
        }
        throw new ClassCastException("Was expecting value of type String for field 'uri', but got " + __value.getClass().getSimpleName());
      case TYPEHASHPREFIXSHA2_256:
        if (__value instanceof byte[]) {
          break;
        }
        throw new ClassCastException("Was expecting value of type byte[] for field 'typeHashPrefixSha2_256', but got " + __value.getClass().getSimpleName());
      case SCOPEDNAME:
        if (__value instanceof String) {
          break;
        }
        throw new ClassCastException("Was expecting value of type String for field 'scopedName', but got " + __value.getClass().getSimpleName());
      default:
        throw new IllegalArgumentException("Unknown field id " + setField);
    }
  }

  @Override
  public void read(TProtocol iprot) throws TException {
    setField_ = 0;
    value_ = null;
    iprot.readStructBegin(metaDataMap);
    TField __field = iprot.readFieldBegin();
    if (__field.type != TType.STOP)
    {
      value_ = readValue(iprot, __field);
      if (value_ != null)
      {
        switch (__field.id) {
          case URI:
            if (__field.type == URI_FIELD_DESC.type) {
              setField_ = __field.id;
            }
            break;
          case TYPEHASHPREFIXSHA2_256:
            if (__field.type == TYPE_HASH_PREFIX_SHA2_256_FIELD_DESC.type) {
              setField_ = __field.id;
            }
            break;
          case SCOPEDNAME:
            if (__field.type == SCOPED_NAME_FIELD_DESC.type) {
              setField_ = __field.id;
            }
            break;
        }
      }
      iprot.readFieldEnd();
      TField __stopField = iprot.readFieldBegin();
      if (__stopField.type != TType.STOP) {
        throw new TProtocolException(TProtocolException.INVALID_DATA, "Union 'TypeUri' is missing a STOP byte");
      }
    }
    iprot.readStructEnd();
  }

  @Override
  protected Object readValue(TProtocol iprot, TField __field) throws TException {
    switch (__field.id) {
      case URI:
        if (__field.type == URI_FIELD_DESC.type) {
          String uri;
          uri = iprot.readString();
          return uri;
        }
        break;
      case TYPEHASHPREFIXSHA2_256:
        if (__field.type == TYPE_HASH_PREFIX_SHA2_256_FIELD_DESC.type) {
          byte[] typeHashPrefixSha2_256;
          typeHashPrefixSha2_256 = iprot.readBinary();
          return typeHashPrefixSha2_256;
        }
        break;
      case SCOPEDNAME:
        if (__field.type == SCOPED_NAME_FIELD_DESC.type) {
          String scopedName;
          scopedName = iprot.readString();
          return scopedName;
        }
        break;
    }
    TProtocolUtil.skip(iprot, __field.type);
    return null;
  }

  @Override
  protected void writeValue(TProtocol oprot, short setField, Object __value) throws TException {
    switch (setField) {
      case URI:
        String uri = (String)getFieldValue();
        oprot.writeString(uri);
        return;
      case TYPEHASHPREFIXSHA2_256:
        byte[] typeHashPrefixSha2_256 = (byte[])getFieldValue();
        oprot.writeBinary(typeHashPrefixSha2_256);
        return;
      case SCOPEDNAME:
        String scopedName = (String)getFieldValue();
        oprot.writeString(scopedName);
        return;
      default:
        throw new IllegalStateException("Cannot write union with unknown field " + setField);
    }
  }

  @Override
  protected TField getFieldDesc(int setField) {
    switch (setField) {
      case URI:
        return URI_FIELD_DESC;
      case TYPEHASHPREFIXSHA2_256:
        return TYPE_HASH_PREFIX_SHA2_256_FIELD_DESC;
      case SCOPEDNAME:
        return SCOPED_NAME_FIELD_DESC;
      default:
        throw new IllegalArgumentException("Unknown field id " + setField);
    }
  }

  @Override
  protected TStruct getStructDesc() {
    return STRUCT_DESC;
  }

  @Override
  protected Map<Integer, FieldMetaData> getMetaDataMap() { return metaDataMap; }

  private Object __getValue(int expectedFieldId) {
    if (getSetField() == expectedFieldId) {
      return getFieldValue();
    } else {
      throw new RuntimeException("Cannot get field '" + getFieldDesc(expectedFieldId).name + "' because union is currently set to " + getFieldDesc(getSetField()).name);
    }
  }

  private void __setValue(int fieldId, Object __value) {
    if (__value == null) throw new NullPointerException();
    setField_ = fieldId;
    value_ = __value;
  }

  /**
   * The universal name of this type, sometimes referred to as a Thrift URI.
   * Usually preferred when the name is shorter or has the same length as the
   * hash prefix.
   */
  public String getUri() {
    return (String) __getValue(URI);
  }

  /**
   * The universal name of this type, sometimes referred to as a Thrift URI.
   * Usually preferred when the name is shorter or has the same length as the
   * hash prefix.
   */
  public void setUri(String __value) {
    __setValue(URI, __value);
  }

  /**
   * A prefix of the SHA2-256 hash of the universal name. It is ByteString
   * instead of binary to fit a 16-byte prefix into the inline storage making
   * use of the small string optimization (SSO). In libstdc++ std::string SSO
   * is limited to 15 bytes and would require an allocation.
   */
  public byte[] getTypeHashPrefixSha2_256() {
    return (byte[]) __getValue(TYPEHASHPREFIXSHA2_256);
  }

  /**
   * A prefix of the SHA2-256 hash of the universal name. It is ByteString
   * instead of binary to fit a 16-byte prefix into the inline storage making
   * use of the small string optimization (SSO). In libstdc++ std::string SSO
   * is limited to 15 bytes and would require an allocation.
   */
  public void setTypeHashPrefixSha2_256(byte[] __value) {
    __setValue(TYPEHASHPREFIXSHA2_256, __value);
  }

  /**
   * The scoped (qualified) name of this type in the form
   * `<filename>.<typename>`, e.g. `search.Query`. Unlike the universal name,
   * it is potentially not unique. This is a fallback for types that do not
   * have universal names yet. Don't rely on `scopedName` to be always
   * available. It will be replaced by `uri` as package declarations are
   * rolled out.
   */
  public String getScopedName() {
    return (String) __getValue(SCOPEDNAME);
  }

  /**
   * The scoped (qualified) name of this type in the form
   * `<filename>.<typename>`, e.g. `search.Query`. Unlike the universal name,
   * it is potentially not unique. This is a fallback for types that do not
   * have universal names yet. Don't rely on `scopedName` to be always
   * available. It will be replaced by `uri` as package declarations are
   * rolled out.
   */
  public void setScopedName(String __value) {
    __setValue(SCOPEDNAME, __value);
  }

  public boolean equals(Object other) {
    if (other instanceof TypeUri) {
      return equals((TypeUri)other);
    } else {
      return false;
    }
  }

  public boolean equals(TypeUri other) {
    return equalsSlowImpl(other);
  }

  @Override
  public int compareTo(TypeUri other) {
    return compareToImpl(other);
  }


  @Override
  public int hashCode() {
    return Arrays.deepHashCode(new Object[] {getSetField(), getFieldValue()});
  }

}
