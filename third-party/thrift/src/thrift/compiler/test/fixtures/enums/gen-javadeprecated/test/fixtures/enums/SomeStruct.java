/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package test.fixtures.enums;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import com.facebook.thrift.*;
import com.facebook.thrift.annotations.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class SomeStruct implements TBase, java.io.Serializable, Cloneable, Comparable<SomeStruct> {
  private static final TStruct STRUCT_DESC = new TStruct("SomeStruct");
  private static final TField REASONABLE_FIELD_DESC = new TField("reasonable", TType.I32, (short)1);
  private static final TField FINE_FIELD_DESC = new TField("fine", TType.I32, (short)2);
  private static final TField QUESTIONABLE_FIELD_DESC = new TField("questionable", TType.I32, (short)3);
  private static final TField TAGS_FIELD_DESC = new TField("tags", TType.SET, (short)4);

  /**
   * 
   * @see Metasyntactic
   */
  public Metasyntactic reasonable;
  /**
   * 
   * @see Metasyntactic
   */
  public Metasyntactic fine;
  /**
   * 
   * @see Metasyntactic
   */
  public Metasyntactic questionable;
  public Set<Integer> tags;
  public static final int REASONABLE = 1;
  public static final int FINE = 2;
  public static final int QUESTIONABLE = 3;
  public static final int TAGS = 4;

  // isset id assignments

  public static final Map<Integer, FieldMetaData> metaDataMap;

  static {
    Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
    tmpMetaDataMap.put(REASONABLE, new FieldMetaData("reasonable", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(FINE, new FieldMetaData("fine", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(QUESTIONABLE, new FieldMetaData("questionable", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(TAGS, new FieldMetaData("tags", TFieldRequirementType.DEFAULT, 
        new SetMetaData(TType.SET, 
            new FieldValueMetaData(TType.I32))));
    metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
  }

  static {
    FieldMetaData.addStructMetaDataMap(SomeStruct.class, metaDataMap);
  }

  public SomeStruct() {
    this.reasonable = test.fixtures.enums.Metasyntactic.FOO;

    this.fine = test.fixtures.enums.Metasyntactic.BAR;

    this.questionable = test.fixtures.enums.Metasyntactic.findByValue(-1);

    this.tags = new HashSet<Integer>();

  }

  public SomeStruct(
      Metasyntactic reasonable,
      Metasyntactic fine,
      Metasyntactic questionable,
      Set<Integer> tags) {
    this();
    this.reasonable = reasonable;
    this.fine = fine;
    this.questionable = questionable;
    this.tags = tags;
  }

  public static class Builder {
    private Metasyntactic reasonable;
    private Metasyntactic fine;
    private Metasyntactic questionable;
    private Set<Integer> tags;

    public Builder() {
    }

    public Builder setReasonable(final Metasyntactic reasonable) {
      this.reasonable = reasonable;
      return this;
    }

    public Builder setFine(final Metasyntactic fine) {
      this.fine = fine;
      return this;
    }

    public Builder setQuestionable(final Metasyntactic questionable) {
      this.questionable = questionable;
      return this;
    }

    public Builder setTags(final Set<Integer> tags) {
      this.tags = tags;
      return this;
    }

    public SomeStruct build() {
      SomeStruct result = new SomeStruct();
      result.setReasonable(this.reasonable);
      result.setFine(this.fine);
      result.setQuestionable(this.questionable);
      result.setTags(this.tags);
      return result;
    }
  }

  public static Builder builder() {
    return new Builder();
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public SomeStruct(SomeStruct other) {
    if (other.isSetReasonable()) {
      this.reasonable = TBaseHelper.deepCopy(other.reasonable);
    }
    if (other.isSetFine()) {
      this.fine = TBaseHelper.deepCopy(other.fine);
    }
    if (other.isSetQuestionable()) {
      this.questionable = TBaseHelper.deepCopy(other.questionable);
    }
    if (other.isSetTags()) {
      this.tags = TBaseHelper.deepCopy(other.tags);
    }
  }

  public SomeStruct deepCopy() {
    return new SomeStruct(this);
  }

  /**
   * 
   * @see Metasyntactic
   */
  public Metasyntactic getReasonable() {
    return this.reasonable;
  }

  /**
   * 
   * @see Metasyntactic
   */
  public SomeStruct setReasonable(Metasyntactic reasonable) {
    this.reasonable = reasonable;
    return this;
  }

  public void unsetReasonable() {
    this.reasonable = null;
  }

  // Returns true if field reasonable is set (has been assigned a value) and false otherwise
  public boolean isSetReasonable() {
    return this.reasonable != null;
  }

  public void setReasonableIsSet(boolean __value) {
    if (!__value) {
      this.reasonable = null;
    }
  }

  /**
   * 
   * @see Metasyntactic
   */
  public Metasyntactic getFine() {
    return this.fine;
  }

  /**
   * 
   * @see Metasyntactic
   */
  public SomeStruct setFine(Metasyntactic fine) {
    this.fine = fine;
    return this;
  }

  public void unsetFine() {
    this.fine = null;
  }

  // Returns true if field fine is set (has been assigned a value) and false otherwise
  public boolean isSetFine() {
    return this.fine != null;
  }

  public void setFineIsSet(boolean __value) {
    if (!__value) {
      this.fine = null;
    }
  }

  /**
   * 
   * @see Metasyntactic
   */
  public Metasyntactic getQuestionable() {
    return this.questionable;
  }

  /**
   * 
   * @see Metasyntactic
   */
  public SomeStruct setQuestionable(Metasyntactic questionable) {
    this.questionable = questionable;
    return this;
  }

  public void unsetQuestionable() {
    this.questionable = null;
  }

  // Returns true if field questionable is set (has been assigned a value) and false otherwise
  public boolean isSetQuestionable() {
    return this.questionable != null;
  }

  public void setQuestionableIsSet(boolean __value) {
    if (!__value) {
      this.questionable = null;
    }
  }

  public Set<Integer> getTags() {
    return this.tags;
  }

  public SomeStruct setTags(Set<Integer> tags) {
    this.tags = tags;
    return this;
  }

  public void unsetTags() {
    this.tags = null;
  }

  // Returns true if field tags is set (has been assigned a value) and false otherwise
  public boolean isSetTags() {
    return this.tags != null;
  }

  public void setTagsIsSet(boolean __value) {
    if (!__value) {
      this.tags = null;
    }
  }

  @SuppressWarnings("unchecked")
  public void setFieldValue(int fieldID, Object __value) {
    switch (fieldID) {
    case REASONABLE:
      if (__value == null) {
        unsetReasonable();
      } else {
        setReasonable((Metasyntactic)__value);
      }
      break;

    case FINE:
      if (__value == null) {
        unsetFine();
      } else {
        setFine((Metasyntactic)__value);
      }
      break;

    case QUESTIONABLE:
      if (__value == null) {
        unsetQuestionable();
      } else {
        setQuestionable((Metasyntactic)__value);
      }
      break;

    case TAGS:
      if (__value == null) {
        unsetTags();
      } else {
        setTags((Set<Integer>)__value);
      }
      break;

    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  public Object getFieldValue(int fieldID) {
    switch (fieldID) {
    case REASONABLE:
      return getReasonable();

    case FINE:
      return getFine();

    case QUESTIONABLE:
      return getQuestionable();

    case TAGS:
      return getTags();

    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  @Override
  public boolean equals(Object _that) {
    if (_that == null)
      return false;
    if (this == _that)
      return true;
    if (!(_that instanceof SomeStruct))
      return false;
    SomeStruct that = (SomeStruct)_that;

    if (!TBaseHelper.equalsNobinary(this.isSetReasonable(), that.isSetReasonable(), this.reasonable, that.reasonable)) { return false; }

    if (!TBaseHelper.equalsNobinary(this.isSetFine(), that.isSetFine(), this.fine, that.fine)) { return false; }

    if (!TBaseHelper.equalsNobinary(this.isSetQuestionable(), that.isSetQuestionable(), this.questionable, that.questionable)) { return false; }

    if (!TBaseHelper.equalsNobinary(this.isSetTags(), that.isSetTags(), this.tags, that.tags)) { return false; }

    return true;
  }

  @Override
  public int hashCode() {
    return Arrays.deepHashCode(new Object[] {reasonable, fine, questionable, tags});
  }

  @Override
  public int compareTo(SomeStruct other) {
    if (other == null) {
      // See java.lang.Comparable docs
      throw new NullPointerException();
    }

    if (other == this) {
      return 0;
    }
    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetReasonable()).compareTo(other.isSetReasonable());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(reasonable, other.reasonable);
    if (lastComparison != 0) { 
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetFine()).compareTo(other.isSetFine());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(fine, other.fine);
    if (lastComparison != 0) { 
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetQuestionable()).compareTo(other.isSetQuestionable());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(questionable, other.questionable);
    if (lastComparison != 0) { 
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetTags()).compareTo(other.isSetTags());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(tags, other.tags);
    if (lastComparison != 0) { 
      return lastComparison;
    }
    return 0;
  }

  public void read(TProtocol iprot) throws TException {
    TField __field;
    iprot.readStructBegin(metaDataMap);
    while (true)
    {
      __field = iprot.readFieldBegin();
      if (__field.type == TType.STOP) {
        break;
      }
      switch (__field.id)
      {
        case REASONABLE:
          if (__field.type == TType.I32) {
            this.reasonable = Metasyntactic.findByValue(iprot.readI32());
          } else {
            TProtocolUtil.skip(iprot, __field.type);
          }
          break;
        case FINE:
          if (__field.type == TType.I32) {
            this.fine = Metasyntactic.findByValue(iprot.readI32());
          } else {
            TProtocolUtil.skip(iprot, __field.type);
          }
          break;
        case QUESTIONABLE:
          if (__field.type == TType.I32) {
            this.questionable = Metasyntactic.findByValue(iprot.readI32());
          } else {
            TProtocolUtil.skip(iprot, __field.type);
          }
          break;
        case TAGS:
          if (__field.type == TType.SET) {
            {
              TSet _set0 = iprot.readSetBegin();
              this.tags = new HashSet<Integer>(Math.max(0, 2*_set0.size));
              for (int _i1 = 0; 
                   (_set0.size < 0) ? iprot.peekSet() : (_i1 < _set0.size); 
                   ++_i1)
              {
                int _elem2;
                _elem2 = iprot.readI32();
                this.tags.add(_elem2);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, __field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, __field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.reasonable != null) {
      oprot.writeFieldBegin(REASONABLE_FIELD_DESC);
      oprot.writeI32(this.reasonable == null ? 0 : this.reasonable.getValue());
      oprot.writeFieldEnd();
    }
    if (this.fine != null) {
      oprot.writeFieldBegin(FINE_FIELD_DESC);
      oprot.writeI32(this.fine == null ? 0 : this.fine.getValue());
      oprot.writeFieldEnd();
    }
    if (this.questionable != null) {
      oprot.writeFieldBegin(QUESTIONABLE_FIELD_DESC);
      oprot.writeI32(this.questionable == null ? 0 : this.questionable.getValue());
      oprot.writeFieldEnd();
    }
    if (this.tags != null) {
      oprot.writeFieldBegin(TAGS_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.I32, this.tags.size()));
        for (int _iter3 : this.tags)        {
          oprot.writeI32(_iter3);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @Override
  public String toString() {
    return toString(1, true);
  }

  @Override
  public String toString(int indent, boolean prettyPrint) {
    String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
    String newLine = prettyPrint ? "\n" : "";
    String space = prettyPrint ? " " : "";
    StringBuilder sb = new StringBuilder("SomeStruct");
    sb.append(space);
    sb.append("(");
    sb.append(newLine);
    boolean first = true;

    sb.append(indentStr);
    sb.append("reasonable");
    sb.append(space);
    sb.append(":").append(space);
    if (this.getReasonable() == null) {
      sb.append("null");
    } else {
      String reasonable_name = this.getReasonable() == null ? "null" : this.getReasonable().name();
      if (reasonable_name != null) {
        sb.append(reasonable_name);
        sb.append(" (");
      }
      sb.append(this.getReasonable());
      if (reasonable_name != null) {
        sb.append(")");
      }
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("fine");
    sb.append(space);
    sb.append(":").append(space);
    if (this.getFine() == null) {
      sb.append("null");
    } else {
      String fine_name = this.getFine() == null ? "null" : this.getFine().name();
      if (fine_name != null) {
        sb.append(fine_name);
        sb.append(" (");
      }
      sb.append(this.getFine());
      if (fine_name != null) {
        sb.append(")");
      }
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("questionable");
    sb.append(space);
    sb.append(":").append(space);
    if (this.getQuestionable() == null) {
      sb.append("null");
    } else {
      String questionable_name = this.getQuestionable() == null ? "null" : this.getQuestionable().name();
      if (questionable_name != null) {
        sb.append(questionable_name);
        sb.append(" (");
      }
      sb.append(this.getQuestionable());
      if (questionable_name != null) {
        sb.append(")");
      }
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("tags");
    sb.append(space);
    sb.append(":").append(space);
    if (this.getTags() == null) {
      sb.append("null");
    } else {
      sb.append(TBaseHelper.toString(this.getTags(), indent + 1, prettyPrint));
    }
    first = false;
    sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }

}

