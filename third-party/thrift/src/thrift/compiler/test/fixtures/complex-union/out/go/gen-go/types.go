// Autogenerated by Thrift for thrift/compiler/test/fixtures/complex-union/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "fmt"
    "reflect"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = reflect.Ptr
var _ = thrift.VOID
var _ = metadata.GoUnusedProtection__

type ContainerTypedef = map[int16]string

func NewContainerTypedef() ContainerTypedef {
    return make(map[int16]string)
}

func WriteContainerTypedef(item ContainerTypedef, p thrift.Encoder) error {
    if err := p.WriteMapBegin(thrift.I16, thrift.STRING, len(item)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range item {
        {
            item := k
            if err := p.WriteI16(item); err != nil {
                return err
            }
        }
    
        {
            item := v
            if err := p.WriteString(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
    }
    return nil
}

func ReadContainerTypedef(p thrift.Decoder) (ContainerTypedef, error) {
    var decodeResult ContainerTypedef
    decodeErr := func() error {
        _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
        if err != nil {
            return thrift.PrependError("error reading map begin: ", err)
        }
        
        mapResult := make(map[int16]string, size)
        for i := 0; i < size; i++ {
            var key int16
            {
                result, err := p.ReadI16()
                if err != nil {
                    return err
                }
                key = result
            }
        
            var value string
            {
                result, err := p.ReadString()
                if err != nil {
                    return err
                }
                value = result
            }
        
            mapResult[key] = value
        }
        
        if err := p.ReadMapEnd(); err != nil {
            return thrift.PrependError("error reading map end: ", err)
        }
        result := mapResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type ComplexUnion struct {
    IntValue *int64 `thrift:"intValue,1" json:"intValue,omitempty" db:"intValue"`
    IntListValue []int64 `thrift:"intListValue,2" json:"intListValue,omitempty" db:"intListValue"`
    StringListValue []string `thrift:"stringListValue,3" json:"stringListValue,omitempty" db:"stringListValue"`
    StringValue *string `thrift:"stringValue,5" json:"stringValue,omitempty" db:"stringValue"`
    TypedefValue ContainerTypedef `thrift:"typedefValue,9" json:"typedefValue,omitempty" db:"typedefValue"`
    StringRef *string `thrift:"stringRef,14" json:"stringRef,omitempty" db:"stringRef"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ComplexUnion)(nil)

func NewComplexUnion() *ComplexUnion {
    return (&ComplexUnion{}).setDefaults()
}

func (x *ComplexUnion) GetIntValue() int64 {
    if !x.IsSetIntValue() {
        return 0
    }
    return *x.IntValue
}

func (x *ComplexUnion) GetIntListValue() []int64 {
    if !x.IsSetIntListValue() {
        return make([]int64, 0)
    }
    return x.IntListValue
}

func (x *ComplexUnion) GetStringListValue() []string {
    if !x.IsSetStringListValue() {
        return make([]string, 0)
    }
    return x.StringListValue
}

func (x *ComplexUnion) GetStringValue() string {
    if !x.IsSetStringValue() {
        return ""
    }
    return *x.StringValue
}

func (x *ComplexUnion) GetTypedefValue() ContainerTypedef {
    if !x.IsSetTypedefValue() {
        return NewContainerTypedef()
    }
    return x.TypedefValue
}

func (x *ComplexUnion) GetStringRef() string {
    if !x.IsSetStringRef() {
        return ""
    }
    return *x.StringRef
}

func (x *ComplexUnion) SetIntValueNonCompat(value int64) *ComplexUnion {
    x.IntValue = &value
    return x
}

func (x *ComplexUnion) SetIntValue(value *int64) *ComplexUnion {
    x.IntValue = value
    return x
}

func (x *ComplexUnion) SetIntListValueNonCompat(value []int64) *ComplexUnion {
    x.IntListValue = value
    return x
}

func (x *ComplexUnion) SetIntListValue(value []int64) *ComplexUnion {
    x.IntListValue = value
    return x
}

func (x *ComplexUnion) SetStringListValueNonCompat(value []string) *ComplexUnion {
    x.StringListValue = value
    return x
}

func (x *ComplexUnion) SetStringListValue(value []string) *ComplexUnion {
    x.StringListValue = value
    return x
}

func (x *ComplexUnion) SetStringValueNonCompat(value string) *ComplexUnion {
    x.StringValue = &value
    return x
}

func (x *ComplexUnion) SetStringValue(value *string) *ComplexUnion {
    x.StringValue = value
    return x
}

func (x *ComplexUnion) SetTypedefValueNonCompat(value ContainerTypedef) *ComplexUnion {
    x.TypedefValue = value
    return x
}

func (x *ComplexUnion) SetTypedefValue(value ContainerTypedef) *ComplexUnion {
    x.TypedefValue = value
    return x
}

func (x *ComplexUnion) SetStringRefNonCompat(value string) *ComplexUnion {
    x.StringRef = &value
    return x
}

func (x *ComplexUnion) SetStringRef(value *string) *ComplexUnion {
    x.StringRef = value
    return x
}

func (x *ComplexUnion) IsSetIntValue() bool {
    return x != nil && x.IntValue != nil
}

func (x *ComplexUnion) IsSetIntListValue() bool {
    return x != nil && x.IntListValue != nil
}

func (x *ComplexUnion) IsSetStringListValue() bool {
    return x != nil && x.StringListValue != nil
}

func (x *ComplexUnion) IsSetStringValue() bool {
    return x != nil && x.StringValue != nil
}

func (x *ComplexUnion) IsSetTypedefValue() bool {
    return x != nil && x.TypedefValue != nil
}

func (x *ComplexUnion) IsSetStringRef() bool {
    return x != nil && x.StringRef != nil
}

func (x *ComplexUnion) writeField1(p thrift.Encoder) error {  // IntValue
    if !x.IsSetIntValue() {
        return nil
    }

    if err := p.WriteFieldBegin("intValue", thrift.I64, 1); err != nil {
        return thrift.PrependError("ComplexUnion write field begin error: ", err)
    }

    item := *x.IntValue
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *ComplexUnion) writeField2(p thrift.Encoder) error {  // IntListValue
    if !x.IsSetIntListValue() {
        return nil
    }

    if err := p.WriteFieldBegin("intListValue", thrift.LIST, 2); err != nil {
        return thrift.PrependError("ComplexUnion write field begin error: ", err)
    }

    item := x.IntListValue
    if err := p.WriteListBegin(thrift.I64, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI64(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *ComplexUnion) writeField3(p thrift.Encoder) error {  // StringListValue
    if !x.IsSetStringListValue() {
        return nil
    }

    if err := p.WriteFieldBegin("stringListValue", thrift.LIST, 3); err != nil {
        return thrift.PrependError("ComplexUnion write field begin error: ", err)
    }

    item := x.StringListValue
    if err := p.WriteListBegin(thrift.STRING, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteString(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *ComplexUnion) writeField5(p thrift.Encoder) error {  // StringValue
    if !x.IsSetStringValue() {
        return nil
    }

    if err := p.WriteFieldBegin("stringValue", thrift.STRING, 5); err != nil {
        return thrift.PrependError("ComplexUnion write field begin error: ", err)
    }

    item := *x.StringValue
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *ComplexUnion) writeField9(p thrift.Encoder) error {  // TypedefValue
    if !x.IsSetTypedefValue() {
        return nil
    }

    if err := p.WriteFieldBegin("typedefValue", thrift.MAP, 9); err != nil {
        return thrift.PrependError("ComplexUnion write field begin error: ", err)
    }

    item := x.TypedefValue
    err := WriteContainerTypedef(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *ComplexUnion) writeField14(p thrift.Encoder) error {  // StringRef
    if !x.IsSetStringRef() {
        return nil
    }

    if err := p.WriteFieldBegin("stringRef", thrift.STRING, 14); err != nil {
        return thrift.PrependError("ComplexUnion write field begin error: ", err)
    }

    item := *x.StringRef
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *ComplexUnion) readField1(p thrift.Decoder) error {  // IntValue
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.IntValue = &result
    return nil
}

func (x *ComplexUnion) readField2(p thrift.Decoder) error {  // IntListValue
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int64, 0, size)
    for i := 0; i < size; i++ {
        var elem int64
        {
            result, err := p.ReadI64()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.IntListValue = result
    return nil
}

func (x *ComplexUnion) readField3(p thrift.Decoder) error {  // StringListValue
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]string, 0, size)
    for i := 0; i < size; i++ {
        var elem string
        {
            result, err := p.ReadString()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.StringListValue = result
    return nil
}

func (x *ComplexUnion) readField5(p thrift.Decoder) error {  // StringValue
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.StringValue = &result
    return nil
}

func (x *ComplexUnion) readField9(p thrift.Decoder) error {  // TypedefValue
    result, err := ReadContainerTypedef(p)
    if err != nil {
        return err
    }

    x.TypedefValue = result
    return nil
}

func (x *ComplexUnion) readField14(p thrift.Decoder) error {  // StringRef
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.StringRef = &result
    return nil
}




func (x *ComplexUnion) countSetFields() int {
    count := int(0)
    if (x.IsSetIntValue()) {
        count++
    }
    if (x.IsSetIntListValue()) {
        count++
    }
    if (x.IsSetStringListValue()) {
        count++
    }
    if (x.IsSetStringValue()) {
        count++
    }
    if (x.IsSetTypedefValue()) {
        count++
    }
    if (x.IsSetStringRef()) {
        count++
    }
    return count
}

func (x *ComplexUnion) CountSetFieldsComplexUnion() int {
    return x.countSetFields()
}



func (x *ComplexUnion) Write(p thrift.Encoder) error {
    if countSet := x.countSetFields(); countSet > 1 {
        return fmt.Errorf("ComplexUnion write union: no more than one field must be set (%d set).", countSet)
    }
    if err := p.WriteStructBegin("ComplexUnion"); err != nil {
        return thrift.PrependError("ComplexUnion write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }
    if err := x.writeField5(p); err != nil {
        return err
    }
    if err := x.writeField9(p); err != nil {
        return err
    }
    if err := x.writeField14(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ComplexUnion write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ComplexUnion write struct end error: ", err)
    }
    return nil
}

func (x *ComplexUnion) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ComplexUnion read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ComplexUnion field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "intValue")):  // intValue
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "intListValue")):  // intListValue
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "stringListValue")):  // stringListValue
            fieldReadErr = x.readField3(p)
        case ((id == 5 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "stringValue")):  // stringValue
            fieldReadErr = x.readField5(p)
        case ((id == 9 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "typedefValue")):  // typedefValue
            fieldReadErr = x.readField9(p)
        case ((id == 14 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "stringRef")):  // stringRef
            fieldReadErr = x.readField14(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ComplexUnion read struct end error: ", err)
    }

    return nil
}

func (x *ComplexUnion) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ComplexUnion) setDefaults() *ComplexUnion {
    return x
}

func (x *ComplexUnion) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_ComplexUnion
}

type ListUnion struct {
    IntListValue []int64 `thrift:"intListValue,2" json:"intListValue,omitempty" db:"intListValue"`
    StringListValue []string `thrift:"stringListValue,3" json:"stringListValue,omitempty" db:"stringListValue"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ListUnion)(nil)

func NewListUnion() *ListUnion {
    return (&ListUnion{}).setDefaults()
}

func (x *ListUnion) GetIntListValue() []int64 {
    if !x.IsSetIntListValue() {
        return make([]int64, 0)
    }
    return x.IntListValue
}

func (x *ListUnion) GetStringListValue() []string {
    if !x.IsSetStringListValue() {
        return make([]string, 0)
    }
    return x.StringListValue
}

func (x *ListUnion) SetIntListValueNonCompat(value []int64) *ListUnion {
    x.IntListValue = value
    return x
}

func (x *ListUnion) SetIntListValue(value []int64) *ListUnion {
    x.IntListValue = value
    return x
}

func (x *ListUnion) SetStringListValueNonCompat(value []string) *ListUnion {
    x.StringListValue = value
    return x
}

func (x *ListUnion) SetStringListValue(value []string) *ListUnion {
    x.StringListValue = value
    return x
}

func (x *ListUnion) IsSetIntListValue() bool {
    return x != nil && x.IntListValue != nil
}

func (x *ListUnion) IsSetStringListValue() bool {
    return x != nil && x.StringListValue != nil
}

func (x *ListUnion) writeField2(p thrift.Encoder) error {  // IntListValue
    if !x.IsSetIntListValue() {
        return nil
    }

    if err := p.WriteFieldBegin("intListValue", thrift.LIST, 2); err != nil {
        return thrift.PrependError("ListUnion write field begin error: ", err)
    }

    item := x.IntListValue
    if err := p.WriteListBegin(thrift.I64, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI64(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ListUnion write field end error: ", err)
    }
    return nil
}

func (x *ListUnion) writeField3(p thrift.Encoder) error {  // StringListValue
    if !x.IsSetStringListValue() {
        return nil
    }

    if err := p.WriteFieldBegin("stringListValue", thrift.LIST, 3); err != nil {
        return thrift.PrependError("ListUnion write field begin error: ", err)
    }

    item := x.StringListValue
    if err := p.WriteListBegin(thrift.STRING, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteString(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ListUnion write field end error: ", err)
    }
    return nil
}

func (x *ListUnion) readField2(p thrift.Decoder) error {  // IntListValue
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int64, 0, size)
    for i := 0; i < size; i++ {
        var elem int64
        {
            result, err := p.ReadI64()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.IntListValue = result
    return nil
}

func (x *ListUnion) readField3(p thrift.Decoder) error {  // StringListValue
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]string, 0, size)
    for i := 0; i < size; i++ {
        var elem string
        {
            result, err := p.ReadString()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.StringListValue = result
    return nil
}

func (x *ListUnion) countSetFields() int {
    count := int(0)
    if (x.IsSetIntListValue()) {
        count++
    }
    if (x.IsSetStringListValue()) {
        count++
    }
    return count
}

func (x *ListUnion) CountSetFieldsListUnion() int {
    return x.countSetFields()
}



func (x *ListUnion) Write(p thrift.Encoder) error {
    if countSet := x.countSetFields(); countSet > 1 {
        return fmt.Errorf("ListUnion write union: no more than one field must be set (%d set).", countSet)
    }
    if err := p.WriteStructBegin("ListUnion"); err != nil {
        return thrift.PrependError("ListUnion write struct begin error: ", err)
    }

    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ListUnion write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ListUnion write struct end error: ", err)
    }
    return nil
}

func (x *ListUnion) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ListUnion read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ListUnion field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 2 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "intListValue")):  // intListValue
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "stringListValue")):  // stringListValue
            fieldReadErr = x.readField3(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ListUnion read struct end error: ", err)
    }

    return nil
}

func (x *ListUnion) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ListUnion) setDefaults() *ListUnion {
    return x
}

func (x *ListUnion) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_ListUnion
}

type DataUnion struct {
    BinaryData []byte `thrift:"binaryData,1" json:"binaryData,omitempty" db:"binaryData"`
    StringData *string `thrift:"stringData,2" json:"stringData,omitempty" db:"stringData"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*DataUnion)(nil)

func NewDataUnion() *DataUnion {
    return (&DataUnion{}).setDefaults()
}

func (x *DataUnion) GetBinaryData() []byte {
    if !x.IsSetBinaryData() {
        return []byte("")
    }
    return x.BinaryData
}

func (x *DataUnion) GetStringData() string {
    if !x.IsSetStringData() {
        return ""
    }
    return *x.StringData
}

func (x *DataUnion) SetBinaryDataNonCompat(value []byte) *DataUnion {
    x.BinaryData = value
    return x
}

func (x *DataUnion) SetBinaryData(value []byte) *DataUnion {
    x.BinaryData = value
    return x
}

func (x *DataUnion) SetStringDataNonCompat(value string) *DataUnion {
    x.StringData = &value
    return x
}

func (x *DataUnion) SetStringData(value *string) *DataUnion {
    x.StringData = value
    return x
}

func (x *DataUnion) IsSetBinaryData() bool {
    return x != nil && x.BinaryData != nil
}

func (x *DataUnion) IsSetStringData() bool {
    return x != nil && x.StringData != nil
}

func (x *DataUnion) writeField1(p thrift.Encoder) error {  // BinaryData
    if !x.IsSetBinaryData() {
        return nil
    }

    if err := p.WriteFieldBegin("binaryData", thrift.STRING, 1); err != nil {
        return thrift.PrependError("DataUnion write field begin error: ", err)
    }

    item := x.BinaryData
    if err := p.WriteBinary(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("DataUnion write field end error: ", err)
    }
    return nil
}

func (x *DataUnion) writeField2(p thrift.Encoder) error {  // StringData
    if !x.IsSetStringData() {
        return nil
    }

    if err := p.WriteFieldBegin("stringData", thrift.STRING, 2); err != nil {
        return thrift.PrependError("DataUnion write field begin error: ", err)
    }

    item := *x.StringData
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("DataUnion write field end error: ", err)
    }
    return nil
}

func (x *DataUnion) readField1(p thrift.Decoder) error {  // BinaryData
    result, err := p.ReadBinary()
    if err != nil {
        return err
    }

    x.BinaryData = result
    return nil
}

func (x *DataUnion) readField2(p thrift.Decoder) error {  // StringData
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.StringData = &result
    return nil
}


func (x *DataUnion) countSetFields() int {
    count := int(0)
    if (x.IsSetBinaryData()) {
        count++
    }
    if (x.IsSetStringData()) {
        count++
    }
    return count
}

func (x *DataUnion) CountSetFieldsDataUnion() int {
    return x.countSetFields()
}



func (x *DataUnion) Write(p thrift.Encoder) error {
    if countSet := x.countSetFields(); countSet > 1 {
        return fmt.Errorf("DataUnion write union: no more than one field must be set (%d set).", countSet)
    }
    if err := p.WriteStructBegin("DataUnion"); err != nil {
        return thrift.PrependError("DataUnion write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("DataUnion write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("DataUnion write struct end error: ", err)
    }
    return nil
}

func (x *DataUnion) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("DataUnion read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("DataUnion field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "binaryData")):  // binaryData
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "stringData")):  // stringData
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("DataUnion read struct end error: ", err)
    }

    return nil
}

func (x *DataUnion) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *DataUnion) setDefaults() *DataUnion {
    return x
}

func (x *DataUnion) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_DataUnion
}

type Val struct {
    StrVal string `thrift:"strVal,1" json:"strVal" db:"strVal"`
    IntVal int32 `thrift:"intVal,2" json:"intVal" db:"intVal"`
    TypedefValue ContainerTypedef `thrift:"typedefValue,9" json:"typedefValue" db:"typedefValue"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Val)(nil)

func NewVal() *Val {
    return (&Val{}).setDefaults()
}

func (x *Val) GetStrVal() string {
    return x.StrVal
}

func (x *Val) GetIntVal() int32 {
    return x.IntVal
}

func (x *Val) GetTypedefValue() ContainerTypedef {
    if !x.IsSetTypedefValue() {
        return NewContainerTypedef()
    }
    return x.TypedefValue
}

func (x *Val) SetStrValNonCompat(value string) *Val {
    x.StrVal = value
    return x
}

func (x *Val) SetStrVal(value string) *Val {
    x.StrVal = value
    return x
}

func (x *Val) SetIntValNonCompat(value int32) *Val {
    x.IntVal = value
    return x
}

func (x *Val) SetIntVal(value int32) *Val {
    x.IntVal = value
    return x
}

func (x *Val) SetTypedefValueNonCompat(value ContainerTypedef) *Val {
    x.TypedefValue = value
    return x
}

func (x *Val) SetTypedefValue(value ContainerTypedef) *Val {
    x.TypedefValue = value
    return x
}

func (x *Val) IsSetTypedefValue() bool {
    return x != nil && x.TypedefValue != nil
}

func (x *Val) writeField1(p thrift.Encoder) error {  // StrVal
    if err := p.WriteFieldBegin("strVal", thrift.STRING, 1); err != nil {
        return thrift.PrependError("Val write field begin error: ", err)
    }

    item := x.StrVal
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("Val write field end error: ", err)
    }
    return nil
}

func (x *Val) writeField2(p thrift.Encoder) error {  // IntVal
    if err := p.WriteFieldBegin("intVal", thrift.I32, 2); err != nil {
        return thrift.PrependError("Val write field begin error: ", err)
    }

    item := x.IntVal
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("Val write field end error: ", err)
    }
    return nil
}

func (x *Val) writeField9(p thrift.Encoder) error {  // TypedefValue
    if err := p.WriteFieldBegin("typedefValue", thrift.MAP, 9); err != nil {
        return thrift.PrependError("Val write field begin error: ", err)
    }

    item := x.TypedefValue
    err := WriteContainerTypedef(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("Val write field end error: ", err)
    }
    return nil
}

func (x *Val) readField1(p thrift.Decoder) error {  // StrVal
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.StrVal = result
    return nil
}

func (x *Val) readField2(p thrift.Decoder) error {  // IntVal
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.IntVal = result
    return nil
}

func (x *Val) readField9(p thrift.Decoder) error {  // TypedefValue
    result, err := ReadContainerTypedef(p)
    if err != nil {
        return err
    }

    x.TypedefValue = result
    return nil
}



func (x *Val) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Val"); err != nil {
        return thrift.PrependError("Val write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField9(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("Val write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("Val write struct end error: ", err)
    }
    return nil
}

func (x *Val) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("Val read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("Val field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "strVal")):  // strVal
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "intVal")):  // intVal
            fieldReadErr = x.readField2(p)
        case ((id == 9 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "typedefValue")):  // typedefValue
            fieldReadErr = x.readField9(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("Val read struct end error: ", err)
    }

    return nil
}

func (x *Val) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Val) setDefaults() *Val {
    return x.
        SetStrValNonCompat("").
        SetIntValNonCompat(0).
        SetTypedefValueNonCompat(NewContainerTypedef())
}

func (x *Val) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_Val
}

type ValUnion struct {
    V1 *Val `thrift:"v1,1" json:"v1,omitempty" db:"v1"`
    V2 *Val `thrift:"v2,2" json:"v2,omitempty" db:"v2"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ValUnion)(nil)

func NewValUnion() *ValUnion {
    return (&ValUnion{}).setDefaults()
}

func (x *ValUnion) GetV1() *Val {
    if !x.IsSetV1() {
        return nil
    }
    return x.V1
}

func (x *ValUnion) GetV2() *Val {
    if !x.IsSetV2() {
        return nil
    }
    return x.V2
}

func (x *ValUnion) SetV1NonCompat(value *Val) *ValUnion {
    x.V1 = value
    return x
}

func (x *ValUnion) SetV1(value *Val) *ValUnion {
    x.V1 = value
    return x
}

func (x *ValUnion) SetV2NonCompat(value *Val) *ValUnion {
    x.V2 = value
    return x
}

func (x *ValUnion) SetV2(value *Val) *ValUnion {
    x.V2 = value
    return x
}

func (x *ValUnion) IsSetV1() bool {
    return x != nil && x.V1 != nil
}

func (x *ValUnion) IsSetV2() bool {
    return x != nil && x.V2 != nil
}

func (x *ValUnion) writeField1(p thrift.Encoder) error {  // V1
    if !x.IsSetV1() {
        return nil
    }

    if err := p.WriteFieldBegin("v1", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError("ValUnion write field begin error: ", err)
    }

    item := x.V1
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ValUnion write field end error: ", err)
    }
    return nil
}

func (x *ValUnion) writeField2(p thrift.Encoder) error {  // V2
    if !x.IsSetV2() {
        return nil
    }

    if err := p.WriteFieldBegin("v2", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError("ValUnion write field begin error: ", err)
    }

    item := x.V2
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ValUnion write field end error: ", err)
    }
    return nil
}

func (x *ValUnion) readField1(p thrift.Decoder) error {  // V1
    result := NewVal()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.V1 = result
    return nil
}

func (x *ValUnion) readField2(p thrift.Decoder) error {  // V2
    result := NewVal()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.V2 = result
    return nil
}



func (x *ValUnion) countSetFields() int {
    count := int(0)
    if (x.IsSetV1()) {
        count++
    }
    if (x.IsSetV2()) {
        count++
    }
    return count
}

func (x *ValUnion) CountSetFieldsValUnion() int {
    return x.countSetFields()
}



func (x *ValUnion) Write(p thrift.Encoder) error {
    if countSet := x.countSetFields(); countSet > 1 {
        return fmt.Errorf("ValUnion write union: no more than one field must be set (%d set).", countSet)
    }
    if err := p.WriteStructBegin("ValUnion"); err != nil {
        return thrift.PrependError("ValUnion write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ValUnion write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ValUnion write struct end error: ", err)
    }
    return nil
}

func (x *ValUnion) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ValUnion read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ValUnion field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "v1")):  // v1
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "v2")):  // v2
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ValUnion read struct end error: ", err)
    }

    return nil
}

func (x *ValUnion) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ValUnion) setDefaults() *ValUnion {
    return x
}

func (x *ValUnion) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_ValUnion
}

type VirtualComplexUnion struct {
    ThingOne *string `thrift:"thingOne,1" json:"thingOne,omitempty" db:"thingOne"`
    ThingTwo *string `thrift:"thingTwo,2" json:"thingTwo,omitempty" db:"thingTwo"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*VirtualComplexUnion)(nil)

func NewVirtualComplexUnion() *VirtualComplexUnion {
    return (&VirtualComplexUnion{}).setDefaults()
}

func (x *VirtualComplexUnion) GetThingOne() string {
    if !x.IsSetThingOne() {
        return ""
    }
    return *x.ThingOne
}

func (x *VirtualComplexUnion) GetThingTwo() string {
    if !x.IsSetThingTwo() {
        return ""
    }
    return *x.ThingTwo
}

func (x *VirtualComplexUnion) SetThingOneNonCompat(value string) *VirtualComplexUnion {
    x.ThingOne = &value
    return x
}

func (x *VirtualComplexUnion) SetThingOne(value *string) *VirtualComplexUnion {
    x.ThingOne = value
    return x
}

func (x *VirtualComplexUnion) SetThingTwoNonCompat(value string) *VirtualComplexUnion {
    x.ThingTwo = &value
    return x
}

func (x *VirtualComplexUnion) SetThingTwo(value *string) *VirtualComplexUnion {
    x.ThingTwo = value
    return x
}

func (x *VirtualComplexUnion) IsSetThingOne() bool {
    return x != nil && x.ThingOne != nil
}

func (x *VirtualComplexUnion) IsSetThingTwo() bool {
    return x != nil && x.ThingTwo != nil
}

func (x *VirtualComplexUnion) writeField1(p thrift.Encoder) error {  // ThingOne
    if !x.IsSetThingOne() {
        return nil
    }

    if err := p.WriteFieldBegin("thingOne", thrift.STRING, 1); err != nil {
        return thrift.PrependError("VirtualComplexUnion write field begin error: ", err)
    }

    item := *x.ThingOne
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("VirtualComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *VirtualComplexUnion) writeField2(p thrift.Encoder) error {  // ThingTwo
    if !x.IsSetThingTwo() {
        return nil
    }

    if err := p.WriteFieldBegin("thingTwo", thrift.STRING, 2); err != nil {
        return thrift.PrependError("VirtualComplexUnion write field begin error: ", err)
    }

    item := *x.ThingTwo
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("VirtualComplexUnion write field end error: ", err)
    }
    return nil
}

func (x *VirtualComplexUnion) readField1(p thrift.Decoder) error {  // ThingOne
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.ThingOne = &result
    return nil
}

func (x *VirtualComplexUnion) readField2(p thrift.Decoder) error {  // ThingTwo
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.ThingTwo = &result
    return nil
}



func (x *VirtualComplexUnion) countSetFields() int {
    count := int(0)
    if (x.IsSetThingOne()) {
        count++
    }
    if (x.IsSetThingTwo()) {
        count++
    }
    return count
}

func (x *VirtualComplexUnion) CountSetFieldsVirtualComplexUnion() int {
    return x.countSetFields()
}



func (x *VirtualComplexUnion) Write(p thrift.Encoder) error {
    if countSet := x.countSetFields(); countSet > 1 {
        return fmt.Errorf("VirtualComplexUnion write union: no more than one field must be set (%d set).", countSet)
    }
    if err := p.WriteStructBegin("VirtualComplexUnion"); err != nil {
        return thrift.PrependError("VirtualComplexUnion write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("VirtualComplexUnion write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("VirtualComplexUnion write struct end error: ", err)
    }
    return nil
}

func (x *VirtualComplexUnion) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("VirtualComplexUnion read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("VirtualComplexUnion field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "thingOne")):  // thingOne
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "thingTwo")):  // thingTwo
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("VirtualComplexUnion read struct end error: ", err)
    }

    return nil
}

func (x *VirtualComplexUnion) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *VirtualComplexUnion) setDefaults() *VirtualComplexUnion {
    return x
}

func (x *VirtualComplexUnion) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_VirtualComplexUnion
}

type NonCopyableStruct struct {
    Num int64 `thrift:"num,1" json:"num" db:"num"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*NonCopyableStruct)(nil)

func NewNonCopyableStruct() *NonCopyableStruct {
    return (&NonCopyableStruct{}).setDefaults()
}

func (x *NonCopyableStruct) GetNum() int64 {
    return x.Num
}

func (x *NonCopyableStruct) SetNumNonCompat(value int64) *NonCopyableStruct {
    x.Num = value
    return x
}

func (x *NonCopyableStruct) SetNum(value int64) *NonCopyableStruct {
    x.Num = value
    return x
}

func (x *NonCopyableStruct) writeField1(p thrift.Encoder) error {  // Num
    if err := p.WriteFieldBegin("num", thrift.I64, 1); err != nil {
        return thrift.PrependError("NonCopyableStruct write field begin error: ", err)
    }

    item := x.Num
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("NonCopyableStruct write field end error: ", err)
    }
    return nil
}

func (x *NonCopyableStruct) readField1(p thrift.Decoder) error {  // Num
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.Num = result
    return nil
}



func (x *NonCopyableStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("NonCopyableStruct"); err != nil {
        return thrift.PrependError("NonCopyableStruct write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("NonCopyableStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("NonCopyableStruct write struct end error: ", err)
    }
    return nil
}

func (x *NonCopyableStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("NonCopyableStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("NonCopyableStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "num")):  // num
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("NonCopyableStruct read struct end error: ", err)
    }

    return nil
}

func (x *NonCopyableStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *NonCopyableStruct) setDefaults() *NonCopyableStruct {
    return x.
        SetNumNonCompat(0)
}

func (x *NonCopyableStruct) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_NonCopyableStruct
}

type NonCopyableUnion struct {
    S *NonCopyableStruct `thrift:"s,1" json:"s,omitempty" db:"s"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*NonCopyableUnion)(nil)

func NewNonCopyableUnion() *NonCopyableUnion {
    return (&NonCopyableUnion{}).setDefaults()
}

func (x *NonCopyableUnion) GetS() *NonCopyableStruct {
    if !x.IsSetS() {
        return nil
    }
    return x.S
}

func (x *NonCopyableUnion) SetSNonCompat(value *NonCopyableStruct) *NonCopyableUnion {
    x.S = value
    return x
}

func (x *NonCopyableUnion) SetS(value *NonCopyableStruct) *NonCopyableUnion {
    x.S = value
    return x
}

func (x *NonCopyableUnion) IsSetS() bool {
    return x != nil && x.S != nil
}

func (x *NonCopyableUnion) writeField1(p thrift.Encoder) error {  // S
    if !x.IsSetS() {
        return nil
    }

    if err := p.WriteFieldBegin("s", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError("NonCopyableUnion write field begin error: ", err)
    }

    item := x.S
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("NonCopyableUnion write field end error: ", err)
    }
    return nil
}

func (x *NonCopyableUnion) readField1(p thrift.Decoder) error {  // S
    result := NewNonCopyableStruct()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.S = result
    return nil
}


func (x *NonCopyableUnion) countSetFields() int {
    count := int(0)
    if (x.IsSetS()) {
        count++
    }
    return count
}

func (x *NonCopyableUnion) CountSetFieldsNonCopyableUnion() int {
    return x.countSetFields()
}



func (x *NonCopyableUnion) Write(p thrift.Encoder) error {
    if countSet := x.countSetFields(); countSet > 1 {
        return fmt.Errorf("NonCopyableUnion write union: no more than one field must be set (%d set).", countSet)
    }
    if err := p.WriteStructBegin("NonCopyableUnion"); err != nil {
        return thrift.PrependError("NonCopyableUnion write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("NonCopyableUnion write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("NonCopyableUnion write struct end error: ", err)
    }
    return nil
}

func (x *NonCopyableUnion) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("NonCopyableUnion read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("NonCopyableUnion field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "s")):  // s
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("NonCopyableUnion read struct end error: ", err)
    }

    return nil
}

func (x *NonCopyableUnion) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *NonCopyableUnion) setDefaults() *NonCopyableUnion {
    return x
}

func (x *NonCopyableUnion) GetThriftStructMetadata() *metadata.ThriftStruct {
    return premadeStructMetadata_NonCopyableUnion
}


// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
  RegisterType(name string, initializer func() any)
}) {

}
