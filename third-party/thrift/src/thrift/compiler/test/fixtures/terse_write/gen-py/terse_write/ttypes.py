#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.cpp.ttypes
import thrift.annotation.hack.ttypes
import thrift.annotation.thrift.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyStruct', 'MyUnion', 'MyStructWithCustomDefault', 'StructLevelTerseStruct', 'FieldLevelTerseStruct', 'TerseStructWithCustomDefault', 'AdaptedFields', 'WrappedFields', 'TerseException', 'MyInteger']

class MyEnum:
  ME0 = 0
  ME1 = 1

  _VALUES_TO_NAMES = {
    0: "ME0",
    1: "ME1",
  }

  _NAMES_TO_VALUES = {
    "ME0": 0,
    "ME1": 1,
  }

class MyStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  r"""
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  BOOL_FIELD = 1
  BYTE_FIELD = 2
  SHORT_FIELD = 3
  INT_FIELD = 4
  LONG_FIELD = 5
  FLOAT_FIELD = 6
  DOUBLE_FIELD = 7
  STRING_FIELD = 8
  BINARY_FIELD = 9
  ENUM_FIELD = 10
  LIST_FIELD = 11
  SET_FIELD = 12
  MAP_FIELD = 13
  STRUCT_FIELD = 14
  
  @staticmethod
  def isUnion():
    return True

  def get_bool_field(self):
    assert self.field == 1
    return self.value

  def get_byte_field(self):
    assert self.field == 2
    return self.value

  def get_short_field(self):
    assert self.field == 3
    return self.value

  def get_int_field(self):
    assert self.field == 4
    return self.value

  def get_long_field(self):
    assert self.field == 5
    return self.value

  def get_float_field(self):
    assert self.field == 6
    return self.value

  def get_double_field(self):
    assert self.field == 7
    return self.value

  def get_string_field(self):
    assert self.field == 8
    return self.value

  def get_binary_field(self):
    assert self.field == 9
    return self.value

  def get_enum_field(self):
    assert self.field == 10
    return self.value

  def get_list_field(self):
    assert self.field == 11
    return self.value

  def get_set_field(self):
    assert self.field == 12
    return self.value

  def get_map_field(self):
    assert self.field == 13
    return self.value

  def get_struct_field(self):
    assert self.field == 14
    return self.value

  def set_bool_field(self, value):
    self.field = 1
    self.value = value

  def set_byte_field(self, value):
    self.field = 2
    self.value = value

  def set_short_field(self, value):
    self.field = 3
    self.value = value

  def set_int_field(self, value):
    self.field = 4
    self.value = value

  def set_long_field(self, value):
    self.field = 5
    self.value = value

  def set_float_field(self, value):
    self.field = 6
    self.value = value

  def set_double_field(self, value):
    self.field = 7
    self.value = value

  def set_string_field(self, value):
    self.field = 8
    self.value = value

  def set_binary_field(self, value):
    self.field = 9
    self.value = value

  def set_enum_field(self, value):
    self.field = 10
    self.value = value

  def set_list_field(self, value):
    self.field = 11
    self.value = value

  def set_set_field(self, value):
    self.field = 12
    self.value = value

  def set_map_field(self, value):
    self.field = 13
    self.value = value

  def set_struct_field(self, value):
    self.field = 14
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bool_field', value)
    if self.field == 2:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('byte_field', value)
    if self.field == 3:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('short_field', value)
    if self.field == 4:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('int_field', value)
    if self.field == 5:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('long_field', value)
    if self.field == 6:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('float_field', value)
    if self.field == 7:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('double_field', value)
    if self.field == 8:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('string_field', value)
    if self.field == 9:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('binary_field', value)
    if self.field == 10:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('enum_field', value)
    if self.field == 11:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('list_field', value)
    if self.field == 12:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('set_field', value)
    if self.field == 13:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('map_field', value)
    if self.field == 14:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('struct_field', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.BOOL:
          _fbthrift_bool_field = iprot.readBool()
          assert self.field == 0 and self.value is None
          self.set_bool_field(_fbthrift_bool_field)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          _fbthrift_byte_field = iprot.readByte()
          assert self.field == 0 and self.value is None
          self.set_byte_field(_fbthrift_byte_field)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          _fbthrift_short_field = iprot.readI16()
          assert self.field == 0 and self.value is None
          self.set_short_field(_fbthrift_short_field)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          _fbthrift_int_field = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_int_field(_fbthrift_int_field)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          _fbthrift_long_field = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_long_field(_fbthrift_long_field)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          _fbthrift_float_field = iprot.readFloat()
          assert self.field == 0 and self.value is None
          self.set_float_field(_fbthrift_float_field)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          _fbthrift_double_field = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_double_field(_fbthrift_double_field)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          _fbthrift_string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_string_field(_fbthrift_string_field)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          _fbthrift_binary_field = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_binary_field(_fbthrift_binary_field)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          _fbthrift_enum_field = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_enum_field(_fbthrift_enum_field)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          _fbthrift_list_field = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              _fbthrift_list_field.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              _fbthrift_list_field.append(_elem6)
          iprot.readListEnd()
          assert self.field == 0 and self.value is None
          self.set_list_field(_fbthrift_list_field)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          _fbthrift_set_field = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readI16()
              _fbthrift_set_field.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readI16()
              _fbthrift_set_field.add(_elem13)
          iprot.readSetEnd()
          assert self.field == 0 and self.value is None
          self.set_set_field(_fbthrift_set_field)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          _fbthrift_map_field = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readI16()
              _val20 = iprot.readI16()
              _fbthrift_map_field[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readI16()
              _val22 = iprot.readI16()
              _fbthrift_map_field[_key21] = _val22
          iprot.readMapEnd()
          assert self.field == 0 and self.value is None
          self.set_map_field(_fbthrift_map_field)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          _fbthrift_struct_field = MyStruct()
          _fbthrift_struct_field.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_struct_field(_fbthrift_struct_field)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      bool_field = self.value
      oprot.writeBool(bool_field)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      byte_field = self.value
      oprot.writeByte(byte_field)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      short_field = self.value
      oprot.writeI16(short_field)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      int_field = self.value
      oprot.writeI32(int_field)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      long_field = self.value
      oprot.writeI64(long_field)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      float_field = self.value
      oprot.writeFloat(float_field)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      double_field = self.value
      oprot.writeDouble(double_field)
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      string_field = self.value
      oprot.writeString(string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(string_field, bytes) else oprot.writeString(string_field)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      binary_field = self.value
      oprot.writeString(binary_field)
      oprot.writeFieldEnd()
    if self.field == 10:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      enum_field = self.value
      oprot.writeI32(enum_field)
      oprot.writeFieldEnd()
    if self.field == 11:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      list_field = self.value
      oprot.writeListBegin(TType.I16, len(list_field))
      for iter23 in list_field:
        oprot.writeI16(iter23)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.field == 12:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      set_field = self.value
      oprot.writeSetBegin(TType.I16, len(set_field))
      for iter24 in set_field:
        oprot.writeI16(iter24)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.field == 13:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      map_field = self.value
      oprot.writeMapBegin(TType.I16, TType.I16, len(map_field))
      for kiter25,viter26 in map_field.items():
        oprot.writeI16(kiter25)
        oprot.writeI16(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.field == 14:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      struct_field = self.value
      struct_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'bool_field' in obj:
      _fbthrift_bool_field = obj['bool_field']
      self.set_bool_field(_fbthrift_bool_field)
    if 'byte_field' in obj:
      _fbthrift_byte_field = obj['byte_field']
      if _fbthrift_byte_field > 0x7f or _fbthrift_byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_byte_field(_fbthrift_byte_field)
    if 'short_field' in obj:
      _fbthrift_short_field = obj['short_field']
      if _fbthrift_short_field > 0x7fff or _fbthrift_short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_short_field(_fbthrift_short_field)
    if 'int_field' in obj:
      _fbthrift_int_field = obj['int_field']
      if _fbthrift_int_field > 0x7fffffff or _fbthrift_int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_int_field(_fbthrift_int_field)
    if 'long_field' in obj:
      _fbthrift_long_field = long(obj['long_field'])
      self.set_long_field(_fbthrift_long_field)
    if 'float_field' in obj:
      _fbthrift_float_field = float(obj['float_field'])
      self.set_float_field(_fbthrift_float_field)
    if 'double_field' in obj:
      _fbthrift_double_field = float(obj['double_field'])
      self.set_double_field(_fbthrift_double_field)
    if 'string_field' in obj:
      _fbthrift_string_field = obj['string_field']
      self.set_string_field(_fbthrift_string_field)
    if 'binary_field' in obj:
      _fbthrift_binary_field = obj['binary_field']
      self.set_binary_field(_fbthrift_binary_field)
    if 'enum_field' in obj:
      _fbthrift_enum_field = obj['enum_field']
      if not _fbthrift_enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % _fbthrift_enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_enum_field(_fbthrift_enum_field)
    if 'list_field' in obj:
      _fbthrift_list_field = []
      for _tmp_e27 in obj['list_field']:
        if _tmp_e27 > 0x7fff or _tmp_e27 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        _fbthrift_list_field.append(_tmp_e27)
      self.set_list_field(_fbthrift_list_field)
    if 'set_field' in obj:
      _fbthrift_set_field = set_cls()
      for _tmp_e28 in obj['set_field']:
        if _tmp_e28 > 0x7fff or _tmp_e28 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        _fbthrift_set_field.add(_tmp_e28)
      self.set_set_field(_fbthrift_set_field)
    if 'map_field' in obj:
      _fbthrift_map_field = dict_cls()
      for _tmp_k29, _tmp_v30 in obj['map_field'].items():
        _tmp_kp31 = int(_tmp_k29)
        if _tmp_kp31 > 0x7fff or _tmp_kp31 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k29)
        if _tmp_v30 > 0x7fff or _tmp_v30 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        _fbthrift_map_field[_tmp_kp31] = _tmp_v30
      self.set_map_field(_fbthrift_map_field)
    if 'struct_field' in obj:
      _fbthrift_struct_field = MyStruct()
      _fbthrift_struct_field.readFromJson(obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_struct_field(_fbthrift_struct_field)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyStructWithCustomDefault:
  r"""
  Attributes:
   - field1
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.field1 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructWithCustomDefault')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I64, 1)
      oprot.writeI64(self.field1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = long(json_obj['field1'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class StructLevelTerseStruct:
  r"""
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
   - union_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype35, _size32) = iprot.readListBegin()
          if _size32 >= 0:
            for _i36 in range(_size32):
              _elem37 = iprot.readI16()
              self.list_field.append(_elem37)
          else: 
            while iprot.peekList():
              _elem38 = iprot.readI16()
              self.list_field.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype42, _size39) = iprot.readSetBegin()
          if _size39 >= 0:
            for _i43 in range(_size39):
              _elem44 = iprot.readI16()
              self.set_field.add(_elem44)
          else: 
            while iprot.peekSet():
              _elem45 = iprot.readI16()
              self.set_field.add(_elem45)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype47, _vtype48, _size46 ) = iprot.readMapBegin() 
          if _size46 >= 0:
            for _i50 in range(_size46):
              _key51 = iprot.readI16()
              _val52 = iprot.readI16()
              self.map_field[_key51] = _val52
          else: 
            while iprot.peekMap():
              _key53 = iprot.readI16()
              _val54 = iprot.readI16()
              self.map_field[_key53] = _val54
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.struct_field = MyStruct()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.union_field = MyUnion()
          self.union_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructLevelTerseStruct')
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter55 in self.list_field:
        oprot.writeI16(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter56 in self.set_field:
        oprot.writeI16(iter56)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter57,viter58 in self.map_field.items():
        oprot.writeI16(kiter57)
        oprot.writeI16(viter58)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    if self.union_field != None:
      oprot.writeFieldBegin('union_field', TType.STRUCT, 15)
      self.union_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e59 in json_obj['list_field']:
        if _tmp_e59 > 0x7fff or _tmp_e59 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e59)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e60 in json_obj['set_field']:
        if _tmp_e60 > 0x7fff or _tmp_e60 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e60)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k61, _tmp_v62 in json_obj['map_field'].items():
        _tmp_kp63 = int(_tmp_k61)
        if _tmp_kp63 > 0x7fff or _tmp_kp63 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k61)
        if _tmp_v62 > 0x7fff or _tmp_v62 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp63] = _tmp_v62
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStruct()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'union_field' in json_obj and json_obj['union_field'] is not None:
      self.union_field = MyUnion()
      self.union_field.readFromJson(json_obj['union_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    if self.union_field is not None:
      value = pprint.pformat(self.union_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    union_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
      'union_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructLevelTerseStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructLevelTerseStruct, self)

  def _to_py_deprecated(self):
    return self

class FieldLevelTerseStruct:
  r"""
  Attributes:
   - terse_bool_field
   - terse_byte_field
   - terse_short_field
   - terse_int_field
   - terse_long_field
   - terse_float_field
   - terse_double_field
   - terse_string_field
   - terse_binary_field
   - terse_enum_field
   - terse_list_field
   - terse_set_field
   - terse_map_field
   - terse_struct_field
   - terse_union_field
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
   - union_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.terse_bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.terse_byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.terse_short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.terse_int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.terse_long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.terse_float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.terse_double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.terse_string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.terse_binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.terse_enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.terse_list_field = []
          (_etype67, _size64) = iprot.readListBegin()
          if _size64 >= 0:
            for _i68 in range(_size64):
              _elem69 = iprot.readI16()
              self.terse_list_field.append(_elem69)
          else: 
            while iprot.peekList():
              _elem70 = iprot.readI16()
              self.terse_list_field.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.terse_set_field = set()
          (_etype74, _size71) = iprot.readSetBegin()
          if _size71 >= 0:
            for _i75 in range(_size71):
              _elem76 = iprot.readI16()
              self.terse_set_field.add(_elem76)
          else: 
            while iprot.peekSet():
              _elem77 = iprot.readI16()
              self.terse_set_field.add(_elem77)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.terse_map_field = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          if _size78 >= 0:
            for _i82 in range(_size78):
              _key83 = iprot.readI16()
              _val84 = iprot.readI16()
              self.terse_map_field[_key83] = _val84
          else: 
            while iprot.peekMap():
              _key85 = iprot.readI16()
              _val86 = iprot.readI16()
              self.terse_map_field[_key85] = _val86
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.terse_struct_field = MyStruct()
          self.terse_struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.STRUCT:
          self.terse_union_field = MyUnion()
          self.terse_union_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype90, _size87) = iprot.readListBegin()
          if _size87 >= 0:
            for _i91 in range(_size87):
              _elem92 = iprot.readI16()
              self.list_field.append(_elem92)
          else: 
            while iprot.peekList():
              _elem93 = iprot.readI16()
              self.list_field.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype97, _size94) = iprot.readSetBegin()
          if _size94 >= 0:
            for _i98 in range(_size94):
              _elem99 = iprot.readI16()
              self.set_field.add(_elem99)
          else: 
            while iprot.peekSet():
              _elem100 = iprot.readI16()
              self.set_field.add(_elem100)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype102, _vtype103, _size101 ) = iprot.readMapBegin() 
          if _size101 >= 0:
            for _i105 in range(_size101):
              _key106 = iprot.readI16()
              _val107 = iprot.readI16()
              self.map_field[_key106] = _val107
          else: 
            while iprot.peekMap():
              _key108 = iprot.readI16()
              _val109 = iprot.readI16()
              self.map_field[_key108] = _val109
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.STRUCT:
          self.struct_field = MyStruct()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRUCT:
          self.union_field = MyUnion()
          self.union_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FieldLevelTerseStruct')
    if self.terse_bool_field != None:
      oprot.writeFieldBegin('terse_bool_field', TType.BOOL, 1)
      oprot.writeBool(self.terse_bool_field)
      oprot.writeFieldEnd()
    if self.terse_byte_field != None:
      oprot.writeFieldBegin('terse_byte_field', TType.BYTE, 2)
      oprot.writeByte(self.terse_byte_field)
      oprot.writeFieldEnd()
    if self.terse_short_field != None:
      oprot.writeFieldBegin('terse_short_field', TType.I16, 3)
      oprot.writeI16(self.terse_short_field)
      oprot.writeFieldEnd()
    if self.terse_int_field != None:
      oprot.writeFieldBegin('terse_int_field', TType.I32, 4)
      oprot.writeI32(self.terse_int_field)
      oprot.writeFieldEnd()
    if self.terse_long_field != None:
      oprot.writeFieldBegin('terse_long_field', TType.I64, 5)
      oprot.writeI64(self.terse_long_field)
      oprot.writeFieldEnd()
    if self.terse_float_field != None:
      oprot.writeFieldBegin('terse_float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.terse_float_field)
      oprot.writeFieldEnd()
    if self.terse_double_field != None:
      oprot.writeFieldBegin('terse_double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.terse_double_field)
      oprot.writeFieldEnd()
    if self.terse_string_field != None:
      oprot.writeFieldBegin('terse_string_field', TType.STRING, 8)
      oprot.writeString(self.terse_string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.terse_string_field, bytes) else oprot.writeString(self.terse_string_field)
      oprot.writeFieldEnd()
    if self.terse_binary_field != None:
      oprot.writeFieldBegin('terse_binary_field', TType.STRING, 9)
      oprot.writeString(self.terse_binary_field)
      oprot.writeFieldEnd()
    if self.terse_enum_field != None:
      oprot.writeFieldBegin('terse_enum_field', TType.I32, 10)
      oprot.writeI32(self.terse_enum_field)
      oprot.writeFieldEnd()
    if self.terse_list_field != None:
      oprot.writeFieldBegin('terse_list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.terse_list_field))
      for iter110 in self.terse_list_field:
        oprot.writeI16(iter110)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.terse_set_field != None:
      oprot.writeFieldBegin('terse_set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.terse_set_field))
      for iter111 in self.terse_set_field:
        oprot.writeI16(iter111)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.terse_map_field != None:
      oprot.writeFieldBegin('terse_map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.terse_map_field))
      for kiter112,viter113 in self.terse_map_field.items():
        oprot.writeI16(kiter112)
        oprot.writeI16(viter113)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.terse_struct_field != None:
      oprot.writeFieldBegin('terse_struct_field', TType.STRUCT, 14)
      self.terse_struct_field.write(oprot)
      oprot.writeFieldEnd()
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 15)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 16)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 17)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 18)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 19)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 20)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 21)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 22)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 23)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 24)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 25)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter114 in self.list_field:
        oprot.writeI16(iter114)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 26)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter115 in self.set_field:
        oprot.writeI16(iter115)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 27)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter116,viter117 in self.map_field.items():
        oprot.writeI16(kiter116)
        oprot.writeI16(viter117)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 28)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    if self.terse_union_field != None:
      oprot.writeFieldBegin('terse_union_field', TType.STRUCT, 29)
      self.terse_union_field.write(oprot)
      oprot.writeFieldEnd()
    if self.union_field != None:
      oprot.writeFieldBegin('union_field', TType.STRUCT, 30)
      self.union_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'terse_bool_field' in json_obj and json_obj['terse_bool_field'] is not None:
      self.terse_bool_field = json_obj['terse_bool_field']
    if 'terse_byte_field' in json_obj and json_obj['terse_byte_field'] is not None:
      self.terse_byte_field = json_obj['terse_byte_field']
      if self.terse_byte_field > 0x7f or self.terse_byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_short_field' in json_obj and json_obj['terse_short_field'] is not None:
      self.terse_short_field = json_obj['terse_short_field']
      if self.terse_short_field > 0x7fff or self.terse_short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_int_field' in json_obj and json_obj['terse_int_field'] is not None:
      self.terse_int_field = json_obj['terse_int_field']
      if self.terse_int_field > 0x7fffffff or self.terse_int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_long_field' in json_obj and json_obj['terse_long_field'] is not None:
      self.terse_long_field = long(json_obj['terse_long_field'])
    if 'terse_float_field' in json_obj and json_obj['terse_float_field'] is not None:
      self.terse_float_field = float(json_obj['terse_float_field'])
    if 'terse_double_field' in json_obj and json_obj['terse_double_field'] is not None:
      self.terse_double_field = float(json_obj['terse_double_field'])
    if 'terse_string_field' in json_obj and json_obj['terse_string_field'] is not None:
      self.terse_string_field = json_obj['terse_string_field']
    if 'terse_binary_field' in json_obj and json_obj['terse_binary_field'] is not None:
      self.terse_binary_field = json_obj['terse_binary_field']
    if 'terse_enum_field' in json_obj and json_obj['terse_enum_field'] is not None:
      self.terse_enum_field = json_obj['terse_enum_field']
      if not self.terse_enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.terse_enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'terse_list_field' in json_obj and json_obj['terse_list_field'] is not None:
      self.terse_list_field = []
      for _tmp_e118 in json_obj['terse_list_field']:
        if _tmp_e118 > 0x7fff or _tmp_e118 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_list_field.append(_tmp_e118)
    if 'terse_set_field' in json_obj and json_obj['terse_set_field'] is not None:
      self.terse_set_field = set_cls()
      for _tmp_e119 in json_obj['terse_set_field']:
        if _tmp_e119 > 0x7fff or _tmp_e119 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_set_field.add(_tmp_e119)
    if 'terse_map_field' in json_obj and json_obj['terse_map_field'] is not None:
      self.terse_map_field = dict_cls()
      for _tmp_k120, _tmp_v121 in json_obj['terse_map_field'].items():
        _tmp_kp122 = int(_tmp_k120)
        if _tmp_kp122 > 0x7fff or _tmp_kp122 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k120)
        if _tmp_v121 > 0x7fff or _tmp_v121 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_map_field[_tmp_kp122] = _tmp_v121
    if 'terse_struct_field' in json_obj and json_obj['terse_struct_field'] is not None:
      self.terse_struct_field = MyStruct()
      self.terse_struct_field.readFromJson(json_obj['terse_struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'terse_union_field' in json_obj and json_obj['terse_union_field'] is not None:
      self.terse_union_field = MyUnion()
      self.terse_union_field.readFromJson(json_obj['terse_union_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e123 in json_obj['list_field']:
        if _tmp_e123 > 0x7fff or _tmp_e123 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e123)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e124 in json_obj['set_field']:
        if _tmp_e124 > 0x7fff or _tmp_e124 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e124)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k125, _tmp_v126 in json_obj['map_field'].items():
        _tmp_kp127 = int(_tmp_k125)
        if _tmp_kp127 > 0x7fff or _tmp_kp127 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k125)
        if _tmp_v126 > 0x7fff or _tmp_v126 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp127] = _tmp_v126
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStruct()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'union_field' in json_obj and json_obj['union_field'] is not None:
      self.union_field = MyUnion()
      self.union_field.readFromJson(json_obj['union_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.terse_bool_field is not None:
      value = pprint.pformat(self.terse_bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_bool_field=%s' % (value))
    if self.terse_byte_field is not None:
      value = pprint.pformat(self.terse_byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_byte_field=%s' % (value))
    if self.terse_short_field is not None:
      value = pprint.pformat(self.terse_short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_short_field=%s' % (value))
    if self.terse_int_field is not None:
      value = pprint.pformat(self.terse_int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_int_field=%s' % (value))
    if self.terse_long_field is not None:
      value = pprint.pformat(self.terse_long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_long_field=%s' % (value))
    if self.terse_float_field is not None:
      value = pprint.pformat(self.terse_float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_float_field=%s' % (value))
    if self.terse_double_field is not None:
      value = pprint.pformat(self.terse_double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_double_field=%s' % (value))
    if self.terse_string_field is not None:
      value = pprint.pformat(self.terse_string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_string_field=%s' % (value))
    if self.terse_binary_field is not None:
      value = pprint.pformat(self.terse_binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_binary_field=%s' % (value))
    if self.terse_enum_field is not None:
      value = pprint.pformat(self.terse_enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_enum_field=%s' % (value))
    if self.terse_list_field is not None:
      value = pprint.pformat(self.terse_list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_list_field=%s' % (value))
    if self.terse_set_field is not None:
      value = pprint.pformat(self.terse_set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_set_field=%s' % (value))
    if self.terse_map_field is not None:
      value = pprint.pformat(self.terse_map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_map_field=%s' % (value))
    if self.terse_struct_field is not None:
      value = pprint.pformat(self.terse_struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_struct_field=%s' % (value))
    if self.terse_union_field is not None:
      value = pprint.pformat(self.terse_union_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_union_field=%s' % (value))
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    if self.union_field is not None:
      value = pprint.pformat(self.union_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    union_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'terse_bool_field',
      'terse_byte_field',
      'terse_short_field',
      'terse_int_field',
      'terse_long_field',
      'terse_float_field',
      'terse_double_field',
      'terse_string_field',
      'terse_binary_field',
      'terse_enum_field',
      'terse_list_field',
      'terse_set_field',
      'terse_map_field',
      'terse_struct_field',
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
      'terse_union_field',
      'union_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.FieldLevelTerseStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.FieldLevelTerseStruct, self)

  def _to_py_deprecated(self):
    return self

class TerseStructWithCustomDefault:
  r"""
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype131, _size128) = iprot.readListBegin()
          if _size128 >= 0:
            for _i132 in range(_size128):
              _elem133 = iprot.readI16()
              self.list_field.append(_elem133)
          else: 
            while iprot.peekList():
              _elem134 = iprot.readI16()
              self.list_field.append(_elem134)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype138, _size135) = iprot.readSetBegin()
          if _size135 >= 0:
            for _i139 in range(_size135):
              _elem140 = iprot.readI16()
              self.set_field.add(_elem140)
          else: 
            while iprot.peekSet():
              _elem141 = iprot.readI16()
              self.set_field.add(_elem141)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype143, _vtype144, _size142 ) = iprot.readMapBegin() 
          if _size142 >= 0:
            for _i146 in range(_size142):
              _key147 = iprot.readI16()
              _val148 = iprot.readI16()
              self.map_field[_key147] = _val148
          else: 
            while iprot.peekMap():
              _key149 = iprot.readI16()
              _val150 = iprot.readI16()
              self.map_field[_key149] = _val150
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.struct_field = MyStructWithCustomDefault()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseStructWithCustomDefault')
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter151 in self.list_field:
        oprot.writeI16(iter151)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter152 in self.set_field:
        oprot.writeI16(iter152)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter153,viter154 in self.map_field.items():
        oprot.writeI16(kiter153)
        oprot.writeI16(viter154)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e155 in json_obj['list_field']:
        if _tmp_e155 > 0x7fff or _tmp_e155 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e155)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e156 in json_obj['set_field']:
        if _tmp_e156 > 0x7fff or _tmp_e156 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e156)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k157, _tmp_v158 in json_obj['map_field'].items():
        _tmp_kp159 = int(_tmp_k157)
        if _tmp_kp159 > 0x7fff or _tmp_kp159 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k157)
        if _tmp_v158 > 0x7fff or _tmp_v158 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp159] = _tmp_v158
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStructWithCustomDefault()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseStructWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseStructWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class AdaptedFields:
  r"""
  Attributes:
   - field1
   - field2
   - field3
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.field2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.field3 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptedFields')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I32, 1)
      oprot.writeI32(self.field1)
      oprot.writeFieldEnd()
    if self.field2 != None:
      oprot.writeFieldBegin('field2', TType.I32, 2)
      oprot.writeI32(self.field2)
      oprot.writeFieldEnd()
    if self.field3 != None:
      oprot.writeFieldBegin('field3', TType.I32, 3)
      oprot.writeI32(self.field3)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = json_obj['field1']
      if self.field1 > 0x7fffffff or self.field1 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'field2' in json_obj and json_obj['field2'] is not None:
      self.field2 = json_obj['field2']
      if self.field2 > 0x7fffffff or self.field2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'field3' in json_obj and json_obj['field3'] is not None:
      self.field3 = json_obj['field3']
      if self.field3 > 0x7fffffff or self.field3 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    if self.field2 is not None:
      value = pprint.pformat(self.field2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field2=%s' % (value))
    if self.field3 is not None:
      value = pprint.pformat(self.field3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field3=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
      'field2',
      'field3',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptedFields, self)

  def _to_py_deprecated(self):
    return self

class WrappedFields:
  r"""
  Attributes:
   - field1
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('WrappedFields')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I32, 1)
      oprot.writeI32(self.field1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = json_obj['field1']
      if self.field1 > 0x7fffffff or self.field1 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.WrappedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.WrappedFields, self)

  def _to_py_deprecated(self):
    return self

class TerseException(TException):
  r"""
  Attributes:
   - msg
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseException')
    if self.msg != None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg.encode('utf-8')) if UTF8STRINGS and not isinstance(self.msg, bytes) else oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'msg' in json_obj and json_obj['msg'] is not None:
      self.msg = json_obj['msg']

  def __str__(self):
    if self.msg:
      return self.msg
    else:
      return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.msg is not None:
      value = pprint.pformat(self.msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    msg=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'msg',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseException, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseException, self)

  def _to_py_deprecated(self):
    return self

MyInteger = UnimplementedTypedef()
all_structs.append(MyStruct)
MyStruct.thrift_spec = (
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

all_structs.append(MyUnion)
MyUnion.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'bool_field', None, None, 2, ), # 1
  (2, TType.BYTE, 'byte_field', None, None, 2, ), # 2
  (3, TType.I16, 'short_field', None, None, 2, ), # 3
  (4, TType.I32, 'int_field', None, None, 2, ), # 4
  (5, TType.I64, 'long_field', None, None, 2, ), # 5
  (6, TType.FLOAT, 'float_field', None, None, 2, ), # 6
  (7, TType.DOUBLE, 'double_field', None, None, 2, ), # 7
  (8, TType.STRING, 'string_field', True, None, 2, ), # 8
  (9, TType.STRING, 'binary_field', False, None, 2, ), # 9
  (10, TType.I32, 'enum_field', MyEnum, None, 2, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), None, 2, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), None, 2, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 2, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 14
)

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None,):
  self.field = 0
  self.value = None
  if bool_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = bool_field
  if byte_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = byte_field
  if short_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = short_field
  if int_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = int_field
  if long_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = long_field
  if float_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = float_field
  if double_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = double_field
  if string_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = string_field
  if binary_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = binary_field
  if enum_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 10
    self.value = enum_field
  if list_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 11
    self.value = list_field
  if set_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 12
    self.value = set_field
  if map_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 13
    self.value = map_field
  if struct_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 14
    self.value = struct_field

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyStructWithCustomDefault)
MyStructWithCustomDefault.thrift_spec = (
  None, # 0
  (1, TType.I64, 'field1', None, 1, 2, ), # 1
)

MyStructWithCustomDefault.thrift_struct_annotations = {
}
MyStructWithCustomDefault.thrift_field_annotations = {
}

def MyStructWithCustomDefault__init__(self, field1=MyStructWithCustomDefault.thrift_spec[1][4],):
  self.field1 = field1

MyStructWithCustomDefault.__init__ = MyStructWithCustomDefault__init__

def MyStructWithCustomDefault__setstate__(self, state):
  state.setdefault('field1', 1)
  self.__dict__ = state

MyStructWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
MyStructWithCustomDefault.__setstate__ = MyStructWithCustomDefault__setstate__

all_structs.append(StructLevelTerseStruct)
StructLevelTerseStruct.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'bool_field', None, None, 3, ), # 1
  (2, TType.BYTE, 'byte_field', None, None, 3, ), # 2
  (3, TType.I16, 'short_field', None, None, 3, ), # 3
  (4, TType.I32, 'int_field', None, None, 3, ), # 4
  (5, TType.I64, 'long_field', None, None, 3, ), # 5
  (6, TType.FLOAT, 'float_field', None, None, 3, ), # 6
  (7, TType.DOUBLE, 'double_field', None, None, 3, ), # 7
  (8, TType.STRING, 'string_field', True, None, 3, ), # 8
  (9, TType.STRING, 'binary_field', False, None, 3, ), # 9
  (10, TType.I32, 'enum_field', MyEnum, None, 3, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), None, 3, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), None, 3, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 3, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 3, ), # 14
  (15, TType.STRUCT, 'union_field', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 15
)

StructLevelTerseStruct.thrift_struct_annotations = {
}
StructLevelTerseStruct.thrift_field_annotations = {
}

def StructLevelTerseStruct__init__(self, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None, union_field=None,):
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  self.list_field = list_field
  self.set_field = set_field
  self.map_field = map_field
  self.struct_field = struct_field
  self.union_field = union_field

StructLevelTerseStruct.__init__ = StructLevelTerseStruct__init__

def StructLevelTerseStruct__setstate__(self, state):
  state.setdefault('bool_field', None)
  state.setdefault('byte_field', None)
  state.setdefault('short_field', None)
  state.setdefault('int_field', None)
  state.setdefault('long_field', None)
  state.setdefault('float_field', None)
  state.setdefault('double_field', None)
  state.setdefault('string_field', None)
  state.setdefault('binary_field', None)
  state.setdefault('enum_field', None)
  state.setdefault('list_field', None)
  state.setdefault('set_field', None)
  state.setdefault('map_field', None)
  state.setdefault('struct_field', None)
  state.setdefault('union_field', None)
  self.__dict__ = state

StructLevelTerseStruct.__getstate__ = lambda self: self.__dict__.copy()
StructLevelTerseStruct.__setstate__ = StructLevelTerseStruct__setstate__

all_structs.append(FieldLevelTerseStruct)
FieldLevelTerseStruct.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'terse_bool_field', None, None, 3, ), # 1
  (2, TType.BYTE, 'terse_byte_field', None, None, 3, ), # 2
  (3, TType.I16, 'terse_short_field', None, None, 3, ), # 3
  (4, TType.I32, 'terse_int_field', None, None, 3, ), # 4
  (5, TType.I64, 'terse_long_field', None, None, 3, ), # 5
  (6, TType.FLOAT, 'terse_float_field', None, None, 3, ), # 6
  (7, TType.DOUBLE, 'terse_double_field', None, None, 3, ), # 7
  (8, TType.STRING, 'terse_string_field', True, None, 3, ), # 8
  (9, TType.STRING, 'terse_binary_field', False, None, 3, ), # 9
  (10, TType.I32, 'terse_enum_field', MyEnum, None, 3, ), # 10
  (11, TType.LIST, 'terse_list_field', (TType.I16,None), None, 3, ), # 11
  (12, TType.SET, 'terse_set_field', (TType.I16,None), None, 3, ), # 12
  (13, TType.MAP, 'terse_map_field', (TType.I16,None,TType.I16,None), None, 3, ), # 13
  (14, TType.STRUCT, 'terse_struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 3, ), # 14
  (15, TType.BOOL, 'bool_field', None, None, 2, ), # 15
  (16, TType.BYTE, 'byte_field', None, None, 2, ), # 16
  (17, TType.I16, 'short_field', None, None, 2, ), # 17
  (18, TType.I32, 'int_field', None, None, 2, ), # 18
  (19, TType.I64, 'long_field', None, None, 2, ), # 19
  (20, TType.FLOAT, 'float_field', None, None, 2, ), # 20
  (21, TType.DOUBLE, 'double_field', None, None, 2, ), # 21
  (22, TType.STRING, 'string_field', True, None, 2, ), # 22
  (23, TType.STRING, 'binary_field', False, None, 2, ), # 23
  (24, TType.I32, 'enum_field', MyEnum, None, 2, ), # 24
  (25, TType.LIST, 'list_field', (TType.I16,None), None, 2, ), # 25
  (26, TType.SET, 'set_field', (TType.I16,None), None, 2, ), # 26
  (27, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 2, ), # 27
  (28, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 28
  (29, TType.STRUCT, 'terse_union_field', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 29
  (30, TType.STRUCT, 'union_field', [MyUnion, MyUnion.thrift_spec, True], None, 2, ), # 30
)

FieldLevelTerseStruct.thrift_struct_annotations = {
}
FieldLevelTerseStruct.thrift_field_annotations = {
}

def FieldLevelTerseStruct__init__(self, terse_bool_field=None, terse_byte_field=None, terse_short_field=None, terse_int_field=None, terse_long_field=None, terse_float_field=None, terse_double_field=None, terse_string_field=None, terse_binary_field=None, terse_enum_field=None, terse_list_field=None, terse_set_field=None, terse_map_field=None, terse_struct_field=None, terse_union_field=None, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None, union_field=None,):
  self.terse_bool_field = terse_bool_field
  self.terse_byte_field = terse_byte_field
  self.terse_short_field = terse_short_field
  self.terse_int_field = terse_int_field
  self.terse_long_field = terse_long_field
  self.terse_float_field = terse_float_field
  self.terse_double_field = terse_double_field
  self.terse_string_field = terse_string_field
  self.terse_binary_field = terse_binary_field
  self.terse_enum_field = terse_enum_field
  self.terse_list_field = terse_list_field
  self.terse_set_field = terse_set_field
  self.terse_map_field = terse_map_field
  self.terse_struct_field = terse_struct_field
  self.terse_union_field = terse_union_field
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  self.list_field = list_field
  self.set_field = set_field
  self.map_field = map_field
  self.struct_field = struct_field
  self.union_field = union_field

FieldLevelTerseStruct.__init__ = FieldLevelTerseStruct__init__

def FieldLevelTerseStruct__setstate__(self, state):
  state.setdefault('terse_bool_field', None)
  state.setdefault('terse_byte_field', None)
  state.setdefault('terse_short_field', None)
  state.setdefault('terse_int_field', None)
  state.setdefault('terse_long_field', None)
  state.setdefault('terse_float_field', None)
  state.setdefault('terse_double_field', None)
  state.setdefault('terse_string_field', None)
  state.setdefault('terse_binary_field', None)
  state.setdefault('terse_enum_field', None)
  state.setdefault('terse_list_field', None)
  state.setdefault('terse_set_field', None)
  state.setdefault('terse_map_field', None)
  state.setdefault('terse_struct_field', None)
  state.setdefault('terse_union_field', None)
  state.setdefault('bool_field', None)
  state.setdefault('byte_field', None)
  state.setdefault('short_field', None)
  state.setdefault('int_field', None)
  state.setdefault('long_field', None)
  state.setdefault('float_field', None)
  state.setdefault('double_field', None)
  state.setdefault('string_field', None)
  state.setdefault('binary_field', None)
  state.setdefault('enum_field', None)
  state.setdefault('list_field', None)
  state.setdefault('set_field', None)
  state.setdefault('map_field', None)
  state.setdefault('struct_field', None)
  state.setdefault('union_field', None)
  self.__dict__ = state

FieldLevelTerseStruct.__getstate__ = lambda self: self.__dict__.copy()
FieldLevelTerseStruct.__setstate__ = FieldLevelTerseStruct__setstate__

all_structs.append(TerseStructWithCustomDefault)
TerseStructWithCustomDefault.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'bool_field', None, True, 3, ), # 1
  (2, TType.BYTE, 'byte_field', None, 1, 3, ), # 2
  (3, TType.I16, 'short_field', None, 2, 3, ), # 3
  (4, TType.I32, 'int_field', None, 3, 3, ), # 4
  (5, TType.I64, 'long_field', None, 4, 3, ), # 5
  (6, TType.FLOAT, 'float_field', None, 5.00000, 3, ), # 6
  (7, TType.DOUBLE, 'double_field', None, 6.00000, 3, ), # 7
  (8, TType.STRING, 'string_field', True, "7", 3, ), # 8
  (9, TType.STRING, 'binary_field', False, "8", 3, ), # 9
  (10, TType.I32, 'enum_field', MyEnum,   1, 3, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), [
    1,
  ], 3, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), set([
    1,
  ]), 3, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), {
    1 : 1,
  }, 3, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStructWithCustomDefault, MyStructWithCustomDefault.thrift_spec, False], None, 3, ), # 14
)

TerseStructWithCustomDefault.thrift_struct_annotations = {
}
TerseStructWithCustomDefault.thrift_field_annotations = {
}

def TerseStructWithCustomDefault__init__(self, bool_field=TerseStructWithCustomDefault.thrift_spec[1][4], byte_field=TerseStructWithCustomDefault.thrift_spec[2][4], short_field=TerseStructWithCustomDefault.thrift_spec[3][4], int_field=TerseStructWithCustomDefault.thrift_spec[4][4], long_field=TerseStructWithCustomDefault.thrift_spec[5][4], float_field=TerseStructWithCustomDefault.thrift_spec[6][4], double_field=TerseStructWithCustomDefault.thrift_spec[7][4], string_field=TerseStructWithCustomDefault.thrift_spec[8][4], binary_field=TerseStructWithCustomDefault.thrift_spec[9][4], enum_field=TerseStructWithCustomDefault.thrift_spec[10][4], list_field=TerseStructWithCustomDefault.thrift_spec[11][4], set_field=TerseStructWithCustomDefault.thrift_spec[12][4], map_field=TerseStructWithCustomDefault.thrift_spec[13][4], struct_field=None,):
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  if list_field is self.thrift_spec[11][4]:
    list_field = [
    1,
  ]
  self.list_field = list_field
  if set_field is self.thrift_spec[12][4]:
    set_field = set([
    1,
  ])
  self.set_field = set_field
  if map_field is self.thrift_spec[13][4]:
    map_field = {
    1 : 1,
  }
  self.map_field = map_field
  self.struct_field = struct_field

TerseStructWithCustomDefault.__init__ = TerseStructWithCustomDefault__init__

def TerseStructWithCustomDefault__setstate__(self, state):
  state.setdefault('bool_field', True)
  state.setdefault('byte_field', 1)
  state.setdefault('short_field', 2)
  state.setdefault('int_field', 3)
  state.setdefault('long_field', 4)
  state.setdefault('float_field', 5.00000)
  state.setdefault('double_field', 6.00000)
  state.setdefault('string_field', "7")
  state.setdefault('binary_field', "8")
  state.setdefault('enum_field',   1)
  state.setdefault('list_field', [
    1,
  ])
  state.setdefault('set_field', set([
    1,
  ]))
  state.setdefault('map_field', {
    1 : 1,
  })
  state.setdefault('struct_field', None)
  self.__dict__ = state

TerseStructWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
TerseStructWithCustomDefault.__setstate__ = TerseStructWithCustomDefault__setstate__

all_structs.append(AdaptedFields)
AdaptedFields.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field1', None, None, 3, ), # 1
  (2, TType.I32, 'field2', None, None, 3, ), # 2
  (3, TType.I32, 'field3', None, None, 3, ), # 3
)

AdaptedFields.thrift_struct_annotations = {
}
AdaptedFields.thrift_field_annotations = {
}

def AdaptedFields__init__(self, field1=None, field2=None, field3=None,):
  self.field1 = field1
  self.field2 = field2
  self.field3 = field3

AdaptedFields.__init__ = AdaptedFields__init__

def AdaptedFields__setstate__(self, state):
  state.setdefault('field1', None)
  state.setdefault('field2', None)
  state.setdefault('field3', None)
  self.__dict__ = state

AdaptedFields.__getstate__ = lambda self: self.__dict__.copy()
AdaptedFields.__setstate__ = AdaptedFields__setstate__

all_structs.append(WrappedFields)
WrappedFields.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field1', None, 7, 3, ), # 1
)

WrappedFields.thrift_struct_annotations = {
}
WrappedFields.thrift_field_annotations = {
}

def WrappedFields__init__(self, field1=WrappedFields.thrift_spec[1][4],):
  self.field1 = field1

WrappedFields.__init__ = WrappedFields__init__

def WrappedFields__setstate__(self, state):
  state.setdefault('field1', 7)
  self.__dict__ = state

WrappedFields.__getstate__ = lambda self: self.__dict__.copy()
WrappedFields.__setstate__ = WrappedFields__setstate__

all_structs.append(TerseException)
TerseException.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'msg', True, None, 3, ), # 1
)

TerseException.thrift_struct_annotations = {
  "message": "msg",
}
TerseException.thrift_field_annotations = {
}

def TerseException__init__(self, msg=None,):
  self.msg = msg

TerseException.__init__ = TerseException__init__

def TerseException__setstate__(self, state):
  state.setdefault('msg', None)
  self.__dict__ = state

TerseException.__getstate__ = lambda self: self.__dict__.copy()
TerseException.__setstate__ = TerseException__setstate__

fix_spec(all_structs)
del all_structs
