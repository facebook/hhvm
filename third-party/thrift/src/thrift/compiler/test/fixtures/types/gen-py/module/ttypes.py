#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException


import include.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'has_bitwise_ops', 'is_unscoped', 'MyForwardRefEnum', 'MyEnumA', 'decorated_struct', 'ContainerStruct', 'CppTypeStruct', 'VirtualStruct', 'MyStructWithForwardRefEnum', 'TrivialNumeric', 'TrivialNestedWithDefault', 'ComplexString', 'ComplexNestedWithDefault', 'MinPadding', 'MyStruct', 'MyDataItem', 'Renaming', 'AnnotatedTypes', 'ForwardUsageRoot', 'ForwardUsageStruct', 'ForwardUsageByRef', 'NoexceptMoveEmpty', 'NoexceptMoveSimpleStruct', 'NoexceptMoveComplexStruct', 'NoExceptMoveUnion', 'AllocatorAware', 'AllocatorAware2', 'TypedefStruct', 'StructWithDoubleUnderscores', 'TBinary', 'IntTypedef', 'UintTypedef']

class has_bitwise_ops:
  none = 0
  zero = 1
  one = 2
  two = 4
  three = 8

  _VALUES_TO_NAMES = {
    0: "none",
    1: "zero",
    2: "one",
    4: "two",
    8: "three",
  }

  _NAMES_TO_VALUES = {
    "none": 0,
    "zero": 1,
    "one": 2,
    "two": 4,
    "three": 8,
  }

class is_unscoped:
  hello = 0
  world = 1

  _VALUES_TO_NAMES = {
    0: "hello",
    1: "world",
  }

  _NAMES_TO_VALUES = {
    "hello": 0,
    "world": 1,
  }

class MyForwardRefEnum:
  ZERO = 0
  NONZERO = 12

  _VALUES_TO_NAMES = {
    0: "ZERO",
    12: "NONZERO",
  }

  _NAMES_TO_VALUES = {
    "ZERO": 0,
    "NONZERO": 12,
  }

class MyEnumA:
  fieldA = 1
  fieldB = 2
  fieldC = 4

  _VALUES_TO_NAMES = {
    1: "fieldA",
    2: "fieldB",
    4: "fieldC",
  }

  _NAMES_TO_VALUES = {
    "fieldA": 1,
    "fieldB": 2,
    "fieldC": 4,
  }

class decorated_struct:
  """
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('decorated_struct')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.STRING, 1)
      oprot.writeString(self.field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.field, bytes) else oprot.writeString(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.decorated_struct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.decorated_struct, self)

  def _to_py_deprecated(self):
    return self

class ContainerStruct:
  """
  Attributes:
   - fieldA
   - fieldB
   - fieldC
   - fieldD
   - fieldE
   - fieldF
   - fieldG
   - fieldH
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 12:
        if ftype == TType.LIST:
          self.fieldA = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI32()
              self.fieldA.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI32()
              self.fieldA.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fieldB = []
          (_etype10, _size7) = iprot.readListBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readI32()
              self.fieldB.append(_elem12)
          else: 
            while iprot.peekList():
              _elem13 = iprot.readI32()
              self.fieldB.append(_elem13)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fieldC = []
          (_etype17, _size14) = iprot.readListBegin()
          if _size14 >= 0:
            for _i18 in range(_size14):
              _elem19 = iprot.readI32()
              self.fieldC.append(_elem19)
          else: 
            while iprot.peekList():
              _elem20 = iprot.readI32()
              self.fieldC.append(_elem20)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fieldD = []
          (_etype24, _size21) = iprot.readListBegin()
          if _size21 >= 0:
            for _i25 in range(_size21):
              _elem26 = iprot.readI32()
              self.fieldD.append(_elem26)
          else: 
            while iprot.peekList():
              _elem27 = iprot.readI32()
              self.fieldD.append(_elem27)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.fieldE = []
          (_etype31, _size28) = iprot.readListBegin()
          if _size28 >= 0:
            for _i32 in range(_size28):
              _elem33 = iprot.readI32()
              self.fieldE.append(_elem33)
          else: 
            while iprot.peekList():
              _elem34 = iprot.readI32()
              self.fieldE.append(_elem34)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.fieldF = set()
          (_etype38, _size35) = iprot.readSetBegin()
          if _size35 >= 0:
            for _i39 in range(_size35):
              _elem40 = iprot.readI32()
              self.fieldF.add(_elem40)
          else: 
            while iprot.peekSet():
              _elem41 = iprot.readI32()
              self.fieldF.add(_elem41)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.fieldG = {}
          (_ktype43, _vtype44, _size42 ) = iprot.readMapBegin() 
          if _size42 >= 0:
            for _i46 in range(_size42):
              _key47 = iprot.readI32()
              _val48 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldG[_key47] = _val48
          else: 
            while iprot.peekMap():
              _key49 = iprot.readI32()
              _val50 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldG[_key49] = _val50
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.fieldH = {}
          (_ktype52, _vtype53, _size51 ) = iprot.readMapBegin() 
          if _size51 >= 0:
            for _i55 in range(_size51):
              _key56 = iprot.readI32()
              _val57 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldH[_key56] = _val57
          else: 
            while iprot.peekMap():
              _key58 = iprot.readI32()
              _val59 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldH[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ContainerStruct')
    if self.fieldB != None:
      oprot.writeFieldBegin('fieldB', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.fieldB))
      for iter60 in self.fieldB:
        oprot.writeI32(iter60)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldC != None:
      oprot.writeFieldBegin('fieldC', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.fieldC))
      for iter61 in self.fieldC:
        oprot.writeI32(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldD != None:
      oprot.writeFieldBegin('fieldD', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.fieldD))
      for iter62 in self.fieldD:
        oprot.writeI32(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldE != None:
      oprot.writeFieldBegin('fieldE', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.fieldE))
      for iter63 in self.fieldE:
        oprot.writeI32(iter63)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldF != None:
      oprot.writeFieldBegin('fieldF', TType.SET, 6)
      oprot.writeSetBegin(TType.I32, len(self.fieldF))
      for iter64 in self.fieldF:
        oprot.writeI32(iter64)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.fieldG != None:
      oprot.writeFieldBegin('fieldG', TType.MAP, 7)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.fieldG))
      for kiter65,viter66 in self.fieldG.items():
        oprot.writeI32(kiter65)
        oprot.writeString(viter66.encode('utf-8')) if UTF8STRINGS and not isinstance(viter66, bytes) else oprot.writeString(viter66)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.fieldH != None:
      oprot.writeFieldBegin('fieldH', TType.MAP, 8)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.fieldH))
      for kiter67,viter68 in self.fieldH.items():
        oprot.writeI32(kiter67)
        oprot.writeString(viter68.encode('utf-8')) if UTF8STRINGS and not isinstance(viter68, bytes) else oprot.writeString(viter68)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.fieldA != None:
      oprot.writeFieldBegin('fieldA', TType.LIST, 12)
      oprot.writeListBegin(TType.I32, len(self.fieldA))
      for iter69 in self.fieldA:
        oprot.writeI32(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.fieldA is not None:
      value = pprint.pformat(self.fieldA, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldA=%s' % (value))
    if self.fieldB is not None:
      value = pprint.pformat(self.fieldB, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldB=%s' % (value))
    if self.fieldC is not None:
      value = pprint.pformat(self.fieldC, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldC=%s' % (value))
    if self.fieldD is not None:
      value = pprint.pformat(self.fieldD, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldD=%s' % (value))
    if self.fieldE is not None:
      value = pprint.pformat(self.fieldE, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldE=%s' % (value))
    if self.fieldF is not None:
      value = pprint.pformat(self.fieldF, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldF=%s' % (value))
    if self.fieldG is not None:
      value = pprint.pformat(self.fieldG, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldG=%s' % (value))
    if self.fieldH is not None:
      value = pprint.pformat(self.fieldH, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldH=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'fieldB',
      'fieldC',
      'fieldD',
      'fieldE',
      'fieldF',
      'fieldG',
      'fieldH',
      'fieldA',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ContainerStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ContainerStruct, self)

  def _to_py_deprecated(self):
    return self

class CppTypeStruct:
  """
  Attributes:
   - fieldA
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldA = []
          (_etype73, _size70) = iprot.readListBegin()
          if _size70 >= 0:
            for _i74 in range(_size70):
              _elem75 = iprot.readI32()
              self.fieldA.append(_elem75)
          else: 
            while iprot.peekList():
              _elem76 = iprot.readI32()
              self.fieldA.append(_elem76)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CppTypeStruct')
    if self.fieldA != None:
      oprot.writeFieldBegin('fieldA', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.fieldA))
      for iter77 in self.fieldA:
        oprot.writeI32(iter77)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.fieldA is not None:
      value = pprint.pformat(self.fieldA, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldA=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'fieldA',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CppTypeStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CppTypeStruct, self)

  def _to_py_deprecated(self):
    return self

class VirtualStruct:
  """
  Attributes:
   - MyIntField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VirtualStruct')
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 1)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'MyIntField',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.VirtualStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.VirtualStruct, self)

  def _to_py_deprecated(self):
    return self

class MyStructWithForwardRefEnum:
  """
  Attributes:
   - a
   - b
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.a = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.b = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructWithForwardRefEnum')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.I32, 1)
      oprot.writeI32(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.I32, 2)
      oprot.writeI32(self.b)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructWithForwardRefEnum, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructWithForwardRefEnum, self)

  def _to_py_deprecated(self):
    return self

class TrivialNumeric:
  """
  Attributes:
   - a
   - b
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.a = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.b = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TrivialNumeric')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.I32, 1)
      oprot.writeI32(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.BOOL, 2)
      oprot.writeBool(self.b)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TrivialNumeric, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TrivialNumeric, self)

  def _to_py_deprecated(self):
    return self

class TrivialNestedWithDefault:
  """
  Attributes:
   - z
   - n
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.z = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.n = TrivialNumeric()
          self.n.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TrivialNestedWithDefault')
    if self.z != None:
      oprot.writeFieldBegin('z', TType.I32, 1)
      oprot.writeI32(self.z)
      oprot.writeFieldEnd()
    if self.n != None:
      oprot.writeFieldBegin('n', TType.STRUCT, 2)
      self.n.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.z is not None:
      value = pprint.pformat(self.z, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    z=%s' % (value))
    if self.n is not None:
      value = pprint.pformat(self.n, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    n=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'z',
      'n',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TrivialNestedWithDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TrivialNestedWithDefault, self)

  def _to_py_deprecated(self):
    return self

class ComplexString:
  """
  Attributes:
   - a
   - b
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.a = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.b = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          if _size78 >= 0:
            for _i82 in range(_size78):
              _key83 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val84 = iprot.readI32()
              self.b[_key83] = _val84
          else: 
            while iprot.peekMap():
              _key85 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val86 = iprot.readI32()
              self.b[_key85] = _val86
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ComplexString')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.STRING, 1)
      oprot.writeString(self.a.encode('utf-8')) if UTF8STRINGS and not isinstance(self.a, bytes) else oprot.writeString(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.b))
      for kiter87,viter88 in self.b.items():
        oprot.writeString(kiter87.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter87, bytes) else oprot.writeString(kiter87)
        oprot.writeI32(viter88)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ComplexString, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ComplexString, self)

  def _to_py_deprecated(self):
    return self

class ComplexNestedWithDefault:
  """
  Attributes:
   - z
   - n
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.z = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.n = ComplexString()
          self.n.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ComplexNestedWithDefault')
    if self.z != None:
      oprot.writeFieldBegin('z', TType.STRING, 1)
      oprot.writeString(self.z.encode('utf-8')) if UTF8STRINGS and not isinstance(self.z, bytes) else oprot.writeString(self.z)
      oprot.writeFieldEnd()
    if self.n != None:
      oprot.writeFieldBegin('n', TType.STRUCT, 2)
      self.n.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.z is not None:
      value = pprint.pformat(self.z, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    z=%s' % (value))
    if self.n is not None:
      value = pprint.pformat(self.n, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    n=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'z',
      'n',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ComplexNestedWithDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ComplexNestedWithDefault, self)

  def _to_py_deprecated(self):
    return self

class MinPadding:
  """
  Attributes:
   - small
   - big
   - medium
   - biggish
   - tiny
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.small = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.big = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.medium = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.biggish = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.tiny = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MinPadding')
    if self.small != None:
      oprot.writeFieldBegin('small', TType.BYTE, 1)
      oprot.writeByte(self.small)
      oprot.writeFieldEnd()
    if self.big != None:
      oprot.writeFieldBegin('big', TType.I64, 2)
      oprot.writeI64(self.big)
      oprot.writeFieldEnd()
    if self.medium != None:
      oprot.writeFieldBegin('medium', TType.I16, 3)
      oprot.writeI16(self.medium)
      oprot.writeFieldEnd()
    if self.biggish != None:
      oprot.writeFieldBegin('biggish', TType.I32, 4)
      oprot.writeI32(self.biggish)
      oprot.writeFieldEnd()
    if self.tiny != None:
      oprot.writeFieldBegin('tiny', TType.BYTE, 5)
      oprot.writeByte(self.tiny)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.small is not None:
      value = pprint.pformat(self.small, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    small=%s' % (value))
    if self.big is not None:
      value = pprint.pformat(self.big, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    big=%s' % (value))
    if self.medium is not None:
      value = pprint.pformat(self.medium, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    medium=%s' % (value))
    if self.biggish is not None:
      value = pprint.pformat(self.biggish, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    biggish=%s' % (value))
    if self.tiny is not None:
      value = pprint.pformat(self.tiny, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tiny=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'small',
      'big',
      'medium',
      'biggish',
      'tiny',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MinPadding, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MinPadding, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  """
  Attributes:
   - MyIntField
   - MyStringField
   - majorVer
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.MyStringField = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.majorVer = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.data = MyDataItem()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 1)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    if self.MyStringField != None:
      oprot.writeFieldBegin('MyStringField', TType.STRING, 2)
      oprot.writeString(self.MyStringField.encode('utf-8')) if UTF8STRINGS and not isinstance(self.MyStringField, bytes) else oprot.writeString(self.MyStringField)
      oprot.writeFieldEnd()
    if self.majorVer != None:
      oprot.writeFieldBegin('majorVer', TType.I64, 3)
      oprot.writeI64(self.majorVer)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRUCT, 4)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    if self.MyStringField is not None:
      value = pprint.pformat(self.MyStringField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyStringField=%s' % (value))
    if self.majorVer is not None:
      value = pprint.pformat(self.majorVer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    majorVer=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'MyIntField',
      'MyStringField',
      'majorVer',
      'data',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class MyDataItem:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataItem')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataItem, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataItem, self)

  def _to_py_deprecated(self):
    return self

class Renaming:
  """
  Attributes:
   - foo
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.foo = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Renaming')
    if self.foo != None:
      oprot.writeFieldBegin('foo', TType.I64, 1)
      oprot.writeI64(self.foo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.foo is not None:
      value = pprint.pformat(self.foo, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    foo=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'foo',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Renaming, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Renaming, self)

  def _to_py_deprecated(self):
    return self

class AnnotatedTypes:
  """
  Attributes:
   - binary_field
   - list_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype92, _size89) = iprot.readListBegin()
          if _size89 >= 0:
            for _i93 in range(_size89):
              _elem94 = {}
              (_ktype96, _vtype97, _size95 ) = iprot.readMapBegin() 
              if _size95 >= 0:
                for _i99 in range(_size95):
                  _key100 = iprot.readI32()
                  _val101 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem94[_key100] = _val101
              else: 
                while iprot.peekMap():
                  _key102 = iprot.readI32()
                  _val103 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem94[_key102] = _val103
              iprot.readMapEnd()
              self.list_field.append(_elem94)
          else: 
            while iprot.peekList():
              _elem104 = {}
              (_ktype106, _vtype107, _size105 ) = iprot.readMapBegin() 
              if _size105 >= 0:
                for _i109 in range(_size105):
                  _key110 = iprot.readI32()
                  _val111 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem104[_key110] = _val111
              else: 
                while iprot.peekMap():
                  _key112 = iprot.readI32()
                  _val113 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem104[_key112] = _val113
              iprot.readMapEnd()
              self.list_field.append(_elem104)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AnnotatedTypes')
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 1)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.list_field))
      for iter114 in self.list_field:
        oprot.writeMapBegin(TType.I32, TType.STRING, len(iter114))
        for kiter115,viter116 in iter114.items():
          oprot.writeI32(kiter115)
          oprot.writeString(viter116.encode('utf-8')) if UTF8STRINGS and not isinstance(viter116, bytes) else oprot.writeString(viter116)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'binary_field',
      'list_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AnnotatedTypes, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AnnotatedTypes, self)

  def _to_py_deprecated(self):
    return self

class ForwardUsageRoot:
  """
  Attributes:
   - ForwardUsageStruct
   - ForwardUsageByRef
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ForwardUsageStruct = ForwardUsageStruct()
          self.ForwardUsageStruct.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ForwardUsageByRef = ForwardUsageByRef()
          self.ForwardUsageByRef.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ForwardUsageRoot')
    if self.ForwardUsageStruct != None:
      oprot.writeFieldBegin('ForwardUsageStruct', TType.STRUCT, 1)
      self.ForwardUsageStruct.write(oprot)
      oprot.writeFieldEnd()
    if self.ForwardUsageByRef != None:
      oprot.writeFieldBegin('ForwardUsageByRef', TType.STRUCT, 2)
      self.ForwardUsageByRef.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.ForwardUsageStruct is not None:
      value = pprint.pformat(self.ForwardUsageStruct, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ForwardUsageStruct=%s' % (value))
    if self.ForwardUsageByRef is not None:
      value = pprint.pformat(self.ForwardUsageByRef, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ForwardUsageByRef=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'ForwardUsageStruct',
      'ForwardUsageByRef',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ForwardUsageRoot, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ForwardUsageRoot, self)

  def _to_py_deprecated(self):
    return self

class ForwardUsageStruct:
  """
  Attributes:
   - foo
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.foo = ForwardUsageRoot()
          self.foo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ForwardUsageStruct')
    if self.foo != None:
      oprot.writeFieldBegin('foo', TType.STRUCT, 1)
      self.foo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.foo is not None:
      value = pprint.pformat(self.foo, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    foo=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'foo',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ForwardUsageStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ForwardUsageStruct, self)

  def _to_py_deprecated(self):
    return self

class ForwardUsageByRef:
  """
  Attributes:
   - foo
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.foo = ForwardUsageRoot()
          self.foo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ForwardUsageByRef')
    if self.foo != None:
      oprot.writeFieldBegin('foo', TType.STRUCT, 1)
      self.foo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.foo is not None:
      value = pprint.pformat(self.foo, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    foo=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'foo',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ForwardUsageByRef, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ForwardUsageByRef, self)

  def _to_py_deprecated(self):
    return self

class NoexceptMoveEmpty:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NoexceptMoveEmpty')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.NoexceptMoveEmpty, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.NoexceptMoveEmpty, self)

  def _to_py_deprecated(self):
    return self

class NoexceptMoveSimpleStruct:
  """
  Attributes:
   - boolField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.boolField = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NoexceptMoveSimpleStruct')
    if self.boolField != None:
      oprot.writeFieldBegin('boolField', TType.I64, 1)
      oprot.writeI64(self.boolField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.boolField is not None:
      value = pprint.pformat(self.boolField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'boolField',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.NoexceptMoveSimpleStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.NoexceptMoveSimpleStruct, self)

  def _to_py_deprecated(self):
    return self

class NoexceptMoveComplexStruct:
  """
  Attributes:
   - MyBoolField
   - MyIntField
   - MyStringField
   - MyStringField2
   - MyBinaryField
   - MyBinaryField2
   - MyBinaryField3
   - MyBinaryListField4
   - MyMapEnumAndInt
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.MyBoolField = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.MyStringField = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.MyStringField2 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.MyBinaryField = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.MyBinaryField2 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.MyBinaryField3 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.MyBinaryListField4 = []
          (_etype120, _size117) = iprot.readListBegin()
          if _size117 >= 0:
            for _i121 in range(_size117):
              _elem122 = iprot.readString()
              self.MyBinaryListField4.append(_elem122)
          else: 
            while iprot.peekList():
              _elem123 = iprot.readString()
              self.MyBinaryListField4.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.MyMapEnumAndInt = {}
          (_ktype125, _vtype126, _size124 ) = iprot.readMapBegin() 
          if _size124 >= 0:
            for _i128 in range(_size124):
              _key129 = iprot.readI32()
              _val130 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.MyMapEnumAndInt[_key129] = _val130
          else: 
            while iprot.peekMap():
              _key131 = iprot.readI32()
              _val132 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.MyMapEnumAndInt[_key131] = _val132
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NoexceptMoveComplexStruct')
    if self.MyBoolField != None:
      oprot.writeFieldBegin('MyBoolField', TType.BOOL, 1)
      oprot.writeBool(self.MyBoolField)
      oprot.writeFieldEnd()
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 2)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    if self.MyStringField != None:
      oprot.writeFieldBegin('MyStringField', TType.STRING, 3)
      oprot.writeString(self.MyStringField.encode('utf-8')) if UTF8STRINGS and not isinstance(self.MyStringField, bytes) else oprot.writeString(self.MyStringField)
      oprot.writeFieldEnd()
    if self.MyStringField2 != None:
      oprot.writeFieldBegin('MyStringField2', TType.STRING, 4)
      oprot.writeString(self.MyStringField2.encode('utf-8')) if UTF8STRINGS and not isinstance(self.MyStringField2, bytes) else oprot.writeString(self.MyStringField2)
      oprot.writeFieldEnd()
    if self.MyBinaryField != None:
      oprot.writeFieldBegin('MyBinaryField', TType.STRING, 5)
      oprot.writeString(self.MyBinaryField)
      oprot.writeFieldEnd()
    if self.MyBinaryField2 != None:
      oprot.writeFieldBegin('MyBinaryField2', TType.STRING, 6)
      oprot.writeString(self.MyBinaryField2)
      oprot.writeFieldEnd()
    if self.MyBinaryField3 != None:
      oprot.writeFieldBegin('MyBinaryField3', TType.STRING, 7)
      oprot.writeString(self.MyBinaryField3)
      oprot.writeFieldEnd()
    if self.MyBinaryListField4 != None:
      oprot.writeFieldBegin('MyBinaryListField4', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.MyBinaryListField4))
      for iter133 in self.MyBinaryListField4:
        oprot.writeString(iter133)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.MyMapEnumAndInt != None:
      oprot.writeFieldBegin('MyMapEnumAndInt', TType.MAP, 9)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.MyMapEnumAndInt))
      for kiter134,viter135 in self.MyMapEnumAndInt.items():
        oprot.writeI32(kiter134)
        oprot.writeString(viter135.encode('utf-8')) if UTF8STRINGS and not isinstance(viter135, bytes) else oprot.writeString(viter135)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyBoolField is not None:
      value = pprint.pformat(self.MyBoolField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyBoolField=%s' % (value))
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    if self.MyStringField is not None:
      value = pprint.pformat(self.MyStringField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyStringField=%s' % (value))
    if self.MyStringField2 is not None:
      value = pprint.pformat(self.MyStringField2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyStringField2=%s' % (value))
    if self.MyBinaryField is not None:
      value = pprint.pformat(self.MyBinaryField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyBinaryField=%s' % (value))
    if self.MyBinaryField2 is not None:
      value = pprint.pformat(self.MyBinaryField2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyBinaryField2=%s' % (value))
    if self.MyBinaryField3 is not None:
      value = pprint.pformat(self.MyBinaryField3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyBinaryField3=%s' % (value))
    if self.MyBinaryListField4 is not None:
      value = pprint.pformat(self.MyBinaryListField4, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyBinaryListField4=%s' % (value))
    if self.MyMapEnumAndInt is not None:
      value = pprint.pformat(self.MyMapEnumAndInt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyMapEnumAndInt=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'MyBoolField',
      'MyIntField',
      'MyStringField',
      'MyStringField2',
      'MyBinaryField',
      'MyBinaryField2',
      'MyBinaryField3',
      'MyBinaryListField4',
      'MyMapEnumAndInt',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.NoexceptMoveComplexStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.NoexceptMoveComplexStruct, self)

  def _to_py_deprecated(self):
    return self

class NoExceptMoveUnion(object):
  """
  Attributes:
   - string_field
   - i32_field
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  STRING_FIELD = 1
  I32_FIELD = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_string_field(self):
    assert self.field == 1
    return self.value

  def get_i32_field(self):
    assert self.field == 2
    return self.value

  def set_string_field(self, value):
    self.field = 1
    self.value = value

  def set_i32_field(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('string_field', value)
    if self.field == 2:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('i32_field', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_string_field(string_field)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          i32_field = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_i32_field(i32_field)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('NoExceptMoveUnion')
    if self.field == 1:
      oprot.writeFieldBegin('string_field', TType.STRING, 1)
      string_field = self.value
      oprot.writeString(string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(string_field, bytes) else oprot.writeString(string_field)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('i32_field', TType.I32, 2)
      i32_field = self.value
      oprot.writeI32(i32_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.NoExceptMoveUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.NoExceptMoveUnion, self)

  def _to_py_deprecated(self):
    return self

class AllocatorAware:
  """
  Attributes:
   - aa_list
   - aa_set
   - aa_map
   - aa_string
   - not_a_container
   - aa_unique
   - aa_shared
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.aa_list = []
          (_etype139, _size136) = iprot.readListBegin()
          if _size136 >= 0:
            for _i140 in range(_size136):
              _elem141 = iprot.readI32()
              self.aa_list.append(_elem141)
          else: 
            while iprot.peekList():
              _elem142 = iprot.readI32()
              self.aa_list.append(_elem142)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.aa_set = set()
          (_etype146, _size143) = iprot.readSetBegin()
          if _size143 >= 0:
            for _i147 in range(_size143):
              _elem148 = iprot.readI32()
              self.aa_set.add(_elem148)
          else: 
            while iprot.peekSet():
              _elem149 = iprot.readI32()
              self.aa_set.add(_elem149)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.aa_map = {}
          (_ktype151, _vtype152, _size150 ) = iprot.readMapBegin() 
          if _size150 >= 0:
            for _i154 in range(_size150):
              _key155 = iprot.readI32()
              _val156 = iprot.readI32()
              self.aa_map[_key155] = _val156
          else: 
            while iprot.peekMap():
              _key157 = iprot.readI32()
              _val158 = iprot.readI32()
              self.aa_map[_key157] = _val158
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.aa_string = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.not_a_container = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.aa_unique = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.aa_shared = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AllocatorAware')
    if self.aa_list != None:
      oprot.writeFieldBegin('aa_list', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.aa_list))
      for iter159 in self.aa_list:
        oprot.writeI32(iter159)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aa_set != None:
      oprot.writeFieldBegin('aa_set', TType.SET, 2)
      oprot.writeSetBegin(TType.I32, len(self.aa_set))
      for iter160 in self.aa_set:
        oprot.writeI32(iter160)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.aa_map != None:
      oprot.writeFieldBegin('aa_map', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.aa_map))
      for kiter161,viter162 in self.aa_map.items():
        oprot.writeI32(kiter161)
        oprot.writeI32(viter162)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.aa_string != None:
      oprot.writeFieldBegin('aa_string', TType.STRING, 4)
      oprot.writeString(self.aa_string.encode('utf-8')) if UTF8STRINGS and not isinstance(self.aa_string, bytes) else oprot.writeString(self.aa_string)
      oprot.writeFieldEnd()
    if self.not_a_container != None:
      oprot.writeFieldBegin('not_a_container', TType.I32, 5)
      oprot.writeI32(self.not_a_container)
      oprot.writeFieldEnd()
    if self.aa_unique != None:
      oprot.writeFieldBegin('aa_unique', TType.I32, 6)
      oprot.writeI32(self.aa_unique)
      oprot.writeFieldEnd()
    if self.aa_shared != None:
      oprot.writeFieldBegin('aa_shared', TType.I32, 7)
      oprot.writeI32(self.aa_shared)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.aa_list is not None:
      value = pprint.pformat(self.aa_list, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_list=%s' % (value))
    if self.aa_set is not None:
      value = pprint.pformat(self.aa_set, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_set=%s' % (value))
    if self.aa_map is not None:
      value = pprint.pformat(self.aa_map, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_map=%s' % (value))
    if self.aa_string is not None:
      value = pprint.pformat(self.aa_string, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_string=%s' % (value))
    if self.not_a_container is not None:
      value = pprint.pformat(self.not_a_container, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    not_a_container=%s' % (value))
    if self.aa_unique is not None:
      value = pprint.pformat(self.aa_unique, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_unique=%s' % (value))
    if self.aa_shared is not None:
      value = pprint.pformat(self.aa_shared, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_shared=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'aa_list',
      'aa_set',
      'aa_map',
      'aa_string',
      'not_a_container',
      'aa_unique',
      'aa_shared',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AllocatorAware, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AllocatorAware, self)

  def _to_py_deprecated(self):
    return self

class AllocatorAware2:
  """
  Attributes:
   - not_a_container
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.not_a_container = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AllocatorAware2')
    if self.not_a_container != None:
      oprot.writeFieldBegin('not_a_container', TType.I32, 1)
      oprot.writeI32(self.not_a_container)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.not_a_container is not None:
      value = pprint.pformat(self.not_a_container, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    not_a_container=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'not_a_container',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AllocatorAware2, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AllocatorAware2, self)

  def _to_py_deprecated(self):
    return self

class TypedefStruct:
  """
  Attributes:
   - i32_field
   - IntTypedef_field
   - UintTypedef_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.i32_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.IntTypedef_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.UintTypedef_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TypedefStruct')
    if self.i32_field != None:
      oprot.writeFieldBegin('i32_field', TType.I32, 1)
      oprot.writeI32(self.i32_field)
      oprot.writeFieldEnd()
    if self.IntTypedef_field != None:
      oprot.writeFieldBegin('IntTypedef_field', TType.I32, 2)
      oprot.writeI32(self.IntTypedef_field)
      oprot.writeFieldEnd()
    if self.UintTypedef_field != None:
      oprot.writeFieldBegin('UintTypedef_field', TType.I32, 3)
      oprot.writeI32(self.UintTypedef_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.i32_field is not None:
      value = pprint.pformat(self.i32_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32_field=%s' % (value))
    if self.IntTypedef_field is not None:
      value = pprint.pformat(self.IntTypedef_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    IntTypedef_field=%s' % (value))
    if self.UintTypedef_field is not None:
      value = pprint.pformat(self.UintTypedef_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    UintTypedef_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'i32_field',
      'IntTypedef_field',
      'UintTypedef_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TypedefStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TypedefStruct, self)

  def _to_py_deprecated(self):
    return self

class StructWithDoubleUnderscores:
  """
  Attributes:
   - __field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.__field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructWithDoubleUnderscores')
    if self.__field != None:
      oprot.writeFieldBegin('__field', TType.I32, 1)
      oprot.writeI32(self.__field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if getattr(self, "__field", None) is not None:
      value = pprint.pformat(getattr(self, "__field", None), indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    __field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      '__field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructWithDoubleUnderscores, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructWithDoubleUnderscores, self)

  def _to_py_deprecated(self):
    return self

TBinary = UnimplementedTypedef()
IntTypedef = UnimplementedTypedef()
UintTypedef = IntTypedef
all_structs.append(decorated_struct)
decorated_struct.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'field', True, None, 2, ), # 1
)

decorated_struct.thrift_struct_annotations = {
  "cpp.declare_equal_to": "1",
  "cpp.declare_hash": "1",
}
decorated_struct.thrift_field_annotations = {
}

def decorated_struct__init__(self, field=None,):
  self.field = field

decorated_struct.__init__ = decorated_struct__init__

def decorated_struct__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

decorated_struct.__getstate__ = lambda self: self.__dict__.copy()
decorated_struct.__setstate__ = decorated_struct__setstate__

all_structs.append(ContainerStruct)
ContainerStruct.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.LIST, 'fieldB', (TType.I32,None), None, 2, ), # 2
  (3, TType.LIST, 'fieldC', (TType.I32,None), None, 2, ), # 3
  (4, TType.LIST, 'fieldD', (TType.I32,None), None, 2, ), # 4
  (5, TType.LIST, 'fieldE', (TType.I32,None), None, 2, ), # 5
  (6, TType.SET, 'fieldF', (TType.I32,None), None, 2, ), # 6
  (7, TType.MAP, 'fieldG', (TType.I32,None,TType.STRING,True), None, 2, ), # 7
  (8, TType.MAP, 'fieldH', (TType.I32,None,TType.STRING,True), None, 2, ), # 8
  None, # 9
  None, # 10
  None, # 11
  (12, TType.LIST, 'fieldA', (TType.I32,None), None, 2, ), # 12
)

ContainerStruct.thrift_struct_annotations = {
}
ContainerStruct.thrift_field_annotations = {
}

def ContainerStruct__init__(self, fieldA=None, fieldB=None, fieldC=None, fieldD=None, fieldE=None, fieldF=None, fieldG=None, fieldH=None,):
  self.fieldA = fieldA
  self.fieldB = fieldB
  self.fieldC = fieldC
  self.fieldD = fieldD
  self.fieldE = fieldE
  self.fieldF = fieldF
  self.fieldG = fieldG
  self.fieldH = fieldH

ContainerStruct.__init__ = ContainerStruct__init__

def ContainerStruct__setstate__(self, state):
  state.setdefault('fieldA', None)
  state.setdefault('fieldB', None)
  state.setdefault('fieldC', None)
  state.setdefault('fieldD', None)
  state.setdefault('fieldE', None)
  state.setdefault('fieldF', None)
  state.setdefault('fieldG', None)
  state.setdefault('fieldH', None)
  self.__dict__ = state

ContainerStruct.__getstate__ = lambda self: self.__dict__.copy()
ContainerStruct.__setstate__ = ContainerStruct__setstate__

all_structs.append(CppTypeStruct)
CppTypeStruct.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'fieldA', (TType.I32,None), None, 2, ), # 1
)

CppTypeStruct.thrift_struct_annotations = {
}
CppTypeStruct.thrift_field_annotations = {
}

def CppTypeStruct__init__(self, fieldA=None,):
  self.fieldA = fieldA

CppTypeStruct.__init__ = CppTypeStruct__init__

def CppTypeStruct__setstate__(self, state):
  state.setdefault('fieldA', None)
  self.__dict__ = state

CppTypeStruct.__getstate__ = lambda self: self.__dict__.copy()
CppTypeStruct.__setstate__ = CppTypeStruct__setstate__

all_structs.append(VirtualStruct)
VirtualStruct.thrift_spec = (
  None, # 0
  (1, TType.I64, 'MyIntField', None, None, 2, ), # 1
)

VirtualStruct.thrift_struct_annotations = {
  "cpp.virtual": "1",
}
VirtualStruct.thrift_field_annotations = {
}

def VirtualStruct__init__(self, MyIntField=None,):
  self.MyIntField = MyIntField

VirtualStruct.__init__ = VirtualStruct__init__

def VirtualStruct__setstate__(self, state):
  state.setdefault('MyIntField', None)
  self.__dict__ = state

VirtualStruct.__getstate__ = lambda self: self.__dict__.copy()
VirtualStruct.__setstate__ = VirtualStruct__setstate__

all_structs.append(MyStructWithForwardRefEnum)
MyStructWithForwardRefEnum.thrift_spec = (
  None, # 0
  (1, TType.I32, 'a', MyForwardRefEnum,   12, 2, ), # 1
  (2, TType.I32, 'b', MyForwardRefEnum,   12, 2, ), # 2
)

MyStructWithForwardRefEnum.thrift_struct_annotations = {
}
MyStructWithForwardRefEnum.thrift_field_annotations = {
}

def MyStructWithForwardRefEnum__init__(self, a=MyStructWithForwardRefEnum.thrift_spec[1][4], b=MyStructWithForwardRefEnum.thrift_spec[2][4],):
  if a is self.thrift_spec[1][4]:
    a =   12
  self.a = a
  if b is self.thrift_spec[2][4]:
    b =   12
  self.b = b

MyStructWithForwardRefEnum.__init__ = MyStructWithForwardRefEnum__init__

def MyStructWithForwardRefEnum__setstate__(self, state):
  state.setdefault('a',   12)
  state.setdefault('b',   12)
  self.__dict__ = state

MyStructWithForwardRefEnum.__getstate__ = lambda self: self.__dict__.copy()
MyStructWithForwardRefEnum.__setstate__ = MyStructWithForwardRefEnum__setstate__

all_structs.append(TrivialNumeric)
TrivialNumeric.thrift_spec = (
  None, # 0
  (1, TType.I32, 'a', None, None, 2, ), # 1
  (2, TType.BOOL, 'b', None, None, 2, ), # 2
)

TrivialNumeric.thrift_struct_annotations = {
}
TrivialNumeric.thrift_field_annotations = {
}

def TrivialNumeric__init__(self, a=None, b=None,):
  self.a = a
  self.b = b

TrivialNumeric.__init__ = TrivialNumeric__init__

def TrivialNumeric__setstate__(self, state):
  state.setdefault('a', None)
  state.setdefault('b', None)
  self.__dict__ = state

TrivialNumeric.__getstate__ = lambda self: self.__dict__.copy()
TrivialNumeric.__setstate__ = TrivialNumeric__setstate__

all_structs.append(TrivialNestedWithDefault)
TrivialNestedWithDefault.thrift_spec = (
  None, # 0
  (1, TType.I32, 'z', None, 4, 2, ), # 1
  (2, TType.STRUCT, 'n', [TrivialNumeric, TrivialNumeric.thrift_spec, False], TrivialNumeric(**{
    "a" : 3,
    "b" : True,
  }), 2, ), # 2
)

TrivialNestedWithDefault.thrift_struct_annotations = {
}
TrivialNestedWithDefault.thrift_field_annotations = {
}

def TrivialNestedWithDefault__init__(self, z=TrivialNestedWithDefault.thrift_spec[1][4], n=TrivialNestedWithDefault.thrift_spec[2][4],):
  self.z = z
  if n is self.thrift_spec[2][4]:
    n = TrivialNumeric(**{
    "a" : 3,
    "b" : True,
  })
  self.n = n

TrivialNestedWithDefault.__init__ = TrivialNestedWithDefault__init__

def TrivialNestedWithDefault__setstate__(self, state):
  state.setdefault('z', 4)
  state.setdefault('n', TrivialNumeric(**{
    "a" : 3,
    "b" : True,
  }))
  self.__dict__ = state

TrivialNestedWithDefault.__getstate__ = lambda self: self.__dict__.copy()
TrivialNestedWithDefault.__setstate__ = TrivialNestedWithDefault__setstate__

all_structs.append(ComplexString)
ComplexString.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'a', True, None, 2, ), # 1
  (2, TType.MAP, 'b', (TType.STRING,True,TType.I32,None), None, 2, ), # 2
)

ComplexString.thrift_struct_annotations = {
}
ComplexString.thrift_field_annotations = {
}

def ComplexString__init__(self, a=None, b=None,):
  self.a = a
  self.b = b

ComplexString.__init__ = ComplexString__init__

def ComplexString__setstate__(self, state):
  state.setdefault('a', None)
  state.setdefault('b', None)
  self.__dict__ = state

ComplexString.__getstate__ = lambda self: self.__dict__.copy()
ComplexString.__setstate__ = ComplexString__setstate__

all_structs.append(ComplexNestedWithDefault)
ComplexNestedWithDefault.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'z', True, "4", 2, ), # 1
  (2, TType.STRUCT, 'n', [ComplexString, ComplexString.thrift_spec, False], ComplexString(**{
    "a" : "3",
    "b" : {
      "a" : 3,
    },
  }), 2, ), # 2
)

ComplexNestedWithDefault.thrift_struct_annotations = {
}
ComplexNestedWithDefault.thrift_field_annotations = {
}

def ComplexNestedWithDefault__init__(self, z=ComplexNestedWithDefault.thrift_spec[1][4], n=ComplexNestedWithDefault.thrift_spec[2][4],):
  self.z = z
  if n is self.thrift_spec[2][4]:
    n = ComplexString(**{
    "a" : "3",
    "b" : {
      "a" : 3,
    },
  })
  self.n = n

ComplexNestedWithDefault.__init__ = ComplexNestedWithDefault__init__

def ComplexNestedWithDefault__setstate__(self, state):
  state.setdefault('z', "4")
  state.setdefault('n', ComplexString(**{
    "a" : "3",
    "b" : {
      "a" : 3,
    },
  }))
  self.__dict__ = state

ComplexNestedWithDefault.__getstate__ = lambda self: self.__dict__.copy()
ComplexNestedWithDefault.__setstate__ = ComplexNestedWithDefault__setstate__

all_structs.append(MinPadding)
MinPadding.thrift_spec = (
  None, # 0
  (1, TType.BYTE, 'small', None, None, 0, ), # 1
  (2, TType.I64, 'big', None, None, 0, ), # 2
  (3, TType.I16, 'medium', None, None, 0, ), # 3
  (4, TType.I32, 'biggish', None, None, 0, ), # 4
  (5, TType.BYTE, 'tiny', None, None, 0, ), # 5
)

MinPadding.thrift_struct_annotations = {
  "cpp.minimize_padding": "1",
}
MinPadding.thrift_field_annotations = {
}

def MinPadding__init__(self, small=None, big=None, medium=None, biggish=None, tiny=None,):
  self.small = small
  self.big = big
  self.medium = medium
  self.biggish = biggish
  self.tiny = tiny

MinPadding.__init__ = MinPadding__init__

def MinPadding__setstate__(self, state):
  state.setdefault('small', None)
  state.setdefault('big', None)
  state.setdefault('medium', None)
  state.setdefault('biggish', None)
  state.setdefault('tiny', None)
  self.__dict__ = state

MinPadding.__getstate__ = lambda self: self.__dict__.copy()
MinPadding.__setstate__ = MinPadding__setstate__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  None, # 0
  (1, TType.I64, 'MyIntField', None, None, 2, ), # 1
  (2, TType.STRING, 'MyStringField', True, None, 2, ), # 2
  (3, TType.I64, 'majorVer', None, None, 2, ), # 3
  (4, TType.STRUCT, 'data', [MyDataItem, MyDataItem.thrift_spec, False], None, 2, ), # 4
)

MyStruct.thrift_struct_annotations = {
  "cpp.noncomparable": "1",
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, MyIntField=None, MyStringField=None, majorVer=None, data=None,):
  self.MyIntField = MyIntField
  self.MyStringField = MyStringField
  self.majorVer = majorVer
  self.data = data

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('MyIntField', None)
  state.setdefault('MyStringField', None)
  state.setdefault('majorVer', None)
  state.setdefault('data', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(MyDataItem)
MyDataItem.thrift_spec = (
)

MyDataItem.thrift_struct_annotations = {
  "cpp.noncomparable": "1",
}
MyDataItem.thrift_field_annotations = {
}

all_structs.append(Renaming)
Renaming.thrift_spec = (
  None, # 0
  (1, TType.I64, 'foo', None, None, 2, ), # 1
)

Renaming.thrift_struct_annotations = {
  "cpp.name": "Renamed",
}
Renaming.thrift_field_annotations = {
  1: {
    "cpp.name": "bar",
  },
}

def Renaming__init__(self, foo=None,):
  self.foo = foo

Renaming.__init__ = Renaming__init__

def Renaming__setstate__(self, state):
  state.setdefault('foo', None)
  self.__dict__ = state

Renaming.__getstate__ = lambda self: self.__dict__.copy()
Renaming.__setstate__ = Renaming__setstate__

all_structs.append(AnnotatedTypes)
AnnotatedTypes.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'binary_field', False, None, 2, ), # 1
  (2, TType.LIST, 'list_field', (TType.MAP,(TType.I32,None,TType.STRING,True)), None, 2, ), # 2
)

AnnotatedTypes.thrift_struct_annotations = {
}
AnnotatedTypes.thrift_field_annotations = {
}

def AnnotatedTypes__init__(self, binary_field=None, list_field=None,):
  self.binary_field = binary_field
  self.list_field = list_field

AnnotatedTypes.__init__ = AnnotatedTypes__init__

def AnnotatedTypes__setstate__(self, state):
  state.setdefault('binary_field', None)
  state.setdefault('list_field', None)
  self.__dict__ = state

AnnotatedTypes.__getstate__ = lambda self: self.__dict__.copy()
AnnotatedTypes.__setstate__ = AnnotatedTypes__setstate__

all_structs.append(ForwardUsageRoot)
ForwardUsageRoot.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'ForwardUsageStruct', [ForwardUsageStruct, ForwardUsageStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.STRUCT, 'ForwardUsageByRef', [ForwardUsageByRef, ForwardUsageByRef.thrift_spec, False], None, 1, ), # 2
)

ForwardUsageRoot.thrift_struct_annotations = {
}
ForwardUsageRoot.thrift_field_annotations = {
  2: {
    "cpp.ref": "true",
  },
}

def ForwardUsageRoot__init__(self, ForwardUsageStruct=None, ForwardUsageByRef=None,):
  self.ForwardUsageStruct = ForwardUsageStruct
  self.ForwardUsageByRef = ForwardUsageByRef

ForwardUsageRoot.__init__ = ForwardUsageRoot__init__

def ForwardUsageRoot__setstate__(self, state):
  state.setdefault('ForwardUsageStruct', None)
  state.setdefault('ForwardUsageByRef', None)
  self.__dict__ = state

ForwardUsageRoot.__getstate__ = lambda self: self.__dict__.copy()
ForwardUsageRoot.__setstate__ = ForwardUsageRoot__setstate__

all_structs.append(ForwardUsageStruct)
ForwardUsageStruct.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'foo', [ForwardUsageRoot, ForwardUsageRoot.thrift_spec, False], None, 1, ), # 1
)

ForwardUsageStruct.thrift_struct_annotations = {
}
ForwardUsageStruct.thrift_field_annotations = {
}

def ForwardUsageStruct__init__(self, foo=None,):
  self.foo = foo

ForwardUsageStruct.__init__ = ForwardUsageStruct__init__

def ForwardUsageStruct__setstate__(self, state):
  state.setdefault('foo', None)
  self.__dict__ = state

ForwardUsageStruct.__getstate__ = lambda self: self.__dict__.copy()
ForwardUsageStruct.__setstate__ = ForwardUsageStruct__setstate__

all_structs.append(ForwardUsageByRef)
ForwardUsageByRef.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'foo', [ForwardUsageRoot, ForwardUsageRoot.thrift_spec, False], None, 1, ), # 1
)

ForwardUsageByRef.thrift_struct_annotations = {
}
ForwardUsageByRef.thrift_field_annotations = {
}

def ForwardUsageByRef__init__(self, foo=None,):
  self.foo = foo

ForwardUsageByRef.__init__ = ForwardUsageByRef__init__

def ForwardUsageByRef__setstate__(self, state):
  state.setdefault('foo', None)
  self.__dict__ = state

ForwardUsageByRef.__getstate__ = lambda self: self.__dict__.copy()
ForwardUsageByRef.__setstate__ = ForwardUsageByRef__setstate__

all_structs.append(NoexceptMoveEmpty)
NoexceptMoveEmpty.thrift_spec = (
)

NoexceptMoveEmpty.thrift_struct_annotations = {
}
NoexceptMoveEmpty.thrift_field_annotations = {
}

all_structs.append(NoexceptMoveSimpleStruct)
NoexceptMoveSimpleStruct.thrift_spec = (
  None, # 0
  (1, TType.I64, 'boolField', None, None, 2, ), # 1
)

NoexceptMoveSimpleStruct.thrift_struct_annotations = {
}
NoexceptMoveSimpleStruct.thrift_field_annotations = {
}

def NoexceptMoveSimpleStruct__init__(self, boolField=None,):
  self.boolField = boolField

NoexceptMoveSimpleStruct.__init__ = NoexceptMoveSimpleStruct__init__

def NoexceptMoveSimpleStruct__setstate__(self, state):
  state.setdefault('boolField', None)
  self.__dict__ = state

NoexceptMoveSimpleStruct.__getstate__ = lambda self: self.__dict__.copy()
NoexceptMoveSimpleStruct.__setstate__ = NoexceptMoveSimpleStruct__setstate__

all_structs.append(NoexceptMoveComplexStruct)
NoexceptMoveComplexStruct.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'MyBoolField', None, None, 2, ), # 1
  (2, TType.I64, 'MyIntField', None, 12, 2, ), # 2
  (3, TType.STRING, 'MyStringField', True, "test", 2, ), # 3
  (4, TType.STRING, 'MyStringField2', True, None, 2, ), # 4
  (5, TType.STRING, 'MyBinaryField', False, None, 2, ), # 5
  (6, TType.STRING, 'MyBinaryField2', False, None, 1, ), # 6
  (7, TType.STRING, 'MyBinaryField3', False, None, 0, ), # 7
  (8, TType.LIST, 'MyBinaryListField4', (TType.STRING,False), None, 2, ), # 8
  (9, TType.MAP, 'MyMapEnumAndInt', (TType.I32,MyEnumA,TType.STRING,True), {
        1 : "fieldA",
        4 : "fieldC",
  }, 2, ), # 9
)

NoexceptMoveComplexStruct.thrift_struct_annotations = {
}
NoexceptMoveComplexStruct.thrift_field_annotations = {
}

def NoexceptMoveComplexStruct__init__(self, MyBoolField=None, MyIntField=NoexceptMoveComplexStruct.thrift_spec[2][4], MyStringField=NoexceptMoveComplexStruct.thrift_spec[3][4], MyStringField2=None, MyBinaryField=None, MyBinaryField2=None, MyBinaryField3=None, MyBinaryListField4=None, MyMapEnumAndInt=NoexceptMoveComplexStruct.thrift_spec[9][4],):
  self.MyBoolField = MyBoolField
  self.MyIntField = MyIntField
  self.MyStringField = MyStringField
  self.MyStringField2 = MyStringField2
  self.MyBinaryField = MyBinaryField
  self.MyBinaryField2 = MyBinaryField2
  self.MyBinaryField3 = MyBinaryField3
  self.MyBinaryListField4 = MyBinaryListField4
  if MyMapEnumAndInt is self.thrift_spec[9][4]:
    MyMapEnumAndInt = {
        1 : "fieldA",
        4 : "fieldC",
  }
  self.MyMapEnumAndInt = MyMapEnumAndInt

NoexceptMoveComplexStruct.__init__ = NoexceptMoveComplexStruct__init__

def NoexceptMoveComplexStruct__setstate__(self, state):
  state.setdefault('MyBoolField', None)
  state.setdefault('MyIntField', 12)
  state.setdefault('MyStringField', "test")
  state.setdefault('MyStringField2', None)
  state.setdefault('MyBinaryField', None)
  state.setdefault('MyBinaryField2', None)
  state.setdefault('MyBinaryField3', None)
  state.setdefault('MyBinaryListField4', None)
  state.setdefault('MyMapEnumAndInt', {
        1 : "fieldA",
        4 : "fieldC",
  })
  self.__dict__ = state

NoexceptMoveComplexStruct.__getstate__ = lambda self: self.__dict__.copy()
NoexceptMoveComplexStruct.__setstate__ = NoexceptMoveComplexStruct__setstate__

all_structs.append(NoExceptMoveUnion)
NoExceptMoveUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'string_field', True, None, 2, ), # 1
  (2, TType.I32, 'i32_field', None, None, 2, ), # 2
)

NoExceptMoveUnion.thrift_struct_annotations = {
}
NoExceptMoveUnion.thrift_field_annotations = {
}

def NoExceptMoveUnion__init__(self, string_field=None, i32_field=None,):
  self.field = 0
  self.value = None
  if string_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = string_field
  if i32_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = i32_field

NoExceptMoveUnion.__init__ = NoExceptMoveUnion__init__

all_structs.append(AllocatorAware)
AllocatorAware.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'aa_list', (TType.I32,None), None, 2, ), # 1
  (2, TType.SET, 'aa_set', (TType.I32,None), None, 2, ), # 2
  (3, TType.MAP, 'aa_map', (TType.I32,None,TType.I32,None), None, 2, ), # 3
  (4, TType.STRING, 'aa_string', True, None, 2, ), # 4
  (5, TType.I32, 'not_a_container', None, None, 2, ), # 5
  (6, TType.I32, 'aa_unique', None, None, 2, ), # 6
  (7, TType.I32, 'aa_shared', None, None, 2, ), # 7
)

AllocatorAware.thrift_struct_annotations = {
  "cpp.allocator": "some_allocator",
}
AllocatorAware.thrift_field_annotations = {
  6: {
    "cpp.ref_type": "unique",
  },
  7: {
    "cpp.ref_type": "shared",
  },
}

def AllocatorAware__init__(self, aa_list=None, aa_set=None, aa_map=None, aa_string=None, not_a_container=None, aa_unique=None, aa_shared=None,):
  self.aa_list = aa_list
  self.aa_set = aa_set
  self.aa_map = aa_map
  self.aa_string = aa_string
  self.not_a_container = not_a_container
  self.aa_unique = aa_unique
  self.aa_shared = aa_shared

AllocatorAware.__init__ = AllocatorAware__init__

def AllocatorAware__setstate__(self, state):
  state.setdefault('aa_list', None)
  state.setdefault('aa_set', None)
  state.setdefault('aa_map', None)
  state.setdefault('aa_string', None)
  state.setdefault('not_a_container', None)
  state.setdefault('aa_unique', None)
  state.setdefault('aa_shared', None)
  self.__dict__ = state

AllocatorAware.__getstate__ = lambda self: self.__dict__.copy()
AllocatorAware.__setstate__ = AllocatorAware__setstate__

all_structs.append(AllocatorAware2)
AllocatorAware2.thrift_spec = (
  None, # 0
  (1, TType.I32, 'not_a_container', None, None, 2, ), # 1
)

AllocatorAware2.thrift_struct_annotations = {
  "cpp.allocator": "some_allocator",
}
AllocatorAware2.thrift_field_annotations = {
}

def AllocatorAware2__init__(self, not_a_container=None,):
  self.not_a_container = not_a_container

AllocatorAware2.__init__ = AllocatorAware2__init__

def AllocatorAware2__setstate__(self, state):
  state.setdefault('not_a_container', None)
  self.__dict__ = state

AllocatorAware2.__getstate__ = lambda self: self.__dict__.copy()
AllocatorAware2.__setstate__ = AllocatorAware2__setstate__

all_structs.append(TypedefStruct)
TypedefStruct.thrift_spec = (
  None, # 0
  (1, TType.I32, 'i32_field', None, None, 2, ), # 1
  (2, TType.I32, 'IntTypedef_field', None, None, 2, ), # 2
  (3, TType.I32, 'UintTypedef_field', None, None, 2, ), # 3
)

TypedefStruct.thrift_struct_annotations = {
}
TypedefStruct.thrift_field_annotations = {
}

def TypedefStruct__init__(self, i32_field=None, IntTypedef_field=None, UintTypedef_field=None,):
  self.i32_field = i32_field
  self.IntTypedef_field = IntTypedef_field
  self.UintTypedef_field = UintTypedef_field

TypedefStruct.__init__ = TypedefStruct__init__

def TypedefStruct__setstate__(self, state):
  state.setdefault('i32_field', None)
  state.setdefault('IntTypedef_field', None)
  state.setdefault('UintTypedef_field', None)
  self.__dict__ = state

TypedefStruct.__getstate__ = lambda self: self.__dict__.copy()
TypedefStruct.__setstate__ = TypedefStruct__setstate__

all_structs.append(StructWithDoubleUnderscores)
StructWithDoubleUnderscores.thrift_spec = (
  None, # 0
  (1, TType.I32, '__field', None, None, 2, ), # 1
)

StructWithDoubleUnderscores.thrift_struct_annotations = {
}
StructWithDoubleUnderscores.thrift_field_annotations = {
}

def StructWithDoubleUnderscores__init__(self, __field=None,):
  self.__field = __field

StructWithDoubleUnderscores.__init__ = StructWithDoubleUnderscores__init__

def StructWithDoubleUnderscores__setstate__(self, state):
  state.setdefault('__field', None)
  self.__dict__ = state

StructWithDoubleUnderscores.__getstate__ = lambda self: self.__dict__.copy()
StructWithDoubleUnderscores.__setstate__ = StructWithDoubleUnderscores__setstate__

fix_spec(all_structs)
del all_structs
