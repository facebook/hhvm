/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/visitation/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::size;
folly::Range<::test_cpp2::cpp_reflection::enum1 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum1_EnumMapFactory::ValuesToNamesMapType _enum1_VALUES_TO_NAMES = _enum1_EnumMapFactory::makeValuesToNamesMap();
FOLLY_POP_WARNING
#endif
}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::size;
folly::Range<::test_cpp2::cpp_reflection::enum2 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum2_EnumMapFactory::ValuesToNamesMapType _enum2_VALUES_TO_NAMES = _enum2_EnumMapFactory::makeValuesToNamesMap();
FOLLY_POP_WARNING
#endif
}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::size;
folly::Range<::test_cpp2::cpp_reflection::enum3 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum3_EnumMapFactory::ValuesToNamesMapType _enum3_VALUES_TO_NAMES = _enum3_EnumMapFactory::makeValuesToNamesMap();
FOLLY_POP_WARNING
#endif
}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::size;
folly::Range<::test_cpp2::cpp_reflection::enum_with_special_names const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum_with_special_names_EnumMapFactory::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES = _enum_with_special_names_EnumMapFactory::makeValuesToNamesMap();
FOLLY_POP_WARNING
#endif
}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union1>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union1>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union1::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union1::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union1>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union1::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union1>::name;
}

void union1::__fbthrift_clear() {
  // clear all fields
  if (getType() == Type::__EMPTY__) { return; }
  switch(getType()) {
    case Type::ui:
      destruct(value_.ui);
      break;
    case Type::ud:
      destruct(value_.ud);
      break;
    case Type::us:
      destruct(value_.us);
      break;
    case Type::ue:
      destruct(value_.ue);
      break;
    default:
      assert(false);
      break;
  }
  type_ = folly::to_underlying(Type::__EMPTY__);
}

bool union1::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}

bool union1::operator==(const union1& rhs) const {
  if (getType() != rhs.getType()) { return false; }
  switch(getType()) {
    case Type::ui:
      return value_.ui == rhs.value_.ui;
    case Type::ud:
      return value_.ud == rhs.value_.ud;
    case Type::us:
      return value_.us == rhs.value_.us;
    case Type::ue:
      return value_.ue == rhs.value_.ue;
    default:
      return true;
  }
}

bool union1::operator<(FOLLY_MAYBE_UNUSED const union1& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (lhs.getType() != rhs.getType()) {
    return lhs.getType() < rhs.getType();
  }
  switch (lhs.getType()) {
    case Type::ui:
      return lhs.value_.ui < rhs.value_.ui;
    case Type::ud:
      return lhs.value_.ud < rhs.value_.ud;
    case Type::us:
      return lhs.value_.us < rhs.value_.us;
    case Type::ue:
      return lhs.value_.ue < rhs.value_.ue;
    default:
      return false;
  }
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union2>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union2>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union2::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union2::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union2>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union2::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union2>::name;
}

void union2::__fbthrift_clear() {
  // clear all fields
  if (getType() == Type::__EMPTY__) { return; }
  switch(getType()) {
    case Type::ui_2:
      destruct(value_.ui_2);
      break;
    case Type::ud_2:
      destruct(value_.ud_2);
      break;
    case Type::us_2:
      destruct(value_.us_2);
      break;
    case Type::ue_2:
      destruct(value_.ue_2);
      break;
    default:
      assert(false);
      break;
  }
  type_ = folly::to_underlying(Type::__EMPTY__);
}

bool union2::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}

bool union2::operator==(const union2& rhs) const {
  if (getType() != rhs.getType()) { return false; }
  switch(getType()) {
    case Type::ui_2:
      return value_.ui_2 == rhs.value_.ui_2;
    case Type::ud_2:
      return value_.ud_2 == rhs.value_.ud_2;
    case Type::us_2:
      return value_.us_2 == rhs.value_.us_2;
    case Type::ue_2:
      return value_.ue_2 == rhs.value_.ue_2;
    default:
      return true;
  }
}

bool union2::operator<(FOLLY_MAYBE_UNUSED const union2& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (lhs.getType() != rhs.getType()) {
    return lhs.getType() < rhs.getType();
  }
  switch (lhs.getType()) {
    case Type::ui_2:
      return lhs.value_.ui_2 < rhs.value_.ui_2;
    case Type::ud_2:
      return lhs.value_.ud_2 < rhs.value_.ud_2;
    case Type::us_2:
      return lhs.value_.us_2 < rhs.value_.us_2;
    case Type::ue_2:
      return lhs.value_.ue_2 < rhs.value_.ue_2;
    default:
      return false;
  }
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union3>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union3>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union3::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union3::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union3>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union3::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union3>::name;
}

void union3::__fbthrift_clear() {
  // clear all fields
  if (getType() == Type::__EMPTY__) { return; }
  switch(getType()) {
    case Type::ui_3:
      destruct(value_.ui_3);
      break;
    case Type::ud_3:
      destruct(value_.ud_3);
      break;
    case Type::us_3:
      destruct(value_.us_3);
      break;
    case Type::ue_3:
      destruct(value_.ue_3);
      break;
    default:
      assert(false);
      break;
  }
  type_ = folly::to_underlying(Type::__EMPTY__);
}

bool union3::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}

bool union3::operator==(const union3& rhs) const {
  if (getType() != rhs.getType()) { return false; }
  switch(getType()) {
    case Type::ui_3:
      return value_.ui_3 == rhs.value_.ui_3;
    case Type::ud_3:
      return value_.ud_3 == rhs.value_.ud_3;
    case Type::us_3:
      return value_.us_3 == rhs.value_.us_3;
    case Type::ue_3:
      return value_.ue_3 == rhs.value_.ue_3;
    default:
      return true;
  }
}

bool union3::operator<(FOLLY_MAYBE_UNUSED const union3& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (lhs.getType() != rhs.getType()) {
    return lhs.getType() < rhs.getType();
  }
  switch (lhs.getType()) {
    case Type::ui_3:
      return lhs.value_.ui_3 < rhs.value_.ui_3;
    case Type::ud_3:
      return lhs.value_.ud_3 < rhs.value_.ud_3;
    case Type::us_3:
      return lhs.value_.us_3 < rhs.value_.us_3;
    case Type::ue_3:
      return lhs.value_.ue_3 < rhs.value_.ue_3;
    default:
      return false;
  }
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structA>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structA>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece structA::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<structA>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece structA::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<structA>::name;
}

structA::structA(const structA&) = default;
structA& structA::operator=(const structA&) = default;
structA::structA(FOLLY_MAYBE_UNUSED structA&& other) noexcept :
    __fbthrift_field_a(std::move(other.__fbthrift_field_a)),
    __fbthrift_field_b(std::move(other.__fbthrift_field_b)),
    __isset(other.__isset) {
}

structA& structA::operator=(FOLLY_MAYBE_UNUSED structA&& other) noexcept {
    this->__fbthrift_field_a = std::move(other.__fbthrift_field_a);
    this->__fbthrift_field_b = std::move(other.__fbthrift_field_b);
    __isset = other.__isset;
    return *this;
}


structA::structA(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void structA::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  this->__fbthrift_field_b = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  __isset = {};
}

void structA::__fbthrift_clear_terse_fields() {
}

bool structA::__fbthrift_is_empty() const {
  return false;
}

bool structA::operator==(FOLLY_MAYBE_UNUSED const structA& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  return true;
}

bool structA::operator<(FOLLY_MAYBE_UNUSED const structA& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED structA& a, FOLLY_MAYBE_UNUSED structA& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}

template void structA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::unionA>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::unionA>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::unionA::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece unionA::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<unionA>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece unionA::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<unionA>::name;
}

void unionA::__fbthrift_clear() {
  // clear all fields
  if (getType() == Type::__EMPTY__) { return; }
  switch(getType()) {
    case Type::i:
      destruct(value_.i);
      break;
    case Type::d:
      destruct(value_.d);
      break;
    case Type::s:
      destruct(value_.s);
      break;
    case Type::e:
      destruct(value_.e);
      break;
    case Type::a:
      destruct(value_.a);
      break;
    default:
      assert(false);
      break;
  }
  type_ = folly::to_underlying(Type::__EMPTY__);
}

bool unionA::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}

bool unionA::operator==(const unionA& rhs) const {
  if (getType() != rhs.getType()) { return false; }
  switch(getType()) {
    case Type::i:
      return value_.i == rhs.value_.i;
    case Type::d:
      return value_.d == rhs.value_.d;
    case Type::s:
      return value_.s == rhs.value_.s;
    case Type::e:
      return value_.e == rhs.value_.e;
    case Type::a:
      return value_.a == rhs.value_.a;
    default:
      return true;
  }
}

bool unionA::operator<(FOLLY_MAYBE_UNUSED const unionA& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (lhs.getType() != rhs.getType()) {
    return lhs.getType() < rhs.getType();
  }
  switch (lhs.getType()) {
    case Type::i:
      return lhs.value_.i < rhs.value_.i;
    case Type::d:
      return lhs.value_.d < rhs.value_.d;
    case Type::s:
      return lhs.value_.s < rhs.value_.s;
    case Type::e:
      return lhs.value_.e < rhs.value_.e;
    case Type::a:
      return lhs.value_.a < rhs.value_.a;
    default:
      return false;
  }
}

void swap(unionA& a, unionA& b) {
  unionA temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void unionA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void unionA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        unionA,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structB>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structB>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece structB::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<structB>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece structB::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<structB>::name;
}


structB::structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg) :
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_d(std::move(d__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void structB::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_c = double();
  this->__fbthrift_field_d = bool();
  __isset = {};
}

void structB::__fbthrift_clear_terse_fields() {
}

bool structB::__fbthrift_is_empty() const {
  return false;
}

bool structB::operator==(FOLLY_MAYBE_UNUSED const structB& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return false;
  }
  return true;
}

bool structB::operator<(FOLLY_MAYBE_UNUSED const structB& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return lhs.d_ref() < rhs.d_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED structB& a, FOLLY_MAYBE_UNUSED structB& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_d, b.__fbthrift_field_d);
  swap(a.__isset, b.__isset);
}

template void structB::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structB::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structC>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structC>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece structC::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<structC>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece structC::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<structC>::name;
}

structC::structC(const structC&) = default;
structC& structC::operator=(const structC&) = default;
structC::structC() :
      __fbthrift_field_a(),
      __fbthrift_field_c(),
      __fbthrift_field_d(),
      __fbthrift_field_e(),
      __fbthrift_field_f() {
}


structC::~structC() {}

structC::structC(FOLLY_MAYBE_UNUSED structC&& other) noexcept :
    __fbthrift_field_a(std::move(other.__fbthrift_field_a)),
    __fbthrift_field_b(std::move(other.__fbthrift_field_b)),
    __fbthrift_field_c(std::move(other.__fbthrift_field_c)),
    __fbthrift_field_d(std::move(other.__fbthrift_field_d)),
    __fbthrift_field_e(std::move(other.__fbthrift_field_e)),
    __fbthrift_field_f(std::move(other.__fbthrift_field_f)),
    __fbthrift_field_g(std::move(other.__fbthrift_field_g)),
    __fbthrift_field_h(std::move(other.__fbthrift_field_h)),
    __fbthrift_field_i(std::move(other.__fbthrift_field_i)),
    __fbthrift_field_j(std::move(other.__fbthrift_field_j)),
    __fbthrift_field_j1(std::move(other.__fbthrift_field_j1)),
    __fbthrift_field_j2(std::move(other.__fbthrift_field_j2)),
    __fbthrift_field_j3(std::move(other.__fbthrift_field_j3)),
    __fbthrift_field_k(std::move(other.__fbthrift_field_k)),
    __fbthrift_field_k1(std::move(other.__fbthrift_field_k1)),
    __fbthrift_field_k2(std::move(other.__fbthrift_field_k2)),
    __fbthrift_field_k3(std::move(other.__fbthrift_field_k3)),
    __fbthrift_field_l(std::move(other.__fbthrift_field_l)),
    __fbthrift_field_l1(std::move(other.__fbthrift_field_l1)),
    __fbthrift_field_l2(std::move(other.__fbthrift_field_l2)),
    __fbthrift_field_l3(std::move(other.__fbthrift_field_l3)),
    __fbthrift_field_m1(std::move(other.__fbthrift_field_m1)),
    __fbthrift_field_m2(std::move(other.__fbthrift_field_m2)),
    __fbthrift_field_m3(std::move(other.__fbthrift_field_m3)),
    __fbthrift_field_n1(std::move(other.__fbthrift_field_n1)),
    __fbthrift_field_n2(std::move(other.__fbthrift_field_n2)),
    __fbthrift_field_n3(std::move(other.__fbthrift_field_n3)),
    __fbthrift_field_o1(std::move(other.__fbthrift_field_o1)),
    __fbthrift_field_o2(std::move(other.__fbthrift_field_o2)),
    __fbthrift_field_o3(std::move(other.__fbthrift_field_o3)),
    __isset(other.__isset) {
}

structC& structC::operator=(FOLLY_MAYBE_UNUSED structC&& other) noexcept {
    this->__fbthrift_field_a = std::move(other.__fbthrift_field_a);
    this->__fbthrift_field_b = std::move(other.__fbthrift_field_b);
    this->__fbthrift_field_c = std::move(other.__fbthrift_field_c);
    this->__fbthrift_field_d = std::move(other.__fbthrift_field_d);
    this->__fbthrift_field_e = std::move(other.__fbthrift_field_e);
    this->__fbthrift_field_f = std::move(other.__fbthrift_field_f);
    this->__fbthrift_field_g = std::move(other.__fbthrift_field_g);
    this->__fbthrift_field_h = std::move(other.__fbthrift_field_h);
    this->__fbthrift_field_i = std::move(other.__fbthrift_field_i);
    this->__fbthrift_field_j = std::move(other.__fbthrift_field_j);
    this->__fbthrift_field_j1 = std::move(other.__fbthrift_field_j1);
    this->__fbthrift_field_j2 = std::move(other.__fbthrift_field_j2);
    this->__fbthrift_field_j3 = std::move(other.__fbthrift_field_j3);
    this->__fbthrift_field_k = std::move(other.__fbthrift_field_k);
    this->__fbthrift_field_k1 = std::move(other.__fbthrift_field_k1);
    this->__fbthrift_field_k2 = std::move(other.__fbthrift_field_k2);
    this->__fbthrift_field_k3 = std::move(other.__fbthrift_field_k3);
    this->__fbthrift_field_l = std::move(other.__fbthrift_field_l);
    this->__fbthrift_field_l1 = std::move(other.__fbthrift_field_l1);
    this->__fbthrift_field_l2 = std::move(other.__fbthrift_field_l2);
    this->__fbthrift_field_l3 = std::move(other.__fbthrift_field_l3);
    this->__fbthrift_field_m1 = std::move(other.__fbthrift_field_m1);
    this->__fbthrift_field_m2 = std::move(other.__fbthrift_field_m2);
    this->__fbthrift_field_m3 = std::move(other.__fbthrift_field_m3);
    this->__fbthrift_field_n1 = std::move(other.__fbthrift_field_n1);
    this->__fbthrift_field_n2 = std::move(other.__fbthrift_field_n2);
    this->__fbthrift_field_n3 = std::move(other.__fbthrift_field_n3);
    this->__fbthrift_field_o1 = std::move(other.__fbthrift_field_o1);
    this->__fbthrift_field_o2 = std::move(other.__fbthrift_field_o2);
    this->__fbthrift_field_o3 = std::move(other.__fbthrift_field_o3);
    __isset = other.__isset;
    return *this;
}


structC::structC(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg, double c__arg, bool d__arg, ::test_cpp2::cpp_reflection::enum1 e__arg, ::test_cpp2::cpp_reflection::enum2 f__arg, ::test_cpp2::cpp_reflection::union1 g__arg, ::test_cpp2::cpp_reflection::unionA h__arg, ::test_cpp2::cpp_reflection::unionA i__arg, ::std::vector<::std::int32_t> j__arg, ::std::vector<::std::int32_t> j1__arg, ::std::vector<::test_cpp2::cpp_reflection::enum1> j2__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> j3__arg, ::std::set<::std::int32_t> k__arg, ::std::set<::std::int32_t> k1__arg, ::std::set<::test_cpp2::cpp_reflection::enum2> k2__arg, ::std::set<::test_cpp2::cpp_reflection::structB> k3__arg, ::std::map<::std::int32_t, ::std::int32_t> l__arg, ::std::map<::std::int32_t, ::std::int32_t> l1__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> l2__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> l3__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> m1__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> m2__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> m3__arg, ::std::map<::std::string, ::std::int32_t> n1__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> n2__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> n3__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> o1__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> o2__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> o3__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)),
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_d(std::move(d__arg)),
    __fbthrift_field_e(std::move(e__arg)),
    __fbthrift_field_f(std::move(f__arg)),
    __fbthrift_field_g(std::move(g__arg)),
    __fbthrift_field_h(std::move(h__arg)),
    __fbthrift_field_i(std::move(i__arg)),
    __fbthrift_field_j(std::move(j__arg)),
    __fbthrift_field_j1(std::move(j1__arg)),
    __fbthrift_field_j2(std::move(j2__arg)),
    __fbthrift_field_j3(std::move(j3__arg)),
    __fbthrift_field_k(std::move(k__arg)),
    __fbthrift_field_k1(std::move(k1__arg)),
    __fbthrift_field_k2(std::move(k2__arg)),
    __fbthrift_field_k3(std::move(k3__arg)),
    __fbthrift_field_l(std::move(l__arg)),
    __fbthrift_field_l1(std::move(l1__arg)),
    __fbthrift_field_l2(std::move(l2__arg)),
    __fbthrift_field_l3(std::move(l3__arg)),
    __fbthrift_field_m1(std::move(m1__arg)),
    __fbthrift_field_m2(std::move(m2__arg)),
    __fbthrift_field_m3(std::move(m3__arg)),
    __fbthrift_field_n1(std::move(n1__arg)),
    __fbthrift_field_n2(std::move(n2__arg)),
    __fbthrift_field_n3(std::move(n3__arg)),
    __fbthrift_field_o1(std::move(o1__arg)),
    __fbthrift_field_o2(std::move(o2__arg)),
    __fbthrift_field_o3(std::move(o3__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
  __isset.set(folly::index_constant<8>(), true);
  __isset.set(folly::index_constant<9>(), true);
  __isset.set(folly::index_constant<10>(), true);
  __isset.set(folly::index_constant<11>(), true);
  __isset.set(folly::index_constant<12>(), true);
  __isset.set(folly::index_constant<13>(), true);
  __isset.set(folly::index_constant<14>(), true);
  __isset.set(folly::index_constant<15>(), true);
  __isset.set(folly::index_constant<16>(), true);
  __isset.set(folly::index_constant<17>(), true);
  __isset.set(folly::index_constant<18>(), true);
  __isset.set(folly::index_constant<19>(), true);
  __isset.set(folly::index_constant<20>(), true);
  __isset.set(folly::index_constant<21>(), true);
  __isset.set(folly::index_constant<22>(), true);
  __isset.set(folly::index_constant<23>(), true);
  __isset.set(folly::index_constant<24>(), true);
  __isset.set(folly::index_constant<25>(), true);
  __isset.set(folly::index_constant<26>(), true);
  __isset.set(folly::index_constant<27>(), true);
  __isset.set(folly::index_constant<28>(), true);
  __isset.set(folly::index_constant<29>(), true);
}


void structC::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  this->__fbthrift_field_b = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_c = double();
  this->__fbthrift_field_d = bool();
  this->__fbthrift_field_e = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_f = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_g);
  ::apache::thrift::clear(this->__fbthrift_field_h);
  ::apache::thrift::clear(this->__fbthrift_field_i);
  this->__fbthrift_field_j.clear();
  this->__fbthrift_field_j1.clear();
  this->__fbthrift_field_j2.clear();
  this->__fbthrift_field_j3.clear();
  this->__fbthrift_field_k.clear();
  this->__fbthrift_field_k1.clear();
  this->__fbthrift_field_k2.clear();
  this->__fbthrift_field_k3.clear();
  this->__fbthrift_field_l.clear();
  this->__fbthrift_field_l1.clear();
  this->__fbthrift_field_l2.clear();
  this->__fbthrift_field_l3.clear();
  this->__fbthrift_field_m1.clear();
  this->__fbthrift_field_m2.clear();
  this->__fbthrift_field_m3.clear();
  this->__fbthrift_field_n1.clear();
  this->__fbthrift_field_n2.clear();
  this->__fbthrift_field_n3.clear();
  this->__fbthrift_field_o1.clear();
  this->__fbthrift_field_o2.clear();
  this->__fbthrift_field_o3.clear();
  __isset = {};
}

void structC::__fbthrift_clear_terse_fields() {
}

bool structC::__fbthrift_is_empty() const {
  return false;
}

bool structC::operator==(FOLLY_MAYBE_UNUSED const structC& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return false;
  }
  if (!(lhs.e_ref() == rhs.e_ref())) {
    return false;
  }
  if (!(lhs.f_ref() == rhs.f_ref())) {
    return false;
  }
  if (!(lhs.g_ref() == rhs.g_ref())) {
    return false;
  }
  if (!(lhs.h_ref() == rhs.h_ref())) {
    return false;
  }
  if (!(lhs.i_ref() == rhs.i_ref())) {
    return false;
  }
  if (!(lhs.j_ref() == rhs.j_ref())) {
    return false;
  }
  if (!(lhs.j1_ref() == rhs.j1_ref())) {
    return false;
  }
  if (!(lhs.j2_ref() == rhs.j2_ref())) {
    return false;
  }
  if (!(lhs.j3_ref() == rhs.j3_ref())) {
    return false;
  }
  if (!(lhs.k_ref() == rhs.k_ref())) {
    return false;
  }
  if (!(lhs.k1_ref() == rhs.k1_ref())) {
    return false;
  }
  if (!(lhs.k2_ref() == rhs.k2_ref())) {
    return false;
  }
  if (!(lhs.k3_ref() == rhs.k3_ref())) {
    return false;
  }
  if (!(lhs.l_ref() == rhs.l_ref())) {
    return false;
  }
  if (!(lhs.l1_ref() == rhs.l1_ref())) {
    return false;
  }
  if (!(lhs.l2_ref() == rhs.l2_ref())) {
    return false;
  }
  if (!(lhs.l3_ref() == rhs.l3_ref())) {
    return false;
  }
  if (!(lhs.m1_ref() == rhs.m1_ref())) {
    return false;
  }
  if (!(lhs.m2_ref() == rhs.m2_ref())) {
    return false;
  }
  if (!(lhs.m3_ref() == rhs.m3_ref())) {
    return false;
  }
  if (!(lhs.n1_ref() == rhs.n1_ref())) {
    return false;
  }
  if (!(lhs.n2_ref() == rhs.n2_ref())) {
    return false;
  }
  if (!(lhs.n3_ref() == rhs.n3_ref())) {
    return false;
  }
  if (!(lhs.o1_ref() == rhs.o1_ref())) {
    return false;
  }
  if (!(lhs.o2_ref() == rhs.o2_ref())) {
    return false;
  }
  if (!(lhs.o3_ref() == rhs.o3_ref())) {
    return false;
  }
  return true;
}

bool structC::operator<(FOLLY_MAYBE_UNUSED const structC& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return lhs.d_ref() < rhs.d_ref();
  }
  if (!(lhs.e_ref() == rhs.e_ref())) {
    return lhs.e_ref() < rhs.e_ref();
  }
  if (!(lhs.f_ref() == rhs.f_ref())) {
    return lhs.f_ref() < rhs.f_ref();
  }
  if (!(lhs.g_ref() == rhs.g_ref())) {
    return lhs.g_ref() < rhs.g_ref();
  }
  if (!(lhs.h_ref() == rhs.h_ref())) {
    return lhs.h_ref() < rhs.h_ref();
  }
  if (!(lhs.i_ref() == rhs.i_ref())) {
    return lhs.i_ref() < rhs.i_ref();
  }
  if (!(lhs.j_ref() == rhs.j_ref())) {
    return lhs.j_ref() < rhs.j_ref();
  }
  if (!(lhs.j1_ref() == rhs.j1_ref())) {
    return lhs.j1_ref() < rhs.j1_ref();
  }
  if (!(lhs.j2_ref() == rhs.j2_ref())) {
    return lhs.j2_ref() < rhs.j2_ref();
  }
  if (!(lhs.j3_ref() == rhs.j3_ref())) {
    return lhs.j3_ref() < rhs.j3_ref();
  }
  if (!(lhs.k_ref() == rhs.k_ref())) {
    return lhs.k_ref() < rhs.k_ref();
  }
  if (!(lhs.k1_ref() == rhs.k1_ref())) {
    return lhs.k1_ref() < rhs.k1_ref();
  }
  if (!(lhs.k2_ref() == rhs.k2_ref())) {
    return lhs.k2_ref() < rhs.k2_ref();
  }
  if (!(lhs.k3_ref() == rhs.k3_ref())) {
    return lhs.k3_ref() < rhs.k3_ref();
  }
  if (!(lhs.l_ref() == rhs.l_ref())) {
    return lhs.l_ref() < rhs.l_ref();
  }
  if (!(lhs.l1_ref() == rhs.l1_ref())) {
    return lhs.l1_ref() < rhs.l1_ref();
  }
  if (!(lhs.l2_ref() == rhs.l2_ref())) {
    return lhs.l2_ref() < rhs.l2_ref();
  }
  if (!(lhs.l3_ref() == rhs.l3_ref())) {
    return lhs.l3_ref() < rhs.l3_ref();
  }
  if (!(lhs.m1_ref() == rhs.m1_ref())) {
    return lhs.m1_ref() < rhs.m1_ref();
  }
  if (!(lhs.m2_ref() == rhs.m2_ref())) {
    return lhs.m2_ref() < rhs.m2_ref();
  }
  if (!(lhs.m3_ref() == rhs.m3_ref())) {
    return lhs.m3_ref() < rhs.m3_ref();
  }
  if (!(lhs.n1_ref() == rhs.n1_ref())) {
    return lhs.n1_ref() < rhs.n1_ref();
  }
  if (!(lhs.n2_ref() == rhs.n2_ref())) {
    return lhs.n2_ref() < rhs.n2_ref();
  }
  if (!(lhs.n3_ref() == rhs.n3_ref())) {
    return lhs.n3_ref() < rhs.n3_ref();
  }
  if (!(lhs.o1_ref() == rhs.o1_ref())) {
    return lhs.o1_ref() < rhs.o1_ref();
  }
  if (!(lhs.o2_ref() == rhs.o2_ref())) {
    return lhs.o2_ref() < rhs.o2_ref();
  }
  if (!(lhs.o3_ref() == rhs.o3_ref())) {
    return lhs.o3_ref() < rhs.o3_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1& structC::get_g() const& {
  return __fbthrift_field_g;
}

::test_cpp2::cpp_reflection::union1 structC::get_g() && {
  return std::move(__fbthrift_field_g);
}

const ::test_cpp2::cpp_reflection::unionA& structC::get_h() const& {
  return __fbthrift_field_h;
}

::test_cpp2::cpp_reflection::unionA structC::get_h() && {
  return std::move(__fbthrift_field_h);
}

const ::test_cpp2::cpp_reflection::unionA& structC::get_i() const& {
  return __fbthrift_field_i;
}

::test_cpp2::cpp_reflection::unionA structC::get_i() && {
  return std::move(__fbthrift_field_i);
}

const ::std::vector<::std::int32_t>& structC::get_j() const& {
  return __fbthrift_field_j;
}

::std::vector<::std::int32_t> structC::get_j() && {
  return std::move(__fbthrift_field_j);
}

const ::std::vector<::std::int32_t>& structC::get_j1() const& {
  return __fbthrift_field_j1;
}

::std::vector<::std::int32_t> structC::get_j1() && {
  return std::move(__fbthrift_field_j1);
}

const ::std::vector<::test_cpp2::cpp_reflection::enum1>& structC::get_j2() const& {
  return __fbthrift_field_j2;
}

::std::vector<::test_cpp2::cpp_reflection::enum1> structC::get_j2() && {
  return std::move(__fbthrift_field_j2);
}

const ::std::vector<::test_cpp2::cpp_reflection::structA>& structC::get_j3() const& {
  return __fbthrift_field_j3;
}

::std::vector<::test_cpp2::cpp_reflection::structA> structC::get_j3() && {
  return std::move(__fbthrift_field_j3);
}

const ::std::set<::std::int32_t>& structC::get_k() const& {
  return __fbthrift_field_k;
}

::std::set<::std::int32_t> structC::get_k() && {
  return std::move(__fbthrift_field_k);
}

const ::std::set<::std::int32_t>& structC::get_k1() const& {
  return __fbthrift_field_k1;
}

::std::set<::std::int32_t> structC::get_k1() && {
  return std::move(__fbthrift_field_k1);
}

const ::std::set<::test_cpp2::cpp_reflection::enum2>& structC::get_k2() const& {
  return __fbthrift_field_k2;
}

::std::set<::test_cpp2::cpp_reflection::enum2> structC::get_k2() && {
  return std::move(__fbthrift_field_k2);
}

const ::std::set<::test_cpp2::cpp_reflection::structB>& structC::get_k3() const& {
  return __fbthrift_field_k3;
}

::std::set<::test_cpp2::cpp_reflection::structB> structC::get_k3() && {
  return std::move(__fbthrift_field_k3);
}

const ::std::map<::std::int32_t, ::std::int32_t>& structC::get_l() const& {
  return __fbthrift_field_l;
}

::std::map<::std::int32_t, ::std::int32_t> structC::get_l() && {
  return std::move(__fbthrift_field_l);
}

const ::std::map<::std::int32_t, ::std::int32_t>& structC::get_l1() const& {
  return __fbthrift_field_l1;
}

::std::map<::std::int32_t, ::std::int32_t> structC::get_l1() && {
  return std::move(__fbthrift_field_l1);
}

const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>& structC::get_l2() const& {
  return __fbthrift_field_l2;
}

::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> structC::get_l2() && {
  return std::move(__fbthrift_field_l2);
}

const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>& structC::get_l3() const& {
  return __fbthrift_field_l3;
}

::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> structC::get_l3() && {
  return std::move(__fbthrift_field_l3);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>& structC::get_m1() const& {
  return __fbthrift_field_m1;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> structC::get_m1() && {
  return std::move(__fbthrift_field_m1);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>& structC::get_m2() const& {
  return __fbthrift_field_m2;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> structC::get_m2() && {
  return std::move(__fbthrift_field_m2);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>& structC::get_m3() const& {
  return __fbthrift_field_m3;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> structC::get_m3() && {
  return std::move(__fbthrift_field_m3);
}

const ::std::map<::std::string, ::std::int32_t>& structC::get_n1() const& {
  return __fbthrift_field_n1;
}

::std::map<::std::string, ::std::int32_t> structC::get_n1() && {
  return std::move(__fbthrift_field_n1);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>& structC::get_n2() const& {
  return __fbthrift_field_n2;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> structC::get_n2() && {
  return std::move(__fbthrift_field_n2);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& structC::get_n3() const& {
  return __fbthrift_field_n3;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> structC::get_n3() && {
  return std::move(__fbthrift_field_n3);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>& structC::get_o1() const& {
  return __fbthrift_field_o1;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> structC::get_o1() && {
  return std::move(__fbthrift_field_o1);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>& structC::get_o2() const& {
  return __fbthrift_field_o2;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> structC::get_o2() && {
  return std::move(__fbthrift_field_o2);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>& structC::get_o3() const& {
  return __fbthrift_field_o3;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> structC::get_o3() && {
  return std::move(__fbthrift_field_o3);
}


void swap(FOLLY_MAYBE_UNUSED structC& a, FOLLY_MAYBE_UNUSED structC& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_d, b.__fbthrift_field_d);
  swap(a.__fbthrift_field_e, b.__fbthrift_field_e);
  swap(a.__fbthrift_field_f, b.__fbthrift_field_f);
  swap(a.__fbthrift_field_g, b.__fbthrift_field_g);
  swap(a.__fbthrift_field_h, b.__fbthrift_field_h);
  swap(a.__fbthrift_field_i, b.__fbthrift_field_i);
  swap(a.__fbthrift_field_j, b.__fbthrift_field_j);
  swap(a.__fbthrift_field_j1, b.__fbthrift_field_j1);
  swap(a.__fbthrift_field_j2, b.__fbthrift_field_j2);
  swap(a.__fbthrift_field_j3, b.__fbthrift_field_j3);
  swap(a.__fbthrift_field_k, b.__fbthrift_field_k);
  swap(a.__fbthrift_field_k1, b.__fbthrift_field_k1);
  swap(a.__fbthrift_field_k2, b.__fbthrift_field_k2);
  swap(a.__fbthrift_field_k3, b.__fbthrift_field_k3);
  swap(a.__fbthrift_field_l, b.__fbthrift_field_l);
  swap(a.__fbthrift_field_l1, b.__fbthrift_field_l1);
  swap(a.__fbthrift_field_l2, b.__fbthrift_field_l2);
  swap(a.__fbthrift_field_l3, b.__fbthrift_field_l3);
  swap(a.__fbthrift_field_m1, b.__fbthrift_field_m1);
  swap(a.__fbthrift_field_m2, b.__fbthrift_field_m2);
  swap(a.__fbthrift_field_m3, b.__fbthrift_field_m3);
  swap(a.__fbthrift_field_n1, b.__fbthrift_field_n1);
  swap(a.__fbthrift_field_n2, b.__fbthrift_field_n2);
  swap(a.__fbthrift_field_n3, b.__fbthrift_field_n3);
  swap(a.__fbthrift_field_o1, b.__fbthrift_field_o1);
  swap(a.__fbthrift_field_o2, b.__fbthrift_field_o2);
  swap(a.__fbthrift_field_o3, b.__fbthrift_field_o3);
  swap(a.__isset, b.__isset);
}

template void structC::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structC::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structC::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structC::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::enumeration, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::integral>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::enumeration>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct1>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct1>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct1::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct1>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct1::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct1>::name;
}

struct1::struct1(const struct1&) = default;
struct1& struct1::operator=(const struct1&) = default;
struct1::struct1() :
      __fbthrift_field_field0(),
      __fbthrift_field_field2(),
      __fbthrift_field_field3() {
}


struct1::~struct1() {}

struct1::struct1(FOLLY_MAYBE_UNUSED struct1&& other) noexcept :
    __fbthrift_field_field0(std::move(other.__fbthrift_field_field0)),
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __fbthrift_field_field5(std::move(other.__fbthrift_field_field5)),
    __isset(other.__isset) {
}

struct1& struct1::operator=(FOLLY_MAYBE_UNUSED struct1&& other) noexcept {
    this->__fbthrift_field_field0 = std::move(other.__fbthrift_field_field0);
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    this->__fbthrift_field_field5 = std::move(other.__fbthrift_field_field5);
    __isset = other.__isset;
    return *this;
}


struct1::struct1(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::enum2 field3__arg, ::test_cpp2::cpp_reflection::union1 field4__arg, ::test_cpp2::cpp_reflection::union2 field5__arg) :
    __fbthrift_field_field0(std::move(field0__arg)),
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)),
    __fbthrift_field_field5(std::move(field5__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}


void struct1::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field0 = ::std::int32_t();
  this->__fbthrift_field_field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_field2 = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_field3 = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_field4);
  ::apache::thrift::clear(this->__fbthrift_field_field5);
  __isset = {};
}

void struct1::__fbthrift_clear_terse_fields() {
}

bool struct1::__fbthrift_is_empty() const {
  return false;
}

bool struct1::operator==(FOLLY_MAYBE_UNUSED const struct1& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return false;
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return false;
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return false;
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return false;
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return false;
  }
  if (!(lhs.field5_ref() == rhs.field5_ref())) {
    return false;
  }
  return true;
}

bool struct1::operator<(FOLLY_MAYBE_UNUSED const struct1& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return lhs.field0_ref() < rhs.field0_ref();
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return lhs.field2_ref() < rhs.field2_ref();
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return lhs.field3_ref() < rhs.field3_ref();
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return lhs.field4_ref() < rhs.field4_ref();
  }
  if (!(lhs.field5_ref() == rhs.field5_ref())) {
    return lhs.field5_ref() < rhs.field5_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1* struct1::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

::test_cpp2::cpp_reflection::union1* struct1::get_field4() & {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

const ::test_cpp2::cpp_reflection::union2& struct1::get_field5() const& {
  return __fbthrift_field_field5;
}

::test_cpp2::cpp_reflection::union2 struct1::get_field5() && {
  return std::move(__fbthrift_field_field5);
}


void swap(FOLLY_MAYBE_UNUSED struct1& a, FOLLY_MAYBE_UNUSED struct1& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field0, b.__fbthrift_field_field0);
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__fbthrift_field_field5, b.__fbthrift_field_field5);
  swap(a.__isset, b.__isset);
}

template void struct1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct2>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct2>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct2::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct2>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct2::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct2>::name;
}

struct2::struct2(const struct2&) = default;
struct2& struct2::operator=(const struct2&) = default;
struct2::struct2() :
      __fbthrift_field_fieldA(),
      __fbthrift_field_fieldC(),
      __fbthrift_field_fieldD() {
}


struct2::~struct2() {}

struct2::struct2(FOLLY_MAYBE_UNUSED struct2&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __fbthrift_field_fieldB(std::move(other.__fbthrift_field_fieldB)),
    __fbthrift_field_fieldC(std::move(other.__fbthrift_field_fieldC)),
    __fbthrift_field_fieldD(std::move(other.__fbthrift_field_fieldD)),
    __fbthrift_field_fieldE(std::move(other.__fbthrift_field_fieldE)),
    __fbthrift_field_fieldF(std::move(other.__fbthrift_field_fieldF)),
    __fbthrift_field_fieldG(std::move(other.__fbthrift_field_fieldG)),
    __isset(other.__isset) {
}

struct2& struct2::operator=(FOLLY_MAYBE_UNUSED struct2&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    this->__fbthrift_field_fieldB = std::move(other.__fbthrift_field_fieldB);
    this->__fbthrift_field_fieldC = std::move(other.__fbthrift_field_fieldC);
    this->__fbthrift_field_fieldD = std::move(other.__fbthrift_field_fieldD);
    this->__fbthrift_field_fieldE = std::move(other.__fbthrift_field_fieldE);
    this->__fbthrift_field_fieldF = std::move(other.__fbthrift_field_fieldF);
    this->__fbthrift_field_fieldG = std::move(other.__fbthrift_field_fieldG);
    __isset = other.__isset;
    return *this;
}


struct2::struct2(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)),
    __fbthrift_field_fieldB(std::move(fieldB__arg)),
    __fbthrift_field_fieldC(std::move(fieldC__arg)),
    __fbthrift_field_fieldD(std::move(fieldD__arg)),
    __fbthrift_field_fieldE(std::move(fieldE__arg)),
    __fbthrift_field_fieldF(std::move(fieldF__arg)),
    __fbthrift_field_fieldG(std::move(fieldG__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
}


void struct2::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA = ::std::int32_t();
  this->__fbthrift_field_fieldB = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_fieldC = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_fieldD = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_fieldE);
  ::apache::thrift::clear(this->__fbthrift_field_fieldF);
  ::apache::thrift::clear(this->__fbthrift_field_fieldG);
  __isset = {};
}

void struct2::__fbthrift_clear_terse_fields() {
}

bool struct2::__fbthrift_is_empty() const {
  return false;
}

bool struct2::operator==(FOLLY_MAYBE_UNUSED const struct2& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return false;
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return false;
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return false;
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return false;
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return false;
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return false;
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return false;
  }
  return true;
}

bool struct2::operator<(FOLLY_MAYBE_UNUSED const struct2& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return lhs.fieldA_ref() < rhs.fieldA_ref();
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return lhs.fieldB_ref() < rhs.fieldB_ref();
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return lhs.fieldC_ref() < rhs.fieldC_ref();
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return lhs.fieldD_ref() < rhs.fieldD_ref();
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return lhs.fieldE_ref() < rhs.fieldE_ref();
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return lhs.fieldF_ref() < rhs.fieldF_ref();
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return lhs.fieldG_ref() < rhs.fieldG_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1& struct2::get_fieldE() const& {
  return __fbthrift_field_fieldE;
}

::test_cpp2::cpp_reflection::union1 struct2::get_fieldE() && {
  return std::move(__fbthrift_field_fieldE);
}

const ::test_cpp2::cpp_reflection::union2& struct2::get_fieldF() const& {
  return __fbthrift_field_fieldF;
}

::test_cpp2::cpp_reflection::union2 struct2::get_fieldF() && {
  return std::move(__fbthrift_field_fieldF);
}

const ::test_cpp2::cpp_reflection::struct1& struct2::get_fieldG() const& {
  return __fbthrift_field_fieldG;
}

::test_cpp2::cpp_reflection::struct1 struct2::get_fieldG() && {
  return std::move(__fbthrift_field_fieldG);
}


void swap(FOLLY_MAYBE_UNUSED struct2& a, FOLLY_MAYBE_UNUSED struct2& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__fbthrift_field_fieldB, b.__fbthrift_field_fieldB);
  swap(a.__fbthrift_field_fieldC, b.__fbthrift_field_fieldC);
  swap(a.__fbthrift_field_fieldD, b.__fbthrift_field_fieldD);
  swap(a.__fbthrift_field_fieldE, b.__fbthrift_field_fieldE);
  swap(a.__fbthrift_field_fieldF, b.__fbthrift_field_fieldF);
  swap(a.__fbthrift_field_fieldG, b.__fbthrift_field_fieldG);
  swap(a.__isset, b.__isset);
}

template void struct2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct3>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct3>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct3::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct3>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct3::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct3>::name;
}

struct3::struct3(const struct3&) = default;
struct3& struct3::operator=(const struct3&) = default;
struct3::struct3() :
      __fbthrift_field_fieldA(),
      __fbthrift_field_fieldC(),
      __fbthrift_field_fieldD() {
}


struct3::~struct3() {}

struct3::struct3(FOLLY_MAYBE_UNUSED struct3&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __fbthrift_field_fieldB(std::move(other.__fbthrift_field_fieldB)),
    __fbthrift_field_fieldC(std::move(other.__fbthrift_field_fieldC)),
    __fbthrift_field_fieldD(std::move(other.__fbthrift_field_fieldD)),
    __fbthrift_field_fieldE(std::move(other.__fbthrift_field_fieldE)),
    __fbthrift_field_fieldF(std::move(other.__fbthrift_field_fieldF)),
    __fbthrift_field_fieldG(std::move(other.__fbthrift_field_fieldG)),
    __fbthrift_field_fieldH(std::move(other.__fbthrift_field_fieldH)),
    __fbthrift_field_fieldI(std::move(other.__fbthrift_field_fieldI)),
    __fbthrift_field_fieldJ(std::move(other.__fbthrift_field_fieldJ)),
    __fbthrift_field_fieldK(std::move(other.__fbthrift_field_fieldK)),
    __fbthrift_field_fieldL(std::move(other.__fbthrift_field_fieldL)),
    __fbthrift_field_fieldM(std::move(other.__fbthrift_field_fieldM)),
    __fbthrift_field_fieldN(std::move(other.__fbthrift_field_fieldN)),
    __fbthrift_field_fieldO(std::move(other.__fbthrift_field_fieldO)),
    __fbthrift_field_fieldP(std::move(other.__fbthrift_field_fieldP)),
    __fbthrift_field_fieldQ(std::move(other.__fbthrift_field_fieldQ)),
    __fbthrift_field_fieldR(std::move(other.__fbthrift_field_fieldR)),
    __isset(other.__isset) {
}

struct3& struct3::operator=(FOLLY_MAYBE_UNUSED struct3&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    this->__fbthrift_field_fieldB = std::move(other.__fbthrift_field_fieldB);
    this->__fbthrift_field_fieldC = std::move(other.__fbthrift_field_fieldC);
    this->__fbthrift_field_fieldD = std::move(other.__fbthrift_field_fieldD);
    this->__fbthrift_field_fieldE = std::move(other.__fbthrift_field_fieldE);
    this->__fbthrift_field_fieldF = std::move(other.__fbthrift_field_fieldF);
    this->__fbthrift_field_fieldG = std::move(other.__fbthrift_field_fieldG);
    this->__fbthrift_field_fieldH = std::move(other.__fbthrift_field_fieldH);
    this->__fbthrift_field_fieldI = std::move(other.__fbthrift_field_fieldI);
    this->__fbthrift_field_fieldJ = std::move(other.__fbthrift_field_fieldJ);
    this->__fbthrift_field_fieldK = std::move(other.__fbthrift_field_fieldK);
    this->__fbthrift_field_fieldL = std::move(other.__fbthrift_field_fieldL);
    this->__fbthrift_field_fieldM = std::move(other.__fbthrift_field_fieldM);
    this->__fbthrift_field_fieldN = std::move(other.__fbthrift_field_fieldN);
    this->__fbthrift_field_fieldO = std::move(other.__fbthrift_field_fieldO);
    this->__fbthrift_field_fieldP = std::move(other.__fbthrift_field_fieldP);
    this->__fbthrift_field_fieldQ = std::move(other.__fbthrift_field_fieldQ);
    this->__fbthrift_field_fieldR = std::move(other.__fbthrift_field_fieldR);
    __isset = other.__isset;
    return *this;
}


struct3::struct3(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg, ::test_cpp2::cpp_reflection::union2 fieldH__arg, ::std::vector<::std::int32_t> fieldI__arg, ::std::vector<::std::string> fieldJ__arg, ::std::vector<::std::string> fieldK__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> fieldL__arg, ::std::set<::std::int32_t> fieldM__arg, ::std::set<::std::string> fieldN__arg, ::std::set<::std::string> fieldO__arg, ::std::set<::test_cpp2::cpp_reflection::structB> fieldP__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> fieldQ__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> fieldR__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)),
    __fbthrift_field_fieldB(std::move(fieldB__arg)),
    __fbthrift_field_fieldC(std::move(fieldC__arg)),
    __fbthrift_field_fieldD(std::move(fieldD__arg)),
    __fbthrift_field_fieldE(std::move(fieldE__arg)),
    __fbthrift_field_fieldF(std::move(fieldF__arg)),
    __fbthrift_field_fieldG(std::move(fieldG__arg)),
    __fbthrift_field_fieldH(std::move(fieldH__arg)),
    __fbthrift_field_fieldI(std::move(fieldI__arg)),
    __fbthrift_field_fieldJ(std::move(fieldJ__arg)),
    __fbthrift_field_fieldK(std::move(fieldK__arg)),
    __fbthrift_field_fieldL(std::move(fieldL__arg)),
    __fbthrift_field_fieldM(std::move(fieldM__arg)),
    __fbthrift_field_fieldN(std::move(fieldN__arg)),
    __fbthrift_field_fieldO(std::move(fieldO__arg)),
    __fbthrift_field_fieldP(std::move(fieldP__arg)),
    __fbthrift_field_fieldQ(std::move(fieldQ__arg)),
    __fbthrift_field_fieldR(std::move(fieldR__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
  __isset.set(folly::index_constant<8>(), true);
  __isset.set(folly::index_constant<9>(), true);
  __isset.set(folly::index_constant<10>(), true);
  __isset.set(folly::index_constant<11>(), true);
  __isset.set(folly::index_constant<12>(), true);
  __isset.set(folly::index_constant<13>(), true);
  __isset.set(folly::index_constant<14>(), true);
  __isset.set(folly::index_constant<15>(), true);
  __isset.set(folly::index_constant<16>(), true);
  __isset.set(folly::index_constant<17>(), true);
}


void struct3::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA = ::std::int32_t();
  this->__fbthrift_field_fieldB = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_fieldC = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_fieldD = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_fieldE);
  ::apache::thrift::clear(this->__fbthrift_field_fieldF);
  ::apache::thrift::clear(this->__fbthrift_field_fieldG);
  ::apache::thrift::clear(this->__fbthrift_field_fieldH);
  this->__fbthrift_field_fieldI.clear();
  this->__fbthrift_field_fieldJ.clear();
  this->__fbthrift_field_fieldK.clear();
  this->__fbthrift_field_fieldL.clear();
  this->__fbthrift_field_fieldM.clear();
  this->__fbthrift_field_fieldN.clear();
  this->__fbthrift_field_fieldO.clear();
  this->__fbthrift_field_fieldP.clear();
  this->__fbthrift_field_fieldQ.clear();
  this->__fbthrift_field_fieldR.clear();
  __isset = {};
}

void struct3::__fbthrift_clear_terse_fields() {
}

bool struct3::__fbthrift_is_empty() const {
  return false;
}

bool struct3::operator==(FOLLY_MAYBE_UNUSED const struct3& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return false;
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return false;
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return false;
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return false;
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return false;
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return false;
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return false;
  }
  if (!(lhs.fieldH_ref() == rhs.fieldH_ref())) {
    return false;
  }
  if (!(lhs.fieldI_ref() == rhs.fieldI_ref())) {
    return false;
  }
  if (!(lhs.fieldJ_ref() == rhs.fieldJ_ref())) {
    return false;
  }
  if (!(lhs.fieldK_ref() == rhs.fieldK_ref())) {
    return false;
  }
  if (!(lhs.fieldL_ref() == rhs.fieldL_ref())) {
    return false;
  }
  if (!(lhs.fieldM_ref() == rhs.fieldM_ref())) {
    return false;
  }
  if (!(lhs.fieldN_ref() == rhs.fieldN_ref())) {
    return false;
  }
  if (!(lhs.fieldO_ref() == rhs.fieldO_ref())) {
    return false;
  }
  if (!(lhs.fieldP_ref() == rhs.fieldP_ref())) {
    return false;
  }
  if (!(lhs.fieldQ_ref() == rhs.fieldQ_ref())) {
    return false;
  }
  if (!(lhs.fieldR_ref() == rhs.fieldR_ref())) {
    return false;
  }
  return true;
}

bool struct3::operator<(FOLLY_MAYBE_UNUSED const struct3& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return lhs.fieldA_ref() < rhs.fieldA_ref();
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return lhs.fieldB_ref() < rhs.fieldB_ref();
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return lhs.fieldC_ref() < rhs.fieldC_ref();
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return lhs.fieldD_ref() < rhs.fieldD_ref();
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return lhs.fieldE_ref() < rhs.fieldE_ref();
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return lhs.fieldF_ref() < rhs.fieldF_ref();
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return lhs.fieldG_ref() < rhs.fieldG_ref();
  }
  if (!(lhs.fieldH_ref() == rhs.fieldH_ref())) {
    return lhs.fieldH_ref() < rhs.fieldH_ref();
  }
  if (!(lhs.fieldI_ref() == rhs.fieldI_ref())) {
    return lhs.fieldI_ref() < rhs.fieldI_ref();
  }
  if (!(lhs.fieldJ_ref() == rhs.fieldJ_ref())) {
    return lhs.fieldJ_ref() < rhs.fieldJ_ref();
  }
  if (!(lhs.fieldK_ref() == rhs.fieldK_ref())) {
    return lhs.fieldK_ref() < rhs.fieldK_ref();
  }
  if (!(lhs.fieldL_ref() == rhs.fieldL_ref())) {
    return lhs.fieldL_ref() < rhs.fieldL_ref();
  }
  if (!(lhs.fieldM_ref() == rhs.fieldM_ref())) {
    return lhs.fieldM_ref() < rhs.fieldM_ref();
  }
  if (!(lhs.fieldN_ref() == rhs.fieldN_ref())) {
    return lhs.fieldN_ref() < rhs.fieldN_ref();
  }
  if (!(lhs.fieldO_ref() == rhs.fieldO_ref())) {
    return lhs.fieldO_ref() < rhs.fieldO_ref();
  }
  if (!(lhs.fieldP_ref() == rhs.fieldP_ref())) {
    return lhs.fieldP_ref() < rhs.fieldP_ref();
  }
  if (!(lhs.fieldQ_ref() == rhs.fieldQ_ref())) {
    return lhs.fieldQ_ref() < rhs.fieldQ_ref();
  }
  if (!(lhs.fieldR_ref() == rhs.fieldR_ref())) {
    return lhs.fieldR_ref() < rhs.fieldR_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1& struct3::get_fieldE() const& {
  return __fbthrift_field_fieldE;
}

::test_cpp2::cpp_reflection::union1 struct3::get_fieldE() && {
  return std::move(__fbthrift_field_fieldE);
}

const ::test_cpp2::cpp_reflection::union2& struct3::get_fieldF() const& {
  return __fbthrift_field_fieldF;
}

::test_cpp2::cpp_reflection::union2 struct3::get_fieldF() && {
  return std::move(__fbthrift_field_fieldF);
}

const ::test_cpp2::cpp_reflection::struct1& struct3::get_fieldG() const& {
  return __fbthrift_field_fieldG;
}

::test_cpp2::cpp_reflection::struct1 struct3::get_fieldG() && {
  return std::move(__fbthrift_field_fieldG);
}

const ::test_cpp2::cpp_reflection::union2& struct3::get_fieldH() const& {
  return __fbthrift_field_fieldH;
}

::test_cpp2::cpp_reflection::union2 struct3::get_fieldH() && {
  return std::move(__fbthrift_field_fieldH);
}

const ::std::vector<::std::int32_t>& struct3::get_fieldI() const& {
  return __fbthrift_field_fieldI;
}

::std::vector<::std::int32_t> struct3::get_fieldI() && {
  return std::move(__fbthrift_field_fieldI);
}

const ::std::vector<::std::string>& struct3::get_fieldJ() const& {
  return __fbthrift_field_fieldJ;
}

::std::vector<::std::string> struct3::get_fieldJ() && {
  return std::move(__fbthrift_field_fieldJ);
}

const ::std::vector<::std::string>& struct3::get_fieldK() const& {
  return __fbthrift_field_fieldK;
}

::std::vector<::std::string> struct3::get_fieldK() && {
  return std::move(__fbthrift_field_fieldK);
}

const ::std::vector<::test_cpp2::cpp_reflection::structA>& struct3::get_fieldL() const& {
  return __fbthrift_field_fieldL;
}

::std::vector<::test_cpp2::cpp_reflection::structA> struct3::get_fieldL() && {
  return std::move(__fbthrift_field_fieldL);
}

const ::std::set<::std::int32_t>& struct3::get_fieldM() const& {
  return __fbthrift_field_fieldM;
}

::std::set<::std::int32_t> struct3::get_fieldM() && {
  return std::move(__fbthrift_field_fieldM);
}

const ::std::set<::std::string>& struct3::get_fieldN() const& {
  return __fbthrift_field_fieldN;
}

::std::set<::std::string> struct3::get_fieldN() && {
  return std::move(__fbthrift_field_fieldN);
}

const ::std::set<::std::string>& struct3::get_fieldO() const& {
  return __fbthrift_field_fieldO;
}

::std::set<::std::string> struct3::get_fieldO() && {
  return std::move(__fbthrift_field_fieldO);
}

const ::std::set<::test_cpp2::cpp_reflection::structB>& struct3::get_fieldP() const& {
  return __fbthrift_field_fieldP;
}

::std::set<::test_cpp2::cpp_reflection::structB> struct3::get_fieldP() && {
  return std::move(__fbthrift_field_fieldP);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldQ() const& {
  return __fbthrift_field_fieldQ;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> struct3::get_fieldQ() && {
  return std::move(__fbthrift_field_fieldQ);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldR() const& {
  return __fbthrift_field_fieldR;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> struct3::get_fieldR() && {
  return std::move(__fbthrift_field_fieldR);
}


void swap(FOLLY_MAYBE_UNUSED struct3& a, FOLLY_MAYBE_UNUSED struct3& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__fbthrift_field_fieldB, b.__fbthrift_field_fieldB);
  swap(a.__fbthrift_field_fieldC, b.__fbthrift_field_fieldC);
  swap(a.__fbthrift_field_fieldD, b.__fbthrift_field_fieldD);
  swap(a.__fbthrift_field_fieldE, b.__fbthrift_field_fieldE);
  swap(a.__fbthrift_field_fieldF, b.__fbthrift_field_fieldF);
  swap(a.__fbthrift_field_fieldG, b.__fbthrift_field_fieldG);
  swap(a.__fbthrift_field_fieldH, b.__fbthrift_field_fieldH);
  swap(a.__fbthrift_field_fieldI, b.__fbthrift_field_fieldI);
  swap(a.__fbthrift_field_fieldJ, b.__fbthrift_field_fieldJ);
  swap(a.__fbthrift_field_fieldK, b.__fbthrift_field_fieldK);
  swap(a.__fbthrift_field_fieldL, b.__fbthrift_field_fieldL);
  swap(a.__fbthrift_field_fieldM, b.__fbthrift_field_fieldM);
  swap(a.__fbthrift_field_fieldN, b.__fbthrift_field_fieldN);
  swap(a.__fbthrift_field_fieldO, b.__fbthrift_field_fieldO);
  swap(a.__fbthrift_field_fieldP, b.__fbthrift_field_fieldP);
  swap(a.__fbthrift_field_fieldQ, b.__fbthrift_field_fieldQ);
  swap(a.__fbthrift_field_fieldR, b.__fbthrift_field_fieldR);
  swap(a.__isset, b.__isset);
}

template void struct3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct4>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct4>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct4::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct4>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct4::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct4>::name;
}

struct4::struct4(const struct4& srcObj) :
    __fbthrift_field_field0(srcObj.__fbthrift_field_field0),
    __fbthrift_field_field1(srcObj.__fbthrift_field_field1),
    __fbthrift_field_field2(srcObj.__fbthrift_field_field2),
    __fbthrift_field_field3(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::structure>(srcObj.__fbthrift_field_field3)),
    __isset(srcObj.__isset) {
}

struct4& struct4::operator=(const struct4& other) {
  struct4 tmp(other);
  swap(*this, tmp);
  return *this;
}

struct4::struct4(FOLLY_MAYBE_UNUSED struct4&& other) noexcept :
    __fbthrift_field_field0(std::move(other.__fbthrift_field_field0)),
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __isset(other.__isset) {
}

struct4& struct4::operator=(FOLLY_MAYBE_UNUSED struct4&& other) noexcept {
    this->__fbthrift_field_field0 = std::move(other.__fbthrift_field_field0);
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    __isset = other.__isset;
    return *this;
}


struct4::struct4(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::std::unique_ptr<::test_cpp2::cpp_reflection::structA> field3__arg) :
    __fbthrift_field_field0(std::move(field0__arg)),
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void struct4::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field0 = ::std::int32_t();
  this->__fbthrift_field_field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_field2 = ::test_cpp2::cpp_reflection::enum1();
  if (this->__fbthrift_field_field3) ::apache::thrift::clear(*this->__fbthrift_field_field3);
  __isset = {};
}

void struct4::__fbthrift_clear_terse_fields() {
}

bool struct4::__fbthrift_is_empty() const {
  return false;
}

bool struct4::operator==(FOLLY_MAYBE_UNUSED const struct4& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return false;
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return false;
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.field3_ref(), rhs.field3_ref()))) {
    return false;
  }
  return true;
}

bool struct4::operator<(FOLLY_MAYBE_UNUSED const struct4& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return lhs.field0_ref() < rhs.field0_ref();
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return lhs.field2_ref() < rhs.field2_ref();
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.field3_ref(), rhs.field3_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.field3_ref(), rhs.field3_ref());
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED struct4& a, FOLLY_MAYBE_UNUSED struct4& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field0, b.__fbthrift_field_field0);
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__isset, b.__isset);
}

template void struct4::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct4::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct4,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct5>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct5>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct5::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct5>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct5::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct5>::name;
}

struct5::struct5(const struct5&) = default;
struct5& struct5::operator=(const struct5&) = default;
struct5::struct5() :
      __fbthrift_field_field0(),
      __fbthrift_field_field2() {
}


struct5::~struct5() {}

struct5::struct5(FOLLY_MAYBE_UNUSED struct5&& other) noexcept :
    __fbthrift_field_field0(std::move(other.__fbthrift_field_field0)),
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __isset(other.__isset) {
}

struct5& struct5::operator=(FOLLY_MAYBE_UNUSED struct5&& other) noexcept {
    this->__fbthrift_field_field0 = std::move(other.__fbthrift_field_field0);
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    __isset = other.__isset;
    return *this;
}


struct5::struct5(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::structA field3__arg, ::test_cpp2::cpp_reflection::structB field4__arg) :
    __fbthrift_field_field0(std::move(field0__arg)),
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}


void struct5::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field0 = ::std::int32_t();
  this->__fbthrift_field_field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_field2 = ::test_cpp2::cpp_reflection::enum1();
  ::apache::thrift::clear(this->__fbthrift_field_field3);
  ::apache::thrift::clear(this->__fbthrift_field_field4);
  __isset = {};
}

void struct5::__fbthrift_clear_terse_fields() {
}

bool struct5::__fbthrift_is_empty() const {
  return false;
}

bool struct5::operator==(FOLLY_MAYBE_UNUSED const struct5& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return false;
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return false;
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return false;
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return false;
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return false;
  }
  return true;
}

bool struct5::operator<(FOLLY_MAYBE_UNUSED const struct5& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return lhs.field0_ref() < rhs.field0_ref();
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return lhs.field2_ref() < rhs.field2_ref();
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return lhs.field3_ref() < rhs.field3_ref();
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return lhs.field4_ref() < rhs.field4_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::structA& struct5::get_field3() const& {
  return __fbthrift_field_field3;
}

::test_cpp2::cpp_reflection::structA struct5::get_field3() && {
  return std::move(__fbthrift_field_field3);
}

const ::test_cpp2::cpp_reflection::structB& struct5::get_field4() const& {
  return __fbthrift_field_field4;
}

::test_cpp2::cpp_reflection::structB struct5::get_field4() && {
  return std::move(__fbthrift_field_field4);
}


void swap(FOLLY_MAYBE_UNUSED struct5& a, FOLLY_MAYBE_UNUSED struct5& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field0, b.__fbthrift_field_field0);
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__isset, b.__isset);
}

template void struct5::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct5::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structB>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_binary>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_binary>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct_binary::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct_binary>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct_binary::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct_binary>::name;
}

struct_binary::struct_binary(const struct_binary&) = default;
struct_binary& struct_binary::operator=(const struct_binary&) = default;
struct_binary::struct_binary(FOLLY_MAYBE_UNUSED struct_binary&& other) noexcept :
    __fbthrift_field_bi(std::move(other.__fbthrift_field_bi)),
    __isset(other.__isset) {
}

struct_binary& struct_binary::operator=(FOLLY_MAYBE_UNUSED struct_binary&& other) noexcept {
    this->__fbthrift_field_bi = std::move(other.__fbthrift_field_bi);
    __isset = other.__isset;
    return *this;
}


struct_binary::struct_binary(apache::thrift::FragileConstructor, ::std::string bi__arg) :
    __fbthrift_field_bi(std::move(bi__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void struct_binary::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_bi = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  __isset = {};
}

void struct_binary::__fbthrift_clear_terse_fields() {
}

bool struct_binary::__fbthrift_is_empty() const {
  return false;
}

bool struct_binary::operator==(FOLLY_MAYBE_UNUSED const struct_binary& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_bi, rhs.__fbthrift_field_bi)) {
    return false;
  }
  return true;
}

bool struct_binary::operator<(FOLLY_MAYBE_UNUSED const struct_binary& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_bi, rhs.__fbthrift_field_bi)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.__fbthrift_field_bi, rhs.__fbthrift_field_bi);
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED struct_binary& a, FOLLY_MAYBE_UNUSED struct_binary& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_bi, b.__fbthrift_field_bi);
  swap(a.__isset, b.__isset);
}

template void struct_binary::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_binary::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_A_struct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::dep_A_struct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece dep_A_struct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<dep_A_struct>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece dep_A_struct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<dep_A_struct>::name;
}


dep_A_struct::dep_A_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg) :
    __fbthrift_field_b(std::move(b__arg)),
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_i_a(std::move(i_a__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void dep_A_struct::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_b);
  ::apache::thrift::clear(this->__fbthrift_field_c);
  this->__fbthrift_field_i_a = ::std::int32_t();
  __isset = {};
}

void dep_A_struct::__fbthrift_clear_terse_fields() {
}

bool dep_A_struct::__fbthrift_is_empty() const {
  return false;
}

bool dep_A_struct::operator==(FOLLY_MAYBE_UNUSED const dep_A_struct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return false;
  }
  return true;
}

bool dep_A_struct::operator<(FOLLY_MAYBE_UNUSED const dep_A_struct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return lhs.i_a_ref() < rhs.i_a_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::dep_B_struct& dep_A_struct::get_b() const& {
  return __fbthrift_field_b;
}

::test_cpp2::cpp_reflection::dep_B_struct dep_A_struct::get_b() && {
  return std::move(__fbthrift_field_b);
}

const ::test_cpp2::cpp_reflection::dep_C_struct& dep_A_struct::get_c() const& {
  return __fbthrift_field_c;
}

::test_cpp2::cpp_reflection::dep_C_struct dep_A_struct::get_c() && {
  return std::move(__fbthrift_field_c);
}


void swap(FOLLY_MAYBE_UNUSED dep_A_struct& a, FOLLY_MAYBE_UNUSED dep_A_struct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_i_a, b.__fbthrift_field_i_a);
  swap(a.__isset, b.__isset);
}

template void dep_A_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_A_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_B_struct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::dep_B_struct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece dep_B_struct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<dep_B_struct>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece dep_B_struct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<dep_B_struct>::name;
}


dep_B_struct::dep_B_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg) :
    __fbthrift_field_b(std::move(b__arg)),
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_i_a(std::move(i_a__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void dep_B_struct::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_b);
  ::apache::thrift::clear(this->__fbthrift_field_c);
  this->__fbthrift_field_i_a = ::std::int32_t();
  __isset = {};
}

void dep_B_struct::__fbthrift_clear_terse_fields() {
}

bool dep_B_struct::__fbthrift_is_empty() const {
  return false;
}

bool dep_B_struct::operator==(FOLLY_MAYBE_UNUSED const dep_B_struct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return false;
  }
  return true;
}

bool dep_B_struct::operator<(FOLLY_MAYBE_UNUSED const dep_B_struct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return lhs.i_a_ref() < rhs.i_a_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::dep_B_struct& dep_B_struct::get_b() const& {
  return __fbthrift_field_b;
}

::test_cpp2::cpp_reflection::dep_B_struct dep_B_struct::get_b() && {
  return std::move(__fbthrift_field_b);
}

const ::test_cpp2::cpp_reflection::dep_C_struct& dep_B_struct::get_c() const& {
  return __fbthrift_field_c;
}

::test_cpp2::cpp_reflection::dep_C_struct dep_B_struct::get_c() && {
  return std::move(__fbthrift_field_c);
}


void swap(FOLLY_MAYBE_UNUSED dep_B_struct& a, FOLLY_MAYBE_UNUSED dep_B_struct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_i_a, b.__fbthrift_field_i_a);
  swap(a.__isset, b.__isset);
}

template void dep_B_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_B_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::annotated>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::annotated>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece annotated::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<annotated>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece annotated::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<annotated>::name;
}


annotated::annotated(apache::thrift::FragileConstructor, ::std::int32_t a__arg) :
    __fbthrift_field_a(std::move(a__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void annotated::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  __isset = {};
}

void annotated::__fbthrift_clear_terse_fields() {
}

bool annotated::__fbthrift_is_empty() const {
  return false;
}

bool annotated::operator==(FOLLY_MAYBE_UNUSED const annotated& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  return true;
}

bool annotated::operator<(FOLLY_MAYBE_UNUSED const annotated& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED annotated& a, FOLLY_MAYBE_UNUSED annotated& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__isset, b.__isset);
}

template void annotated::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void annotated::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union_with_special_names>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union_with_special_names>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union_with_special_names::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union_with_special_names::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union_with_special_names>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union_with_special_names::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union_with_special_names>::name;
}

void union_with_special_names::__fbthrift_clear() {
  // clear all fields
  if (getType() == Type::__EMPTY__) { return; }
  switch(getType()) {
    case Type::get:
      destruct(value_.get);
      break;
    case Type::getter:
      destruct(value_.getter);
      break;
    case Type::lists:
      destruct(value_.lists);
      break;
    case Type::maps:
      destruct(value_.maps);
      break;
    case Type::name:
      destruct(value_.name);
      break;
    case Type::name_to_value:
      destruct(value_.name_to_value);
      break;
    case Type::names:
      destruct(value_.names);
      break;
    case Type::prefix_tree:
      destruct(value_.prefix_tree);
      break;
    case Type::sets:
      destruct(value_.sets);
      break;
    case Type::setter:
      destruct(value_.setter);
      break;
    case Type::str:
      destruct(value_.str);
      break;
    case Type::strings:
      destruct(value_.strings);
      break;
    case Type::type:
      destruct(value_.type);
      break;
    case Type::value:
      destruct(value_.value);
      break;
    case Type::value_to_name:
      destruct(value_.value_to_name);
      break;
    case Type::values:
      destruct(value_.values);
      break;
    case Type::id:
      destruct(value_.id);
      break;
    case Type::ids:
      destruct(value_.ids);
      break;
    case Type::descriptor:
      destruct(value_.descriptor);
      break;
    case Type::descriptors:
      destruct(value_.descriptors);
      break;
    case Type::key:
      destruct(value_.key);
      break;
    case Type::keys:
      destruct(value_.keys);
      break;
    case Type::annotation:
      destruct(value_.annotation);
      break;
    case Type::annotations:
      destruct(value_.annotations);
      break;
    case Type::member:
      destruct(value_.member);
      break;
    case Type::members:
      destruct(value_.members);
      break;
    case Type::field:
      destruct(value_.field);
      break;
    case Type::fields:
      destruct(value_.fields);
      break;
    default:
      assert(false);
      break;
  }
  type_ = folly::to_underlying(Type::__EMPTY__);
}

bool union_with_special_names::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}

bool union_with_special_names::operator==(const union_with_special_names& rhs) const {
  if (getType() != rhs.getType()) { return false; }
  switch(getType()) {
    case Type::get:
      return value_.get == rhs.value_.get;
    case Type::getter:
      return value_.getter == rhs.value_.getter;
    case Type::lists:
      return value_.lists == rhs.value_.lists;
    case Type::maps:
      return value_.maps == rhs.value_.maps;
    case Type::name:
      return value_.name == rhs.value_.name;
    case Type::name_to_value:
      return value_.name_to_value == rhs.value_.name_to_value;
    case Type::names:
      return value_.names == rhs.value_.names;
    case Type::prefix_tree:
      return value_.prefix_tree == rhs.value_.prefix_tree;
    case Type::sets:
      return value_.sets == rhs.value_.sets;
    case Type::setter:
      return value_.setter == rhs.value_.setter;
    case Type::str:
      return value_.str == rhs.value_.str;
    case Type::strings:
      return value_.strings == rhs.value_.strings;
    case Type::type:
      return value_.type == rhs.value_.type;
    case Type::value:
      return value_.value == rhs.value_.value;
    case Type::value_to_name:
      return value_.value_to_name == rhs.value_.value_to_name;
    case Type::values:
      return value_.values == rhs.value_.values;
    case Type::id:
      return value_.id == rhs.value_.id;
    case Type::ids:
      return value_.ids == rhs.value_.ids;
    case Type::descriptor:
      return value_.descriptor == rhs.value_.descriptor;
    case Type::descriptors:
      return value_.descriptors == rhs.value_.descriptors;
    case Type::key:
      return value_.key == rhs.value_.key;
    case Type::keys:
      return value_.keys == rhs.value_.keys;
    case Type::annotation:
      return value_.annotation == rhs.value_.annotation;
    case Type::annotations:
      return value_.annotations == rhs.value_.annotations;
    case Type::member:
      return value_.member == rhs.value_.member;
    case Type::members:
      return value_.members == rhs.value_.members;
    case Type::field:
      return value_.field == rhs.value_.field;
    case Type::fields:
      return value_.fields == rhs.value_.fields;
    default:
      return true;
  }
}

bool union_with_special_names::operator<(FOLLY_MAYBE_UNUSED const union_with_special_names& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (lhs.getType() != rhs.getType()) {
    return lhs.getType() < rhs.getType();
  }
  switch (lhs.getType()) {
    case Type::get:
      return lhs.value_.get < rhs.value_.get;
    case Type::getter:
      return lhs.value_.getter < rhs.value_.getter;
    case Type::lists:
      return lhs.value_.lists < rhs.value_.lists;
    case Type::maps:
      return lhs.value_.maps < rhs.value_.maps;
    case Type::name:
      return lhs.value_.name < rhs.value_.name;
    case Type::name_to_value:
      return lhs.value_.name_to_value < rhs.value_.name_to_value;
    case Type::names:
      return lhs.value_.names < rhs.value_.names;
    case Type::prefix_tree:
      return lhs.value_.prefix_tree < rhs.value_.prefix_tree;
    case Type::sets:
      return lhs.value_.sets < rhs.value_.sets;
    case Type::setter:
      return lhs.value_.setter < rhs.value_.setter;
    case Type::str:
      return lhs.value_.str < rhs.value_.str;
    case Type::strings:
      return lhs.value_.strings < rhs.value_.strings;
    case Type::type:
      return lhs.value_.type < rhs.value_.type;
    case Type::value:
      return lhs.value_.value < rhs.value_.value;
    case Type::value_to_name:
      return lhs.value_.value_to_name < rhs.value_.value_to_name;
    case Type::values:
      return lhs.value_.values < rhs.value_.values;
    case Type::id:
      return lhs.value_.id < rhs.value_.id;
    case Type::ids:
      return lhs.value_.ids < rhs.value_.ids;
    case Type::descriptor:
      return lhs.value_.descriptor < rhs.value_.descriptor;
    case Type::descriptors:
      return lhs.value_.descriptors < rhs.value_.descriptors;
    case Type::key:
      return lhs.value_.key < rhs.value_.key;
    case Type::keys:
      return lhs.value_.keys < rhs.value_.keys;
    case Type::annotation:
      return lhs.value_.annotation < rhs.value_.annotation;
    case Type::annotations:
      return lhs.value_.annotations < rhs.value_.annotations;
    case Type::member:
      return lhs.value_.member < rhs.value_.member;
    case Type::members:
      return lhs.value_.members < rhs.value_.members;
    case Type::field:
      return lhs.value_.field < rhs.value_.field;
    case Type::fields:
      return lhs.value_.fields < rhs.value_.fields;
    default:
      return false;
  }
}

void swap(union_with_special_names& a, union_with_special_names& b) {
  union_with_special_names temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_special_names>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_with_special_names>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct_with_special_names::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct_with_special_names>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct_with_special_names::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct_with_special_names>::name;
}


struct_with_special_names::struct_with_special_names(apache::thrift::FragileConstructor, ::std::int32_t get__arg, ::std::int32_t getter__arg, ::std::int32_t lists__arg, ::std::int32_t maps__arg, ::std::int32_t name__arg, ::std::int32_t name_to_value__arg, ::std::int32_t names__arg, ::std::int32_t prefix_tree__arg, ::std::int32_t sets__arg, ::std::int32_t setter__arg, ::std::int32_t str__arg, ::std::int32_t strings__arg, ::std::int32_t type__arg, ::std::int32_t value__arg, ::std::int32_t value_to_name__arg, ::std::int32_t values__arg, ::std::int32_t id__arg, ::std::int32_t ids__arg, ::std::int32_t descriptor__arg, ::std::int32_t descriptors__arg, ::std::int32_t key__arg, ::std::int32_t keys__arg, ::std::int32_t annotation__arg, ::std::int32_t annotations__arg, ::std::int32_t member__arg, ::std::int32_t members__arg, ::std::int32_t field__arg, ::std::int32_t fields__arg) :
    __fbthrift_field_get(std::move(get__arg)),
    __fbthrift_field_getter(std::move(getter__arg)),
    __fbthrift_field_lists(std::move(lists__arg)),
    __fbthrift_field_maps(std::move(maps__arg)),
    __fbthrift_field_name(std::move(name__arg)),
    __fbthrift_field_name_to_value(std::move(name_to_value__arg)),
    __fbthrift_field_names(std::move(names__arg)),
    __fbthrift_field_prefix_tree(std::move(prefix_tree__arg)),
    __fbthrift_field_sets(std::move(sets__arg)),
    __fbthrift_field_setter(std::move(setter__arg)),
    __fbthrift_field_str(std::move(str__arg)),
    __fbthrift_field_strings(std::move(strings__arg)),
    __fbthrift_field_type(std::move(type__arg)),
    __fbthrift_field_value(std::move(value__arg)),
    __fbthrift_field_value_to_name(std::move(value_to_name__arg)),
    __fbthrift_field_values(std::move(values__arg)),
    __fbthrift_field_id(std::move(id__arg)),
    __fbthrift_field_ids(std::move(ids__arg)),
    __fbthrift_field_descriptor(std::move(descriptor__arg)),
    __fbthrift_field_descriptors(std::move(descriptors__arg)),
    __fbthrift_field_key(std::move(key__arg)),
    __fbthrift_field_keys(std::move(keys__arg)),
    __fbthrift_field_annotation(std::move(annotation__arg)),
    __fbthrift_field_annotations(std::move(annotations__arg)),
    __fbthrift_field_member(std::move(member__arg)),
    __fbthrift_field_members(std::move(members__arg)),
    __fbthrift_field_field(std::move(field__arg)),
    __fbthrift_field_fields(std::move(fields__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
  __isset.set(folly::index_constant<8>(), true);
  __isset.set(folly::index_constant<9>(), true);
  __isset.set(folly::index_constant<10>(), true);
  __isset.set(folly::index_constant<11>(), true);
  __isset.set(folly::index_constant<12>(), true);
  __isset.set(folly::index_constant<13>(), true);
  __isset.set(folly::index_constant<14>(), true);
  __isset.set(folly::index_constant<15>(), true);
  __isset.set(folly::index_constant<16>(), true);
  __isset.set(folly::index_constant<17>(), true);
  __isset.set(folly::index_constant<18>(), true);
  __isset.set(folly::index_constant<19>(), true);
  __isset.set(folly::index_constant<20>(), true);
  __isset.set(folly::index_constant<21>(), true);
  __isset.set(folly::index_constant<22>(), true);
  __isset.set(folly::index_constant<23>(), true);
  __isset.set(folly::index_constant<24>(), true);
  __isset.set(folly::index_constant<25>(), true);
  __isset.set(folly::index_constant<26>(), true);
  __isset.set(folly::index_constant<27>(), true);
}


void struct_with_special_names::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_get = ::std::int32_t();
  this->__fbthrift_field_getter = ::std::int32_t();
  this->__fbthrift_field_lists = ::std::int32_t();
  this->__fbthrift_field_maps = ::std::int32_t();
  this->__fbthrift_field_name = ::std::int32_t();
  this->__fbthrift_field_name_to_value = ::std::int32_t();
  this->__fbthrift_field_names = ::std::int32_t();
  this->__fbthrift_field_prefix_tree = ::std::int32_t();
  this->__fbthrift_field_sets = ::std::int32_t();
  this->__fbthrift_field_setter = ::std::int32_t();
  this->__fbthrift_field_str = ::std::int32_t();
  this->__fbthrift_field_strings = ::std::int32_t();
  this->__fbthrift_field_type = ::std::int32_t();
  this->__fbthrift_field_value = ::std::int32_t();
  this->__fbthrift_field_value_to_name = ::std::int32_t();
  this->__fbthrift_field_values = ::std::int32_t();
  this->__fbthrift_field_id = ::std::int32_t();
  this->__fbthrift_field_ids = ::std::int32_t();
  this->__fbthrift_field_descriptor = ::std::int32_t();
  this->__fbthrift_field_descriptors = ::std::int32_t();
  this->__fbthrift_field_key = ::std::int32_t();
  this->__fbthrift_field_keys = ::std::int32_t();
  this->__fbthrift_field_annotation = ::std::int32_t();
  this->__fbthrift_field_annotations = ::std::int32_t();
  this->__fbthrift_field_member = ::std::int32_t();
  this->__fbthrift_field_members = ::std::int32_t();
  this->__fbthrift_field_field = ::std::int32_t();
  this->__fbthrift_field_fields = ::std::int32_t();
  __isset = {};
}

void struct_with_special_names::__fbthrift_clear_terse_fields() {
}

bool struct_with_special_names::__fbthrift_is_empty() const {
  return false;
}

bool struct_with_special_names::operator==(FOLLY_MAYBE_UNUSED const struct_with_special_names& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.get_ref() == rhs.get_ref())) {
    return false;
  }
  if (!(lhs.getter_ref() == rhs.getter_ref())) {
    return false;
  }
  if (!(lhs.lists_ref() == rhs.lists_ref())) {
    return false;
  }
  if (!(lhs.maps_ref() == rhs.maps_ref())) {
    return false;
  }
  if (!(lhs.name_ref() == rhs.name_ref())) {
    return false;
  }
  if (!(lhs.name_to_value_ref() == rhs.name_to_value_ref())) {
    return false;
  }
  if (!(lhs.names_ref() == rhs.names_ref())) {
    return false;
  }
  if (!(lhs.prefix_tree_ref() == rhs.prefix_tree_ref())) {
    return false;
  }
  if (!(lhs.sets_ref() == rhs.sets_ref())) {
    return false;
  }
  if (!(lhs.setter_ref() == rhs.setter_ref())) {
    return false;
  }
  if (!(lhs.str_ref() == rhs.str_ref())) {
    return false;
  }
  if (!(lhs.strings_ref() == rhs.strings_ref())) {
    return false;
  }
  if (!(lhs.type_ref() == rhs.type_ref())) {
    return false;
  }
  if (!(lhs.value_ref() == rhs.value_ref())) {
    return false;
  }
  if (!(lhs.value_to_name_ref() == rhs.value_to_name_ref())) {
    return false;
  }
  if (!(lhs.values_ref() == rhs.values_ref())) {
    return false;
  }
  if (!(lhs.id_ref() == rhs.id_ref())) {
    return false;
  }
  if (!(lhs.ids_ref() == rhs.ids_ref())) {
    return false;
  }
  if (!(lhs.descriptor_ref() == rhs.descriptor_ref())) {
    return false;
  }
  if (!(lhs.descriptors_ref() == rhs.descriptors_ref())) {
    return false;
  }
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return false;
  }
  if (!(lhs.keys_ref() == rhs.keys_ref())) {
    return false;
  }
  if (!(lhs.annotation_ref() == rhs.annotation_ref())) {
    return false;
  }
  if (!(lhs.annotations_ref() == rhs.annotations_ref())) {
    return false;
  }
  if (!(lhs.member_ref() == rhs.member_ref())) {
    return false;
  }
  if (!(lhs.members_ref() == rhs.members_ref())) {
    return false;
  }
  if (!(lhs.field_ref() == rhs.field_ref())) {
    return false;
  }
  if (!(lhs.fields_ref() == rhs.fields_ref())) {
    return false;
  }
  return true;
}

bool struct_with_special_names::operator<(FOLLY_MAYBE_UNUSED const struct_with_special_names& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.get_ref() == rhs.get_ref())) {
    return lhs.get_ref() < rhs.get_ref();
  }
  if (!(lhs.getter_ref() == rhs.getter_ref())) {
    return lhs.getter_ref() < rhs.getter_ref();
  }
  if (!(lhs.lists_ref() == rhs.lists_ref())) {
    return lhs.lists_ref() < rhs.lists_ref();
  }
  if (!(lhs.maps_ref() == rhs.maps_ref())) {
    return lhs.maps_ref() < rhs.maps_ref();
  }
  if (!(lhs.name_ref() == rhs.name_ref())) {
    return lhs.name_ref() < rhs.name_ref();
  }
  if (!(lhs.name_to_value_ref() == rhs.name_to_value_ref())) {
    return lhs.name_to_value_ref() < rhs.name_to_value_ref();
  }
  if (!(lhs.names_ref() == rhs.names_ref())) {
    return lhs.names_ref() < rhs.names_ref();
  }
  if (!(lhs.prefix_tree_ref() == rhs.prefix_tree_ref())) {
    return lhs.prefix_tree_ref() < rhs.prefix_tree_ref();
  }
  if (!(lhs.sets_ref() == rhs.sets_ref())) {
    return lhs.sets_ref() < rhs.sets_ref();
  }
  if (!(lhs.setter_ref() == rhs.setter_ref())) {
    return lhs.setter_ref() < rhs.setter_ref();
  }
  if (!(lhs.str_ref() == rhs.str_ref())) {
    return lhs.str_ref() < rhs.str_ref();
  }
  if (!(lhs.strings_ref() == rhs.strings_ref())) {
    return lhs.strings_ref() < rhs.strings_ref();
  }
  if (!(lhs.type_ref() == rhs.type_ref())) {
    return lhs.type_ref() < rhs.type_ref();
  }
  if (!(lhs.value_ref() == rhs.value_ref())) {
    return lhs.value_ref() < rhs.value_ref();
  }
  if (!(lhs.value_to_name_ref() == rhs.value_to_name_ref())) {
    return lhs.value_to_name_ref() < rhs.value_to_name_ref();
  }
  if (!(lhs.values_ref() == rhs.values_ref())) {
    return lhs.values_ref() < rhs.values_ref();
  }
  if (!(lhs.id_ref() == rhs.id_ref())) {
    return lhs.id_ref() < rhs.id_ref();
  }
  if (!(lhs.ids_ref() == rhs.ids_ref())) {
    return lhs.ids_ref() < rhs.ids_ref();
  }
  if (!(lhs.descriptor_ref() == rhs.descriptor_ref())) {
    return lhs.descriptor_ref() < rhs.descriptor_ref();
  }
  if (!(lhs.descriptors_ref() == rhs.descriptors_ref())) {
    return lhs.descriptors_ref() < rhs.descriptors_ref();
  }
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return lhs.key_ref() < rhs.key_ref();
  }
  if (!(lhs.keys_ref() == rhs.keys_ref())) {
    return lhs.keys_ref() < rhs.keys_ref();
  }
  if (!(lhs.annotation_ref() == rhs.annotation_ref())) {
    return lhs.annotation_ref() < rhs.annotation_ref();
  }
  if (!(lhs.annotations_ref() == rhs.annotations_ref())) {
    return lhs.annotations_ref() < rhs.annotations_ref();
  }
  if (!(lhs.member_ref() == rhs.member_ref())) {
    return lhs.member_ref() < rhs.member_ref();
  }
  if (!(lhs.members_ref() == rhs.members_ref())) {
    return lhs.members_ref() < rhs.members_ref();
  }
  if (!(lhs.field_ref() == rhs.field_ref())) {
    return lhs.field_ref() < rhs.field_ref();
  }
  if (!(lhs.fields_ref() == rhs.fields_ref())) {
    return lhs.fields_ref() < rhs.fields_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED struct_with_special_names& a, FOLLY_MAYBE_UNUSED struct_with_special_names& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_get, b.__fbthrift_field_get);
  swap(a.__fbthrift_field_getter, b.__fbthrift_field_getter);
  swap(a.__fbthrift_field_lists, b.__fbthrift_field_lists);
  swap(a.__fbthrift_field_maps, b.__fbthrift_field_maps);
  swap(a.__fbthrift_field_name, b.__fbthrift_field_name);
  swap(a.__fbthrift_field_name_to_value, b.__fbthrift_field_name_to_value);
  swap(a.__fbthrift_field_names, b.__fbthrift_field_names);
  swap(a.__fbthrift_field_prefix_tree, b.__fbthrift_field_prefix_tree);
  swap(a.__fbthrift_field_sets, b.__fbthrift_field_sets);
  swap(a.__fbthrift_field_setter, b.__fbthrift_field_setter);
  swap(a.__fbthrift_field_str, b.__fbthrift_field_str);
  swap(a.__fbthrift_field_strings, b.__fbthrift_field_strings);
  swap(a.__fbthrift_field_type, b.__fbthrift_field_type);
  swap(a.__fbthrift_field_value, b.__fbthrift_field_value);
  swap(a.__fbthrift_field_value_to_name, b.__fbthrift_field_value_to_name);
  swap(a.__fbthrift_field_values, b.__fbthrift_field_values);
  swap(a.__fbthrift_field_id, b.__fbthrift_field_id);
  swap(a.__fbthrift_field_ids, b.__fbthrift_field_ids);
  swap(a.__fbthrift_field_descriptor, b.__fbthrift_field_descriptor);
  swap(a.__fbthrift_field_descriptors, b.__fbthrift_field_descriptors);
  swap(a.__fbthrift_field_key, b.__fbthrift_field_key);
  swap(a.__fbthrift_field_keys, b.__fbthrift_field_keys);
  swap(a.__fbthrift_field_annotation, b.__fbthrift_field_annotation);
  swap(a.__fbthrift_field_annotations, b.__fbthrift_field_annotations);
  swap(a.__fbthrift_field_member, b.__fbthrift_field_member);
  swap(a.__fbthrift_field_members, b.__fbthrift_field_members);
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__fbthrift_field_fields, b.__fbthrift_field_fields);
  swap(a.__isset, b.__isset);
}

template void struct_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_indirections>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_with_indirections>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct_with_indirections::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct_with_indirections>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct_with_indirections::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct_with_indirections>::name;
}

struct_with_indirections::struct_with_indirections(const struct_with_indirections&) = default;
struct_with_indirections& struct_with_indirections::operator=(const struct_with_indirections&) = default;
struct_with_indirections::struct_with_indirections() :
      __fbthrift_field_real(),
      __fbthrift_field_fake(),
      __fbthrift_field_number(),
      __fbthrift_field_result() {
}


struct_with_indirections::~struct_with_indirections() {}

struct_with_indirections::struct_with_indirections(FOLLY_MAYBE_UNUSED struct_with_indirections&& other) noexcept :
    __fbthrift_field_real(std::move(other.__fbthrift_field_real)),
    __fbthrift_field_fake(std::move(other.__fbthrift_field_fake)),
    __fbthrift_field_number(std::move(other.__fbthrift_field_number)),
    __fbthrift_field_result(std::move(other.__fbthrift_field_result)),
    __fbthrift_field_phrase(std::move(other.__fbthrift_field_phrase)),
    __isset(other.__isset) {
}

struct_with_indirections& struct_with_indirections::operator=(FOLLY_MAYBE_UNUSED struct_with_indirections&& other) noexcept {
    this->__fbthrift_field_real = std::move(other.__fbthrift_field_real);
    this->__fbthrift_field_fake = std::move(other.__fbthrift_field_fake);
    this->__fbthrift_field_number = std::move(other.__fbthrift_field_number);
    this->__fbthrift_field_result = std::move(other.__fbthrift_field_result);
    this->__fbthrift_field_phrase = std::move(other.__fbthrift_field_phrase);
    __isset = other.__isset;
    return *this;
}


struct_with_indirections::struct_with_indirections(apache::thrift::FragileConstructor, ::std::int32_t real__arg, ::test_cpp2::cpp_reflection::FakeI32 fake__arg, ::test_cpp2::cpp_reflection::HasANumber number__arg, ::test_cpp2::cpp_reflection::HasAResult result__arg, ::test_cpp2::cpp_reflection::HasAPhrase phrase__arg) :
    __fbthrift_field_real(std::move(real__arg)),
    __fbthrift_field_fake(std::move(fake__arg)),
    __fbthrift_field_number(std::move(number__arg)),
    __fbthrift_field_result(std::move(result__arg)),
    __fbthrift_field_phrase(std::move(phrase__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
}


void struct_with_indirections::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_real = ::std::int32_t();
  this->__fbthrift_field_fake = ::test_cpp2::cpp_reflection::FakeI32();
  ::apache::thrift::apply_indirection(this->__fbthrift_field_number) = 0;
  ::apache::thrift::apply_indirection(this->__fbthrift_field_result) = 0;
  ::apache::thrift::apply_indirection(this->__fbthrift_field_phrase) = apache::thrift::StringTraits<::folly::remove_cvref_t<::folly::invoke_result_t<::apache::thrift::detail::apply_indirection_fn, CppHasAPhrase const&>>>::fromStringLiteral("");
  __isset = {};
}

void struct_with_indirections::__fbthrift_clear_terse_fields() {
}

bool struct_with_indirections::__fbthrift_is_empty() const {
  return false;
}

bool struct_with_indirections::operator==(FOLLY_MAYBE_UNUSED const struct_with_indirections& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.real_ref() == rhs.real_ref())) {
    return false;
  }
  if (!(lhs.fake_ref() == rhs.fake_ref())) {
    return false;
  }
  if (!(lhs.number_ref() == rhs.number_ref())) {
    return false;
  }
  if (!(lhs.result_ref() == rhs.result_ref())) {
    return false;
  }
  if (!(lhs.phrase_ref() == rhs.phrase_ref())) {
    return false;
  }
  return true;
}

bool struct_with_indirections::operator<(FOLLY_MAYBE_UNUSED const struct_with_indirections& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.real_ref() == rhs.real_ref())) {
    return lhs.real_ref() < rhs.real_ref();
  }
  if (!(lhs.fake_ref() == rhs.fake_ref())) {
    return lhs.fake_ref() < rhs.fake_ref();
  }
  if (!(lhs.number_ref() == rhs.number_ref())) {
    return lhs.number_ref() < rhs.number_ref();
  }
  if (!(lhs.result_ref() == rhs.result_ref())) {
    return lhs.result_ref() < rhs.result_ref();
  }
  if (!(lhs.phrase_ref() == rhs.phrase_ref())) {
    return lhs.phrase_ref() < rhs.phrase_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED struct_with_indirections& a, FOLLY_MAYBE_UNUSED struct_with_indirections& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_real, b.__fbthrift_field_real);
  swap(a.__fbthrift_field_fake, b.__fbthrift_field_fake);
  swap(a.__fbthrift_field_number, b.__fbthrift_field_number);
  swap(a.__fbthrift_field_result, b.__fbthrift_field_result);
  swap(a.__fbthrift_field_phrase, b.__fbthrift_field_phrase);
  swap(a.__isset, b.__isset);
}

template void struct_with_indirections::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_indirections::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace test_cpp2 { namespace cpp_reflection { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}} // test_cpp2::cpp_reflection
