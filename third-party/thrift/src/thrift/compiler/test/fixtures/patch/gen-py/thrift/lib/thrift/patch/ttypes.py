#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.thrift.ttypes
import thrift.annotation.scope.ttypes
import thrift.annotation.cpp.ttypes
import thrift.lib.thrift.standard.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'PatchOp', 'GeneratePatch', 'GenerateOptionalPatch', 'BoolPatch', 'BytePatch', 'I16Patch', 'I32Patch', 'I64Patch', 'FloatPatch', 'DoublePatch', 'StringPatch', 'BinaryPatch', 'OptionalBoolPatch', 'OptionalBytePatch', 'OptionalI16Patch', 'OptionalI32Patch', 'OptionalI64Patch', 'OptionalFloatPatch', 'OptionalDoublePatch', 'OptionalStringPatch', 'OptionalBinaryPatch']

class PatchOp:
  """
  The meaning of the patch op field ids, in all properly formulated patch
  definitions.
  
  Patch field ids are interpreted at runtime, as a dynamic patch protocol,
  without any additional schema derived from IDL patch definitions.
  """
  Assign = 1
  Clear = 2
  Patch = 3
  EnsureUnion = 4
  EnsureStruct = 5
  PatchAfter = 6
  Remove = 7
  Add = 8
  Put = 9
  Unspecified = 0

  _VALUES_TO_NAMES = {
    1: "Assign",
    2: "Clear",
    3: "Patch",
    4: "EnsureUnion",
    5: "EnsureStruct",
    6: "PatchAfter",
    7: "Remove",
    8: "Add",
    9: "Put",
    0: "Unspecified",
  }

  _NAMES_TO_VALUES = {
    "Assign": 1,
    "Clear": 2,
    "Patch": 3,
    "EnsureUnion": 4,
    "EnsureStruct": 5,
    "PatchAfter": 6,
    "Remove": 7,
    "Add": 8,
    "Put": 9,
    "Unspecified": 0,
  }

class GeneratePatch:
  """
  An annotation that indicates a patch representation
  should be generated for the associated definition.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GeneratePatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.GeneratePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.GeneratePatch, self)

  def _to_py_deprecated(self):
    return self

class GenerateOptionalPatch:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GenerateOptionalPatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.GenerateOptionalPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.GenerateOptionalPatch, self)

  def _to_py_deprecated(self):
    return self

class BoolPatch:
  """
  A patch for a boolean value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - invert: If the bool value should be inverted.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.assign = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.invert = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BoolPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.BOOL, 1)
      oprot.writeBool(self.assign)
      oprot.writeFieldEnd()
    if self.invert != None:
      oprot.writeFieldBegin('invert', TType.BOOL, 9)
      oprot.writeBool(self.invert)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'invert' in json_obj and json_obj['invert'] is not None:
      self.invert = json_obj['invert']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.invert is not None:
      value = pprint.pformat(self.invert, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    invert=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'invert',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BoolPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BoolPatch, self)

  def _to_py_deprecated(self):
    return self

class BytePatch:
  """
  A patch for an 8-bit integer value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.assign = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.add = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BytePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.BYTE, 1)
      oprot.writeByte(self.assign)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BYTE, 8)
      oprot.writeByte(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7f or self.assign < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7f or self.add < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BytePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BytePatch, self)

  def _to_py_deprecated(self):
    return self

class I16Patch:
  """
  A patch for a 16-bit integer value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.assign = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.add = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I16Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I16, 1)
      oprot.writeI16(self.assign)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I16, 8)
      oprot.writeI16(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7fff or self.assign < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7fff or self.add < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I16Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I16Patch, self)

  def _to_py_deprecated(self):
    return self

class I32Patch:
  """
  A patch for a 32-bit integer value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.add = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I32Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I32, 8)
      oprot.writeI32(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7fffffff or self.assign < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7fffffff or self.add < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I32Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I32Patch, self)

  def _to_py_deprecated(self):
    return self

class I64Patch:
  """
  A patch for a 64-bit integer value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.assign = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.add = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I64Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I64, 1)
      oprot.writeI64(self.assign)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I64, 8)
      oprot.writeI64(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = long(json_obj['assign'])
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = long(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I64Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I64Patch, self)

  def _to_py_deprecated(self):
    return self

class FloatPatch:
  """
  A patch for a 32-bit floating point value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.assign = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.FLOAT:
          self.add = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FloatPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.FLOAT, 1)
      oprot.writeFloat(self.assign)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.FLOAT, 8)
      oprot.writeFloat(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = float(json_obj['assign'])
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = float(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.FloatPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.FloatPatch, self)

  def _to_py_deprecated(self):
    return self

class DoublePatch:
  """
  A patch for an 64-bit floating point value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.assign = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.add = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DoublePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.DOUBLE, 1)
      oprot.writeDouble(self.assign)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.DOUBLE, 8)
      oprot.writeDouble(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = float(json_obj['assign'])
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = float(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DoublePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DoublePatch, self)

  def _to_py_deprecated(self):
    return self

class StringPatch:
  """
  A patch for a string value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - clear: Clear a given string.
   - prepend: Prepend to a given value.
   - append: Append to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.assign = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.prepend = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.append = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StringPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRING, 1)
      oprot.writeString(self.assign.encode('utf-8')) if UTF8STRINGS and not isinstance(self.assign, bytes) else oprot.writeString(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.STRING, 8)
      oprot.writeString(self.prepend.encode('utf-8')) if UTF8STRINGS and not isinstance(self.prepend, bytes) else oprot.writeString(self.prepend)
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.STRING, 9)
      oprot.writeString(self.append.encode('utf-8')) if UTF8STRINGS and not isinstance(self.append, bytes) else oprot.writeString(self.append)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = json_obj['prepend']
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = json_obj['append']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StringPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StringPatch, self)

  def _to_py_deprecated(self):
    return self

class BinaryPatch:
  """
  A patch for a binary value.
  
  Attributes:
   - assign: Assign to a given value.
  
  If set, all other patch operations are ignored.
   - clear: Clear a given binary.
   - prepend: Prepend to a given value.
   - append: Append to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.assign = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.prepend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.append = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BinaryPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRING, 1)
      oprot.writeString(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.STRING, 8)
      oprot.writeString(self.prepend)
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.STRING, 9)
      oprot.writeString(self.append)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = json_obj['prepend']
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = json_obj['append']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BinaryPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BinaryPatch, self)

  def _to_py_deprecated(self):
    return self

class OptionalBoolPatch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = BoolPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.ensure = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = BoolPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalBoolPatch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.BOOL, 4)
      oprot.writeBool(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = BoolPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = json_obj['ensure']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = BoolPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalBoolPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalBoolPatch, self)

  def _to_py_deprecated(self):
    return self

class OptionalBytePatch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = BytePatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.ensure = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = BytePatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalBytePatch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.BYTE, 4)
      oprot.writeByte(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = BytePatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = json_obj['ensure']
      if self.ensure > 0x7f or self.ensure < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = BytePatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalBytePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalBytePatch, self)

  def _to_py_deprecated(self):
    return self

class OptionalI16Patch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = I16Patch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.ensure = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = I16Patch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalI16Patch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.I16, 4)
      oprot.writeI16(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = I16Patch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = json_obj['ensure']
      if self.ensure > 0x7fff or self.ensure < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = I16Patch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalI16Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalI16Patch, self)

  def _to_py_deprecated(self):
    return self

class OptionalI32Patch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = I32Patch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.ensure = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = I32Patch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalI32Patch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.I32, 4)
      oprot.writeI32(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = I32Patch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = json_obj['ensure']
      if self.ensure > 0x7fffffff or self.ensure < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = I32Patch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalI32Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalI32Patch, self)

  def _to_py_deprecated(self):
    return self

class OptionalI64Patch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = I64Patch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.ensure = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = I64Patch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalI64Patch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.I64, 4)
      oprot.writeI64(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = I64Patch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = long(json_obj['ensure'])
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = I64Patch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalI64Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalI64Patch, self)

  def _to_py_deprecated(self):
    return self

class OptionalFloatPatch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = FloatPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.FLOAT:
          self.ensure = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = FloatPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalFloatPatch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.FLOAT, 4)
      oprot.writeFloat(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = FloatPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = float(json_obj['ensure'])
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = FloatPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalFloatPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalFloatPatch, self)

  def _to_py_deprecated(self):
    return self

class OptionalDoublePatch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = DoublePatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.ensure = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = DoublePatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalDoublePatch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.DOUBLE, 4)
      oprot.writeDouble(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = DoublePatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = float(json_obj['ensure'])
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = DoublePatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalDoublePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalDoublePatch, self)

  def _to_py_deprecated(self):
    return self

class OptionalStringPatch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = StringPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ensure = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = StringPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalStringPatch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRING, 4)
      oprot.writeString(self.ensure.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ensure, bytes) else oprot.writeString(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = StringPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = json_obj['ensure']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = StringPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalStringPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalStringPatch, self)

  def _to_py_deprecated(self):
    return self

class OptionalBinaryPatch:
  """
  Attributes:
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = BinaryPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ensure = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = BinaryPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OptionalBinaryPatch')
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRING, 4)
      oprot.writeString(self.ensure)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = BinaryPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = json_obj['ensure']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = BinaryPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.OptionalBinaryPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.OptionalBinaryPatch, self)

  def _to_py_deprecated(self):
    return self

all_structs.append(GeneratePatch)
GeneratePatch.thrift_spec = (
)

GeneratePatch.thrift_struct_annotations = {
}
GeneratePatch.thrift_field_annotations = {
}

all_structs.append(GenerateOptionalPatch)
GenerateOptionalPatch.thrift_spec = (
)

GenerateOptionalPatch.thrift_struct_annotations = {
}
GenerateOptionalPatch.thrift_field_annotations = {
}

all_structs.append(BoolPatch)
BoolPatch.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'assign', None, None, 1, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  (9, TType.BOOL, 'invert', None, None, 2, ), # 9
)

BoolPatch.thrift_struct_annotations = {
}
BoolPatch.thrift_field_annotations = {
}

def BoolPatch__init__(self, assign=None, invert=None,):
  self.assign = assign
  self.invert = invert

BoolPatch.__init__ = BoolPatch__init__

def BoolPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('invert', None)
  self.__dict__ = state

BoolPatch.__getstate__ = lambda self: self.__dict__.copy()
BoolPatch.__setstate__ = BoolPatch__setstate__

all_structs.append(BytePatch)
BytePatch.thrift_spec = (
  None, # 0
  (1, TType.BYTE, 'assign', None, None, 1, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.BYTE, 'add', None, None, 2, ), # 8
)

BytePatch.thrift_struct_annotations = {
}
BytePatch.thrift_field_annotations = {
}

def BytePatch__init__(self, assign=None, add=None,):
  self.assign = assign
  self.add = add

BytePatch.__init__ = BytePatch__init__

def BytePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('add', None)
  self.__dict__ = state

BytePatch.__getstate__ = lambda self: self.__dict__.copy()
BytePatch.__setstate__ = BytePatch__setstate__

all_structs.append(I16Patch)
I16Patch.thrift_spec = (
  None, # 0
  (1, TType.I16, 'assign', None, None, 1, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.I16, 'add', None, None, 2, ), # 8
)

I16Patch.thrift_struct_annotations = {
}
I16Patch.thrift_field_annotations = {
}

def I16Patch__init__(self, assign=None, add=None,):
  self.assign = assign
  self.add = add

I16Patch.__init__ = I16Patch__init__

def I16Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('add', None)
  self.__dict__ = state

I16Patch.__getstate__ = lambda self: self.__dict__.copy()
I16Patch.__setstate__ = I16Patch__setstate__

all_structs.append(I32Patch)
I32Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', None, None, 1, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.I32, 'add', None, None, 2, ), # 8
)

I32Patch.thrift_struct_annotations = {
}
I32Patch.thrift_field_annotations = {
}

def I32Patch__init__(self, assign=None, add=None,):
  self.assign = assign
  self.add = add

I32Patch.__init__ = I32Patch__init__

def I32Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('add', None)
  self.__dict__ = state

I32Patch.__getstate__ = lambda self: self.__dict__.copy()
I32Patch.__setstate__ = I32Patch__setstate__

all_structs.append(I64Patch)
I64Patch.thrift_spec = (
  None, # 0
  (1, TType.I64, 'assign', None, None, 1, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.I64, 'add', None, None, 2, ), # 8
)

I64Patch.thrift_struct_annotations = {
}
I64Patch.thrift_field_annotations = {
}

def I64Patch__init__(self, assign=None, add=None,):
  self.assign = assign
  self.add = add

I64Patch.__init__ = I64Patch__init__

def I64Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('add', None)
  self.__dict__ = state

I64Patch.__getstate__ = lambda self: self.__dict__.copy()
I64Patch.__setstate__ = I64Patch__setstate__

all_structs.append(FloatPatch)
FloatPatch.thrift_spec = (
  None, # 0
  (1, TType.FLOAT, 'assign', None, None, 1, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.FLOAT, 'add', None, None, 2, ), # 8
)

FloatPatch.thrift_struct_annotations = {
}
FloatPatch.thrift_field_annotations = {
}

def FloatPatch__init__(self, assign=None, add=None,):
  self.assign = assign
  self.add = add

FloatPatch.__init__ = FloatPatch__init__

def FloatPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('add', None)
  self.__dict__ = state

FloatPatch.__getstate__ = lambda self: self.__dict__.copy()
FloatPatch.__setstate__ = FloatPatch__setstate__

all_structs.append(DoublePatch)
DoublePatch.thrift_spec = (
  None, # 0
  (1, TType.DOUBLE, 'assign', None, None, 1, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.DOUBLE, 'add', None, None, 2, ), # 8
)

DoublePatch.thrift_struct_annotations = {
}
DoublePatch.thrift_field_annotations = {
}

def DoublePatch__init__(self, assign=None, add=None,):
  self.assign = assign
  self.add = add

DoublePatch.__init__ = DoublePatch__init__

def DoublePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('add', None)
  self.__dict__ = state

DoublePatch.__getstate__ = lambda self: self.__dict__.copy()
DoublePatch.__setstate__ = DoublePatch__setstate__

all_structs.append(StringPatch)
StringPatch.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'assign', True, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.STRING, 'prepend', True, None, 2, ), # 8
  (9, TType.STRING, 'append', True, None, 2, ), # 9
)

StringPatch.thrift_struct_annotations = {
}
StringPatch.thrift_field_annotations = {
}

def StringPatch__init__(self, assign=None, clear=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.prepend = prepend
  self.append = append

StringPatch.__init__ = StringPatch__init__

def StringPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

StringPatch.__getstate__ = lambda self: self.__dict__.copy()
StringPatch.__setstate__ = StringPatch__setstate__

all_structs.append(BinaryPatch)
BinaryPatch.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'assign', False, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.STRING, 'prepend', False, None, 2, ), # 8
  (9, TType.STRING, 'append', False, None, 2, ), # 9
)

BinaryPatch.thrift_struct_annotations = {
}
BinaryPatch.thrift_field_annotations = {
}

def BinaryPatch__init__(self, assign=None, clear=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.prepend = prepend
  self.append = append

BinaryPatch.__init__ = BinaryPatch__init__

def BinaryPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

BinaryPatch.__getstate__ = lambda self: self.__dict__.copy()
BinaryPatch.__setstate__ = BinaryPatch__setstate__

all_structs.append(OptionalBoolPatch)
OptionalBoolPatch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [BoolPatch, BoolPatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'ensure', None, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [BoolPatch, BoolPatch.thrift_spec, False], None, 2, ), # 6
)

OptionalBoolPatch.thrift_struct_annotations = {
}
OptionalBoolPatch.thrift_field_annotations = {
}

def OptionalBoolPatch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalBoolPatch.__init__ = OptionalBoolPatch__init__

def OptionalBoolPatch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalBoolPatch.__getstate__ = lambda self: self.__dict__.copy()
OptionalBoolPatch.__setstate__ = OptionalBoolPatch__setstate__

all_structs.append(OptionalBytePatch)
OptionalBytePatch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [BytePatch, BytePatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.BYTE, 'ensure', None, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [BytePatch, BytePatch.thrift_spec, False], None, 2, ), # 6
)

OptionalBytePatch.thrift_struct_annotations = {
}
OptionalBytePatch.thrift_field_annotations = {
}

def OptionalBytePatch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalBytePatch.__init__ = OptionalBytePatch__init__

def OptionalBytePatch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalBytePatch.__getstate__ = lambda self: self.__dict__.copy()
OptionalBytePatch.__setstate__ = OptionalBytePatch__setstate__

all_structs.append(OptionalI16Patch)
OptionalI16Patch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [I16Patch, I16Patch.thrift_spec, False], None, 2, ), # 3
  (4, TType.I16, 'ensure', None, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [I16Patch, I16Patch.thrift_spec, False], None, 2, ), # 6
)

OptionalI16Patch.thrift_struct_annotations = {
}
OptionalI16Patch.thrift_field_annotations = {
}

def OptionalI16Patch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalI16Patch.__init__ = OptionalI16Patch__init__

def OptionalI16Patch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalI16Patch.__getstate__ = lambda self: self.__dict__.copy()
OptionalI16Patch.__setstate__ = OptionalI16Patch__setstate__

all_structs.append(OptionalI32Patch)
OptionalI32Patch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [I32Patch, I32Patch.thrift_spec, False], None, 2, ), # 3
  (4, TType.I32, 'ensure', None, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [I32Patch, I32Patch.thrift_spec, False], None, 2, ), # 6
)

OptionalI32Patch.thrift_struct_annotations = {
}
OptionalI32Patch.thrift_field_annotations = {
}

def OptionalI32Patch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalI32Patch.__init__ = OptionalI32Patch__init__

def OptionalI32Patch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalI32Patch.__getstate__ = lambda self: self.__dict__.copy()
OptionalI32Patch.__setstate__ = OptionalI32Patch__setstate__

all_structs.append(OptionalI64Patch)
OptionalI64Patch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [I64Patch, I64Patch.thrift_spec, False], None, 2, ), # 3
  (4, TType.I64, 'ensure', None, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [I64Patch, I64Patch.thrift_spec, False], None, 2, ), # 6
)

OptionalI64Patch.thrift_struct_annotations = {
}
OptionalI64Patch.thrift_field_annotations = {
}

def OptionalI64Patch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalI64Patch.__init__ = OptionalI64Patch__init__

def OptionalI64Patch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalI64Patch.__getstate__ = lambda self: self.__dict__.copy()
OptionalI64Patch.__setstate__ = OptionalI64Patch__setstate__

all_structs.append(OptionalFloatPatch)
OptionalFloatPatch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [FloatPatch, FloatPatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.FLOAT, 'ensure', None, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [FloatPatch, FloatPatch.thrift_spec, False], None, 2, ), # 6
)

OptionalFloatPatch.thrift_struct_annotations = {
}
OptionalFloatPatch.thrift_field_annotations = {
}

def OptionalFloatPatch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalFloatPatch.__init__ = OptionalFloatPatch__init__

def OptionalFloatPatch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalFloatPatch.__getstate__ = lambda self: self.__dict__.copy()
OptionalFloatPatch.__setstate__ = OptionalFloatPatch__setstate__

all_structs.append(OptionalDoublePatch)
OptionalDoublePatch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [DoublePatch, DoublePatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.DOUBLE, 'ensure', None, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [DoublePatch, DoublePatch.thrift_spec, False], None, 2, ), # 6
)

OptionalDoublePatch.thrift_struct_annotations = {
}
OptionalDoublePatch.thrift_field_annotations = {
}

def OptionalDoublePatch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalDoublePatch.__init__ = OptionalDoublePatch__init__

def OptionalDoublePatch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalDoublePatch.__getstate__ = lambda self: self.__dict__.copy()
OptionalDoublePatch.__setstate__ = OptionalDoublePatch__setstate__

all_structs.append(OptionalStringPatch)
OptionalStringPatch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [StringPatch, StringPatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRING, 'ensure', True, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [StringPatch, StringPatch.thrift_spec, False], None, 2, ), # 6
)

OptionalStringPatch.thrift_struct_annotations = {
}
OptionalStringPatch.thrift_field_annotations = {
}

def OptionalStringPatch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalStringPatch.__init__ = OptionalStringPatch__init__

def OptionalStringPatch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalStringPatch.__getstate__ = lambda self: self.__dict__.copy()
OptionalStringPatch.__setstate__ = OptionalStringPatch__setstate__

all_structs.append(OptionalBinaryPatch)
OptionalBinaryPatch.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [BinaryPatch, BinaryPatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRING, 'ensure', False, None, 1, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [BinaryPatch, BinaryPatch.thrift_spec, False], None, 2, ), # 6
)

OptionalBinaryPatch.thrift_struct_annotations = {
}
OptionalBinaryPatch.thrift_field_annotations = {
}

def OptionalBinaryPatch__init__(self, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

OptionalBinaryPatch.__init__ = OptionalBinaryPatch__init__

def OptionalBinaryPatch__setstate__(self, state):
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

OptionalBinaryPatch.__getstate__ = lambda self: self.__dict__.copy()
OptionalBinaryPatch.__setstate__ = OptionalBinaryPatch__setstate__

fix_spec(all_structs)
del all_structs
