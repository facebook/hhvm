/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/complex-union/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>

namespace apache::thrift {
namespace ident {
struct intValue;
struct stringValue;
struct intListValue;
struct stringListValue;
struct typedefValue;
struct stringRef;
struct intListValue;
struct stringListValue;
struct binaryData;
struct stringData;
struct strVal;
struct intVal;
struct typedefValue;
struct v1;
struct v2;
struct thingOne;
struct thingTwo;
struct num;
struct s;
} // namespace ident
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_intValue
#define APACHE_THRIFT_ACCESSOR_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringValue
#define APACHE_THRIFT_ACCESSOR_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intListValue
#define APACHE_THRIFT_ACCESSOR_intListValue
APACHE_THRIFT_DEFINE_ACCESSOR(intListValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringListValue
#define APACHE_THRIFT_ACCESSOR_stringListValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringListValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedefValue
#define APACHE_THRIFT_ACCESSOR_typedefValue
APACHE_THRIFT_DEFINE_ACCESSOR(typedefValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringRef
#define APACHE_THRIFT_ACCESSOR_stringRef
APACHE_THRIFT_DEFINE_ACCESSOR(stringRef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intListValue
#define APACHE_THRIFT_ACCESSOR_intListValue
APACHE_THRIFT_DEFINE_ACCESSOR(intListValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringListValue
#define APACHE_THRIFT_ACCESSOR_stringListValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringListValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_binaryData
#define APACHE_THRIFT_ACCESSOR_binaryData
APACHE_THRIFT_DEFINE_ACCESSOR(binaryData);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringData
#define APACHE_THRIFT_ACCESSOR_stringData
APACHE_THRIFT_DEFINE_ACCESSOR(stringData);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_strVal
#define APACHE_THRIFT_ACCESSOR_strVal
APACHE_THRIFT_DEFINE_ACCESSOR(strVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intVal
#define APACHE_THRIFT_ACCESSOR_intVal
APACHE_THRIFT_DEFINE_ACCESSOR(intVal);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedefValue
#define APACHE_THRIFT_ACCESSOR_typedefValue
APACHE_THRIFT_DEFINE_ACCESSOR(typedefValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_v1
#define APACHE_THRIFT_ACCESSOR_v1
APACHE_THRIFT_DEFINE_ACCESSOR(v1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_v2
#define APACHE_THRIFT_ACCESSOR_v2
APACHE_THRIFT_DEFINE_ACCESSOR(v2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_thingOne
#define APACHE_THRIFT_ACCESSOR_thingOne
APACHE_THRIFT_DEFINE_ACCESSOR(thingOne);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_thingTwo
#define APACHE_THRIFT_ACCESSOR_thingTwo
APACHE_THRIFT_DEFINE_ACCESSOR(thingTwo);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_num
#define APACHE_THRIFT_ACCESSOR_num
APACHE_THRIFT_DEFINE_ACCESSOR(num);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_s
#define APACHE_THRIFT_ACCESSOR_s
APACHE_THRIFT_DEFINE_ACCESSOR(s);
#endif
} // namespace detail
} // namespace apache::thrift

// BEGIN declare_enums
// END declare_enums
// BEGIN forward_declare
namespace cpp2 {
class ComplexUnion;
class ListUnion;
class DataUnion;
class Val;
class ValUnion;
class VirtualComplexUnion;
class NonCopyableStruct;
class NonCopyableUnion;
} // namespace cpp2
// END forward_declare
namespace apache::thrift::detail::annotation {
} // namespace apache::thrift::detail::annotation

namespace apache::thrift::detail::qualifier {
} // namespace apache::thrift::detail::qualifier

// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace cpp2 {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "containerTypedef", "kind": "typedef" } */
using containerTypedef = ::std::map<::std::int16_t, ::std::string>;

/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "ComplexUnion", "kind": "union" } */
class ComplexUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 6;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1,5,2,3,9,14};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::intValue,
    ::apache::thrift::ident::stringValue,
    ::apache::thrift::ident::intListValue,
    ::apache::thrift::ident::stringListValue,
    ::apache::thrift::ident::typedefValue,
    ::apache::thrift::ident::stringRef
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::list<::apache::thrift::type::i64_t>,
    ::apache::thrift::type::list<::apache::thrift::type::string_t>,
    ::apache::thrift::type::map<::apache::thrift::type::i16_t, ::apache::thrift::type::string_t>,
    ::apache::thrift::type::string_t
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = ComplexUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:
  enum class Type : int {
    __EMPTY__ = 0,
    intValue = 1,
    stringValue = 5,
    intListValue = 2,
    stringListValue = 3,
    typedefValue = 9,
    stringRef = 14,
  } ;

  ComplexUnion()
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {}

  ComplexUnion(ComplexUnion&& rhs) noexcept
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::intListValue:
      {
        set_intListValue(std::move(rhs.value_.intListValue));
        break;
      }
      case Type::stringListValue:
      {
        set_stringListValue(std::move(rhs.value_.stringListValue));
        break;
      }
      case Type::typedefValue:
      {
        set_typedefValue(std::move(rhs.value_.typedefValue));
        break;
      }
      case Type::stringRef:
      {
        set_stringRef(std::move(*rhs.value_.stringRef));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  ComplexUnion(const ComplexUnion& rhs);

  ComplexUnion& operator=(ComplexUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::intListValue:
      {
        set_intListValue(std::move(rhs.value_.intListValue));
        break;
      }
      case Type::stringListValue:
      {
        set_stringListValue(std::move(rhs.value_.stringListValue));
        break;
      }
      case Type::typedefValue:
      {
        set_typedefValue(std::move(rhs.value_.typedefValue));
        break;
      }
      case Type::stringRef:
      {
        set_stringRef(std::move(*rhs.value_.stringRef));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  ComplexUnion& operator=(const ComplexUnion& rhs);

  ~ComplexUnion();

  union storage_type {
    ::std::int64_t intValue;
    ::std::string stringValue;
    ::std::vector<::std::int64_t> intListValue;
    ::std::vector<::std::string> stringListValue;
    ::cpp2::containerTypedef typedefValue;
    ::std::unique_ptr<::std::string> stringRef;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const ComplexUnion&) const;
  bool operator<(const ComplexUnion&) const;

  /** Glean { "field": "intValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::int64_t& set_intValue(::std::int64_t t = ::std::int64_t()) {
    using T0 = ::std::int64_t;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::intValue);
    ::new (std::addressof(value_.intValue)) T(t);
    return value_.intValue;
  }


  /** Glean { "field": "stringValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringValue(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) T(t);
    return value_.stringValue;
  }

  /** Glean { "field": "stringValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringValue(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) T(std::move(t));
    return value_.stringValue;
  }

  /** Glean { "field": "stringValue" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringValue(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }


  /** Glean { "field": "intListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::int64_t>& set_intListValue(::std::vector<::std::int64_t> const &t) {
    using T0 = ::std::vector<::std::int64_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::intListValue);
    ::new (std::addressof(value_.intListValue)) T(t);
    return value_.intListValue;
  }

  /** Glean { "field": "intListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::int64_t>& set_intListValue(::std::vector<::std::int64_t>&& t) {
    using T0 = ::std::vector<::std::int64_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::intListValue);
    ::new (std::addressof(value_.intListValue)) T(std::move(t));
    return value_.intListValue;
  }

  /** Glean { "field": "intListValue" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::int64_t>, T...>> ::std::vector<::std::int64_t>& set_intListValue(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::intListValue);
    ::new (std::addressof(value_.intListValue)) ::std::vector<::std::int64_t>(std::forward<T>(t)...);
    return value_.intListValue;
  }

  /** Glean { "field": "stringListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::string>& set_stringListValue(::std::vector<::std::string> const &t) {
    using T0 = ::std::vector<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringListValue);
    ::new (std::addressof(value_.stringListValue)) T(t);
    return value_.stringListValue;
  }

  /** Glean { "field": "stringListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::string>& set_stringListValue(::std::vector<::std::string>&& t) {
    using T0 = ::std::vector<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringListValue);
    ::new (std::addressof(value_.stringListValue)) T(std::move(t));
    return value_.stringListValue;
  }

  /** Glean { "field": "stringListValue" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::string>, T...>> ::std::vector<::std::string>& set_stringListValue(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringListValue);
    ::new (std::addressof(value_.stringListValue)) ::std::vector<::std::string>(std::forward<T>(t)...);
    return value_.stringListValue;
  }

  /** Glean { "field": "typedefValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::cpp2::containerTypedef& set_typedefValue(::cpp2::containerTypedef const &t) {
    using T0 = ::cpp2::containerTypedef;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::typedefValue);
    ::new (std::addressof(value_.typedefValue)) T(t);
    return value_.typedefValue;
  }

  /** Glean { "field": "typedefValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::cpp2::containerTypedef& set_typedefValue(::cpp2::containerTypedef&& t) {
    using T0 = ::cpp2::containerTypedef;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::typedefValue);
    ::new (std::addressof(value_.typedefValue)) T(std::move(t));
    return value_.typedefValue;
  }

  /** Glean { "field": "typedefValue" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::containerTypedef, T...>> ::cpp2::containerTypedef& set_typedefValue(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::typedefValue);
    ::new (std::addressof(value_.typedefValue)) ::cpp2::containerTypedef(std::forward<T>(t)...);
    return value_.typedefValue;
  }

  /** Glean { "field": "stringRef" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::unique_ptr<::std::string>& set_stringRef(::std::string const &t) {
    using T0 = ::std::unique_ptr<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringRef);
    ::new (std::addressof(value_.stringRef)) T(new typename T::element_type(t));
    return value_.stringRef;
  }

  /** Glean { "field": "stringRef" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::unique_ptr<::std::string>& set_stringRef(::std::string&& t) {
    using T0 = ::std::unique_ptr<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringRef);
    ::new (std::addressof(value_.stringRef)) T(new typename T::element_type(std::move(t)));
    return value_.stringRef;
  }

  /** Glean { "field": "stringRef" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::unique_ptr<::std::string>& set_stringRef(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringRef);
    ::new (std::addressof(value_.stringRef)) ::std::unique_ptr<::std::string>(new ::std::unique_ptr<::std::string>::element_type(std::forward<T>(t)...));
    return value_.stringRef;
  }

  /** Glean { "field": "stringRef" } */
  ::std::unique_ptr<::std::string>& set_stringRef(::std::unique_ptr<::std::string> t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringRef);
    ::new (std::addressof(value_.stringRef)) ::std::unique_ptr<::std::string>(std::move(t));
    return value_.stringRef;
  }

  /** Glean { "field": "intValue" } */
  ::std::int64_t const& get_intValue() const {
    if (getType() != Type::intValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.intValue;
  }

  /** Glean { "field": "stringValue" } */
  ::std::string const& get_stringValue() const {
    if (getType() != Type::stringValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringValue;
  }

  /** Glean { "field": "intListValue" } */
  ::std::vector<::std::int64_t> const& get_intListValue() const {
    if (getType() != Type::intListValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.intListValue;
  }

  /** Glean { "field": "stringListValue" } */
  ::std::vector<::std::string> const& get_stringListValue() const {
    if (getType() != Type::stringListValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringListValue;
  }

  /** Glean { "field": "typedefValue" } */
  ::cpp2::containerTypedef const& get_typedefValue() const {
    if (getType() != Type::typedefValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.typedefValue;
  }

  /** Glean { "field": "stringRef" } */
  ::std::unique_ptr<::std::string> const& get_stringRef() const {
    if (getType() != Type::stringRef) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringRef;
  }

  ::std::int64_t& mutable_intValue() {
    assert(getType() == Type::intValue);
    return value_.intValue;
  }

  ::std::string& mutable_stringValue() {
    assert(getType() == Type::stringValue);
    return value_.stringValue;
  }

  ::std::vector<::std::int64_t>& mutable_intListValue() {
    assert(getType() == Type::intListValue);
    return value_.intListValue;
  }

  ::std::vector<::std::string>& mutable_stringListValue() {
    assert(getType() == Type::stringListValue);
    return value_.stringListValue;
  }

  ::cpp2::containerTypedef& mutable_typedefValue() {
    assert(getType() == Type::typedefValue);
    return value_.typedefValue;
  }

  ::std::unique_ptr<::std::string>& mutable_stringRef() {
    assert(getType() == Type::stringRef);
    return value_.stringRef;
  }

  template <typename..., typename T = ::std::int64_t>
  T move_intValue() {
    assert(getType() == Type::intValue);
    return std::move(value_.intValue);
  }

  template <typename..., typename T = ::std::string>
  T move_stringValue() {
    assert(getType() == Type::stringValue);
    return std::move(value_.stringValue);
  }

  template <typename..., typename T = ::std::vector<::std::int64_t>>
  T move_intListValue() {
    assert(getType() == Type::intListValue);
    return std::move(value_.intListValue);
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  T move_stringListValue() {
    assert(getType() == Type::stringListValue);
    return std::move(value_.stringListValue);
  }

  template <typename..., typename T = ::cpp2::containerTypedef>
  T move_typedefValue() {
    assert(getType() == Type::typedefValue);
    return std::move(value_.typedefValue);
  }

  template <typename..., typename T = ::std::unique_ptr<::std::string>>
  T move_stringRef() {
    assert(getType() == Type::stringRef);
    return std::move(value_.stringRef);
  }

  /** Glean { "field": "intValue" } */
  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue_ref() const& {
    return {value_.intValue, fbthrift_type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intValue" } */
  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue_ref() & {
    return {value_.intValue, fbthrift_type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intValue" } */
  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue_ref() && {
    return {std::move(value_.intValue), fbthrift_type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::int64_t&> intValue() const& {
    return {value_.intValue, fbthrift_type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::int64_t&> intValue() & {
    return {value_.intValue, fbthrift_type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::int64_t&&> intValue() && {
    return {std::move(value_.intValue), fbthrift_type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "stringValue" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringValue_ref() const& {
    return {value_.stringValue, fbthrift_type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringValue" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringValue_ref() & {
    return {value_.stringValue, fbthrift_type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringValue" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringValue_ref() && {
    return {std::move(value_.stringValue), fbthrift_type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::string&> stringValue() const& {
    return {value_.stringValue, fbthrift_type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&> stringValue() & {
    return {value_.stringValue, fbthrift_type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&&> stringValue() && {
    return {std::move(value_.stringValue), fbthrift_type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "intListValue" } */
  template <typename..., typename T = ::std::vector<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intListValue_ref() const& {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  template <typename..., typename T = ::std::vector<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intListValue_ref() & {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  template <typename..., typename T = ::std::vector<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intListValue_ref() && {
    return {std::move(value_.intListValue), fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::vector<::std::int64_t>&> intListValue() const& {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::int64_t>&> intListValue() & {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::int64_t>&&> intListValue() && {
    return {std::move(value_.intListValue), fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "stringListValue" } */
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringListValue_ref() const& {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringListValue_ref() & {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringListValue_ref() && {
    return {std::move(value_.stringListValue), fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::vector<::std::string>&> stringListValue() const& {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::string>&> stringListValue() & {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::string>&&> stringListValue() && {
    return {std::move(value_.stringListValue), fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "typedefValue" } */
  template <typename..., typename T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> typedefValue_ref() const& {
    return {value_.typedefValue, fbthrift_type_, folly::to_underlying(Type::typedefValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> typedefValue_ref() & {
    return {value_.typedefValue, fbthrift_type_, folly::to_underlying(Type::typedefValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> typedefValue_ref() && {
    return {std::move(value_.typedefValue), fbthrift_type_, folly::to_underlying(Type::typedefValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "typedefValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::cpp2::containerTypedef&> typedefValue() const& {
    return {value_.typedefValue, fbthrift_type_, folly::to_underlying(Type::typedefValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "typedefValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::containerTypedef&> typedefValue() & {
    return {value_.typedefValue, fbthrift_type_, folly::to_underlying(Type::typedefValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "typedefValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::containerTypedef&&> typedefValue() && {
    return {std::move(value_.typedefValue), fbthrift_type_, folly::to_underlying(Type::typedefValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "stringRef" } */
  template <typename..., typename T = ::std::unique_ptr<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringRef_ref() const& {
    return {value_.stringRef, fbthrift_type_, folly::to_underlying(Type::stringRef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringRef" } */
  template <typename..., typename T = ::std::unique_ptr<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringRef_ref() & {
    return {value_.stringRef, fbthrift_type_, folly::to_underlying(Type::stringRef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringRef" } */
  template <typename..., typename T = ::std::unique_ptr<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringRef_ref() && {
    return {std::move(value_.stringRef), fbthrift_type_, folly::to_underlying(Type::stringRef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringRef" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::unique_ptr<::std::string>&> stringRef() const& {
    return {value_.stringRef, fbthrift_type_, folly::to_underlying(Type::stringRef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringRef" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::unique_ptr<::std::string>&> stringRef() & {
    return {value_.stringRef, fbthrift_type_, folly::to_underlying(Type::stringRef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringRef" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::unique_ptr<::std::string>&&> stringRef() && {
    return {std::move(value_.stringRef), fbthrift_type_, folly::to_underlying(Type::stringRef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(fbthrift_type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> fbthrift_type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ComplexUnion>;
  friend void swap(ComplexUnion& a, ComplexUnion& b);
};

template <class Protocol_>
unsigned long ComplexUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "ListUnion", "kind": "union" } */
class ListUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 2;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,2,3};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::intListValue,
    ::apache::thrift::ident::stringListValue
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::list<::apache::thrift::type::i64_t>,
    ::apache::thrift::type::list<::apache::thrift::type::string_t>
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = ListUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:
  enum class Type : int {
    __EMPTY__ = 0,
    intListValue = 2,
    stringListValue = 3,
  } ;

  ListUnion()
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {}

  ListUnion(ListUnion&& rhs) noexcept
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::intListValue:
      {
        set_intListValue(std::move(rhs.value_.intListValue));
        break;
      }
      case Type::stringListValue:
      {
        set_stringListValue(std::move(rhs.value_.stringListValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  ListUnion(const ListUnion& rhs);

  ListUnion& operator=(ListUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::intListValue:
      {
        set_intListValue(std::move(rhs.value_.intListValue));
        break;
      }
      case Type::stringListValue:
      {
        set_stringListValue(std::move(rhs.value_.stringListValue));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  ListUnion& operator=(const ListUnion& rhs);

  ~ListUnion();

  union storage_type {
    ::std::vector<::std::int64_t> intListValue;
    ::std::vector<::std::string> stringListValue;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const ListUnion&) const;
  bool operator<(const ListUnion&) const;

  /** Glean { "field": "intListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::int64_t>& set_intListValue(::std::vector<::std::int64_t> const &t) {
    using T0 = ::std::vector<::std::int64_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::intListValue);
    ::new (std::addressof(value_.intListValue)) T(t);
    return value_.intListValue;
  }

  /** Glean { "field": "intListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::int64_t>& set_intListValue(::std::vector<::std::int64_t>&& t) {
    using T0 = ::std::vector<::std::int64_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::intListValue);
    ::new (std::addressof(value_.intListValue)) T(std::move(t));
    return value_.intListValue;
  }

  /** Glean { "field": "intListValue" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::int64_t>, T...>> ::std::vector<::std::int64_t>& set_intListValue(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::intListValue);
    ::new (std::addressof(value_.intListValue)) ::std::vector<::std::int64_t>(std::forward<T>(t)...);
    return value_.intListValue;
  }

  /** Glean { "field": "stringListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::string>& set_stringListValue(::std::vector<::std::string> const &t) {
    using T0 = ::std::vector<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringListValue);
    ::new (std::addressof(value_.stringListValue)) T(t);
    return value_.stringListValue;
  }

  /** Glean { "field": "stringListValue" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::string>& set_stringListValue(::std::vector<::std::string>&& t) {
    using T0 = ::std::vector<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringListValue);
    ::new (std::addressof(value_.stringListValue)) T(std::move(t));
    return value_.stringListValue;
  }

  /** Glean { "field": "stringListValue" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::string>, T...>> ::std::vector<::std::string>& set_stringListValue(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringListValue);
    ::new (std::addressof(value_.stringListValue)) ::std::vector<::std::string>(std::forward<T>(t)...);
    return value_.stringListValue;
  }

  /** Glean { "field": "intListValue" } */
  ::std::vector<::std::int64_t> const& get_intListValue() const {
    if (getType() != Type::intListValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.intListValue;
  }

  /** Glean { "field": "stringListValue" } */
  ::std::vector<::std::string> const& get_stringListValue() const {
    if (getType() != Type::stringListValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringListValue;
  }

  ::std::vector<::std::int64_t>& mutable_intListValue() {
    assert(getType() == Type::intListValue);
    return value_.intListValue;
  }

  ::std::vector<::std::string>& mutable_stringListValue() {
    assert(getType() == Type::stringListValue);
    return value_.stringListValue;
  }

  template <typename..., typename T = ::std::vector<::std::int64_t>>
  T move_intListValue() {
    assert(getType() == Type::intListValue);
    return std::move(value_.intListValue);
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  T move_stringListValue() {
    assert(getType() == Type::stringListValue);
    return std::move(value_.stringListValue);
  }

  /** Glean { "field": "intListValue" } */
  template <typename..., typename T = ::std::vector<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intListValue_ref() const& {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  template <typename..., typename T = ::std::vector<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intListValue_ref() & {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  template <typename..., typename T = ::std::vector<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intListValue_ref() && {
    return {std::move(value_.intListValue), fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::vector<::std::int64_t>&> intListValue() const& {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::int64_t>&> intListValue() & {
    return {value_.intListValue, fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "intListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::int64_t>&&> intListValue() && {
    return {std::move(value_.intListValue), fbthrift_type_, folly::to_underlying(Type::intListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "stringListValue" } */
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringListValue_ref() const& {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringListValue_ref() & {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringListValue_ref() && {
    return {std::move(value_.stringListValue), fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::vector<::std::string>&> stringListValue() const& {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::string>&> stringListValue() & {
    return {value_.stringListValue, fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringListValue" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::vector<::std::string>&&> stringListValue() && {
    return {std::move(value_.stringListValue), fbthrift_type_, folly::to_underlying(Type::stringListValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(fbthrift_type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> fbthrift_type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ListUnion>;
  friend void swap(ListUnion& a, ListUnion& b);
};

template <class Protocol_>
unsigned long ListUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "DataUnion", "kind": "union" } */
class DataUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 2;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1,2};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::binaryData,
    ::apache::thrift::ident::stringData
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::binary_t,
    ::apache::thrift::type::string_t
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = DataUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:
  enum class Type : int {
    __EMPTY__ = 0,
    binaryData = 1,
    stringData = 2,
  } ;

  DataUnion()
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {}

  DataUnion(DataUnion&& rhs) noexcept
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::binaryData:
      {
        set_binaryData(std::move(rhs.value_.binaryData));
        break;
      }
      case Type::stringData:
      {
        set_stringData(std::move(rhs.value_.stringData));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  DataUnion(const DataUnion& rhs);

  DataUnion& operator=(DataUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::binaryData:
      {
        set_binaryData(std::move(rhs.value_.binaryData));
        break;
      }
      case Type::stringData:
      {
        set_stringData(std::move(rhs.value_.stringData));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  DataUnion& operator=(const DataUnion& rhs);

  ~DataUnion();

  union storage_type {
    ::std::string binaryData;
    ::std::string stringData;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const DataUnion&) const;
  bool operator<(const DataUnion&) const;

  /** Glean { "field": "binaryData" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_binaryData(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::binaryData);
    ::new (std::addressof(value_.binaryData)) T(t);
    return value_.binaryData;
  }

  /** Glean { "field": "binaryData" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_binaryData(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::binaryData);
    ::new (std::addressof(value_.binaryData)) T(std::move(t));
    return value_.binaryData;
  }

  /** Glean { "field": "binaryData" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_binaryData(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::binaryData);
    ::new (std::addressof(value_.binaryData)) ::std::string(std::forward<T>(t)...);
    return value_.binaryData;
  }


  /** Glean { "field": "stringData" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringData(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringData);
    ::new (std::addressof(value_.stringData)) T(t);
    return value_.stringData;
  }

  /** Glean { "field": "stringData" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringData(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringData);
    ::new (std::addressof(value_.stringData)) T(std::move(t));
    return value_.stringData;
  }

  /** Glean { "field": "stringData" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringData(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::stringData);
    ::new (std::addressof(value_.stringData)) ::std::string(std::forward<T>(t)...);
    return value_.stringData;
  }


  /** Glean { "field": "binaryData" } */
  ::std::string const& get_binaryData() const {
    if (getType() != Type::binaryData) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.binaryData;
  }

  /** Glean { "field": "stringData" } */
  ::std::string const& get_stringData() const {
    if (getType() != Type::stringData) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringData;
  }

  ::std::string& mutable_binaryData() {
    assert(getType() == Type::binaryData);
    return value_.binaryData;
  }

  ::std::string& mutable_stringData() {
    assert(getType() == Type::stringData);
    return value_.stringData;
  }

  template <typename..., typename T = ::std::string>
  T move_binaryData() {
    assert(getType() == Type::binaryData);
    return std::move(value_.binaryData);
  }

  template <typename..., typename T = ::std::string>
  T move_stringData() {
    assert(getType() == Type::stringData);
    return std::move(value_.stringData);
  }

  /** Glean { "field": "binaryData" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> binaryData_ref() const& {
    return {value_.binaryData, fbthrift_type_, folly::to_underlying(Type::binaryData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "binaryData" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> binaryData_ref() & {
    return {value_.binaryData, fbthrift_type_, folly::to_underlying(Type::binaryData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "binaryData" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> binaryData_ref() && {
    return {std::move(value_.binaryData), fbthrift_type_, folly::to_underlying(Type::binaryData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "binaryData" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::string&> binaryData() const& {
    return {value_.binaryData, fbthrift_type_, folly::to_underlying(Type::binaryData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "binaryData" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&> binaryData() & {
    return {value_.binaryData, fbthrift_type_, folly::to_underlying(Type::binaryData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "binaryData" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&&> binaryData() && {
    return {std::move(value_.binaryData), fbthrift_type_, folly::to_underlying(Type::binaryData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "stringData" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringData_ref() const& {
    return {value_.stringData, fbthrift_type_, folly::to_underlying(Type::stringData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringData" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringData_ref() & {
    return {value_.stringData, fbthrift_type_, folly::to_underlying(Type::stringData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringData" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringData_ref() && {
    return {std::move(value_.stringData), fbthrift_type_, folly::to_underlying(Type::stringData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringData" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::string&> stringData() const& {
    return {value_.stringData, fbthrift_type_, folly::to_underlying(Type::stringData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringData" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&> stringData() & {
    return {value_.stringData, fbthrift_type_, folly::to_underlying(Type::stringData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "stringData" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&&> stringData() && {
    return {std::move(value_.stringData), fbthrift_type_, folly::to_underlying(Type::stringData), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(fbthrift_type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> fbthrift_type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<DataUnion>;
  friend void swap(DataUnion& a, DataUnion& b);
};

template <class Protocol_>
unsigned long DataUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "Val", "kind": "struct" } */
class Val final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 3;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1,2,9};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::strVal,
    ::apache::thrift::ident::intVal,
    ::apache::thrift::ident::typedefValue
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::i32_t,
    ::apache::thrift::type::map<::apache::thrift::type::i16_t, ::apache::thrift::type::string_t>
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = Val;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:

  Val();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Val(apache::thrift::FragileConstructor, ::std::string strVal__arg, ::std::int32_t intVal__arg, ::cpp2::containerTypedef typedefValue__arg);

  Val(Val&&) noexcept;

  Val(const Val& src);


  Val& operator=(Val&&) noexcept;
  Val& operator=(const Val& src);

  ~Val();

 private:
  ::std::string __fbthrift_field_strVal;
 private:
  ::std::int32_t __fbthrift_field_intVal;
 private:
  ::cpp2::containerTypedef __fbthrift_field_typedefValue;
 private:
  apache::thrift::detail::isset_bitset<3, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const Val&) const;
  bool operator<(const Val&) const;

  /** Glean { "field": "strVal" } */
  template <typename..., typename fbthrift_T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> strVal_ref() const& {
    return {this->__fbthrift_field_strVal, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "strVal" } */
  template <typename..., typename fbthrift_T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> strVal_ref() & {
    return {this->__fbthrift_field_strVal, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "strVal" } */
  template <typename..., typename fbthrift_T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> strVal_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_strVal), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "strVal" } */
  template <typename..., typename fbthrift_T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> strVal() const& {
    return {this->__fbthrift_field_strVal, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "strVal" } */
  template <typename..., typename fbthrift_T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> strVal() & {
    return {this->__fbthrift_field_strVal, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "strVal" } */
  template <typename..., typename fbthrift_T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> strVal() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_strVal), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "intVal" } */
  template <typename..., typename fbthrift_T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> intVal_ref() const& {
    return {this->__fbthrift_field_intVal, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "intVal" } */
  template <typename..., typename fbthrift_T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> intVal_ref() & {
    return {this->__fbthrift_field_intVal, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "intVal" } */
  template <typename..., typename fbthrift_T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> intVal_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_intVal), __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "intVal" } */
  template <typename..., typename fbthrift_T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> intVal() const& {
    return {this->__fbthrift_field_intVal, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "intVal" } */
  template <typename..., typename fbthrift_T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> intVal() & {
    return {this->__fbthrift_field_intVal, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "intVal" } */
  template <typename..., typename fbthrift_T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> intVal() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_intVal), __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename fbthrift_T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> typedefValue_ref() const& {
    return {this->__fbthrift_field_typedefValue, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename fbthrift_T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> typedefValue_ref() & {
    return {this->__fbthrift_field_typedefValue, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename fbthrift_T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> typedefValue_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_typedefValue), __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename fbthrift_T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> typedefValue() const& {
    return {this->__fbthrift_field_typedefValue, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename fbthrift_T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> typedefValue() & {
    return {this->__fbthrift_field_typedefValue, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "typedefValue" } */
  template <typename..., typename fbthrift_T = ::cpp2::containerTypedef>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> typedefValue() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_typedefValue), __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "strVal" } */
  [[deprecated("Use `FOO.strVal().value()` instead of `FOO.get_strVal()`")]]
  const ::std::string& get_strVal() const& {
    return __fbthrift_field_strVal;
  }

  /** Glean { "field": "strVal" } */
  [[deprecated("Use `FOO.strVal().value()` instead of `FOO.get_strVal()`")]]
  ::std::string get_strVal() && {
    return static_cast<::std::string&&>(__fbthrift_field_strVal);
  }

  /** Glean { "field": "strVal" } */
  template <typename T_Val_strVal_struct_setter = ::std::string>
  [[deprecated("Use `FOO.strVal() = BAR` instead of `FOO.set_strVal(BAR)`")]]
  ::std::string& set_strVal(T_Val_strVal_struct_setter&& strVal_) {
    strVal_ref() = std::forward<T_Val_strVal_struct_setter>(strVal_);
    return __fbthrift_field_strVal;
  }

  /** Glean { "field": "intVal" } */
  [[deprecated("Use `FOO.intVal().value()` instead of `FOO.get_intVal()`")]]
  ::std::int32_t get_intVal() const;

  /** Glean { "field": "intVal" } */
  [[deprecated("Use `FOO.intVal() = BAR` instead of `FOO.set_intVal(BAR)`")]]
  ::std::int32_t& set_intVal(::std::int32_t intVal_);

  /** Glean { "field": "typedefValue" } */
  [[deprecated("Use `FOO.typedefValue().value()` instead of `FOO.get_typedefValue()`")]]
  const ::cpp2::containerTypedef& get_typedefValue() const&;

  /** Glean { "field": "typedefValue" } */
  [[deprecated("Use `FOO.typedefValue().value()` instead of `FOO.get_typedefValue()`")]]
  ::cpp2::containerTypedef get_typedefValue() &&;

  /** Glean { "field": "typedefValue" } */
  template <typename T_Val_typedefValue_struct_setter = ::cpp2::containerTypedef>
  [[deprecated("Use `FOO.typedefValue() = BAR` instead of `FOO.set_typedefValue(BAR)`")]]
  ::cpp2::containerTypedef& set_typedefValue(T_Val_typedefValue_struct_setter&& typedefValue_) {
    typedefValue_ref() = std::forward<T_Val_typedefValue_struct_setter>(typedefValue_);
    return __fbthrift_field_typedefValue;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<Val>;
  friend void swap(Val& a, Val& b);
};

template <class Protocol_>
unsigned long Val::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "ValUnion", "kind": "union" } */
class ValUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 2;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1,2};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::v1,
    ::apache::thrift::ident::v2
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::struct_t<::cpp2::Val>,
    ::apache::thrift::type::struct_t<::cpp2::Val>
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = ValUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:
  enum class Type : int {
    __EMPTY__ = 0,
    v1 = 1,
    v2 = 2,
  } ;

  ValUnion()
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {}

  ValUnion(ValUnion&& rhs) noexcept
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::v1:
      {
        set_v1(std::move(rhs.value_.v1));
        break;
      }
      case Type::v2:
      {
        set_v2(std::move(rhs.value_.v2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  ValUnion(const ValUnion& rhs);

  ValUnion& operator=(ValUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::v1:
      {
        set_v1(std::move(rhs.value_.v1));
        break;
      }
      case Type::v2:
      {
        set_v2(std::move(rhs.value_.v2));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  ValUnion& operator=(const ValUnion& rhs);

  ~ValUnion();

  union storage_type {
    ::cpp2::Val v1;
    ::cpp2::Val v2;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const ValUnion&) const;
  bool operator<(const ValUnion&) const;

  /** Glean { "field": "v1" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::cpp2::Val& set_v1(::cpp2::Val const &t) {
    using T0 = ::cpp2::Val;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::v1);
    ::new (std::addressof(value_.v1)) T(t);
    return value_.v1;
  }

  /** Glean { "field": "v1" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::cpp2::Val& set_v1(::cpp2::Val&& t) {
    using T0 = ::cpp2::Val;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::v1);
    ::new (std::addressof(value_.v1)) T(std::move(t));
    return value_.v1;
  }

  /** Glean { "field": "v1" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::Val, T...>> ::cpp2::Val& set_v1(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::v1);
    ::new (std::addressof(value_.v1)) ::cpp2::Val(std::forward<T>(t)...);
    return value_.v1;
  }

  /** Glean { "field": "v2" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::cpp2::Val& set_v2(::cpp2::Val const &t) {
    using T0 = ::cpp2::Val;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::v2);
    ::new (std::addressof(value_.v2)) T(t);
    return value_.v2;
  }

  /** Glean { "field": "v2" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::cpp2::Val& set_v2(::cpp2::Val&& t) {
    using T0 = ::cpp2::Val;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::v2);
    ::new (std::addressof(value_.v2)) T(std::move(t));
    return value_.v2;
  }

  /** Glean { "field": "v2" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::Val, T...>> ::cpp2::Val& set_v2(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::v2);
    ::new (std::addressof(value_.v2)) ::cpp2::Val(std::forward<T>(t)...);
    return value_.v2;
  }

  /** Glean { "field": "v1" } */
  ::cpp2::Val const& get_v1() const {
    if (getType() != Type::v1) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.v1;
  }

  /** Glean { "field": "v2" } */
  ::cpp2::Val const& get_v2() const {
    if (getType() != Type::v2) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.v2;
  }

  ::cpp2::Val& mutable_v1() {
    assert(getType() == Type::v1);
    return value_.v1;
  }

  ::cpp2::Val& mutable_v2() {
    assert(getType() == Type::v2);
    return value_.v2;
  }

  template <typename..., typename T = ::cpp2::Val>
  T move_v1() {
    assert(getType() == Type::v1);
    return std::move(value_.v1);
  }

  template <typename..., typename T = ::cpp2::Val>
  T move_v2() {
    assert(getType() == Type::v2);
    return std::move(value_.v2);
  }

  /** Glean { "field": "v1" } */
  template <typename..., typename T = ::cpp2::Val>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> v1_ref() const& {
    return {value_.v1, fbthrift_type_, folly::to_underlying(Type::v1), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v1" } */
  template <typename..., typename T = ::cpp2::Val>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> v1_ref() & {
    return {value_.v1, fbthrift_type_, folly::to_underlying(Type::v1), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v1" } */
  template <typename..., typename T = ::cpp2::Val>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> v1_ref() && {
    return {std::move(value_.v1), fbthrift_type_, folly::to_underlying(Type::v1), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v1" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::cpp2::Val&> v1() const& {
    return {value_.v1, fbthrift_type_, folly::to_underlying(Type::v1), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v1" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::Val&> v1() & {
    return {value_.v1, fbthrift_type_, folly::to_underlying(Type::v1), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v1" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::Val&&> v1() && {
    return {std::move(value_.v1), fbthrift_type_, folly::to_underlying(Type::v1), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "v2" } */
  template <typename..., typename T = ::cpp2::Val>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> v2_ref() const& {
    return {value_.v2, fbthrift_type_, folly::to_underlying(Type::v2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v2" } */
  template <typename..., typename T = ::cpp2::Val>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> v2_ref() & {
    return {value_.v2, fbthrift_type_, folly::to_underlying(Type::v2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v2" } */
  template <typename..., typename T = ::cpp2::Val>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> v2_ref() && {
    return {std::move(value_.v2), fbthrift_type_, folly::to_underlying(Type::v2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v2" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::cpp2::Val&> v2() const& {
    return {value_.v2, fbthrift_type_, folly::to_underlying(Type::v2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v2" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::Val&> v2() & {
    return {value_.v2, fbthrift_type_, folly::to_underlying(Type::v2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "v2" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::Val&&> v2() && {
    return {std::move(value_.v2), fbthrift_type_, folly::to_underlying(Type::v2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(fbthrift_type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> fbthrift_type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ValUnion>;
  friend void swap(ValUnion& a, ValUnion& b);
};

template <class Protocol_>
unsigned long ValUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "VirtualComplexUnion", "kind": "union" } */
class VirtualComplexUnion  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 2;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1,2};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::thingOne,
    ::apache::thrift::ident::thingTwo
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = VirtualComplexUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:
  enum class Type : int {
    __EMPTY__ = 0,
    thingOne = 1,
    thingTwo = 2,
  } ;

  VirtualComplexUnion()
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {}

  VirtualComplexUnion(VirtualComplexUnion&& rhs) noexcept
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::thingOne:
      {
        set_thingOne(std::move(rhs.value_.thingOne));
        break;
      }
      case Type::thingTwo:
      {
        set_thingTwo(std::move(rhs.value_.thingTwo));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  VirtualComplexUnion(const VirtualComplexUnion& rhs);

  VirtualComplexUnion& operator=(VirtualComplexUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::thingOne:
      {
        set_thingOne(std::move(rhs.value_.thingOne));
        break;
      }
      case Type::thingTwo:
      {
        set_thingTwo(std::move(rhs.value_.thingTwo));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  VirtualComplexUnion& operator=(const VirtualComplexUnion& rhs);

  virtual ~VirtualComplexUnion();

  union storage_type {
    ::std::string thingOne;
    ::std::string thingTwo;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const VirtualComplexUnion&) const;
  bool operator<(const VirtualComplexUnion&) const;

  /** Glean { "field": "thingOne" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_thingOne(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::thingOne);
    ::new (std::addressof(value_.thingOne)) T(t);
    return value_.thingOne;
  }

  /** Glean { "field": "thingOne" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_thingOne(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::thingOne);
    ::new (std::addressof(value_.thingOne)) T(std::move(t));
    return value_.thingOne;
  }

  /** Glean { "field": "thingOne" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_thingOne(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::thingOne);
    ::new (std::addressof(value_.thingOne)) ::std::string(std::forward<T>(t)...);
    return value_.thingOne;
  }


  /** Glean { "field": "thingTwo" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_thingTwo(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::thingTwo);
    ::new (std::addressof(value_.thingTwo)) T(t);
    return value_.thingTwo;
  }

  /** Glean { "field": "thingTwo" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_thingTwo(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::thingTwo);
    ::new (std::addressof(value_.thingTwo)) T(std::move(t));
    return value_.thingTwo;
  }

  /** Glean { "field": "thingTwo" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_thingTwo(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::thingTwo);
    ::new (std::addressof(value_.thingTwo)) ::std::string(std::forward<T>(t)...);
    return value_.thingTwo;
  }


  /** Glean { "field": "thingOne" } */
  ::std::string const& get_thingOne() const {
    if (getType() != Type::thingOne) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.thingOne;
  }

  /** Glean { "field": "thingTwo" } */
  ::std::string const& get_thingTwo() const {
    if (getType() != Type::thingTwo) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.thingTwo;
  }

  ::std::string& mutable_thingOne() {
    assert(getType() == Type::thingOne);
    return value_.thingOne;
  }

  ::std::string& mutable_thingTwo() {
    assert(getType() == Type::thingTwo);
    return value_.thingTwo;
  }

  template <typename..., typename T = ::std::string>
  T move_thingOne() {
    assert(getType() == Type::thingOne);
    return std::move(value_.thingOne);
  }

  template <typename..., typename T = ::std::string>
  T move_thingTwo() {
    assert(getType() == Type::thingTwo);
    return std::move(value_.thingTwo);
  }

  /** Glean { "field": "thingOne" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> thingOne_ref() const& {
    return {value_.thingOne, fbthrift_type_, folly::to_underlying(Type::thingOne), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingOne" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> thingOne_ref() & {
    return {value_.thingOne, fbthrift_type_, folly::to_underlying(Type::thingOne), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingOne" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> thingOne_ref() && {
    return {std::move(value_.thingOne), fbthrift_type_, folly::to_underlying(Type::thingOne), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingOne" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::string&> thingOne() const& {
    return {value_.thingOne, fbthrift_type_, folly::to_underlying(Type::thingOne), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingOne" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&> thingOne() & {
    return {value_.thingOne, fbthrift_type_, folly::to_underlying(Type::thingOne), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingOne" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&&> thingOne() && {
    return {std::move(value_.thingOne), fbthrift_type_, folly::to_underlying(Type::thingOne), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  /** Glean { "field": "thingTwo" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> thingTwo_ref() const& {
    return {value_.thingTwo, fbthrift_type_, folly::to_underlying(Type::thingTwo), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingTwo" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> thingTwo_ref() & {
    return {value_.thingTwo, fbthrift_type_, folly::to_underlying(Type::thingTwo), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingTwo" } */
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> thingTwo_ref() && {
    return {std::move(value_.thingTwo), fbthrift_type_, folly::to_underlying(Type::thingTwo), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingTwo" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::std::string&> thingTwo() const& {
    return {value_.thingTwo, fbthrift_type_, folly::to_underlying(Type::thingTwo), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingTwo" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&> thingTwo() & {
    return {value_.thingTwo, fbthrift_type_, folly::to_underlying(Type::thingTwo), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "thingTwo" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::std::string&&> thingTwo() && {
    return {std::move(value_.thingTwo), fbthrift_type_, folly::to_underlying(Type::thingTwo), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(fbthrift_type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> fbthrift_type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<VirtualComplexUnion>;
  friend void swap(VirtualComplexUnion& a, VirtualComplexUnion& b);
};

template <class Protocol_>
unsigned long VirtualComplexUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "NonCopyableStruct", "kind": "struct" } */
class NonCopyableStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 1;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::num
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = NonCopyableStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:

  NonCopyableStruct() :
      __fbthrift_field_num() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NonCopyableStruct(apache::thrift::FragileConstructor, ::std::int64_t num__arg);

  NonCopyableStruct(NonCopyableStruct&&) = default;


  NonCopyableStruct& operator=(NonCopyableStruct&&) = default;
 private:
  ::std::int64_t __fbthrift_field_num;
 private:
  apache::thrift::detail::isset_bitset<1, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const NonCopyableStruct&) const;
  bool operator<(const NonCopyableStruct&) const;

  /** Glean { "field": "num" } */
  template <typename..., typename fbthrift_T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> num_ref() const& {
    return {this->__fbthrift_field_num, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "num" } */
  template <typename..., typename fbthrift_T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> num_ref() & {
    return {this->__fbthrift_field_num, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "num" } */
  template <typename..., typename fbthrift_T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> num_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_num), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "num" } */
  template <typename..., typename fbthrift_T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> num() const& {
    return {this->__fbthrift_field_num, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "num" } */
  template <typename..., typename fbthrift_T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> num() & {
    return {this->__fbthrift_field_num, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "num" } */
  template <typename..., typename fbthrift_T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> num() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_num), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "num" } */
  [[deprecated("Use `FOO.num().value()` instead of `FOO.get_num()`")]]
  ::std::int64_t get_num() const;

  /** Glean { "field": "num" } */
  [[deprecated("Use `FOO.num() = BAR` instead of `FOO.set_num(BAR)`")]]
  ::std::int64_t& set_num(::std::int64_t num_);

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<NonCopyableStruct>;
  friend void swap(NonCopyableStruct& a, NonCopyableStruct& b);
};

template <class Protocol_>
unsigned long NonCopyableStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/complex-union/src/module.thrift", "name": "NonCopyableUnion", "kind": "union" } */
class NonCopyableUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 1;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::s
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::struct_t<::cpp2::NonCopyableStruct>
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = NonCopyableUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:
  enum class Type : int {
    __EMPTY__ = 0,
    s = 1,
  } ;

  NonCopyableUnion()
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {}

  NonCopyableUnion(NonCopyableUnion&& rhs) noexcept
      : fbthrift_type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  NonCopyableUnion& operator=(NonCopyableUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  ~NonCopyableUnion();

  union storage_type {
    ::cpp2::NonCopyableStruct s;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const NonCopyableUnion&) const;
  bool operator<(const NonCopyableUnion&) const;


  /** Glean { "field": "s" } */
  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::cpp2::NonCopyableStruct& set_s(::cpp2::NonCopyableStruct&& t) {
    using T0 = ::cpp2::NonCopyableStruct;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::s);
    ::new (std::addressof(value_.s)) T(std::move(t));
    return value_.s;
  }

  /** Glean { "field": "s" } */
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::NonCopyableStruct, T...>> ::cpp2::NonCopyableStruct& set_s(T&&... t) {
    __fbthrift_clear();
    fbthrift_type_ = folly::to_underlying(Type::s);
    ::new (std::addressof(value_.s)) ::cpp2::NonCopyableStruct(std::forward<T>(t)...);
    return value_.s;
  }

  /** Glean { "field": "s" } */
  ::cpp2::NonCopyableStruct const& get_s() const {
    if (getType() != Type::s) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.s;
  }

  ::cpp2::NonCopyableStruct& mutable_s() {
    assert(getType() == Type::s);
    return value_.s;
  }

  template <typename..., typename T = ::cpp2::NonCopyableStruct>
  T move_s() {
    assert(getType() == Type::s);
    return std::move(value_.s);
  }

  /** Glean { "field": "s" } */
  template <typename..., typename T = ::cpp2::NonCopyableStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> s_ref() const& {
    return {value_.s, fbthrift_type_, folly::to_underlying(Type::s), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "s" } */
  template <typename..., typename T = ::cpp2::NonCopyableStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> s_ref() & {
    return {value_.s, fbthrift_type_, folly::to_underlying(Type::s), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "s" } */
  template <typename..., typename T = ::cpp2::NonCopyableStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> s_ref() && {
    return {std::move(value_.s), fbthrift_type_, folly::to_underlying(Type::s), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "s" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<const ::cpp2::NonCopyableStruct&> s() const& {
    return {value_.s, fbthrift_type_, folly::to_underlying(Type::s), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "s" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::NonCopyableStruct&> s() & {
    return {value_.s, fbthrift_type_, folly::to_underlying(Type::s), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  /** Glean { "field": "s" } */
  FOLLY_ERASE ::apache::thrift::union_field_ref<::cpp2::NonCopyableStruct&&> s() && {
    return {std::move(value_.s), fbthrift_type_, folly::to_underlying(Type::s), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(fbthrift_type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> fbthrift_type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<NonCopyableUnion>;
  friend void swap(NonCopyableUnion& a, NonCopyableUnion& b);
};

template <class Protocol_>
unsigned long NonCopyableUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


} // namespace cpp2

namespace apache::thrift {

template <> struct TEnumDataStorage<::cpp2::ComplexUnion::Type>;

template <> struct TEnumTraits<::cpp2::ComplexUnion::Type> {
  using type = ::cpp2::ComplexUnion::Type;

  static constexpr std::size_t const size = 6;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }

  static constexpr type min() { return type::intValue; }
  static constexpr type max() { return type::stringRef; }
};

template <> struct TEnumDataStorage<::cpp2::ListUnion::Type>;

template <> struct TEnumTraits<::cpp2::ListUnion::Type> {
  using type = ::cpp2::ListUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }

  static constexpr type min() { return type::intListValue; }
  static constexpr type max() { return type::stringListValue; }
};

template <> struct TEnumDataStorage<::cpp2::DataUnion::Type>;

template <> struct TEnumTraits<::cpp2::DataUnion::Type> {
  using type = ::cpp2::DataUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }

  static constexpr type min() { return type::binaryData; }
  static constexpr type max() { return type::stringData; }
};

template <> struct TEnumDataStorage<::cpp2::ValUnion::Type>;

template <> struct TEnumTraits<::cpp2::ValUnion::Type> {
  using type = ::cpp2::ValUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }

  static constexpr type min() { return type::v1; }
  static constexpr type max() { return type::v2; }
};

template <> struct TEnumDataStorage<::cpp2::VirtualComplexUnion::Type>;

template <> struct TEnumTraits<::cpp2::VirtualComplexUnion::Type> {
  using type = ::cpp2::VirtualComplexUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }

  static constexpr type min() { return type::thingOne; }
  static constexpr type max() { return type::thingTwo; }
};

template <> struct TEnumDataStorage<::cpp2::NonCopyableUnion::Type>;

template <> struct TEnumTraits<::cpp2::NonCopyableUnion::Type> {
  using type = ::cpp2::NonCopyableUnion::Type;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }

  static constexpr type min() { return type::s; }
  static constexpr type max() { return type::s; }
};
} // namespace apache::thrift

namespace apache::thrift::detail {
template <> struct TSchemaAssociation<::cpp2::ComplexUnion, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\x1d\x19\xd1\x5b\x5d\xfb\xfc\xab\xff\x76\x2d\xa5\x0e\x6e\xfe\x36", 16};
};
template <> struct TSchemaAssociation<::cpp2::ListUnion, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\xee\xb9\x54\xd3\x0e\x71\xce\x4f\xc7\x44\x9e\xe1\xfe\xf0\xa2\xa4", 16};
};
template <> struct TSchemaAssociation<::cpp2::DataUnion, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\x43\x17\x35\x12\xe2\xa9\xb9\x04\xb3\x7c\x07\x3c\x3c\xbf\x3f\x89", 16};
};
template <> struct TSchemaAssociation<::cpp2::Val, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\xd3\xe0\x5d\x1f\x81\x32\x5c\x95\xe5\xbb\x22\x29\xa2\xa8\x2b\x91", 16};
};
template <> struct TSchemaAssociation<::cpp2::ValUnion, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\xf0\x64\x4d\x29\xad\x2c\x0c\x76\xad\xc7\x87\x6f\x2b\x50\xe2\x2d", 16};
};
template <> struct TSchemaAssociation<::cpp2::VirtualComplexUnion, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\xa7\xed\xb8\x33\x38\xed\x2e\xf8\x9d\xdc\x65\x2a\x10\xa7\xee\x26", 16};
};
template <> struct TSchemaAssociation<::cpp2::NonCopyableStruct, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\x59\x8a\x53\x0f\x6c\x5a\x23\x7d\x14\x4f\x17\x0d\xf2\x75\x68\x3c", 16};
};
template <> struct TSchemaAssociation<::cpp2::NonCopyableUnion, false> {
  static ::folly::Range<const ::std::string_view*>(*bundle)();
  static constexpr int64_t programId = -7776979624902092624;
  static constexpr ::std::string_view definitionKey = {"\xd4\x4e\x11\x18\xab\xcc\xac\xf0\x41\x47\x82\xd2\x6f\x98\xcb\x64", 16};
};
} // namespace apache::thrift::detail
