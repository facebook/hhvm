// @generated by "php idl.php inc {input.idl.php} {output.inc}"

#if EXT_TYPE == 0
"memcache_connect", T(Object), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-connect.php )\n *\n * Memcache::connect() establishes a connection to the memcached server.\n * The connection, which was opened using Memcache::connect() will be\n * automatically closed at the end of script execution. Also you can close\n * it with Memcache::close(). Also you can use memcache_connect() function.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     connections. This parameter may also specify other\n *                     transports like unix:///path/to/memcached.sock to\n *                     use UNIX domain sockets, in this case port must also\n *                     be set to 0.\n * @port       int     Point to the port where memcached is listening for\n *                     connections. Set this parameter to 0 when using UNIX\n *                     domain sockets.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the daemon. Think twice before changing the\n *                     default value of 1 second - you can lose all the\n *                     advantages of caching if your connection is too\n *                     slow.\n * @timeoutms  int\n *\n * @return     object  Returns TRUE on success or FALSE on failure.\n */", 
"memcache_pconnect", T(Object), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-pconnect.php )\n *\n * Memcache::pconnect() is similar to Memcache::connect() with the\n * difference, that the connection it establishes is persistent. This\n * connection is not closed after the end of script execution and by\n * Memcache::close() function. Also you can use memcache_pconnect()\n * function.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     connections. This parameter may also specify other\n *                     transports like unix:///path/to/memcached.sock to\n *                     use UNIX domain sockets, in this case port must also\n *                     be set to 0.\n * @port       int     Point to the port where memcached is listening for\n *                     connections. Set this parameter to 0 when using UNIX\n *                     domain sockets.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the daemon. Think twice before changing the\n *                     default value of 1 second - you can lose all the\n *                     advantages of caching if your connection is too\n *                     slow.\n * @timeoutms  int\n *\n * @return     object  Returns TRUE on success or FALSE on failure.\n */", 
"memcache_add", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-add.php )\n *\n * Memcache::add() stores variable var with key only if such key doesn't\n * exist at the server yet. Also you can use memcache_add() function.\n *\n * @memcache   object  The key that will be associated with the item.\n * @key        string  The variable to store. Strings and integers are\n *                     stored as is, other types are stored serialized.\n * @var        mixed   Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses zlib).\n * @flag       int     Expiration time of the item. If it's equal to zero,\n *                     the item will never expire. You can also use Unix\n *                     timestamp or a number of seconds starting from\n *                     current time, but in the latter case the number of\n *                     seconds may not exceed 2592000 (30 days).\n * @expire     int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure. Returns\n *                     FALSE if such key already exist. For the rest\n *                     Memcache::add() behaves similarly to\n *                     Memcache::set().\n */", 
"memcache_set", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-set.php )\n *\n * Memcache::set() stores an item var with key on the memcached server.\n * Parameter expire is expiration time in seconds. If it's 0, the item\n * never expires (but memcached server doesn't guarantee this item to be\n * stored all the time, it could be deleted from the cache to make place\n * for other items). You can use MEMCACHE_COMPRESSED constant as flag value\n * if you want to use on-the-fly compression (uses zlib).\n *\n * Remember that resource variables (i.e. file and connection descriptors)\n * cannot be stored in the cache, because they cannot be adequately\n * represented in serialized state. Also you can use memcache_set()\n * function.\n *\n * @memcache   object  The key that will be associated with the item.\n * @key        string  The variable to store. Strings and integers are\n *                     stored as is, other types are stored serialized.\n * @var        mixed   Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses zlib).\n * @flag       int     Expiration time of the item. If it's equal to zero,\n *                     the item will never expire. You can also use Unix\n *                     timestamp or a number of seconds starting from\n *                     current time, but in the latter case the number of\n *                     seconds may not exceed 2592000 (30 days).\n * @expire     int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", 
"memcache_replace", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-replace.php )\n *\n * Memcache::replace() should be used to replace value of existing item\n * with key. In case if item with such key doesn't exists,\n * Memcache::replace() returns FALSE. For the rest Memcache::replace()\n * behaves similarly to Memcache::set(). Also you can use\n * memcache_replace() function.\n *\n * @memcache   object  The key that will be associated with the item.\n * @key        string  The variable to store. Strings and integers are\n *                     stored as is, other types are stored serialized.\n * @var        mixed   Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses zlib).\n * @flag       int     Expiration time of the item. If it's equal to zero,\n *                     the item will never expire. You can also use Unix\n *                     timestamp or a number of seconds starting from\n *                     current time, but in the latter case the number of\n *                     seconds may not exceed 2592000 (30 days).\n * @expire     int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", 
"memcache_get", T(Variant), S(0), "memcache", T(Object), NULL, NULL, S(0), "key", T(Variant), NULL, NULL, S(0), "flags", T(Variant), "N;", "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-get.php )\n *\n * Memcache::get() returns previously stored data if an item with such key\n * exists on the server at this moment.\n *\n * You can pass array of keys to Memcache::get() to get array of values.\n * The result array will contain only found key-value pairs.\n *\n * @memcache   object  The key or array of keys to fetch.\n * @key        mixed   If present, flags fetched along with the values will\n *                     be written to this parameter. These flags are the\n *                     same as the ones given to for example\n *                     Memcache::set(). The lowest byte of the int is\n *                     reserved for pecl/memcache internal usage (e.g. to\n *                     indicate compression and serialization status).\n * @flags      mixed\n *\n * @return     mixed   Returns the string associated with the key or FALSE\n *                     on failure or if such key was not found.\n */", 
"memcache_delete", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "key", T(String), NULL, NULL, S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-delete.php )\n *\n * Memcache::delete() deletes item with the key. If parameter timeout is\n * specified, the item will expire after timeout seconds. Also you can use\n * memcache_delete() function.\n *\n * @memcache   object  The key associated with the item to delete.\n * @key        string  Execution time of the item. If it's equal to zero,\n *                     the item will be deleted right away whereas if you\n *                     set it to 30, the item will be deleted in 30\n *                     seconds.\n * @expire     int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", 
"memcache_increment", T(Int64), S(0), "memcache", T(Object), NULL, NULL, S(0), "key", T(String), NULL, NULL, S(0), "offset", T(Int32), "i:1;", "1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-increment.php\n * )\n *\n * Memcache::increment() increments value of an item by the specified\n * value. If item specified by key was not numeric and cannot be converted\n * to a number, it will change its value to value. Memcache::increment()\n * does not create an item if it doesn't already exist.\n *\n * Do not use Memcache::increment() with items that have been stored\n * compressed because subsequent calls to Memcache::get() will fail. Also\n * you can use memcache_increment() function.\n *\n * @memcache   object  Key of the item to increment.\n * @key        string  Increment the item by value.\n * @offset     int\n *\n * @return     int     Returns new items value on success or FALSE on\n *                     failure.\n */", 
"memcache_decrement", T(Int64), S(0), "memcache", T(Object), NULL, NULL, S(0), "key", T(String), NULL, NULL, S(0), "offset", T(Int32), "i:1;", "1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-decrement.php\n * )\n *\n * Memcache::decrement() decrements value of the item by value. Similarly\n * to Memcache::increment(), current value of the item is being converted\n * to numerical and after that value is substracted.\n *\n * New item's value will not be less than zero.\n *\n * Do not use Memcache::decrement() with item, which was stored\n * compressed, because consequent call to Memcache::get() will fail.\n * Memcache::decrement() does not create an item if it didn't exist. Also\n * you can use memcache_decrement() function.\n *\n * @memcache   object  Key of the item do decrement.\n * @key        string  Decrement the item by value.\n * @offset     int\n *\n * @return     int     Returns item's new value on success or FALSE on\n *                     failure.\n */", 
"memcache_close", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-close.php )\n *\n * Memcache::close() closes connection to memcached server. This function\n * doesn't close persistent connections, which are closed only during\n * web-server shutdown/restart. Also you can use memcache_close() function.\n *\n * @memcache   object\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", 
"memcache_debug", T(Boolean), S(0), "onoff", T(Boolean), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-debug.php )\n *\n * memcache_debug() turns on debug output if parameter on_off is equal to\n * TRUE and turns off if it's FALSE.\n *\n * memcache_debug() is accessible only if PHP was built with\n * --enable-debug option and always returns TRUE in this case. Otherwise,\n * this function has no effect and always returns FALSE.\n *\n * @onoff      bool    Turns debug output on if equals to TRUE. Turns debug\n *                     output off if equals to FALSE.\n *\n * @return     bool    Returns TRUE if PHP was built with --enable-debug\n *                     option, otherwise returns FALSE.\n */", 
"memcache_get_version", T(Variant), S(0), "memcache", T(Object), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/function.memcache-get-version.php )\n *\n *\n * @memcache   object\n *\n * @return     mixed\n */", 
"memcache_flush", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "timestamp", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-flush.php )\n *\n * Memcache::flush() immediately invalidates all existing items.\n * Memcache::flush() doesn't actually free any resources, it only marks all\n * the items as expired, so occupied memory will be overwritten by new\n * items. Also you can use memcache_flush() function.\n *\n * @memcache   object\n * @timestamp  int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", 
"memcache_setoptimeout", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "timeoutms", T(Int32), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/function.memcache-setoptimeout.php )\n *\n *\n * @memcache   object\n * @timeoutms  int\n *\n * @return     bool\n */", 
"memcache_get_server_status", T(Int32), S(0), "memcache", T(Object), NULL, NULL, S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/function.memcache-get-server-status.php )\n *\n *\n * @memcache   object\n * @host       string\n * @port       int\n *\n * @return     int\n */", 
"memcache_set_compress_threshold", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "threshold", T(Int32), NULL, NULL, S(0), "min_savings", T(Double), "d:0.2;", "0.2", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/function.memcache-set-compress-threshold.php )\n *\n *\n * @memcache   object\n * @threshold  int\n * @min_savings\n *             float\n *\n * @return     bool\n */", 
"memcache_get_stats", T(Array), S(0), "memcache", T(Object), NULL, NULL, S(0), "type", T(String), "N;", "null", S(0), "slabid", T(Int32), "i:0;", "0", S(0), "limit", T(Int32), "i:100;", "100", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-get-stats.php\n * )\n *\n *\n * @memcache   object\n * @type       string\n * @slabid     int\n * @limit      int\n *\n * @return     map\n */", 
"memcache_get_extended_stats", T(Array), S(0), "memcache", T(Object), NULL, NULL, S(0), "type", T(String), "N;", "null", S(0), "slabid", T(Int32), "i:0;", "0", S(0), "limit", T(Int32), "i:100;", "100", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/function.memcache-get-extended-stats.php )\n *\n *\n * @memcache   object\n * @type       string\n * @slabid     int\n * @limit      int\n *\n * @return     map\n */", 
"memcache_set_server_params", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:11211;", "11211", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "retry_interval", T(Int32), "i:0;", "0", S(0), "status", T(Boolean), "b:1;", "true", S(0), "failure_callback", T(Variant), "N;", "null", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/function.memcache-set-server-params.php )\n *\n *\n * @memcache   object\n * @host       string\n * @port       int\n * @timeout    int\n * @retry_interval\n *             int\n * @status     bool\n * @failure_callback\n *             mixed\n *\n * @return     bool\n */", 
"memcache_add_server", T(Boolean), S(0), "memcache", T(Object), NULL, NULL, S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:11211;", "11211", S(0), "persistent", T(Boolean), "b:0;", "false", S(0), "weight", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "retry_interval", T(Int32), "i:0;", "0", S(0), "status", T(Boolean), "b:1;", "true", S(0), "failure_callback", T(Variant), "N;", "null", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/function.memcache-add-server.php\n * )\n *\n *\n * @memcache   object\n * @host       string\n * @port       int\n * @persistent bool\n * @weight     int\n * @timeout    int\n * @retry_interval\n *             int\n * @status     bool\n * @failure_callback\n *             mixed\n * @timeoutms  int\n *\n * @return     bool\n */", 

#elif EXT_TYPE == 1

#elif EXT_TYPE == 2
"Memcache", "", NULL, "__construct", T(Void), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.--construct.php )\n *\n *\n */", S(16384),"connect", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.connect.php )\n *\n * Memcache::connect() establishes a connection to the memcached server.\n * The connection, which was opened using Memcache::connect() will be\n * automatically closed at the end of script execution. Also you can close\n * it with Memcache::close(). Also you can use memcache_connect() function.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     connections. This parameter may also specify other\n *                     transports like unix:///path/to/memcached.sock to\n *                     use UNIX domain sockets, in this case port must also\n *                     be set to 0.\n * @port       int     Point to the port where memcached is listening for\n *                     connections. Set this parameter to 0 when using UNIX\n *                     domain sockets.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the daemon. Think twice before changing the\n *                     default value of 1 second - you can lose all the\n *                     advantages of caching if your connection is too\n *                     slow.\n * @timeoutms  int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"pconnect", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.pconnect.php )\n *\n * Memcache::pconnect() is similar to Memcache::connect() with the\n * difference, that the connection it establishes is persistent. This\n * connection is not closed after the end of script execution and by\n * Memcache::close() function. Also you can use memcache_pconnect()\n * function.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     connections. This parameter may also specify other\n *                     transports like unix:///path/to/memcached.sock to\n *                     use UNIX domain sockets, in this case port must also\n *                     be set to 0.\n * @port       int     Point to the port where memcached is listening for\n *                     connections. Set this parameter to 0 when using UNIX\n *                     domain sockets.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the daemon. Think twice before changing the\n *                     default value of 1 second - you can lose all the\n *                     advantages of caching if your connection is too\n *                     slow.\n * @timeoutms  int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"add", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.add.php )\n *\n * Memcache::add() stores variable var with key only if such key doesn't\n * exist at the server yet. Also you can use memcache_add() function.\n *\n * @key        string  The key that will be associated with the item.\n * @var        mixed   The variable to store. Strings and integers are\n *                     stored as is, other types are stored serialized.\n * @flag       int     Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses zlib).\n * @expire     int     Expiration time of the item. If it's equal to zero,\n *                     the item will never expire. You can also use Unix\n *                     timestamp or a number of seconds starting from\n *                     current time, but in the latter case the number of\n *                     seconds may not exceed 2592000 (30 days).\n *\n * @return     bool    Returns TRUE on success or FALSE on failure. Returns\n *                     FALSE if such key already exist. For the rest\n *                     Memcache::add() behaves similarly to\n *                     Memcache::set().\n */", S(16384),"set", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.set.php )\n *\n * Memcache::set() stores an item var with key on the memcached server.\n * Parameter expire is expiration time in seconds. If it's 0, the item\n * never expires (but memcached server doesn't guarantee this item to be\n * stored all the time, it could be deleted from the cache to make place\n * for other items). You can use MEMCACHE_COMPRESSED constant as flag value\n * if you want to use on-the-fly compression (uses zlib).\n *\n * Remember that resource variables (i.e. file and connection descriptors)\n * cannot be stored in the cache, because they cannot be adequately\n * represented in serialized state. Also you can use memcache_set()\n * function.\n *\n * @key        string  The key that will be associated with the item.\n * @var        mixed   The variable to store. Strings and integers are\n *                     stored as is, other types are stored serialized.\n * @flag       int     Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses zlib).\n * @expire     int     Expiration time of the item. If it's equal to zero,\n *                     the item will never expire. You can also use Unix\n *                     timestamp or a number of seconds starting from\n *                     current time, but in the latter case the number of\n *                     seconds may not exceed 2592000 (30 days).\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"replace", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.replace.php )\n *\n * Memcache::replace() should be used to replace value of existing item\n * with key. In case if item with such key doesn't exists,\n * Memcache::replace() returns FALSE. For the rest Memcache::replace()\n * behaves similarly to Memcache::set(). Also you can use\n * memcache_replace() function.\n *\n * @key        string  The key that will be associated with the item.\n * @var        mixed   The variable to store. Strings and integers are\n *                     stored as is, other types are stored serialized.\n * @flag       int     Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses zlib).\n * @expire     int     Expiration time of the item. If it's equal to zero,\n *                     the item will never expire. You can also use Unix\n *                     timestamp or a number of seconds starting from\n *                     current time, but in the latter case the number of\n *                     seconds may not exceed 2592000 (30 days).\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"get", T(Variant), S(0), "key", T(Variant), NULL, NULL, S(0), "flags", T(Variant), "N;", "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.get.php )\n *\n * Memcache::get() returns previously stored data if an item with such key\n * exists on the server at this moment.\n *\n * You can pass array of keys to Memcache::get() to get array of values.\n * The result array will contain only found key-value pairs.\n *\n * @key        mixed   The key or array of keys to fetch.\n * @flags      mixed   If present, flags fetched along with the values will\n *                     be written to this parameter. These flags are the\n *                     same as the ones given to for example\n *                     Memcache::set(). The lowest byte of the int is\n *                     reserved for pecl/memcache internal usage (e.g. to\n *                     indicate compression and serialization status).\n *\n * @return     mixed   Returns the string associated with the key or FALSE\n *                     on failure or if such key was not found.\n */", S(16384),"delete", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.delete.php )\n *\n * Memcache::delete() deletes item with the key. If parameter timeout is\n * specified, the item will expire after timeout seconds. Also you can use\n * memcache_delete() function.\n *\n * @key        string  The key associated with the item to delete.\n * @expire     int     Execution time of the item. If it's equal to zero,\n *                     the item will be deleted right away whereas if you\n *                     set it to 30, the item will be deleted in 30\n *                     seconds.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"increment", T(Int64), S(0), "key", T(String), NULL, NULL, S(0), "offset", T(Int32), "i:1;", "1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.increment.php )\n *\n * Memcache::increment() increments value of an item by the specified\n * value. If item specified by key was not numeric and cannot be converted\n * to a number, it will change its value to value. Memcache::increment()\n * does not create an item if it doesn't already exist.\n *\n * Do not use Memcache::increment() with items that have been stored\n * compressed because subsequent calls to Memcache::get() will fail. Also\n * you can use memcache_increment() function.\n *\n * @key        string  Key of the item to increment.\n * @offset     int     Increment the item by value.\n *\n * @return     int     Returns new items value on success or FALSE on\n *                     failure.\n */", S(16384),"decrement", T(Int64), S(0), "key", T(String), NULL, NULL, S(0), "offset", T(Int32), "i:1;", "1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.decrement.php )\n *\n * Memcache::decrement() decrements value of the item by value. Similarly\n * to Memcache::increment(), current value of the item is being converted\n * to numerical and after that value is substracted.\n *\n * New item's value will not be less than zero.\n *\n * Do not use Memcache::decrement() with item, which was stored\n * compressed, because consequent call to Memcache::get() will fail.\n * Memcache::decrement() does not create an item if it didn't exist. Also\n * you can use memcache_decrement() function.\n *\n * @key        string  Key of the item do decrement.\n * @offset     int     Decrement the item by value.\n *\n * @return     int     Returns item's new value on success or FALSE on\n *                     failure.\n */", S(16384),"getversion", T(Variant), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.getversion.php )\n *\n * Memcache::getVersion() returns a string with server's version number.\n * Also you can use memcache_get_version() function.\n *\n * @return     mixed   Returns a string of server version number or FALSE\n *                     on failure.\n */", S(16384),"flush", T(Boolean), S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.flush.php )\n *\n * Memcache::flush() immediately invalidates all existing items.\n * Memcache::flush() doesn't actually free any resources, it only marks all\n * the items as expired, so occupied memory will be overwritten by new\n * items. Also you can use memcache_flush() function.\n *\n * @expire     int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"setoptimeout", T(Boolean), S(0), "timeoutms", T(Int64), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.setoptimeout.php )\n *\n *\n * @timeoutms  int\n *\n * @return     bool\n */", S(16384),"close", T(Boolean), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.close.php )\n *\n * Memcache::close() closes connection to memcached server. This function\n * doesn't close persistent connections, which are closed only during\n * web-server shutdown/restart. Also you can use memcache_close() function.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"getserverstatus", T(Int32), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.getserverstatus.php )\n *\n * Memcache::getServerStatus() returns a the servers online/offline\n * status. You can also use memcache_get_server_status() function.\n *\n * This function has been added to Memcache version 2.1.0.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     connections.\n * @port       int     Point to the port where memcached is listening for\n *                     connections.\n *\n * @return     int     Returns a the servers status. 0 if server is failed,\n *                     non-zero otherwise\n */", S(16384),"setcompressthreshold", T(Boolean), S(0), "threshold", T(Int32), NULL, NULL, S(0), "min_savings", T(Double), "d:0.2;", "0.2", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/memcache.setcompressthreshold.php )\n *\n * Memcache::setCompressThreshold() enables automatic compression of large\n * values. You can also use the memcache_set_compress_threshold() function.\n *\n * This function has been added to Memcache version 2.0.0.\n *\n * @threshold  int     Controls the minimum value length before attempting\n *                     to compress automatically.\n * @min_savings\n *             float   Specifies the minimum amount of savings to actually\n *                     store the value compressed. The supplied value must\n *                     be between 0 and 1. Default value is 0.2 giving a\n *                     minimum 20% compression savings.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"getstats", T(Array), S(0), "type", T(String), "N;", "null", S(0), "slabid", T(Int32), "i:0;", "0", S(0), "limit", T(Int32), "i:100;", "100", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.getstats.php )\n *\n * Memcache::getStats() returns an associative array with server's\n * statistics. Array keys correspond to stats parameters and values to\n * parameter's values. Also you can use memcache_get_stats() function.\n *\n * @type       string  The type of statistics to fetch. Valid values are\n *                     {reset, malloc, maps, cachedump, slabs, items,\n *                     sizes}. According to the memcached protocol spec\n *                     these additional arguments \"are subject to change\n *                     for the convenience of memcache developers\".\n * @slabid     int     Used in conjunction with type set to cachedump to\n *                     identify the slab to dump from. The cachedump\n *                     command ties up the server and is strictly to be\n *                     used for debugging purposes.\n * @limit      int     Used in conjunction with type set to cachedump to\n *                     limit the number of entries to dump.\n *\n * @return     map     Returns an associative array of server statistics or\n *                     FALSE on failure.\n */", S(16384),"getextendedstats", T(Array), S(0), "type", T(String), "N;", "null", S(0), "slabid", T(Int32), "i:0;", "0", S(0), "limit", T(Int32), "i:100;", "100", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.getextendedstats.php )\n *\n * Memcache::getExtendedStats() returns a two-dimensional associative\n * array with server statistics. Array keys correspond to host:port of\n * server and values contain the individual server statistics. A failed\n * server will have its corresponding entry set to FALSE. You can also use\n * the memcache_get_extended_stats() function.\n *\n * This function has been added to Memcache version 2.0.0.\n *\n * @type       string  The type of statistics to fetch. Valid values are\n *                     {reset, malloc, maps, cachedump, slabs, items,\n *                     sizes}. According to the memcached protocol spec\n *                     these additional arguments \"are subject to change\n *                     for the convenience of memcache developers\".\n * @slabid     int     Used in conjunction with type set to cachedump to\n *                     identify the slab to dump from. The cachedump\n *                     command ties up the server and is strictly to be\n *                     used for debugging purposes.\n * @limit      int     Used in conjunction with type set to cachedump to\n *                     limit the number of entries to dump.\n *\n * @return     map     Returns a two-dimensional associative array of\n *                     server statistics or FALSE on failure.\n */", S(16384),"setserverparams", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:11211;", "11211", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "retry_interval", T(Int32), "i:0;", "0", S(0), "status", T(Boolean), "b:1;", "true", S(0), "failure_callback", T(Variant), "N;", "null", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.setserverparams.php )\n *\n * Memcache::setServerParams() changes server parameters at runtime. You\n * can also use the memcache_set_server_params() function.\n *\n * This function has been added to Memcache version 2.1.0.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     connections.\n * @port       int     Point to the port where memcached is listening for\n *                     connections.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the daemon. Think twice before changing the\n *                     default value of 1 second - you can lose all the\n *                     advantages of caching if your connection is too\n *                     slow.\n * @retry_interval\n *             int     Controls how often a failed server will be retried,\n *                     the default value is 15 seconds. Setting this\n *                     parameter to -1 disables automatic retry. Neither\n *                     this nor the persistent parameter has any effect\n *                     when the extension is loaded dynamically via dl().\n * @status     bool    Controls if the server should be flagged as online.\n *                     Setting this parameter to FALSE and retry_interval\n *                     to -1 allows a failed server to be kept in the pool\n *                     so as not to affect the key distribution algoritm.\n *                     Requests for this server will then failover or fail\n *                     immediately depending on the memcache.allow_failover\n *                     setting. Default to TRUE, meaning the server should\n *                     be considered online.\n * @failure_callback\n *             mixed   Allows the user to specify a callback function to\n *                     run upon encountering an error. The callback is run\n *                     before failover is attempted. The function takes two\n *                     parameters, the hostname and port of the failed\n *                     server.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"addserver", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:11211;", "11211", S(0), "persistent", T(Boolean), "b:0;", "false", S(0), "weight", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "retry_interval", T(Int32), "i:0;", "0", S(0), "status", T(Boolean), "b:1;", "true", S(0), "failure_callback", T(Variant), "N;", "null", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.addserver.php )\n *\n * Memcache::addServer() adds a server to the connection pool. The\n * connection, which was opened using Memcache::addServer() will be\n * automatically closed at the end of script execution, you can also close\n * it manually with Memcache::close(). You can also use the\n * memcache_add_server() function.\n *\n * When using this method (as opposed to Memcache::connect() and\n * Memcache::pconnect()) the network connection is not established until\n * actually needed. Thus there is no overhead in adding a large number of\n * servers to the pool, even though they might not all be used.\n *\n * Failover may occur at any stage in any of the methods, as long as other\n * servers are available the request the user won't notice. Any kind of\n * socket or Memcached server level errors (except out-of-memory) may\n * trigger the failover. Normal client errors such as adding an existing\n * key will not trigger a failover.\n *\n * This function has been added to Memcache version 2.0.0.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     connections. This parameter may also specify other\n *                     transports like unix:///path/to/memcached.sock to\n *                     use UNIX domain sockets, in this case port must also\n *                     be set to 0.\n * @port       int     Point to the port where memcached is listening for\n *                     connections. Set this parameter to 0 when using UNIX\n *                     domain sockets.\n * @persistent bool    Controls the use of a persistent connection. Default\n *                     to TRUE.\n * @weight     int     Number of buckets to create for this server which in\n *                     turn control its probability of it being selected.\n *                     The probability is relative to the total weight of\n *                     all servers.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the daemon. Think twice before changing the\n *                     default value of 1 second - you can lose all the\n *                     advantages of caching if your connection is too\n *                     slow.\n * @retry_interval\n *             int     Controls how often a failed server will be retried,\n *                     the default value is 15 seconds. Setting this\n *                     parameter to -1 disables automatic retry. Neither\n *                     this nor the persistent parameter has any effect\n *                     when the extension is loaded dynamically via dl().\n *\n *                     Each failed connection struct has its own timeout\n *                     and before it has expired the struct will be skipped\n *                     when selecting backends to serve a request. Once\n *                     expired the connection will be successfully\n *                     reconnected or marked as failed for another\n *                     retry_interval seconds. The typical effect is that\n *                     each web server child will retry the connection\n *                     about every retry_interval seconds when serving a\n *                     page.\n * @status     bool    Controls if the server should be flagged as online.\n *                     Setting this parameter to FALSE and retry_interval\n *                     to -1 allows a failed server to be kept in the pool\n *                     so as not to affect the key distribution algorithm.\n *                     Requests for this server will then failover or fail\n *                     immediately depending on the memcache.allow_failover\n *                     setting. Default to TRUE, meaning the server should\n *                     be considered online.\n * @failure_callback\n *             mixed   Allows the user to specify a callback function to\n *                     run upon encountering an error. The callback is run\n *                     before failover is attempted. The function takes two\n *                     parameters, the hostname and port of the failed\n *                     server.\n * @timeoutms  int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"__destruct", T(Variant), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcache.--destruct.php )\n *\n *\n * @return     mixed\n */", S(16384),NULL,NULL,NULL,
S(16384), "/**\n * ( excerpt from http://php.net/manual/en/class.memcache.php )\n *\n * Represents a connection to a set of memcache servers.\n *\n */", 
#elif EXT_TYPE == 3

#endif
