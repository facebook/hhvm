/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.facebook.thrift.*;
import com.facebook.thrift.annotations.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class NestedContainers {

  public interface Iface {

    public void mapList(Map<Integer,List<Integer>> foo) throws TException;

    public void mapSet(Map<Integer,Set<Integer>> foo) throws TException;

    public void listMap(List<Map<Integer,Integer>> foo) throws TException;

    public void listSet(List<Set<Integer>> foo) throws TException;

    public void turtles(List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo) throws TException;

  }

  public interface AsyncIface {

    public void mapList(Map<Integer,List<Integer>> foo, AsyncMethodCallback resultHandler) throws TException;

    public void mapSet(Map<Integer,Set<Integer>> foo, AsyncMethodCallback resultHandler) throws TException;

    public void listMap(List<Map<Integer,Integer>> foo, AsyncMethodCallback resultHandler) throws TException;

    public void listSet(List<Set<Integer>> foo, AsyncMethodCallback resultHandler) throws TException;

    public void turtles(List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo, AsyncMethodCallback resultHandler) throws TException;

  }

  public static class Client extends EventHandlerBase implements Iface, TClientIf {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    @Override
    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    @Override
    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void mapList(Map<Integer,List<Integer>> foo) throws TException
    {
      ContextStack ctx = getContextStack("NestedContainers.mapList", null);
      this.setContextStack(ctx);
      send_mapList(foo);
      recv_mapList();
    }

    public void send_mapList(Map<Integer,List<Integer>> foo) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "NestedContainers.mapList", null);
      oprot_.writeMessageBegin(new TMessage("mapList", TMessageType.CALL, seqid_));
      mapList_args args = new mapList_args();
      args.foo = foo;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "NestedContainers.mapList", args);
      return;
    }

    public void recv_mapList() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "NestedContainers.mapList");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      mapList_result result = new mapList_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "NestedContainers.mapList", result);

      return;
    }

    public void mapSet(Map<Integer,Set<Integer>> foo) throws TException
    {
      ContextStack ctx = getContextStack("NestedContainers.mapSet", null);
      this.setContextStack(ctx);
      send_mapSet(foo);
      recv_mapSet();
    }

    public void send_mapSet(Map<Integer,Set<Integer>> foo) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "NestedContainers.mapSet", null);
      oprot_.writeMessageBegin(new TMessage("mapSet", TMessageType.CALL, seqid_));
      mapSet_args args = new mapSet_args();
      args.foo = foo;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "NestedContainers.mapSet", args);
      return;
    }

    public void recv_mapSet() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "NestedContainers.mapSet");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      mapSet_result result = new mapSet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "NestedContainers.mapSet", result);

      return;
    }

    public void listMap(List<Map<Integer,Integer>> foo) throws TException
    {
      ContextStack ctx = getContextStack("NestedContainers.listMap", null);
      this.setContextStack(ctx);
      send_listMap(foo);
      recv_listMap();
    }

    public void send_listMap(List<Map<Integer,Integer>> foo) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "NestedContainers.listMap", null);
      oprot_.writeMessageBegin(new TMessage("listMap", TMessageType.CALL, seqid_));
      listMap_args args = new listMap_args();
      args.foo = foo;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "NestedContainers.listMap", args);
      return;
    }

    public void recv_listMap() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "NestedContainers.listMap");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listMap_result result = new listMap_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "NestedContainers.listMap", result);

      return;
    }

    public void listSet(List<Set<Integer>> foo) throws TException
    {
      ContextStack ctx = getContextStack("NestedContainers.listSet", null);
      this.setContextStack(ctx);
      send_listSet(foo);
      recv_listSet();
    }

    public void send_listSet(List<Set<Integer>> foo) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "NestedContainers.listSet", null);
      oprot_.writeMessageBegin(new TMessage("listSet", TMessageType.CALL, seqid_));
      listSet_args args = new listSet_args();
      args.foo = foo;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "NestedContainers.listSet", args);
      return;
    }

    public void recv_listSet() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "NestedContainers.listSet");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSet_result result = new listSet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "NestedContainers.listSet", result);

      return;
    }

    public void turtles(List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo) throws TException
    {
      ContextStack ctx = getContextStack("NestedContainers.turtles", null);
      this.setContextStack(ctx);
      send_turtles(foo);
      recv_turtles();
    }

    public void send_turtles(List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "NestedContainers.turtles", null);
      oprot_.writeMessageBegin(new TMessage("turtles", TMessageType.CALL, seqid_));
      turtles_args args = new turtles_args();
      args.foo = foo;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "NestedContainers.turtles", args);
      return;
    }

    public void recv_turtles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "NestedContainers.turtles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      turtles_result result = new turtles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "NestedContainers.turtles", result);

      return;
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void mapList(Map<Integer,List<Integer>> foo, AsyncMethodCallback resultHandler8) throws TException {
      checkReady();
      mapList_call method_call = new mapList_call(foo, resultHandler8, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class mapList_call extends TAsyncMethodCall {
      private Map<Integer,List<Integer>> foo;
      public mapList_call(Map<Integer,List<Integer>> foo, AsyncMethodCallback resultHandler9, TAsyncClient client5, TProtocolFactory protocolFactory6, TNonblockingTransport transport7) throws TException {
        super(client5, protocolFactory6, transport7, resultHandler9, false);
        this.foo = foo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("mapList", TMessageType.CALL, 0));
        mapList_args args = new mapList_args();
        args.setFoo(foo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_mapList();
      }
    }

    public void mapSet(Map<Integer,Set<Integer>> foo, AsyncMethodCallback resultHandler13) throws TException {
      checkReady();
      mapSet_call method_call = new mapSet_call(foo, resultHandler13, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class mapSet_call extends TAsyncMethodCall {
      private Map<Integer,Set<Integer>> foo;
      public mapSet_call(Map<Integer,Set<Integer>> foo, AsyncMethodCallback resultHandler14, TAsyncClient client10, TProtocolFactory protocolFactory11, TNonblockingTransport transport12) throws TException {
        super(client10, protocolFactory11, transport12, resultHandler14, false);
        this.foo = foo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("mapSet", TMessageType.CALL, 0));
        mapSet_args args = new mapSet_args();
        args.setFoo(foo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_mapSet();
      }
    }

    public void listMap(List<Map<Integer,Integer>> foo, AsyncMethodCallback resultHandler18) throws TException {
      checkReady();
      listMap_call method_call = new listMap_call(foo, resultHandler18, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listMap_call extends TAsyncMethodCall {
      private List<Map<Integer,Integer>> foo;
      public listMap_call(List<Map<Integer,Integer>> foo, AsyncMethodCallback resultHandler19, TAsyncClient client15, TProtocolFactory protocolFactory16, TNonblockingTransport transport17) throws TException {
        super(client15, protocolFactory16, transport17, resultHandler19, false);
        this.foo = foo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listMap", TMessageType.CALL, 0));
        listMap_args args = new listMap_args();
        args.setFoo(foo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_listMap();
      }
    }

    public void listSet(List<Set<Integer>> foo, AsyncMethodCallback resultHandler23) throws TException {
      checkReady();
      listSet_call method_call = new listSet_call(foo, resultHandler23, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSet_call extends TAsyncMethodCall {
      private List<Set<Integer>> foo;
      public listSet_call(List<Set<Integer>> foo, AsyncMethodCallback resultHandler24, TAsyncClient client20, TProtocolFactory protocolFactory21, TNonblockingTransport transport22) throws TException {
        super(client20, protocolFactory21, transport22, resultHandler24, false);
        this.foo = foo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSet", TMessageType.CALL, 0));
        listSet_args args = new listSet_args();
        args.setFoo(foo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_listSet();
      }
    }

    public void turtles(List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo, AsyncMethodCallback resultHandler28) throws TException {
      checkReady();
      turtles_call method_call = new turtles_call(foo, resultHandler28, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class turtles_call extends TAsyncMethodCall {
      private List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo;
      public turtles_call(List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo, AsyncMethodCallback resultHandler29, TAsyncClient client25, TProtocolFactory protocolFactory26, TNonblockingTransport transport27) throws TException {
        super(client25, protocolFactory26, transport27, resultHandler29, false);
        this.foo = foo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("turtles", TMessageType.CALL, 0));
        turtles_args args = new turtles_args();
        args.setFoo(foo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_turtles();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      event_handler_ = new TProcessorEventHandler(); // Empty handler
      processMap_.put("mapList", new mapList());
      processMap_.put("mapSet", new mapSet());
      processMap_.put("listMap", new listMap());
      processMap_.put("listSet", new listSet());
      processMap_.put("turtles", new turtles());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException;
    }

    public void setEventHandler(TProcessorEventHandler handler) {
      this.event_handler_ = handler;
    }

    private Iface iface_;
    protected TProcessorEventHandler event_handler_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot, server_ctx);
      return true;
    }

    private class mapList implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("NestedContainers.mapList", server_ctx);
        mapList_args args = new mapList_args();
        event_handler_.preRead(handler_ctx, "NestedContainers.mapList");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "NestedContainers.mapList", args);
        mapList_result result = new mapList_result();
        iface_.mapList(args.foo);
        event_handler_.preWrite(handler_ctx, "NestedContainers.mapList", result);
        oprot.writeMessageBegin(new TMessage("mapList", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "NestedContainers.mapList", result);
      }

    }

    private class mapSet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("NestedContainers.mapSet", server_ctx);
        mapSet_args args = new mapSet_args();
        event_handler_.preRead(handler_ctx, "NestedContainers.mapSet");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "NestedContainers.mapSet", args);
        mapSet_result result = new mapSet_result();
        iface_.mapSet(args.foo);
        event_handler_.preWrite(handler_ctx, "NestedContainers.mapSet", result);
        oprot.writeMessageBegin(new TMessage("mapSet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "NestedContainers.mapSet", result);
      }

    }

    private class listMap implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("NestedContainers.listMap", server_ctx);
        listMap_args args = new listMap_args();
        event_handler_.preRead(handler_ctx, "NestedContainers.listMap");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "NestedContainers.listMap", args);
        listMap_result result = new listMap_result();
        iface_.listMap(args.foo);
        event_handler_.preWrite(handler_ctx, "NestedContainers.listMap", result);
        oprot.writeMessageBegin(new TMessage("listMap", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "NestedContainers.listMap", result);
      }

    }

    private class listSet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("NestedContainers.listSet", server_ctx);
        listSet_args args = new listSet_args();
        event_handler_.preRead(handler_ctx, "NestedContainers.listSet");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "NestedContainers.listSet", args);
        listSet_result result = new listSet_result();
        iface_.listSet(args.foo);
        event_handler_.preWrite(handler_ctx, "NestedContainers.listSet", result);
        oprot.writeMessageBegin(new TMessage("listSet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "NestedContainers.listSet", result);
      }

    }

    private class turtles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("NestedContainers.turtles", server_ctx);
        turtles_args args = new turtles_args();
        event_handler_.preRead(handler_ctx, "NestedContainers.turtles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "NestedContainers.turtles", args);
        turtles_result result = new turtles_result();
        iface_.turtles(args.foo);
        event_handler_.preWrite(handler_ctx, "NestedContainers.turtles", result);
        oprot.writeMessageBegin(new TMessage("turtles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "NestedContainers.turtles", result);
      }

    }

  }

  public static class mapList_args implements TBase, java.io.Serializable, Cloneable, Comparable<mapList_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("mapList_args");
    private static final TField FOO_FIELD_DESC = new TField("foo", TType.MAP, (short)1);

    public Map<Integer,List<Integer>> foo;
    public static final int FOO = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(FOO, new FieldMetaData("foo", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I32), 
              new ListMetaData(TType.LIST, 
                  new FieldValueMetaData(TType.I32)))));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(mapList_args.class, metaDataMap);
    }

    public mapList_args() {
    }

    public mapList_args(
        Map<Integer,List<Integer>> foo) {
      this();
      this.foo = foo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mapList_args(mapList_args other) {
      if (other.isSetFoo()) {
        this.foo = TBaseHelper.deepCopy(other.foo);
      }
    }

    public mapList_args deepCopy() {
      return new mapList_args(this);
    }

    public Map<Integer,List<Integer>> getFoo() {
      return this.foo;
    }

    public mapList_args setFoo(Map<Integer,List<Integer>> foo) {
      this.foo = foo;
      return this;
    }

    public void unsetFoo() {
      this.foo = null;
    }

    // Returns true if field foo is set (has been assigned a value) and false otherwise
    public boolean isSetFoo() {
      return this.foo != null;
    }

    public void setFooIsSet(boolean __value) {
      if (!__value) {
        this.foo = null;
      }
    }

    @SuppressWarnings("unchecked")
    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case FOO:
        if (__value == null) {
          unsetFoo();
        } else {
          setFoo((Map<Integer,List<Integer>>)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case FOO:
        return getFoo();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof mapList_args))
        return false;
      mapList_args that = (mapList_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetFoo(), that.isSetFoo(), this.foo, that.foo)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {foo});
    }

    @Override
    public int compareTo(mapList_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetFoo()).compareTo(other.isSetFoo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(foo, other.foo);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          case FOO:
            if (__field.type == TType.MAP) {
              {
                TMap _map30 = iprot.readMapBegin();
                this.foo = new HashMap<Integer,List<Integer>>(Math.max(0, 2*_map30.size));
                for (int _i31 = 0; 
                     (_map30.size < 0) ? iprot.peekMap() : (_i31 < _map30.size); 
                     ++_i31)
                {
                  int _key32;
                  List<Integer> _val33;
                  _key32 = iprot.readI32();
                  {
                    TList _list34 = iprot.readListBegin();
                    _val33 = new ArrayList<Integer>(Math.max(0, _list34.size));
                    for (int _i35 = 0; 
                         (_list34.size < 0) ? iprot.peekList() : (_i35 < _list34.size); 
                         ++_i35)
                    {
                      int _elem36;
                      _elem36 = iprot.readI32();
                      _val33.add(_elem36);
                    }
                    iprot.readListEnd();
                  }
                  this.foo.put(_key32, _val33);
                }
                iprot.readMapEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.foo != null) {
        oprot.writeFieldBegin(FOO_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I32, TType.LIST, this.foo.size()));
          for (Map.Entry<Integer, List<Integer>> _iter37 : this.foo.entrySet())          {
            oprot.writeI32(_iter37.getKey());
            {
              oprot.writeListBegin(new TList(TType.I32, _iter37.getValue().size()));
              for (int _iter38 : _iter37.getValue())              {
                oprot.writeI32(_iter38);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("mapList_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("foo");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getFoo() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getFoo(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mapList_result implements TBase, java.io.Serializable, Cloneable, Comparable<mapList_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("mapList_result");

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(mapList_result.class, metaDataMap);
    }

    public mapList_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mapList_result(mapList_result other) {
    }

    public mapList_result deepCopy() {
      return new mapList_result(this);
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof mapList_result))
        return false;
      mapList_result that = (mapList_result)_that;

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {});
    }

    @Override
    public int compareTo(mapList_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("mapList_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mapSet_args implements TBase, java.io.Serializable, Cloneable, Comparable<mapSet_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("mapSet_args");
    private static final TField FOO_FIELD_DESC = new TField("foo", TType.MAP, (short)1);

    public Map<Integer,Set<Integer>> foo;
    public static final int FOO = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(FOO, new FieldMetaData("foo", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I32), 
              new SetMetaData(TType.SET, 
                  new FieldValueMetaData(TType.I32)))));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(mapSet_args.class, metaDataMap);
    }

    public mapSet_args() {
    }

    public mapSet_args(
        Map<Integer,Set<Integer>> foo) {
      this();
      this.foo = foo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mapSet_args(mapSet_args other) {
      if (other.isSetFoo()) {
        this.foo = TBaseHelper.deepCopy(other.foo);
      }
    }

    public mapSet_args deepCopy() {
      return new mapSet_args(this);
    }

    public Map<Integer,Set<Integer>> getFoo() {
      return this.foo;
    }

    public mapSet_args setFoo(Map<Integer,Set<Integer>> foo) {
      this.foo = foo;
      return this;
    }

    public void unsetFoo() {
      this.foo = null;
    }

    // Returns true if field foo is set (has been assigned a value) and false otherwise
    public boolean isSetFoo() {
      return this.foo != null;
    }

    public void setFooIsSet(boolean __value) {
      if (!__value) {
        this.foo = null;
      }
    }

    @SuppressWarnings("unchecked")
    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case FOO:
        if (__value == null) {
          unsetFoo();
        } else {
          setFoo((Map<Integer,Set<Integer>>)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case FOO:
        return getFoo();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof mapSet_args))
        return false;
      mapSet_args that = (mapSet_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetFoo(), that.isSetFoo(), this.foo, that.foo)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {foo});
    }

    @Override
    public int compareTo(mapSet_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetFoo()).compareTo(other.isSetFoo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(foo, other.foo);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          case FOO:
            if (__field.type == TType.MAP) {
              {
                TMap _map39 = iprot.readMapBegin();
                this.foo = new HashMap<Integer,Set<Integer>>(Math.max(0, 2*_map39.size));
                for (int _i40 = 0; 
                     (_map39.size < 0) ? iprot.peekMap() : (_i40 < _map39.size); 
                     ++_i40)
                {
                  int _key41;
                  Set<Integer> _val42;
                  _key41 = iprot.readI32();
                  {
                    TSet _set43 = iprot.readSetBegin();
                    _val42 = new HashSet<Integer>(Math.max(0, 2*_set43.size));
                    for (int _i44 = 0; 
                         (_set43.size < 0) ? iprot.peekSet() : (_i44 < _set43.size); 
                         ++_i44)
                    {
                      int _elem45;
                      _elem45 = iprot.readI32();
                      _val42.add(_elem45);
                    }
                    iprot.readSetEnd();
                  }
                  this.foo.put(_key41, _val42);
                }
                iprot.readMapEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.foo != null) {
        oprot.writeFieldBegin(FOO_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I32, TType.SET, this.foo.size()));
          for (Map.Entry<Integer, Set<Integer>> _iter46 : this.foo.entrySet())          {
            oprot.writeI32(_iter46.getKey());
            {
              oprot.writeSetBegin(new TSet(TType.I32, _iter46.getValue().size()));
              for (int _iter47 : _iter46.getValue())              {
                oprot.writeI32(_iter47);
              }
              oprot.writeSetEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("mapSet_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("foo");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getFoo() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getFoo(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mapSet_result implements TBase, java.io.Serializable, Cloneable, Comparable<mapSet_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("mapSet_result");

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(mapSet_result.class, metaDataMap);
    }

    public mapSet_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mapSet_result(mapSet_result other) {
    }

    public mapSet_result deepCopy() {
      return new mapSet_result(this);
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof mapSet_result))
        return false;
      mapSet_result that = (mapSet_result)_that;

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {});
    }

    @Override
    public int compareTo(mapSet_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("mapSet_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listMap_args implements TBase, java.io.Serializable, Cloneable, Comparable<listMap_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listMap_args");
    private static final TField FOO_FIELD_DESC = new TField("foo", TType.LIST, (short)1);

    public List<Map<Integer,Integer>> foo;
    public static final int FOO = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(FOO, new FieldMetaData("foo", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new MapMetaData(TType.MAP, 
                  new FieldValueMetaData(TType.I32), 
                  new FieldValueMetaData(TType.I32)))));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listMap_args.class, metaDataMap);
    }

    public listMap_args() {
    }

    public listMap_args(
        List<Map<Integer,Integer>> foo) {
      this();
      this.foo = foo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listMap_args(listMap_args other) {
      if (other.isSetFoo()) {
        this.foo = TBaseHelper.deepCopy(other.foo);
      }
    }

    public listMap_args deepCopy() {
      return new listMap_args(this);
    }

    public List<Map<Integer,Integer>> getFoo() {
      return this.foo;
    }

    public listMap_args setFoo(List<Map<Integer,Integer>> foo) {
      this.foo = foo;
      return this;
    }

    public void unsetFoo() {
      this.foo = null;
    }

    // Returns true if field foo is set (has been assigned a value) and false otherwise
    public boolean isSetFoo() {
      return this.foo != null;
    }

    public void setFooIsSet(boolean __value) {
      if (!__value) {
        this.foo = null;
      }
    }

    @SuppressWarnings("unchecked")
    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case FOO:
        if (__value == null) {
          unsetFoo();
        } else {
          setFoo((List<Map<Integer,Integer>>)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case FOO:
        return getFoo();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listMap_args))
        return false;
      listMap_args that = (listMap_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetFoo(), that.isSetFoo(), this.foo, that.foo)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {foo});
    }

    @Override
    public int compareTo(listMap_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetFoo()).compareTo(other.isSetFoo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(foo, other.foo);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          case FOO:
            if (__field.type == TType.LIST) {
              {
                TList _list48 = iprot.readListBegin();
                this.foo = new ArrayList<Map<Integer,Integer>>(Math.max(0, _list48.size));
                for (int _i49 = 0; 
                     (_list48.size < 0) ? iprot.peekList() : (_i49 < _list48.size); 
                     ++_i49)
                {
                  Map<Integer,Integer> _elem50;
                  {
                    TMap _map51 = iprot.readMapBegin();
                    _elem50 = new HashMap<Integer,Integer>(Math.max(0, 2*_map51.size));
                    for (int _i52 = 0; 
                         (_map51.size < 0) ? iprot.peekMap() : (_i52 < _map51.size); 
                         ++_i52)
                    {
                      int _key53;
                      int _val54;
                      _key53 = iprot.readI32();
                      _val54 = iprot.readI32();
                      _elem50.put(_key53, _val54);
                    }
                    iprot.readMapEnd();
                  }
                  this.foo.add(_elem50);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.foo != null) {
        oprot.writeFieldBegin(FOO_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.MAP, this.foo.size()));
          for (Map<Integer,Integer> _iter55 : this.foo)          {
            {
              oprot.writeMapBegin(new TMap(TType.I32, TType.I32, _iter55.size()));
              for (Map.Entry<Integer, Integer> _iter56 : _iter55.entrySet())              {
                oprot.writeI32(_iter56.getKey());
                oprot.writeI32(_iter56.getValue());
              }
              oprot.writeMapEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listMap_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("foo");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getFoo() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getFoo(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listMap_result implements TBase, java.io.Serializable, Cloneable, Comparable<listMap_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listMap_result");

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listMap_result.class, metaDataMap);
    }

    public listMap_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listMap_result(listMap_result other) {
    }

    public listMap_result deepCopy() {
      return new listMap_result(this);
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listMap_result))
        return false;
      listMap_result that = (listMap_result)_that;

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {});
    }

    @Override
    public int compareTo(listMap_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listMap_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSet_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSet_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSet_args");
    private static final TField FOO_FIELD_DESC = new TField("foo", TType.LIST, (short)1);

    public List<Set<Integer>> foo;
    public static final int FOO = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(FOO, new FieldMetaData("foo", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new SetMetaData(TType.SET, 
                  new FieldValueMetaData(TType.I32)))));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSet_args.class, metaDataMap);
    }

    public listSet_args() {
    }

    public listSet_args(
        List<Set<Integer>> foo) {
      this();
      this.foo = foo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSet_args(listSet_args other) {
      if (other.isSetFoo()) {
        this.foo = TBaseHelper.deepCopy(other.foo);
      }
    }

    public listSet_args deepCopy() {
      return new listSet_args(this);
    }

    public List<Set<Integer>> getFoo() {
      return this.foo;
    }

    public listSet_args setFoo(List<Set<Integer>> foo) {
      this.foo = foo;
      return this;
    }

    public void unsetFoo() {
      this.foo = null;
    }

    // Returns true if field foo is set (has been assigned a value) and false otherwise
    public boolean isSetFoo() {
      return this.foo != null;
    }

    public void setFooIsSet(boolean __value) {
      if (!__value) {
        this.foo = null;
      }
    }

    @SuppressWarnings("unchecked")
    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case FOO:
        if (__value == null) {
          unsetFoo();
        } else {
          setFoo((List<Set<Integer>>)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case FOO:
        return getFoo();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSet_args))
        return false;
      listSet_args that = (listSet_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetFoo(), that.isSetFoo(), this.foo, that.foo)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {foo});
    }

    @Override
    public int compareTo(listSet_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetFoo()).compareTo(other.isSetFoo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(foo, other.foo);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          case FOO:
            if (__field.type == TType.LIST) {
              {
                TList _list57 = iprot.readListBegin();
                this.foo = new ArrayList<Set<Integer>>(Math.max(0, _list57.size));
                for (int _i58 = 0; 
                     (_list57.size < 0) ? iprot.peekList() : (_i58 < _list57.size); 
                     ++_i58)
                {
                  Set<Integer> _elem59;
                  {
                    TSet _set60 = iprot.readSetBegin();
                    _elem59 = new HashSet<Integer>(Math.max(0, 2*_set60.size));
                    for (int _i61 = 0; 
                         (_set60.size < 0) ? iprot.peekSet() : (_i61 < _set60.size); 
                         ++_i61)
                    {
                      int _elem62;
                      _elem62 = iprot.readI32();
                      _elem59.add(_elem62);
                    }
                    iprot.readSetEnd();
                  }
                  this.foo.add(_elem59);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.foo != null) {
        oprot.writeFieldBegin(FOO_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.SET, this.foo.size()));
          for (Set<Integer> _iter63 : this.foo)          {
            {
              oprot.writeSetBegin(new TSet(TType.I32, _iter63.size()));
              for (int _iter64 : _iter63)              {
                oprot.writeI32(_iter64);
              }
              oprot.writeSetEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSet_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("foo");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getFoo() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getFoo(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSet_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSet_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSet_result");

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSet_result.class, metaDataMap);
    }

    public listSet_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSet_result(listSet_result other) {
    }

    public listSet_result deepCopy() {
      return new listSet_result(this);
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSet_result))
        return false;
      listSet_result that = (listSet_result)_that;

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {});
    }

    @Override
    public int compareTo(listSet_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSet_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class turtles_args implements TBase, java.io.Serializable, Cloneable, Comparable<turtles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("turtles_args");
    private static final TField FOO_FIELD_DESC = new TField("foo", TType.LIST, (short)1);

    public List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo;
    public static final int FOO = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(FOO, new FieldMetaData("foo", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new ListMetaData(TType.LIST, 
                  new MapMetaData(TType.MAP, 
                      new FieldValueMetaData(TType.I32), 
                      new MapMetaData(TType.MAP, 
                          new FieldValueMetaData(TType.I32), 
                          new SetMetaData(TType.SET, 
                              new FieldValueMetaData(TType.I32))))))));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(turtles_args.class, metaDataMap);
    }

    public turtles_args() {
    }

    public turtles_args(
        List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo) {
      this();
      this.foo = foo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public turtles_args(turtles_args other) {
      if (other.isSetFoo()) {
        this.foo = TBaseHelper.deepCopy(other.foo);
      }
    }

    public turtles_args deepCopy() {
      return new turtles_args(this);
    }

    public List<List<Map<Integer,Map<Integer,Set<Integer>>>>> getFoo() {
      return this.foo;
    }

    public turtles_args setFoo(List<List<Map<Integer,Map<Integer,Set<Integer>>>>> foo) {
      this.foo = foo;
      return this;
    }

    public void unsetFoo() {
      this.foo = null;
    }

    // Returns true if field foo is set (has been assigned a value) and false otherwise
    public boolean isSetFoo() {
      return this.foo != null;
    }

    public void setFooIsSet(boolean __value) {
      if (!__value) {
        this.foo = null;
      }
    }

    @SuppressWarnings("unchecked")
    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case FOO:
        if (__value == null) {
          unsetFoo();
        } else {
          setFoo((List<List<Map<Integer,Map<Integer,Set<Integer>>>>>)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case FOO:
        return getFoo();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof turtles_args))
        return false;
      turtles_args that = (turtles_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetFoo(), that.isSetFoo(), this.foo, that.foo)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {foo});
    }

    @Override
    public int compareTo(turtles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetFoo()).compareTo(other.isSetFoo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(foo, other.foo);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          case FOO:
            if (__field.type == TType.LIST) {
              {
                TList _list65 = iprot.readListBegin();
                this.foo = new ArrayList<List<Map<Integer,Map<Integer,Set<Integer>>>>>(Math.max(0, _list65.size));
                for (int _i66 = 0; 
                     (_list65.size < 0) ? iprot.peekList() : (_i66 < _list65.size); 
                     ++_i66)
                {
                  List<Map<Integer,Map<Integer,Set<Integer>>>> _elem67;
                  {
                    TList _list68 = iprot.readListBegin();
                    _elem67 = new ArrayList<Map<Integer,Map<Integer,Set<Integer>>>>(Math.max(0, _list68.size));
                    for (int _i69 = 0; 
                         (_list68.size < 0) ? iprot.peekList() : (_i69 < _list68.size); 
                         ++_i69)
                    {
                      Map<Integer,Map<Integer,Set<Integer>>> _elem70;
                      {
                        TMap _map71 = iprot.readMapBegin();
                        _elem70 = new HashMap<Integer,Map<Integer,Set<Integer>>>(Math.max(0, 2*_map71.size));
                        for (int _i72 = 0; 
                             (_map71.size < 0) ? iprot.peekMap() : (_i72 < _map71.size); 
                             ++_i72)
                        {
                          int _key73;
                          Map<Integer,Set<Integer>> _val74;
                          _key73 = iprot.readI32();
                          {
                            TMap _map75 = iprot.readMapBegin();
                            _val74 = new HashMap<Integer,Set<Integer>>(Math.max(0, 2*_map75.size));
                            for (int _i76 = 0; 
                                 (_map75.size < 0) ? iprot.peekMap() : (_i76 < _map75.size); 
                                 ++_i76)
                            {
                              int _key77;
                              Set<Integer> _val78;
                              _key77 = iprot.readI32();
                              {
                                TSet _set79 = iprot.readSetBegin();
                                _val78 = new HashSet<Integer>(Math.max(0, 2*_set79.size));
                                for (int _i80 = 0; 
                                     (_set79.size < 0) ? iprot.peekSet() : (_i80 < _set79.size); 
                                     ++_i80)
                                {
                                  int _elem81;
                                  _elem81 = iprot.readI32();
                                  _val78.add(_elem81);
                                }
                                iprot.readSetEnd();
                              }
                              _val74.put(_key77, _val78);
                            }
                            iprot.readMapEnd();
                          }
                          _elem70.put(_key73, _val74);
                        }
                        iprot.readMapEnd();
                      }
                      _elem67.add(_elem70);
                    }
                    iprot.readListEnd();
                  }
                  this.foo.add(_elem67);
                }
                iprot.readListEnd();
              }
            } else {
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.foo != null) {
        oprot.writeFieldBegin(FOO_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.foo.size()));
          for (List<Map<Integer,Map<Integer,Set<Integer>>>> _iter82 : this.foo)          {
            {
              oprot.writeListBegin(new TList(TType.MAP, _iter82.size()));
              for (Map<Integer,Map<Integer,Set<Integer>>> _iter83 : _iter82)              {
                {
                  oprot.writeMapBegin(new TMap(TType.I32, TType.MAP, _iter83.size()));
                  for (Map.Entry<Integer, Map<Integer,Set<Integer>>> _iter84 : _iter83.entrySet())                  {
                    oprot.writeI32(_iter84.getKey());
                    {
                      oprot.writeMapBegin(new TMap(TType.I32, TType.SET, _iter84.getValue().size()));
                      for (Map.Entry<Integer, Set<Integer>> _iter85 : _iter84.getValue().entrySet())                      {
                        oprot.writeI32(_iter85.getKey());
                        {
                          oprot.writeSetBegin(new TSet(TType.I32, _iter85.getValue().size()));
                          for (int _iter86 : _iter85.getValue())                          {
                            oprot.writeI32(_iter86);
                          }
                          oprot.writeSetEnd();
                        }
                      }
                      oprot.writeMapEnd();
                    }
                  }
                  oprot.writeMapEnd();
                }
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("turtles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("foo");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getFoo() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getFoo(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class turtles_result implements TBase, java.io.Serializable, Cloneable, Comparable<turtles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("turtles_result");

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(turtles_result.class, metaDataMap);
    }

    public turtles_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public turtles_result(turtles_result other) {
    }

    public turtles_result deepCopy() {
      return new turtles_result(this);
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof turtles_result))
        return false;
      turtles_result that = (turtles_result)_that;

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {});
    }

    @Override
    public int compareTo(turtles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) {
          break;
        }
        switch (__field.id)
        {
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("turtles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
