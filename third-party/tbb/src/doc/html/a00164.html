<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>tbb::task_scheduler_init Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00249.html">tbb</a></li><li class="navelem"><a class="el" href="a00164.html">task_scheduler_init</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="a00324.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tbb::task_scheduler_init Class Reference<div class="ingroups"><a class="el" href="a00276.html">Task Scheduling</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class delimiting the scope of task scheduler activity.  
 <a href="a00164.html#details">More...</a></p>

<p><code>#include &lt;task_scheduler_init.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tbb::task_scheduler_init:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00164.png" usemap="#tbb::task_scheduler_init_map" alt=""/>
  <map id="tbb::task_scheduler_init_map" name="tbb::task_scheduler_init_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a485028b867bffef5829209330e79e64c"><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#a485028b867bffef5829209330e79e64c">initialize</a> (int number_of_threads=<a class="el" href="a00164.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a>)</td></tr>
<tr class="memdesc:a485028b867bffef5829209330e79e64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that scheduler exists for this thread.  <a href="#a485028b867bffef5829209330e79e64c">More...</a><br/></td></tr>
<tr class="separator:a485028b867bffef5829209330e79e64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5294f74b123a646a1762c68d11e39a"><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#a0f5294f74b123a646a1762c68d11e39a">initialize</a> (int number_of_threads, stack_size_type thread_stack_size)</td></tr>
<tr class="memdesc:a0f5294f74b123a646a1762c68d11e39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The overloaded method with stack size parameter.  <a href="#a0f5294f74b123a646a1762c68d11e39a">More...</a><br/></td></tr>
<tr class="separator:a0f5294f74b123a646a1762c68d11e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d5dca7f79c5769bb96f674e4da0c04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15d5dca7f79c5769bb96f674e4da0c04"></a>
void __TBB_EXPORTED_METHOD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#a15d5dca7f79c5769bb96f674e4da0c04">terminate</a> ()</td></tr>
<tr class="memdesc:a15d5dca7f79c5769bb96f674e4da0c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of method initialize. <br/></td></tr>
<tr class="separator:a15d5dca7f79c5769bb96f674e4da0c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae261cf6c54a3689ef4e2c079fe0f67d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae261cf6c54a3689ef4e2c079fe0f67d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#ae261cf6c54a3689ef4e2c079fe0f67d0">blocking_terminate</a> ()</td></tr>
<tr class="memdesc:ae261cf6c54a3689ef4e2c079fe0f67d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00164.html#a15d5dca7f79c5769bb96f674e4da0c04" title="Inverse of method initialize. ">terminate()</a> that waits for worker threads termination. Throws exception on error. <br/></td></tr>
<tr class="separator:ae261cf6c54a3689ef4e2c079fe0f67d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2721ff874fb21f97b470d14a5ec151f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2721ff874fb21f97b470d14a5ec151f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#a2721ff874fb21f97b470d14a5ec151f3">blocking_terminate</a> (const std::nothrow_t &amp;) __TBB_NOEXCEPT(true)</td></tr>
<tr class="memdesc:a2721ff874fb21f97b470d14a5ec151f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00164.html#a15d5dca7f79c5769bb96f674e4da0c04" title="Inverse of method initialize. ">terminate()</a> that waits for worker threads termination. Returns false on error. <br/></td></tr>
<tr class="separator:a2721ff874fb21f97b470d14a5ec151f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2657d9b7c39fede2d19507d0e94688"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2657d9b7c39fede2d19507d0e94688"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#a8b2657d9b7c39fede2d19507d0e94688">task_scheduler_init</a> (int number_of_threads=<a class="el" href="a00164.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a>, stack_size_type thread_stack_size=0)</td></tr>
<tr class="memdesc:a8b2657d9b7c39fede2d19507d0e94688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for default constructor followed by call to initialize(number_of_threads). <br/></td></tr>
<tr class="separator:a8b2657d9b7c39fede2d19507d0e94688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b121334ec39c1d91bd4fe9a51892b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20b121334ec39c1d91bd4fe9a51892b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#a20b121334ec39c1d91bd4fe9a51892b0">~task_scheduler_init</a> ()</td></tr>
<tr class="memdesc:a20b121334ec39c1d91bd4fe9a51892b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy scheduler for this thread if thread has no other live task_scheduler_inits. <br/></td></tr>
<tr class="separator:a20b121334ec39c1d91bd4fe9a51892b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5505d7fed9d5493676aa15c176512c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed5505d7fed9d5493676aa15c176512c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#aed5505d7fed9d5493676aa15c176512c">is_active</a> () const </td></tr>
<tr class="memdesc:aed5505d7fed9d5493676aa15c176512c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if scheduler is active (initialized); false otherwise. <br/></td></tr>
<tr class="separator:aed5505d7fed9d5493676aa15c176512c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa0c0d46ec09bedc1ee876aa8aa87c3d1"><td class="memItemLeft" align="right" valign="top">static int __TBB_EXPORTED_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#aa0c0d46ec09bedc1ee876aa8aa87c3d1">default_num_threads</a> ()</td></tr>
<tr class="memdesc:aa0c0d46ec09bedc1ee876aa8aa87c3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads TBB scheduler would create if initialized by default.  <a href="#aa0c0d46ec09bedc1ee876aa8aa87c3d1">More...</a><br/></td></tr>
<tr class="separator:aa0c0d46ec09bedc1ee876aa8aa87c3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a945886f5ef48300a8ebff2d077c166b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a945886f5ef48300a8ebff2d077c166b1"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a> = -1</td></tr>
<tr class="memdesc:a945886f5ef48300a8ebff2d077c166b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for number of threads that is automatic. <br/></td></tr>
<tr class="separator:a945886f5ef48300a8ebff2d077c166b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e49ff2f59a4e53c9c07897b57f084d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e49ff2f59a4e53c9c07897b57f084d"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html#af0e49ff2f59a4e53c9c07897b57f084d">deferred</a> = -2</td></tr>
<tr class="memdesc:af0e49ff2f59a4e53c9c07897b57f084d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument to <a class="el" href="a00164.html#a485028b867bffef5829209330e79e64c" title="Ensure that scheduler exists for this thread. ">initialize()</a> or constructor that causes initialization to be deferred. <br/></td></tr>
<tr class="separator:af0e49ff2f59a4e53c9c07897b57f084d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class delimiting the scope of task scheduler activity. </p>
<p>A thread can construct a <a class="el" href="a00164.html" title="Class delimiting the scope of task scheduler activity. ">task_scheduler_init</a> object and keep it alive while it uses TBB's tasking subsystem (including parallel algorithms).</p>
<p>This class allows to customize properties of the TBB task pool to some extent. For example it can limit concurrency level of parallel work initiated by the given thread. It also can be used to specify stack size of the TBB worker threads, though this setting is not effective if the thread pool has already been created.</p>
<p>If a parallel construct is used without <a class="el" href="a00164.html" title="Class delimiting the scope of task scheduler activity. ">task_scheduler_init</a> object previously created, the scheduler will be initialized automatically with default settings, and will persist until this thread exits. Default concurrency level is defined as described in <a class="el" href="a00164.html#a485028b867bffef5829209330e79e64c" title="Ensure that scheduler exists for this thread. ">task_scheduler_init::initialize()</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa0c0d46ec09bedc1ee876aa8aa87c3d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int __TBB_EXPORTED_FUNC tbb::task_scheduler_init::default_num_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of threads TBB scheduler would create if initialized by default. </p>
<p>Result returned by this method does not depend on whether the scheduler has already been initialized.</p>
<p>Because tbb 2.0 does not support blocking tasks yet, you may use this method to boost the number of threads in the tbb's internal pool, if your tasks are doing I/O operations. The optimal number of additional threads depends on how much time your tasks spend in the blocked state.</p>
<p>Before TBB 3.0 U4 this method returned the number of logical CPU in the system. Currently on Windows, Linux and FreeBSD it returns the number of logical CPUs available to the current process in accordance with its affinity mask.</p>
<p>NOTE: The return value of this method never changes after its first invocation. This means that changes in the process affinity mask that took place after this method was first invoked will not affect the number of worker threads in the TBB worker threads pool. </p>

</div>
</div>
<a class="anchor" id="a485028b867bffef5829209330e79e64c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_scheduler_init::initialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_threads</em> = <code><a class="el" href="a00164.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that scheduler exists for this thread. </p>
<p>A value of -1 lets TBB decide on the number of threads, which is usually maximal hardware concurrency for this process, that is the number of logical CPUs on the machine (possibly limited by the processor affinity mask of this process (Windows) or of this thread (Linux, FreeBSD). It is preferable option for production code because it helps to avoid nasty surprises when several TBB based components run side-by-side or in a nested fashion inside the same process.</p>
<p>The number_of_threads is ignored if any other task_scheduler_inits currently exist. A thread may construct multiple task_scheduler_inits. Doing so does no harm because the underlying scheduler is reference counted. </p>

<p>Referenced by <a class="el" href="a00164.html#a8b2657d9b7c39fede2d19507d0e94688">task_scheduler_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f5294f74b123a646a1762c68d11e39a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_scheduler_init::initialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack_size_type&#160;</td>
          <td class="paramname"><em>thread_stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The overloaded method with stack size parameter. </p>
<p>Overloading is necessary to preserve ABI compatibility </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>task_scheduler_init.h</li>
</ul>
</div><!-- contents -->
<hr>
<p></p>
Copyright &copy; 2005-2018 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
