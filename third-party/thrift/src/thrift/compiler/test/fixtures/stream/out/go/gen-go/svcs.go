// Autogenerated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "context"
    "errors"
    "fmt"
    "io"
    "reflect"
    "sync"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = io.EOF
var _ = reflect.Ptr
var _ = sync.OnceFunc
var _ = thrift.VOID
var _ = metadata.GoUnusedProtection__


type PubSubStreamingService interface {
    Returnstream(ctx context.Context, i32From int32, i32To int32) (func(context.Context, chan<- int32) error, error)
    Streamthrows(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Servicethrows(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Servicethrows2(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Boththrows(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Responseandstreamstreamthrows(ctx context.Context, foo int32) (int32, func(context.Context, chan<- int32) error, error)
    Responseandstreamservicethrows(ctx context.Context, foo int32) (int32, func(context.Context, chan<- int32) error, error)
    Responseandstreamboththrows(ctx context.Context, foo int32) (int32, func(context.Context, chan<- int32) error, error)
    ReturnstreamFast(ctx context.Context, i32From int32, i32To int32) (func(context.Context, chan<- int32) error, error)
}

type PubSubStreamingServiceClient interface {
    io.Closer
    Returnstream(ctx context.Context, i32From int32, i32To int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    Streamthrows(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    Servicethrows(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    Servicethrows2(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    Boththrows(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    Responseandstreamstreamthrows(ctx context.Context, foo int32) (int32, <-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    Responseandstreamservicethrows(ctx context.Context, foo int32) (int32, <-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    Responseandstreamboththrows(ctx context.Context, foo int32) (int32, <-chan int32 /* elem stream */, <-chan error /* stream err */, error)
    ReturnstreamFast(ctx context.Context, i32From int32, i32To int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error)
}

type pubSubStreamingServiceClientImpl struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ PubSubStreamingServiceClient = (*pubSubStreamingServiceClientImpl)(nil)

func NewPubSubStreamingServiceChannelClient(channel thrift.RequestChannel) PubSubStreamingServiceClient {
    return &pubSubStreamingServiceClientImpl{
        ch: channel,
    }
}

func (c *pubSubStreamingServiceClientImpl) Close() error {
    return c.ch.Close()
}

func (c *pubSubStreamingServiceClientImpl) Returnstream(ctx context.Context, i32From int32, i32To int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceReturnstream{
        I32From: i32From,
        I32To: i32To,
    }
    fbthriftResp := newRespPubSubStreamingServiceReturnstream()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceReturnstream()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "returnstream",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftEx
    }
    return fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) Streamthrows(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceStreamthrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceStreamthrows()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceStreamthrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "streamthrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftEx
    }
    return fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) Servicethrows(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceServicethrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceServicethrows()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceServicethrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "servicethrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftEx
    }
    return fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) Servicethrows2(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceServicethrows2{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceServicethrows2()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceServicethrows2()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "servicethrows2",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftEx
    }
    return fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) Boththrows(ctx context.Context, foo int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceBoththrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceBoththrows()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceBoththrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "boththrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftEx
    }
    return fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) Responseandstreamstreamthrows(ctx context.Context, foo int32) (int32, <-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    var fbthriftRespZero int32
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return fbthriftRespZero, nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceResponseandstreamstreamthrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceResponseandstreamstreamthrows()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceResponseandstreamstreamthrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "responseandstreamstreamthrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) Responseandstreamservicethrows(ctx context.Context, foo int32) (int32, <-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    var fbthriftRespZero int32
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return fbthriftRespZero, nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceResponseandstreamservicethrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceResponseandstreamservicethrows()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceResponseandstreamservicethrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "responseandstreamservicethrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) Responseandstreamboththrows(ctx context.Context, foo int32) (int32, <-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    var fbthriftRespZero int32
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return fbthriftRespZero, nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceResponseandstreamboththrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceResponseandstreamboththrows()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceResponseandstreamboththrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "responseandstreamboththrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), fbthriftElemChan, fbthriftErrChan, nil
}

func (c *pubSubStreamingServiceClientImpl) ReturnstreamFast(ctx context.Context, i32From int32, i32To int32) (<-chan int32 /* elem stream */, <-chan error /* stream err */, error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceReturnstreamFast{
        I32From: i32From,
        I32To: i32To,
    }
    fbthriftResp := newRespPubSubStreamingServiceReturnstreamFast()

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceReturnstreamFast()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    fbthriftErr := c.ch.SendRequestStream(
        fbthriftStreamCtx,
        "returnstreamFast",
        fbthriftReq,
        fbthriftResp,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, nil, fbthriftEx
    }
    return fbthriftElemChan, fbthriftErrChan, nil
}


type PubSubStreamingServiceProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler              PubSubStreamingService
}

func NewPubSubStreamingServiceProcessor(handler PubSubStreamingService) *PubSubStreamingServiceProcessor {
    p := &PubSubStreamingServiceProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("returnstream", &procFuncPubSubStreamingServiceReturnstream{handler: handler})
    p.AddToProcessorFunctionMap("streamthrows", &procFuncPubSubStreamingServiceStreamthrows{handler: handler})
    p.AddToProcessorFunctionMap("servicethrows", &procFuncPubSubStreamingServiceServicethrows{handler: handler})
    p.AddToProcessorFunctionMap("servicethrows2", &procFuncPubSubStreamingServiceServicethrows2{handler: handler})
    p.AddToProcessorFunctionMap("boththrows", &procFuncPubSubStreamingServiceBoththrows{handler: handler})
    p.AddToProcessorFunctionMap("responseandstreamstreamthrows", &procFuncPubSubStreamingServiceResponseandstreamstreamthrows{handler: handler})
    p.AddToProcessorFunctionMap("responseandstreamservicethrows", &procFuncPubSubStreamingServiceResponseandstreamservicethrows{handler: handler})
    p.AddToProcessorFunctionMap("responseandstreamboththrows", &procFuncPubSubStreamingServiceResponseandstreamboththrows{handler: handler})
    p.AddToProcessorFunctionMap("returnstreamFast", &procFuncPubSubStreamingServiceReturnstreamFast{handler: handler})
    p.AddToFunctionServiceMap("returnstream", "PubSubStreamingService")
    p.AddToFunctionServiceMap("streamthrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("servicethrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("servicethrows2", "PubSubStreamingService")
    p.AddToFunctionServiceMap("boththrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("responseandstreamstreamthrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("responseandstreamservicethrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("responseandstreamboththrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("returnstreamFast", "PubSubStreamingService")

    return p
}

func (p *PubSubStreamingServiceProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *PubSubStreamingServiceProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *PubSubStreamingServiceProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *PubSubStreamingServiceProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *PubSubStreamingServiceProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *PubSubStreamingServiceProcessor) PackageName() string {
    return "module"
}

func (p *PubSubStreamingServiceProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.PubSubStreamingService")
}


type procFuncPubSubStreamingServiceReturnstream struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceReturnstream)(nil)

func (p *procFuncPubSubStreamingServiceReturnstream) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceReturnstream()
}

func (p *procFuncPubSubStreamingServiceReturnstream) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceStreamthrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceStreamthrows)(nil)

func (p *procFuncPubSubStreamingServiceStreamthrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceStreamthrows()
}

func (p *procFuncPubSubStreamingServiceStreamthrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceServicethrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceServicethrows)(nil)

func (p *procFuncPubSubStreamingServiceServicethrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceServicethrows()
}

func (p *procFuncPubSubStreamingServiceServicethrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceServicethrows2 struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceServicethrows2)(nil)

func (p *procFuncPubSubStreamingServiceServicethrows2) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceServicethrows2()
}

func (p *procFuncPubSubStreamingServiceServicethrows2) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceBoththrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceBoththrows)(nil)

func (p *procFuncPubSubStreamingServiceBoththrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceBoththrows()
}

func (p *procFuncPubSubStreamingServiceBoththrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceResponseandstreamstreamthrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceResponseandstreamstreamthrows)(nil)

func (p *procFuncPubSubStreamingServiceResponseandstreamstreamthrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceResponseandstreamstreamthrows()
}

func (p *procFuncPubSubStreamingServiceResponseandstreamstreamthrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceResponseandstreamservicethrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceResponseandstreamservicethrows)(nil)

func (p *procFuncPubSubStreamingServiceResponseandstreamservicethrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceResponseandstreamservicethrows()
}

func (p *procFuncPubSubStreamingServiceResponseandstreamservicethrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceResponseandstreamboththrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceResponseandstreamboththrows)(nil)

func (p *procFuncPubSubStreamingServiceResponseandstreamboththrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceResponseandstreamboththrows()
}

func (p *procFuncPubSubStreamingServiceResponseandstreamboththrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


type procFuncPubSubStreamingServiceReturnstreamFast struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceReturnstreamFast)(nil)

func (p *procFuncPubSubStreamingServiceReturnstreamFast) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceReturnstreamFast()
}

func (p *procFuncPubSubStreamingServiceReturnstreamFast) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, thrift.NewApplicationException(thrift.INTERNAL_ERROR, "not supported")
}


