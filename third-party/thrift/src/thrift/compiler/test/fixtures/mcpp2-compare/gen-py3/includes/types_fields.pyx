#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cython.operator cimport dereference as deref
from libcpp.memory cimport make_unique, unique_ptr, shared_ptr
from thrift.py3.types cimport assign_unique_ptr, assign_shared_ptr, assign_shared_const_ptr

cimport thrift.py3.types
from thrift.py3.types cimport (
    reset_field as __reset_field,
    StructFieldsSetter as __StructFieldsSetter
)

from thrift.py3.types cimport const_pointer_cast, BadEnum as _fbthrift_BadEnum


@__cython.auto_pickle(False)
cdef class __AStruct_FieldsSetter(__StructFieldsSetter):

    @staticmethod
    cdef __AStruct_FieldsSetter _fbthrift_create(_includes_types.cAStruct* struct_cpp_obj):
        cdef __AStruct_FieldsSetter __fbthrift_inst = __AStruct_FieldsSetter.__new__(__AStruct_FieldsSetter)
        __fbthrift_inst._struct_cpp_obj = struct_cpp_obj
        __fbthrift_inst._setters[__cstring_view(<const char*>"FieldA")] = __AStruct_FieldsSetter._set_field_0
        return __fbthrift_inst

    cdef void set_field(__AStruct_FieldsSetter self, const char* name, object value) except *:
        cdef __cstring_view cname = __cstring_view(name)
        cdef cumap[__cstring_view, __AStruct_FieldsSetterFunc].iterator found = self._setters.find(cname)
        if found == self._setters.end():
            raise TypeError(f"invalid field name {name.decode('utf-8')}")
        deref(found).second(self, value)

    cdef void _set_field_0(self, _fbthrift_value) except *:
        # for field FieldA
        if _fbthrift_value is None:
            __reset_field[_includes_types.cAStruct](deref(self._struct_cpp_obj), 0)
            return
        if not isinstance(_fbthrift_value, int):
            raise TypeError(f'FieldA is not a { int !r}.')
        _fbthrift_value = <cint32_t> _fbthrift_value
        deref(self._struct_cpp_obj).FieldA_ref().assign(_fbthrift_value)


@__cython.auto_pickle(False)
cdef class __AStructB_FieldsSetter(__StructFieldsSetter):

    @staticmethod
    cdef __AStructB_FieldsSetter _fbthrift_create(_includes_types.cAStructB* struct_cpp_obj):
        cdef __AStructB_FieldsSetter __fbthrift_inst = __AStructB_FieldsSetter.__new__(__AStructB_FieldsSetter)
        __fbthrift_inst._struct_cpp_obj = struct_cpp_obj
        __fbthrift_inst._setters[__cstring_view(<const char*>"FieldA")] = __AStructB_FieldsSetter._set_field_0
        return __fbthrift_inst

    cdef void set_field(__AStructB_FieldsSetter self, const char* name, object value) except *:
        cdef __cstring_view cname = __cstring_view(name)
        cdef cumap[__cstring_view, __AStructB_FieldsSetterFunc].iterator found = self._setters.find(cname)
        if found == self._setters.end():
            raise TypeError(f"invalid field name {name.decode('utf-8')}")
        deref(found).second(self, value)

    cdef void _set_field_0(self, _fbthrift_value) except *:
        # for field FieldA
        if _fbthrift_value is None:
            __reset_field[_includes_types.cAStructB](deref(self._struct_cpp_obj), 0)
            return
        if not isinstance(_fbthrift_value, _includes_types.AStruct):
            raise TypeError(f'FieldA is not a { _includes_types.AStruct !r}.')
        assign_shared_const_ptr[_includes_types.cAStruct](deref(self._struct_cpp_obj).FieldA_ref(), const_pointer_cast((<_includes_types.AStruct?>_fbthrift_value)._cpp_obj))

