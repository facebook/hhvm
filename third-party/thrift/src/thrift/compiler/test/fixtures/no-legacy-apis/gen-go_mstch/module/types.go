// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package module // [[[ program thrift source path ]]]

import (
    "fmt"
    "strings"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)


// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = thrift.ZERO
var _ = strings.Split


type MyEnum int32

const (
    MyEnum_MyValue1 MyEnum = 0
    MyEnum_MyValue2 MyEnum = 1
)

// Enum value maps for MyEnum
var (
    MyEnumToName = map[MyEnum]string {
        MyEnum_MyValue1: "MyValue1",
        MyEnum_MyValue2: "MyValue2",
    }

    MyEnumToValue = map[string]MyEnum {
        "MyValue1": MyEnum_MyValue1,
        "MyValue2": MyEnum_MyValue2,
    }

    MyEnumNames = []string{
        "MyValue1",
        "MyValue2",
    }

    MyEnumValues = []MyEnum{
        MyEnum_MyValue1,
        MyEnum_MyValue2,
    }
)

func (x MyEnum) String() string {
    if v, ok := MyEnumToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x MyEnum) Ptr() *MyEnum {
    return &x
}

// Deprecated: Use MyEnumToValue instead (e.g. `x, ok := MyEnumToValue["name"]`).
func MyEnumFromString(s string) (MyEnum, error) {
    if v, ok := MyEnumToValue[s]; ok {
        return v, nil
    }
    return MyEnum(0), fmt.Errorf("not a valid MyEnum string")
}

// Deprecated: Use MyEnum.Ptr() instead.
func MyEnumPtr(v MyEnum) *MyEnum {
    return &v
}


type MyStruct struct {
    MyIntField int64 `thrift:"myIntField,1" json:"myIntField" db:"myIntField"`
    MyStringField string `thrift:"myStringField,2" json:"myStringField" db:"myStringField"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MyStruct{}

func NewMyStruct() *MyStruct {
    return (&MyStruct{}).
        SetMyIntFieldNonCompat(0).
        SetMyStringFieldNonCompat("")
}

func (x *MyStruct) GetMyIntFieldNonCompat() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyStringFieldNonCompat() string {
    return x.MyStringField
}

func (x *MyStruct) GetMyStringField() string {
    return x.MyStringField
}

func (x *MyStruct) SetMyIntFieldNonCompat(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyIntField(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyStringFieldNonCompat(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMyStringField(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) writeField1(p thrift.Protocol) error {  // MyIntField
    if err := p.WriteFieldBegin("myIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyIntFieldNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField2(p thrift.Protocol) error {  // MyStringField
    if err := p.WriteFieldBegin("myStringField", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyStringFieldNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) readField1(p thrift.Protocol) error {  // MyIntField
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetMyIntFieldNonCompat(result)
    return nil
}

func (x *MyStruct) readField2(p thrift.Protocol) error {  // MyStringField
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetMyStringFieldNonCompat(result)
    return nil
}

func (x *MyStruct) toString1() string {  // MyIntField
    return fmt.Sprintf("%v", x.GetMyIntFieldNonCompat())
}

func (x *MyStruct) toString2() string {  // MyStringField
    return fmt.Sprintf("%v", x.GetMyStringFieldNonCompat())
}


// Deprecated: Use MyStruct.Set* methods instead or set the fields directly.
type MyStructBuilder struct {
    obj *MyStruct
}

func NewMyStructBuilder() *MyStructBuilder {
    return &MyStructBuilder{
        obj: NewMyStruct(),
    }
}

func (x *MyStructBuilder) MyIntField(value int64) *MyStructBuilder {
    x.obj.MyIntField = value
    return x
}

func (x *MyStructBuilder) MyStringField(value string) *MyStructBuilder {
    x.obj.MyStringField = value
    return x
}

func (x *MyStructBuilder) Emit() *MyStruct {
    var objCopy MyStruct = *x.obj
    return &objCopy
}

func (x *MyStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MyStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // myIntField
            expectedType := thrift.Type(thrift.I64)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // myStringField
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }
    }

    if err := p.ReadFieldEnd(); err != nil {
        return err
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyStruct({")
    sb.WriteString(fmt.Sprintf("MyIntField:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("MyStringField:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type MyUnion struct {
    MyEnum *MyEnum `thrift:"myEnum,1" json:"myEnum,omitempty" db:"myEnum"`
    MyDataItem *MyStruct `thrift:"myDataItem,2" json:"myDataItem,omitempty" db:"myDataItem"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MyUnion{}

func NewMyUnion() *MyUnion {
    return (&MyUnion{})
}

func (x *MyUnion) GetMyEnumNonCompat() *MyEnum {
    return x.MyEnum
}

func (x *MyUnion) GetMyEnum() MyEnum {
    if !x.IsSetMyEnum() {
        return 0
    }

    return *x.MyEnum
}

func (x *MyUnion) GetMyDataItemNonCompat() *MyStruct {
    return x.MyDataItem
}

func (x *MyUnion) GetMyDataItem() *MyStruct {
    if !x.IsSetMyDataItem() {
        return nil
    }

    return x.MyDataItem
}

func (x *MyUnion) SetMyEnumNonCompat(value MyEnum) *MyUnion {
    x.MyEnum = &value
    return x
}

func (x *MyUnion) SetMyEnum(value *MyEnum) *MyUnion {
    x.MyEnum = value
    return x
}

func (x *MyUnion) SetMyDataItemNonCompat(value MyStruct) *MyUnion {
    x.MyDataItem = &value
    return x
}

func (x *MyUnion) SetMyDataItem(value *MyStruct) *MyUnion {
    x.MyDataItem = value
    return x
}

func (x *MyUnion) IsSetMyEnum() bool {
    return x.MyEnum != nil
}

func (x *MyUnion) IsSetMyDataItem() bool {
    return x.MyDataItem != nil
}

func (x *MyUnion) writeField1(p thrift.Protocol) error {  // MyEnum
    if !x.IsSetMyEnum() {
        return nil
    }

    if err := p.WriteFieldBegin("myEnum", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetMyEnumNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyUnion) writeField2(p thrift.Protocol) error {  // MyDataItem
    if !x.IsSetMyDataItem() {
        return nil
    }

    if err := p.WriteFieldBegin("myDataItem", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyDataItemNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyUnion) readField1(p thrift.Protocol) error {  // MyEnum
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := MyEnum(enumResult)

    x.SetMyEnumNonCompat(result)
    return nil
}

func (x *MyUnion) readField2(p thrift.Protocol) error {  // MyDataItem
    result := *NewMyStruct()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetMyDataItemNonCompat(result)
    return nil
}

func (x *MyUnion) toString1() string {  // MyEnum
    if x.IsSetMyEnum() {
        return fmt.Sprintf("%v", *x.GetMyEnumNonCompat())
    }
    return fmt.Sprintf("%v", x.GetMyEnumNonCompat())
}

func (x *MyUnion) toString2() string {  // MyDataItem
    return fmt.Sprintf("%v", x.GetMyDataItemNonCompat())
}

// Deprecated: Use NewMyUnion().GetMyEnum() instead.
var MyUnion_MyEnum_DEFAULT = NewMyUnion().GetMyEnum()

// Deprecated: Use NewMyUnion().GetMyDataItem() instead.
var MyUnion_MyDataItem_DEFAULT = NewMyUnion().GetMyDataItem()

// Deprecated: Use NewMyUnion().GetMyDataItem() instead.
func (x *MyUnion) DefaultGetMyDataItem() *MyStruct {
    if !x.IsSetMyDataItem() {
        return NewMyStruct()
    }
    return x.MyDataItem
}

func (x *MyUnion) countSetFields() int {
    count := int(0)
    if (x.IsSetMyEnum()) {
        count++
    }
    if (x.IsSetMyDataItem()) {
        count++
    }
    return count
}

func (x *MyUnion) CountSetFieldsMyUnion() int {
    return x.countSetFields()
}


// Deprecated: Use MyUnion.Set* methods instead or set the fields directly.
type MyUnionBuilder struct {
    obj *MyUnion
}

func NewMyUnionBuilder() *MyUnionBuilder {
    return &MyUnionBuilder{
        obj: NewMyUnion(),
    }
}

func (x *MyUnionBuilder) MyEnum(value *MyEnum) *MyUnionBuilder {
    x.obj.MyEnum = value
    return x
}

func (x *MyUnionBuilder) MyDataItem(value *MyStruct) *MyUnionBuilder {
    x.obj.MyDataItem = value
    return x
}

func (x *MyUnionBuilder) Emit() *MyUnion {
    var objCopy MyUnion = *x.obj
    return &objCopy
}

func (x *MyUnion) Write(p thrift.Protocol) error {
    if countSet := x.countSetFields(); countSet > 1 {
        return fmt.Errorf("%T write union: no more than one field must be set (%d set).", x, countSet)
    }
    if err := p.WriteStructBegin("MyUnion"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyUnion) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // myEnum
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // myDataItem
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }
    }

    if err := p.ReadFieldEnd(); err != nil {
        return err
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyUnion) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyUnion({")
    sb.WriteString(fmt.Sprintf("MyEnum:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("MyDataItem:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
	  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("test.dev/fixtures/no-legacy-apis/MyStruct", func() any { return NewMyStruct() })
    registry.RegisterType("test.dev/fixtures/no-legacy-apis/MyUnion", func() any { return NewMyUnion() })

    registry.RegisterType("test.dev/fixtures/no-legacy-apis/MyEnum", func() any { return MyEnum(0) })
}
