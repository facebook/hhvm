/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/basic-annotations/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



namespace apache {
namespace thrift {
namespace ident {
struct name;
struct majorVer;
struct abstract;
struct annotation_with_quote;
struct class_;
struct annotation_with_trailing_comma;
struct empty_annotations;
struct my_enum;
struct cpp_type_annotation;
struct my_union;
struct id;
struct password;
} // namespace ident
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_majorVer
#define APACHE_THRIFT_ACCESSOR_majorVer
APACHE_THRIFT_DEFINE_ACCESSOR(majorVer);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_abstract
#define APACHE_THRIFT_ACCESSOR_abstract
APACHE_THRIFT_DEFINE_ACCESSOR(abstract);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotation_with_quote
#define APACHE_THRIFT_ACCESSOR_annotation_with_quote
APACHE_THRIFT_DEFINE_ACCESSOR(annotation_with_quote);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_class_
#define APACHE_THRIFT_ACCESSOR_class_
APACHE_THRIFT_DEFINE_ACCESSOR(class_);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotation_with_trailing_comma
#define APACHE_THRIFT_ACCESSOR_annotation_with_trailing_comma
APACHE_THRIFT_DEFINE_ACCESSOR(annotation_with_trailing_comma);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_empty_annotations
#define APACHE_THRIFT_ACCESSOR_empty_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(empty_annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_my_enum
#define APACHE_THRIFT_ACCESSOR_my_enum
APACHE_THRIFT_DEFINE_ACCESSOR(my_enum);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cpp_type_annotation
#define APACHE_THRIFT_ACCESSOR_cpp_type_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(cpp_type_annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_my_union
#define APACHE_THRIFT_ACCESSOR_my_union
APACHE_THRIFT_DEFINE_ACCESSOR(my_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_password
#define APACHE_THRIFT_ACCESSOR_password
APACHE_THRIFT_DEFINE_ACCESSOR(password);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace cpp2 {

enum class YourEnum {
  MyValue1 = 0,
  MyValue2 = 1,
  REALM = 2,
};



} // cpp2

namespace std {
template<> struct hash<::cpp2::YourEnum> :
  ::apache::thrift::detail::enum_hash<::cpp2::YourEnum> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::cpp2::YourEnum>;

template <> struct TEnumTraits<::cpp2::YourEnum> {
  using type = ::cpp2::YourEnum;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static bool findName(type value, folly::StringPiece* out) noexcept;
  static bool findValue(folly::StringPiece name, type* out) noexcept;

#if FOLLY_HAS_STRING_VIEW
  static bool findName(type value, std::string_view* out) noexcept {
    folly::StringPiece outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
#endif
  static char const* findName(type value) noexcept {
    folly::StringPiece ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::MyValue1; }
  static constexpr type max() { return type::REALM; }
};


}} // apache::thrift


// END declare_enums
// BEGIN forward_declare
namespace cpp2 {
class MyStructNestedAnnotation;
namespace detail {
class YourUnion;
} // namespace detail
namespace detail {
class YourException;
} // namespace detail
namespace detail {
class YourStruct;
} // namespace detail
class SecretStruct;
} // cpp2
// END forward_declare
namespace apache::thrift::detail::annotation {
} // namespace apache::thrift::detail::annotation

namespace apache::thrift::detail::qualifier {
} // namespace apache::thrift::detail::qualifier

// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace cpp2 {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;


namespace detail {
class YourUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0};
  using __fbthrift_reflection_type_tags = folly::tag_t<
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 0;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = YourUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
  } ;

  YourUnion()
      : type_(folly::to_underlying(Type::__EMPTY__)) {}

  YourUnion(YourUnion&& rhs) noexcept
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  YourUnion(const YourUnion& rhs);

  YourUnion& operator=(YourUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  YourUnion& operator=(const YourUnion& rhs);


  union storage_type {

  } ;

  bool operator==(const YourUnion&) const;
  bool operator<(const YourUnion&) const;

  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<YourUnion>;
  friend void swap(YourUnion& a, YourUnion& b);
};

template <class Protocol_>
unsigned long YourUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}
} // namespace detail

using YourUnion = ::apache::thrift::adapt_detail::adapted_t<::StaticCast, ::cpp2::detail::YourUnion>;

typedef std::deque<std::string> list_string_6884;

namespace detail {
class YourStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const char* __fbthrift_thrift_uri();
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::majorVer,
    ::apache::thrift::ident::abstract,
    ::apache::thrift::ident::annotation_with_quote,
    ::apache::thrift::ident::class_,
    ::apache::thrift::ident::annotation_with_trailing_comma,
    ::apache::thrift::ident::empty_annotations,
    ::apache::thrift::ident::my_enum,
    ::apache::thrift::ident::cpp_type_annotation,
    ::apache::thrift::ident::my_union
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,2,1,3,4,5,6,7,8,9};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::enum_t<::cpp2::YourEnum>,
    ::apache::thrift::type::cpp_type<std::deque<std::string>, ::apache::thrift::type::list<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::adapted<::StaticCast, ::apache::thrift::type::union_t<::cpp2::detail::YourUnion>>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 9;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = YourStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  YourStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  YourStruct(apache::thrift::FragileConstructor, ::std::int64_t majorVer__arg, ::std::string abstract__arg, ::std::string annotation_with_quote__arg, ::std::string class___arg, ::std::string annotation_with_trailing_comma__arg, ::std::string empty_annotations__arg, ::cpp2::YourEnum my_enum__arg, ::cpp2::list_string_6884 cpp_type_annotation__arg, ::cpp2::YourUnion my_union__arg);

  YourStruct(YourStruct&&) noexcept;
  YourStruct(const YourStruct& src);


  YourStruct& operator=(YourStruct&&) noexcept;
  YourStruct& operator=(const YourStruct& src);

  ~YourStruct();

 private:
  ::std::int64_t __fbthrift_field_majorVer;
 private:
  ::std::string __fbthrift_field_abstract;
 private:
  ::std::string __fbthrift_field_annotation_with_quote;
 private:
  ::std::string __fbthrift_field_class_;
 private:
  ::std::string __fbthrift_field_annotation_with_trailing_comma;
 private:
  ::std::string __fbthrift_field_empty_annotations;
 private:
  ::cpp2::YourEnum __fbthrift_field_my_enum;
 private:
  ::cpp2::list_string_6884 __fbthrift_field_cpp_type_annotation;
 private:
  ::cpp2::YourUnion __fbthrift_field_my_union;
 private:
  apache::thrift::detail::isset_bitset<9, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const YourStruct&) const;
  bool operator<(const YourStruct&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> majorVer_ref() const& {
    return {this->__fbthrift_field_majorVer, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> majorVer_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_majorVer), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> majorVer_ref() & {
    return {this->__fbthrift_field_majorVer, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> majorVer_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_majorVer), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> majorVer() const& {
    return {this->__fbthrift_field_majorVer, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> majorVer() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_majorVer), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> majorVer() & {
    return {this->__fbthrift_field_majorVer, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> majorVer() && {
    return {static_cast<T&&>(this->__fbthrift_field_majorVer), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> abstract_ref() const& {
    return {this->__fbthrift_field_abstract, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> abstract_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_abstract), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> abstract_ref() & {
    return {this->__fbthrift_field_abstract, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> abstract_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_abstract), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> abstract() const& {
    return {this->__fbthrift_field_abstract, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> abstract() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_abstract), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> abstract() & {
    return {this->__fbthrift_field_abstract, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> abstract() && {
    return {static_cast<T&&>(this->__fbthrift_field_abstract), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> annotation_with_quote_ref() const& {
    return {this->__fbthrift_field_annotation_with_quote, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> annotation_with_quote_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_annotation_with_quote), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> annotation_with_quote_ref() & {
    return {this->__fbthrift_field_annotation_with_quote, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> annotation_with_quote_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_annotation_with_quote), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> annotation_with_quote() const& {
    return {this->__fbthrift_field_annotation_with_quote, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> annotation_with_quote() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_annotation_with_quote), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> annotation_with_quote() & {
    return {this->__fbthrift_field_annotation_with_quote, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> annotation_with_quote() && {
    return {static_cast<T&&>(this->__fbthrift_field_annotation_with_quote), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> class__ref() const& {
    return {this->__fbthrift_field_class_, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> class__ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_class_), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> class__ref() & {
    return {this->__fbthrift_field_class_, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> class__ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_class_), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> class_() const& {
    return {this->__fbthrift_field_class_, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> class_() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_class_), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> class_() & {
    return {this->__fbthrift_field_class_, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> class_() && {
    return {static_cast<T&&>(this->__fbthrift_field_class_), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> annotation_with_trailing_comma_ref() const& {
    return {this->__fbthrift_field_annotation_with_trailing_comma, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> annotation_with_trailing_comma_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_annotation_with_trailing_comma), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> annotation_with_trailing_comma_ref() & {
    return {this->__fbthrift_field_annotation_with_trailing_comma, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> annotation_with_trailing_comma_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_annotation_with_trailing_comma), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> annotation_with_trailing_comma() const& {
    return {this->__fbthrift_field_annotation_with_trailing_comma, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> annotation_with_trailing_comma() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_annotation_with_trailing_comma), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> annotation_with_trailing_comma() & {
    return {this->__fbthrift_field_annotation_with_trailing_comma, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> annotation_with_trailing_comma() && {
    return {static_cast<T&&>(this->__fbthrift_field_annotation_with_trailing_comma), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> empty_annotations_ref() const& {
    return {this->__fbthrift_field_empty_annotations, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> empty_annotations_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_empty_annotations), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> empty_annotations_ref() & {
    return {this->__fbthrift_field_empty_annotations, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> empty_annotations_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_empty_annotations), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> empty_annotations() const& {
    return {this->__fbthrift_field_empty_annotations, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> empty_annotations() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_empty_annotations), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> empty_annotations() & {
    return {this->__fbthrift_field_empty_annotations, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> empty_annotations() && {
    return {static_cast<T&&>(this->__fbthrift_field_empty_annotations), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> my_enum_ref() const& {
    return {this->__fbthrift_field_my_enum, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> my_enum_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_my_enum), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> my_enum_ref() & {
    return {this->__fbthrift_field_my_enum, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> my_enum_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_my_enum), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> my_enum() const& {
    return {this->__fbthrift_field_my_enum, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> my_enum() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_my_enum), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> my_enum() & {
    return {this->__fbthrift_field_my_enum, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::YourEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> my_enum() && {
    return {static_cast<T&&>(this->__fbthrift_field_my_enum), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cpp_type_annotation_ref() const& {
    return {this->__fbthrift_field_cpp_type_annotation, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cpp_type_annotation_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_cpp_type_annotation), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cpp_type_annotation_ref() & {
    return {this->__fbthrift_field_cpp_type_annotation, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cpp_type_annotation_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_cpp_type_annotation), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cpp_type_annotation() const& {
    return {this->__fbthrift_field_cpp_type_annotation, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cpp_type_annotation() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_cpp_type_annotation), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cpp_type_annotation() & {
    return {this->__fbthrift_field_cpp_type_annotation, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::list_string_6884>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cpp_type_annotation() && {
    return {static_cast<T&&>(this->__fbthrift_field_cpp_type_annotation), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> my_union_ref() const& {
    return {this->__fbthrift_field_my_union, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> my_union_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_my_union), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> my_union_ref() & {
    return {this->__fbthrift_field_my_union, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> my_union_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_my_union), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> my_union() const& {
    return {this->__fbthrift_field_my_union, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> my_union() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_my_union), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> my_union() & {
    return {this->__fbthrift_field_my_union, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::cpp2::YourUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> my_union() && {
    return {static_cast<T&&>(this->__fbthrift_field_my_union), __isset.at(8), __isset.bit(8)};
  }

  ::std::int64_t get_majorVer() const {
    return __fbthrift_field_majorVer;
  }

  [[deprecated("Use `FOO.majorVer_ref() = BAR;` instead of `FOO.set_majorVer(BAR);`")]]
  ::std::int64_t& set_majorVer(::std::int64_t majorVer_) {
    majorVer_ref() = majorVer_;
    return __fbthrift_field_majorVer;
  }

  const ::std::string& get_abstract() const& {
    return __fbthrift_field_abstract;
  }

  ::std::string get_abstract() && {
    return std::move(__fbthrift_field_abstract);
  }

  template <typename T_YourStruct_abstract_struct_setter = ::std::string>
  [[deprecated("Use `FOO.abstract_ref() = BAR;` instead of `FOO.set_abstract(BAR);`")]]
  ::std::string& set_abstract(T_YourStruct_abstract_struct_setter&& abstract_) {
    abstract_ref() = std::forward<T_YourStruct_abstract_struct_setter>(abstract_);
    return __fbthrift_field_abstract;
  }

  const ::std::string& get_annotation_with_quote() const& {
    return __fbthrift_field_annotation_with_quote;
  }

  ::std::string get_annotation_with_quote() && {
    return std::move(__fbthrift_field_annotation_with_quote);
  }

  template <typename T_YourStruct_annotation_with_quote_struct_setter = ::std::string>
  [[deprecated("Use `FOO.annotation_with_quote_ref() = BAR;` instead of `FOO.set_annotation_with_quote(BAR);`")]]
  ::std::string& set_annotation_with_quote(T_YourStruct_annotation_with_quote_struct_setter&& annotation_with_quote_) {
    annotation_with_quote_ref() = std::forward<T_YourStruct_annotation_with_quote_struct_setter>(annotation_with_quote_);
    return __fbthrift_field_annotation_with_quote;
  }

  const ::std::string& get_class_() const& {
    return __fbthrift_field_class_;
  }

  ::std::string get_class_() && {
    return std::move(__fbthrift_field_class_);
  }

  template <typename T_YourStruct_class__struct_setter = ::std::string>
  [[deprecated("Use `FOO.class__ref() = BAR;` instead of `FOO.set_class_(BAR);`")]]
  ::std::string& set_class_(T_YourStruct_class__struct_setter&& class__) {
    class__ref() = std::forward<T_YourStruct_class__struct_setter>(class__);
    return __fbthrift_field_class_;
  }

  const ::std::string& get_annotation_with_trailing_comma() const& {
    return __fbthrift_field_annotation_with_trailing_comma;
  }

  ::std::string get_annotation_with_trailing_comma() && {
    return std::move(__fbthrift_field_annotation_with_trailing_comma);
  }

  template <typename T_YourStruct_annotation_with_trailing_comma_struct_setter = ::std::string>
  [[deprecated("Use `FOO.annotation_with_trailing_comma_ref() = BAR;` instead of `FOO.set_annotation_with_trailing_comma(BAR);`")]]
  ::std::string& set_annotation_with_trailing_comma(T_YourStruct_annotation_with_trailing_comma_struct_setter&& annotation_with_trailing_comma_) {
    annotation_with_trailing_comma_ref() = std::forward<T_YourStruct_annotation_with_trailing_comma_struct_setter>(annotation_with_trailing_comma_);
    return __fbthrift_field_annotation_with_trailing_comma;
  }

  const ::std::string& get_empty_annotations() const& {
    return __fbthrift_field_empty_annotations;
  }

  ::std::string get_empty_annotations() && {
    return std::move(__fbthrift_field_empty_annotations);
  }

  template <typename T_YourStruct_empty_annotations_struct_setter = ::std::string>
  [[deprecated("Use `FOO.empty_annotations_ref() = BAR;` instead of `FOO.set_empty_annotations(BAR);`")]]
  ::std::string& set_empty_annotations(T_YourStruct_empty_annotations_struct_setter&& empty_annotations_) {
    empty_annotations_ref() = std::forward<T_YourStruct_empty_annotations_struct_setter>(empty_annotations_);
    return __fbthrift_field_empty_annotations;
  }

  ::cpp2::YourEnum get_my_enum() const {
    return __fbthrift_field_my_enum;
  }

  [[deprecated("Use `FOO.my_enum_ref() = BAR;` instead of `FOO.set_my_enum(BAR);`")]]
  ::cpp2::YourEnum& set_my_enum(::cpp2::YourEnum my_enum_) {
    my_enum_ref() = my_enum_;
    return __fbthrift_field_my_enum;
  }
  const ::cpp2::list_string_6884& get_cpp_type_annotation() const&;
  ::cpp2::list_string_6884 get_cpp_type_annotation() &&;

  template <typename T_YourStruct_cpp_type_annotation_struct_setter = ::cpp2::list_string_6884>
  [[deprecated("Use `FOO.cpp_type_annotation_ref() = BAR;` instead of `FOO.set_cpp_type_annotation(BAR);`")]]
  ::cpp2::list_string_6884& set_cpp_type_annotation(T_YourStruct_cpp_type_annotation_struct_setter&& cpp_type_annotation_) {
    cpp_type_annotation_ref() = std::forward<T_YourStruct_cpp_type_annotation_struct_setter>(cpp_type_annotation_);
    return __fbthrift_field_cpp_type_annotation;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<YourStruct>;
  friend void swap(YourStruct& a, YourStruct& b);
};

template <class Protocol_>
unsigned long YourStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}
} // namespace detail

using YourStruct = ::apache::thrift::adapt_detail::adapted_t<::StaticCast, ::cpp2::detail::YourStruct>;

typedef ::cpp2::YourStruct AwesomeStruct;
typedef ::cpp2::YourStruct FantasticStruct;

class MyStructNestedAnnotation final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::name
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::string_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 1;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = MyStructNestedAnnotation;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  MyStructNestedAnnotation();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyStructNestedAnnotation(apache::thrift::FragileConstructor, ::std::string name__arg);

  MyStructNestedAnnotation(MyStructNestedAnnotation&&) noexcept;

  MyStructNestedAnnotation(const MyStructNestedAnnotation& src);


  MyStructNestedAnnotation& operator=(MyStructNestedAnnotation&&) noexcept;
  MyStructNestedAnnotation& operator=(const MyStructNestedAnnotation& src);

  ~MyStructNestedAnnotation();

 private:
  ::std::string __fbthrift_field_name;
 private:
  apache::thrift::detail::isset_bitset<1, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const MyStructNestedAnnotation&) const;
  bool operator<(const MyStructNestedAnnotation&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->__fbthrift_field_name, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_name), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->__fbthrift_field_name, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_name), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name() const& {
    return {this->__fbthrift_field_name, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_name), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name() & {
    return {this->__fbthrift_field_name, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name() && {
    return {static_cast<T&&>(this->__fbthrift_field_name), __isset.at(0), __isset.bit(0)};
  }

  const ::std::string& get_name() const& {
    return __fbthrift_field_name;
  }

  ::std::string get_name() && {
    return std::move(__fbthrift_field_name);
  }

  template <typename T_MyStructNestedAnnotation_name_struct_setter = ::std::string>
  [[deprecated("Use `FOO.name_ref() = BAR;` instead of `FOO.set_name(BAR);`")]]
  ::std::string& set_name(T_MyStructNestedAnnotation_name_struct_setter&& name_) {
    name_ref() = std::forward<T_MyStructNestedAnnotation_name_struct_setter>(name_);
    return __fbthrift_field_name;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<MyStructNestedAnnotation>;
  friend void swap(MyStructNestedAnnotation& a, MyStructNestedAnnotation& b);
};

template <class Protocol_>
unsigned long MyStructNestedAnnotation::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


namespace detail {
class FOLLY_EXPORT YourException : public virtual apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0};
  using __fbthrift_reflection_type_tags = folly::tag_t<
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 0;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::SAFE;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = YourException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  YourException();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  YourException(apache::thrift::FragileConstructor);

  YourException(YourException&&) noexcept;

  YourException(const YourException& src);


  YourException& operator=(YourException&&) noexcept;
  YourException& operator=(const YourException& src);

  ~YourException() override;


 public:

  bool operator==(const YourException&) const;
  bool operator<(const YourException&) const;

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::cpp2::detail::YourException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<YourException>;
  friend void swap(YourException& a, YourException& b);
};

template <class Protocol_>
unsigned long YourException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}
} // namespace detail

using YourException = ::apache::thrift::adapt_detail::adapted_t<::StaticCast, ::cpp2::detail::YourException>;


class SecretStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::id,
    ::apache::thrift::ident::password
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::string_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 2;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = SecretStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  SecretStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SecretStruct(apache::thrift::FragileConstructor, ::std::int64_t id__arg, ::std::string password__arg);

  SecretStruct(SecretStruct&&) noexcept;

  SecretStruct(const SecretStruct& src);


  SecretStruct& operator=(SecretStruct&&) noexcept;
  SecretStruct& operator=(const SecretStruct& src);

  ~SecretStruct();

 private:
  ::std::int64_t __fbthrift_field_id;
 private:
  ::std::string __fbthrift_field_password;
 private:
  apache::thrift::detail::isset_bitset<2, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const SecretStruct&) const;
  bool operator<(const SecretStruct&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->__fbthrift_field_id, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_id), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->__fbthrift_field_id, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_id), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id() const& {
    return {this->__fbthrift_field_id, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_id), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id() & {
    return {this->__fbthrift_field_id, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id() && {
    return {static_cast<T&&>(this->__fbthrift_field_id), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> password_ref() const& {
    return {this->__fbthrift_field_password, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> password_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_password), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> password_ref() & {
    return {this->__fbthrift_field_password, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> password_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_password), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> password() const& {
    return {this->__fbthrift_field_password, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> password() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_password), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> password() & {
    return {this->__fbthrift_field_password, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> password() && {
    return {static_cast<T&&>(this->__fbthrift_field_password), __isset.at(1), __isset.bit(1)};
  }

  ::std::int64_t get_id() const {
    return __fbthrift_field_id;
  }

  [[deprecated("Use `FOO.id_ref() = BAR;` instead of `FOO.set_id(BAR);`")]]
  ::std::int64_t& set_id(::std::int64_t id_) {
    id_ref() = id_;
    return __fbthrift_field_id;
  }

  const ::std::string& get_password() const& {
    return __fbthrift_field_password;
  }

  ::std::string get_password() && {
    return std::move(__fbthrift_field_password);
  }

  template <typename T_SecretStruct_password_struct_setter = ::std::string>
  [[deprecated("Use `FOO.password_ref() = BAR;` instead of `FOO.set_password(BAR);`")]]
  ::std::string& set_password(T_SecretStruct_password_struct_setter&& password_) {
    password_ref() = std::forward<T_SecretStruct_password_struct_setter>(password_);
    return __fbthrift_field_password;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<SecretStruct>;
  friend void swap(SecretStruct& a, SecretStruct& b);
};

template <class Protocol_>
unsigned long SecretStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


} // cpp2

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::cpp2::detail::YourUnion::Type>;

template <> struct TEnumTraits<::cpp2::detail::YourUnion::Type> {
  using type = ::cpp2::detail::YourUnion::Type;

  static constexpr std::size_t const size = 0;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static bool findName(type value, folly::StringPiece* out) noexcept;
  static bool findValue(folly::StringPiece name, type* out) noexcept;

#if FOLLY_HAS_STRING_VIEW
  static bool findName(type value, std::string_view* out) noexcept {
    folly::StringPiece outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
#endif
  static char const* findName(type value) noexcept {
    folly::StringPiece ret;
    (void)findName(value, &ret);
    return ret.data();
  }
};
}} // apache::thrift
