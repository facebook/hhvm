/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>


using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////


// Class Invoke Tables
extern struct ObjectStaticCallbacks cw_reflectionfunctionabstract;
extern struct ObjectStaticCallbacks cw_reflectionobject;
extern struct ObjectStaticCallbacks cw_splfileobject;
extern struct ObjectStaticCallbacks cw_unexpectedvalueexception;
extern struct ObjectStaticCallbacks cw_stdclass;
extern struct ObjectStaticCallbacks cw_reflectionexception;
extern struct ObjectStaticCallbacks cw_overflowexception;
extern struct ObjectStaticCallbacks cw_splfileinfo;
extern struct ObjectStaticCallbacks cw_arrayiterator;
extern struct ObjectStaticCallbacks cw_appenditerator;
extern struct ObjectStaticCallbacks cw_outofboundsexception;
extern struct ObjectStaticCallbacks cw_logicexception;
extern struct ObjectStaticCallbacks cw_rangeexception;
extern struct ObjectStaticCallbacks cw_splobjectstorage;
extern struct ObjectStaticCallbacks cw_invalidargumentexception;
extern struct ObjectStaticCallbacks cw_reflectionclass;
extern struct ObjectStaticCallbacks cw_underflowexception;
extern struct ObjectStaticCallbacks cw_reflectionextension;
extern struct ObjectStaticCallbacks cw_outofrangeexception;
extern struct ObjectStaticCallbacks cw_reflectionmethod;
extern struct ObjectStaticCallbacks cw_badmethodcallexception;
extern struct ObjectStaticCallbacks cw_pear_error;
extern struct ObjectStaticCallbacks cw_reflectionproperty;
extern struct ObjectStaticCallbacks cw___php_incomplete_class;
extern struct ObjectStaticCallbacks cw_runtimeexception;
extern struct ObjectStaticCallbacks cw_exception;
extern struct ObjectStaticCallbacks cw_reflectionfunction;
extern struct ObjectStaticCallbacks cw_errorexception;
extern struct ObjectStaticCallbacks cw_recursivedirectoryiterator;
extern struct ObjectStaticCallbacks cw_directoryiterator;
extern struct ObjectStaticCallbacks cw_badfunctioncallexception;
extern struct ObjectStaticCallbacks cw_lengthexception;
extern struct ObjectStaticCallbacks cw_domainexception;
extern struct ObjectStaticCallbacks cw_recursiveiteratoriterator;
extern struct ObjectStaticCallbacks cw_directory;
extern struct ObjectStaticCallbacks cw_filteriterator;
extern struct ObjectStaticCallbacks cw_reflectionparameter;
Object co_pdoexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdoexception)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdoexception
Variant c_pdoexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdoexception
Variant c_pdoexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdoexception
Variant &c_pdoexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdoexception
void c_pdoexception::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_pdoexception
void c_pdoexception::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdoexception
Variant c_pdoexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdoexception
Variant c_pdoexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdoexception
Variant c_pdoexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdoexception
bool c_pdoexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdoexception
bool c_pdoexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdoexception
bool c_pdoexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdoexception
Variant c_pdoexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdoexception
Variant c_pdoexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdoexception
Variant c_pdoexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdoexception
Variant& c_pdoexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdoexception
Variant& c_pdoexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdoexception
Variant& c_pdoexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdoexception
Variant c_pdoexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdoexception
IMPLEMENT_CLASS(pdoexception)
c_pdoexception *c_pdoexception::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_pdoexception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_pdoexception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_pdoexception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_pdoexception::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdoexception::cloneImpl() {
  c_pdoexception *obj = NEW(c_pdoexception)();
  cloneSet(obj);
  return obj;
}
void c_pdoexception::cloneSet(c_pdoexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
Variant c_pdoexception::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
Variant c_pdoexception::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdoexception
Variant c_pdoexception::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdoexception
Variant c_pdoexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdoexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdoexception = {
  c_pdoexception::os_getInit,
  c_pdoexception::os_get,
  c_pdoexception::os_lval,
  c_pdoexception::os_invoke,
  c_pdoexception::os_constant,
};
Object co_domdocumentfragment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocumentfragment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumentfragment
Variant c_domdocumentfragment::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumentfragment
Variant c_domdocumentfragment::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumentfragment
Variant &c_domdocumentfragment::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumentfragment
void c_domdocumentfragment::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumentfragment
void c_domdocumentfragment::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocumentfragment
Variant c_domdocumentfragment::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumentfragment
Variant c_domdocumentfragment::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumentfragment
Variant c_domdocumentfragment::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocumentfragment
bool c_domdocumentfragment::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumentfragment
bool c_domdocumentfragment::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumentfragment
bool c_domdocumentfragment::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocumentfragment
Variant c_domdocumentfragment::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumentfragment
Variant c_domdocumentfragment::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumentfragment
Variant c_domdocumentfragment::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocumentfragment
Variant& c_domdocumentfragment::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumentfragment
Variant& c_domdocumentfragment::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumentfragment
Variant& c_domdocumentfragment::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumentfragment
Variant c_domdocumentfragment::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumentfragment
IMPLEMENT_CLASS(domdocumentfragment)
c_domdocumentfragment *c_domdocumentfragment::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domdocumentfragment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domdocumentfragment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domdocumentfragment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domdocumentfragment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocumentfragment::cloneImpl() {
  c_domdocumentfragment *obj = NEW(c_domdocumentfragment)();
  cloneSet(obj);
  return obj;
}
void c_domdocumentfragment::cloneSet(c_domdocumentfragment *clone) {
  c_domnode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x1E44C8E8C1920931LL, appendxml) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendxml(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x1E44C8E8C1920931LL, appendxml) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD(0x1E44C8E8C1920931LL, appendxml) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocumentfragment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocumentfragment = {
  c_domdocumentfragment::os_getInit,
  c_domdocumentfragment::os_get,
  c_domdocumentfragment::os_lval,
  c_domdocumentfragment::os_invoke,
  c_domdocumentfragment::os_constant,
};
Object co_domtext(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domtext)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domtext
Variant c_domtext::os_getInit(const char *s, int64 hash) {
  return c_domcharacterdata::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domtext
Variant c_domtext::os_get(const char *s, int64 hash) {
  return c_domcharacterdata::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domtext
Variant &c_domtext::os_lval(const char *s, int64 hash) {
  return c_domcharacterdata::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domtext
void c_domtext::o_getArray(Array &props) const {
  c_domcharacterdata::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domtext
void c_domtext::o_setArray(CArrRef props) {
  c_domcharacterdata::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_domtext
Variant c_domtext::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domtext
Variant c_domtext::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domcharacterdata::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domtext
Variant c_domtext::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domtext
bool c_domtext::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domtext
bool c_domtext::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domcharacterdata::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domtext
bool c_domtext::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_domtext
Variant c_domtext::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domtext
Variant c_domtext::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domcharacterdata::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domtext
Variant c_domtext::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domtext
Variant& c_domtext::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domtext
Variant& c_domtext::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domcharacterdata::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domtext
Variant& c_domtext::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domtext
Variant c_domtext::os_constant(const char *s) {
  return c_domcharacterdata::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domtext
IMPLEMENT_CLASS(domtext)
c_domtext *c_domtext::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domtext::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_domtext::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_domtext::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_domtext::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domtext::cloneImpl() {
  c_domtext *obj = NEW(c_domtext)();
  cloneSet(obj);
  return obj;
}
void c_domtext::cloneSet(c_domtext *clone) {
  c_domcharacterdata::cloneSet(clone);
}
Variant c_domtext::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
Variant c_domtext::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
Variant c_domtext::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domtext
Variant c_domtext::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domtext
Variant c_domtext::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domcharacterdata::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domtext::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domcharacterdata::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domtext = {
  c_domtext::os_getInit,
  c_domtext::os_get,
  c_domtext::os_lval,
  c_domtext::os_invoke,
  c_domtext::os_constant,
};
Object co_debuggerclient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_debuggerclient)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerclient
Variant c_debuggerclient::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerclient
Variant c_debuggerclient::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerclient
Variant &c_debuggerclient::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerclient
void c_debuggerclient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerclient
void c_debuggerclient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_debuggerclient
Variant c_debuggerclient::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerclient
Variant c_debuggerclient::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerclient
Variant c_debuggerclient::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_debuggerclient
bool c_debuggerclient::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerclient
bool c_debuggerclient::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerclient
bool c_debuggerclient::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_debuggerclient
Variant c_debuggerclient::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerclient
Variant c_debuggerclient::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerclient
Variant c_debuggerclient::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_debuggerclient
Variant& c_debuggerclient::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerclient
Variant& c_debuggerclient::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerclient
Variant& c_debuggerclient::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerclient
Variant c_debuggerclient::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_RETURN(0x2038737F45604DE2LL, q_debuggerclient_AUTO_COMPLETE_VARIABLES, "AUTO_COMPLETE_VARIABLES");
      break;
    case 3:
      HASH_RETURN(0x78221A7B002235D3LL, q_debuggerclient_AUTO_COMPLETE_CONSTANTS, "AUTO_COMPLETE_CONSTANTS");
      break;
    case 7:
      HASH_RETURN(0x1B352E31B034F827LL, q_debuggerclient_AUTO_COMPLETE_FILENAMES, "AUTO_COMPLETE_FILENAMES");
      HASH_RETURN(0x0F17BB5BEC004CA7LL, q_debuggerclient_AUTO_COMPLETE_CLASSES, "AUTO_COMPLETE_CLASSES");
      break;
    case 15:
      HASH_RETURN(0x7CAE318E6EF6449FLL, q_debuggerclient_AUTO_COMPLETE_FUNCTIONS, "AUTO_COMPLETE_FUNCTIONS");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerclient
IMPLEMENT_CLASS(debuggerclient)
c_debuggerclient *c_debuggerclient::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_debuggerclient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_debuggerclient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_debuggerclient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_debuggerclient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_debuggerclient::cloneImpl() {
  c_debuggerclient *obj = NEW(c_debuggerclient)();
  cloneSet(obj);
  return obj;
}
void c_debuggerclient::cloneSet(c_debuggerclient *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
Variant c_debuggerclient::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x07768FF90B181780LL, addcompletion) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addcompletion(arg0), null);
        }
      }
      break;
    case 2:
      HASH_GUARD(0x20F2EA2BBFF5AA42LL, ask) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_ask(count, arg0));
          return (t_ask(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 4:
      HASH_GUARD(0x0E836DA3377C4984LL, getframe) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD(0x1D033DFD1DCAEA85LL, printframe) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_printframe(arg0), null);
        }
      }
      break;
    case 8:
      HASH_GUARD(0x3E0170A7802E3888LL, send) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 13:
      HASH_GUARD(0x16AD79F9AF3ECC0DLL, comment) {
        if (count < 1) return throw_missing_arguments("comment", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_comment(count, arg0), null);
          return (t_comment(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 14:
      HASH_GUARD(0x7A24AFD8ADE43B8ELL, args) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      HASH_GUARD(0x6B3BF595A55159CFLL, helpbody) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpbody(arg0), null);
        }
      }
      break;
    case 17:
      HASH_GUARD(0x1015EB3F52B098D1LL, print) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_print(count, arg0), null);
          return (t_print(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 23:
      HASH_GUARD(0x182AC39D2C493A97LL, getcommand) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      HASH_GUARD(0x67A7ABCB74D168D7LL, argrest) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argrest(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x016509DCA13DB6DFLL, error) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_error(count, arg0), null);
          return (t_error(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x0F2EF58F157D479FLL, info) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_info(count, arg0), null);
          return (t_info(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 35:
      HASH_GUARD(0x5F8B4ACA3731C423LL, helptitle) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helptitle(arg0), null);
        }
      }
      break;
    case 38:
      HASH_GUARD(0x2191643700554726LL, getcurrentlocation) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD(0x620C55BAC770E928LL, argvalue) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argvalue(arg0));
        }
      }
      break;
    case 44:
      HASH_GUARD(0x6CB0A07E0516B6ACLL, tutorial) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_tutorial(arg0), null);
        }
      }
      break;
    case 47:
      HASH_GUARD(0x5412C8462A696DEFLL, argcount) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      HASH_GUARD(0x5CE665973E2B4C6FLL, helpsection) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpsection(arg0), null);
        }
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x64C0B4BCDA99F6F4LL, arg) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_arg(arg0, arg1));
        }
      }
      HASH_GUARD(0x665AFB5CDFD23534LL, help) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_help(count, arg0), null);
          return (t_help(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 54:
      HASH_GUARD(0x04A108469024B7B6LL, xend) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xend(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD(0x7C41EEC813FC6FB7LL, getstacktrace) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      HASH_GUARD(0x6C5E35754AA2B277LL, wrap) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_wrap(arg0));
        }
      }
      break;
    case 57:
      HASH_GUARD(0x58C72230857ACDB9LL, code) {
        if (count < 1) return throw_missing_arguments("code", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_code(count, arg0), null);
          return (t_code(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 58:
      HASH_GUARD(0x0732FA520631017ALL, quit) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD(0x07B89E83B77C677FLL, output) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_output(count, arg0), null);
          return (t_output(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
Variant c_debuggerclient::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x07768FF90B181780LL, addcompletion) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD(0x20F2EA2BBFF5AA42LL, ask) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        if (count <= 1) return (t_ask(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_ask(count,a0, params));
      }
      break;
    case 4:
      HASH_GUARD(0x0E836DA3377C4984LL, getframe) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD(0x1D033DFD1DCAEA85LL, printframe) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD(0x3E0170A7802E3888LL, send) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x16AD79F9AF3ECC0DLL, comment) {
        if (count < 1) return throw_missing_arguments("comment", count+1, 1);
        if (count <= 1) return (t_comment(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_comment(count,a0, params), null);
      }
      break;
    case 14:
      HASH_GUARD(0x7A24AFD8ADE43B8ELL, args) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      HASH_GUARD(0x6B3BF595A55159CFLL, helpbody) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD(0x1015EB3F52B098D1LL, print) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        if (count <= 1) return (t_print(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_print(count,a0, params), null);
      }
      break;
    case 23:
      HASH_GUARD(0x182AC39D2C493A97LL, getcommand) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      HASH_GUARD(0x67A7ABCB74D168D7LL, argrest) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x016509DCA13DB6DFLL, error) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        if (count <= 1) return (t_error(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_error(count,a0, params), null);
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x0F2EF58F157D479FLL, info) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        if (count <= 1) return (t_info(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_info(count,a0, params), null);
      }
      break;
    case 35:
      HASH_GUARD(0x5F8B4ACA3731C423LL, helptitle) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD(0x2191643700554726LL, getcurrentlocation) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD(0x620C55BAC770E928LL, argvalue) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD(0x6CB0A07E0516B6ACLL, tutorial) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD(0x5412C8462A696DEFLL, argcount) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      HASH_GUARD(0x5CE665973E2B4C6FLL, helpsection) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x64C0B4BCDA99F6F4LL, arg) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        return (t_arg(a0, a1));
      }
      HASH_GUARD(0x665AFB5CDFD23534LL, help) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        if (count <= 1) return (t_help(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_help(count,a0, params), null);
      }
      break;
    case 54:
      HASH_GUARD(0x04A108469024B7B6LL, xend) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x7C41EEC813FC6FB7LL, getstacktrace) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      HASH_GUARD(0x6C5E35754AA2B277LL, wrap) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD(0x58C72230857ACDB9LL, code) {
        if (count < 1) return throw_missing_arguments("code", count+1, 1);
        if (count <= 1) return (t_code(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_code(count,a0, params), null);
      }
      break;
    case 58:
      HASH_GUARD(0x0732FA520631017ALL, quit) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD(0x07B89E83B77C677FLL, output) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        if (count <= 1) return (t_output(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_output(count,a0, params), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerclient
Variant c_debuggerclient::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerclient
Variant c_debuggerclient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x07768FF90B181780LL, addcompletion) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD(0x20F2EA2BBFF5AA42LL, ask) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_ask(count, a0));
        return (t_ask(count, a0,vargs));
      }
      break;
    case 4:
      HASH_GUARD(0x0E836DA3377C4984LL, getframe) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD(0x1D033DFD1DCAEA85LL, printframe) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD(0x3E0170A7802E3888LL, send) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x16AD79F9AF3ECC0DLL, comment) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("comment", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_comment(count, a0), null);
        return (t_comment(count, a0,vargs), null);
      }
      break;
    case 14:
      HASH_GUARD(0x7A24AFD8ADE43B8ELL, args) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      HASH_GUARD(0x6B3BF595A55159CFLL, helpbody) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD(0x1015EB3F52B098D1LL, print) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_print(count, a0), null);
        return (t_print(count, a0,vargs), null);
      }
      break;
    case 23:
      HASH_GUARD(0x182AC39D2C493A97LL, getcommand) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcommand());
      }
      HASH_GUARD(0x67A7ABCB74D168D7LL, argrest) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x016509DCA13DB6DFLL, error) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_error(count, a0), null);
        return (t_error(count, a0,vargs), null);
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD(0x0F2EF58F157D479FLL, info) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_info(count, a0), null);
        return (t_info(count, a0,vargs), null);
      }
      break;
    case 35:
      HASH_GUARD(0x5F8B4ACA3731C423LL, helptitle) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD(0x2191643700554726LL, getcurrentlocation) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD(0x620C55BAC770E928LL, argvalue) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD(0x6CB0A07E0516B6ACLL, tutorial) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD(0x5412C8462A696DEFLL, argcount) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argcount());
      }
      HASH_GUARD(0x5CE665973E2B4C6FLL, helpsection) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x64C0B4BCDA99F6F4LL, arg) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_arg(a0, a1));
      }
      HASH_GUARD(0x665AFB5CDFD23534LL, help) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_help(count, a0), null);
        return (t_help(count, a0,vargs), null);
      }
      break;
    case 54:
      HASH_GUARD(0x04A108469024B7B6LL, xend) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x7C41EEC813FC6FB7LL, getstacktrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstacktrace());
      }
      HASH_GUARD(0x6C5E35754AA2B277LL, wrap) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD(0x58C72230857ACDB9LL, code) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("code", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_code(count, a0), null);
        return (t_code(count, a0,vargs), null);
      }
      break;
    case 58:
      HASH_GUARD(0x0732FA520631017ALL, quit) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD(0x07B89E83B77C677FLL, output) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_output(count, a0), null);
        return (t_output(count, a0,vargs), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_debuggerclient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_debuggerclient = {
  c_debuggerclient::os_getInit,
  c_debuggerclient::os_get,
  c_debuggerclient::os_lval,
  c_debuggerclient::os_invoke,
  c_debuggerclient::os_constant,
};
Object co_domcdatasection(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcdatasection)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcdatasection
Variant c_domcdatasection::os_getInit(const char *s, int64 hash) {
  return c_domtext::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcdatasection
Variant c_domcdatasection::os_get(const char *s, int64 hash) {
  return c_domtext::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcdatasection
Variant &c_domcdatasection::os_lval(const char *s, int64 hash) {
  return c_domtext::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcdatasection
void c_domcdatasection::o_getArray(Array &props) const {
  c_domtext::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domcdatasection
void c_domcdatasection::o_setArray(CArrRef props) {
  c_domtext::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcdatasection
Variant c_domcdatasection::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcdatasection
Variant c_domcdatasection::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domtext::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcdatasection
Variant c_domcdatasection::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcdatasection
bool c_domcdatasection::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcdatasection
bool c_domcdatasection::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domtext::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcdatasection
bool c_domcdatasection::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcdatasection
Variant c_domcdatasection::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcdatasection
Variant c_domcdatasection::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domtext::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcdatasection
Variant c_domcdatasection::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcdatasection
Variant& c_domcdatasection::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcdatasection
Variant& c_domcdatasection::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domtext::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcdatasection
Variant& c_domcdatasection::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcdatasection
Variant c_domcdatasection::os_constant(const char *s) {
  return c_domtext::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcdatasection
IMPLEMENT_CLASS(domcdatasection)
c_domcdatasection *c_domcdatasection::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domcdatasection::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_domcdatasection::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_domcdatasection::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domcdatasection::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcdatasection::cloneImpl() {
  c_domcdatasection *obj = NEW(c_domcdatasection)();
  cloneSet(obj);
  return obj;
}
void c_domcdatasection::cloneSet(c_domcdatasection *clone) {
  c_domtext::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcdatasection
Variant c_domcdatasection::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domtext::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcdatasection::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domtext::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcdatasection = {
  c_domcdatasection::os_getInit,
  c_domcdatasection::os_get,
  c_domcdatasection::os_lval,
  c_domcdatasection::os_invoke,
  c_domcdatasection::os_constant,
};
Object co_locale(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_locale)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_locale
Variant c_locale::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_locale
Variant c_locale::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_locale
Variant &c_locale::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_locale
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_locale
void c_locale::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_locale
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_locale
void c_locale::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_locale
#ifndef OMIT_JUMP_TABLE_CLASS_get_locale
Variant c_locale::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_locale
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_locale
Variant c_locale::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_locale
Variant c_locale::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_exists_locale
bool c_locale::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_locale
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_locale
bool c_locale::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_locale
bool c_locale::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_set_locale
Variant c_locale::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_locale
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_locale
Variant c_locale::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_locale
Variant c_locale::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_lval_locale
Variant& c_locale::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_locale
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_locale
Variant& c_locale::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_locale
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_locale
Variant& c_locale::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_locale
Variant c_locale::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_RETURN(0x78695696B47AF8CDLL, q_locale_ACTUAL_LOCALE, "ACTUAL_LOCALE");
      HASH_RETURN(0x35B10383BBF3BAE1LL, q_locale_VALID_LOCALE, "VALID_LOCALE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_locale
IMPLEMENT_CLASS(locale)
c_locale *c_locale::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_locale::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_locale::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_locale::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_locale::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_locale::cloneImpl() {
  c_locale *obj = NEW(c_locale)();
  cloneSet(obj);
  return obj;
}
void c_locale::cloneSet(c_locale *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_locale
Variant c_locale::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_locale
Variant c_locale::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_locale
Variant c_locale::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_locale
Variant c_locale::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_locale::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_locale = {
  c_locale::os_getInit,
  c_locale::os_get,
  c_locale::os_lval,
  c_locale::os_invoke,
  c_locale::os_constant,
};
Object co_domdocumenttype(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocumenttype)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumenttype
Variant c_domdocumenttype::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumenttype
Variant c_domdocumenttype::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumenttype
Variant &c_domdocumenttype::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumenttype
void c_domdocumenttype::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumenttype
void c_domdocumenttype::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocumenttype
Variant c_domdocumenttype::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumenttype
Variant c_domdocumenttype::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumenttype
Variant c_domdocumenttype::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocumenttype
bool c_domdocumenttype::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumenttype
bool c_domdocumenttype::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumenttype
bool c_domdocumenttype::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocumenttype
Variant c_domdocumenttype::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumenttype
Variant c_domdocumenttype::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumenttype
Variant c_domdocumenttype::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocumenttype
Variant& c_domdocumenttype::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumenttype
Variant& c_domdocumenttype::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumenttype
Variant& c_domdocumenttype::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumenttype
Variant c_domdocumenttype::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumenttype
IMPLEMENT_CLASS(domdocumenttype)
c_domdocumenttype *c_domdocumenttype::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domdocumenttype::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domdocumenttype::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domdocumenttype::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domdocumenttype::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocumenttype::cloneImpl() {
  c_domdocumenttype *obj = NEW(c_domdocumenttype)();
  cloneSet(obj);
  return obj;
}
void c_domdocumenttype::cloneSet(c_domdocumenttype *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domdocumenttype::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumenttype
Variant c_domdocumenttype::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocumenttype::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocumenttype = {
  c_domdocumenttype::os_getInit,
  c_domdocumenttype::os_get,
  c_domdocumenttype::os_lval,
  c_domdocumenttype::os_invoke,
  c_domdocumenttype::os_constant,
};
Object co_sqlite3stmt(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3stmt)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3stmt
Variant c_sqlite3stmt::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3stmt
Variant c_sqlite3stmt::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3stmt
Variant &c_sqlite3stmt::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3stmt
void c_sqlite3stmt::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3stmt
void c_sqlite3stmt::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3stmt
Variant c_sqlite3stmt::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3stmt
Variant c_sqlite3stmt::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3stmt
Variant c_sqlite3stmt::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3stmt
bool c_sqlite3stmt::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3stmt
bool c_sqlite3stmt::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3stmt
bool c_sqlite3stmt::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3stmt
Variant c_sqlite3stmt::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3stmt
Variant c_sqlite3stmt::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3stmt
Variant c_sqlite3stmt::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3stmt
Variant& c_sqlite3stmt::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3stmt
Variant& c_sqlite3stmt::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3stmt
Variant& c_sqlite3stmt::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3stmt
Variant c_sqlite3stmt::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3stmt
IMPLEMENT_CLASS(sqlite3stmt)
c_sqlite3stmt *c_sqlite3stmt::create(Object a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_sqlite3stmt::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_sqlite3stmt::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  }
}
void c_sqlite3stmt::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_sqlite3stmt::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3stmt::cloneImpl() {
  c_sqlite3stmt *obj = NEW(c_sqlite3stmt)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3stmt::cloneSet(c_sqlite3stmt *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 7:
      HASH_GUARD(0x31DA235C5A226667LL, clear) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindparam(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindparam(arg0, ref(arg1), arg2));
        }
      }
      break;
    case 23:
      HASH_GUARD(0x72FA987001E93357LL, paramcount) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD(0x31DA235C5A226667LL, clear) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD(0x72FA987001E93357LL, paramcount) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD(0x31DA235C5A226667LL, clear) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD(0x72FA987001E93357LL, paramcount) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3stmt::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3stmt = {
  c_sqlite3stmt::os_getInit,
  c_sqlite3stmt::os_get,
  c_sqlite3stmt::os_lval,
  c_sqlite3stmt::os_invoke,
  c_sqlite3stmt::os_constant,
};
Object co_domnodelist(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnodelist)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodelist
Variant c_domnodelist::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodelist
Variant c_domnodelist::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodelist
Variant &c_domnodelist::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodelist
void c_domnodelist::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodelist
void c_domnodelist::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnodelist
Variant c_domnodelist::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodelist
Variant c_domnodelist::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodelist
Variant c_domnodelist::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnodelist
bool c_domnodelist::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodelist
bool c_domnodelist::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodelist
bool c_domnodelist::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnodelist
Variant c_domnodelist::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodelist
Variant c_domnodelist::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodelist
Variant c_domnodelist::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnodelist
Variant& c_domnodelist::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodelist
Variant& c_domnodelist::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodelist
Variant& c_domnodelist::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodelist
Variant c_domnodelist::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodelist
IMPLEMENT_CLASS(domnodelist)
c_domnodelist *c_domnodelist::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnodelist::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnodelist::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnodelist::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnodelist::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnodelist::cloneImpl() {
  c_domnodelist *obj = NEW(c_domnodelist)();
  cloneSet(obj);
  return obj;
}
void c_domnodelist::cloneSet(c_domnodelist *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnodelist::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
Variant c_domnodelist::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
Variant c_domnodelist::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodelist
Variant c_domnodelist::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodelist
Variant c_domnodelist::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnodelist::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnodelist = {
  c_domnodelist::os_getInit,
  c_domnodelist::os_get,
  c_domnodelist::os_lval,
  c_domnodelist::os_invoke,
  c_domnodelist::os_constant,
};
Object co_normalizer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_normalizer)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_normalizer
Variant c_normalizer::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_normalizer
Variant c_normalizer::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_normalizer
Variant &c_normalizer::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_normalizer
void c_normalizer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_normalizer
void c_normalizer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_normalizer
Variant c_normalizer::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_normalizer
Variant c_normalizer::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_normalizer
Variant c_normalizer::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_normalizer
bool c_normalizer::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_normalizer
bool c_normalizer::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_normalizer
bool c_normalizer::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_normalizer
Variant c_normalizer::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_normalizer
Variant c_normalizer::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_normalizer
Variant c_normalizer::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_normalizer
Variant& c_normalizer::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_normalizer
Variant& c_normalizer::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_normalizer
Variant& c_normalizer::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_normalizer
Variant c_normalizer::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 1:
      HASH_RETURN(0x2C9DA0E379A28381LL, q_normalizer_FORM_KD, "FORM_KD");
      HASH_RETURN(0x1C369D0E14B76C41LL, q_normalizer_FORM_KC, "FORM_KC");
      HASH_RETURN(0x3E3AA0A97BD09921LL, q_normalizer_NFKC, "NFKC");
      break;
    case 2:
      HASH_RETURN(0x07512AA38ADD1AE2LL, q_normalizer_FORM_D, "FORM_D");
      break;
    case 6:
      HASH_RETURN(0x51422F059BEFCD86LL, q_normalizer_NFC, "NFC");
      break;
    case 15:
      HASH_RETURN(0x58B301790FA834EFLL, q_normalizer_NFD, "NFD");
      HASH_RETURN(0x3CF19F2D23C185CFLL, q_normalizer_NFKD, "NFKD");
      break;
    case 19:
      HASH_RETURN(0x2EFDCA1922BFB273LL, q_normalizer_NONE, "NONE");
      break;
    case 31:
      HASH_RETURN(0x3BE3511FDA9A9E7FLL, q_normalizer_FORM_C, "FORM_C");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_normalizer
IMPLEMENT_CLASS(normalizer)
c_normalizer *c_normalizer::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_normalizer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_normalizer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_normalizer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_normalizer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_normalizer::cloneImpl() {
  c_normalizer *obj = NEW(c_normalizer)();
  cloneSet(obj);
  return obj;
}
void c_normalizer::cloneSet(c_normalizer *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
Variant c_normalizer::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(o_getClassName(), arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_normalize(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(o_getClassName(), arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_isnormalized(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
Variant c_normalizer::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_normalizer
Variant c_normalizer::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(c, arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_isnormalized(c, arg0, arg1));
        }
      }
      break;
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(c, arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (ti_normalize(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_normalizer
Variant c_normalizer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_normalizer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_normalizer = {
  c_normalizer::os_getInit,
  c_normalizer::os_get,
  c_normalizer::os_lval,
  c_normalizer::os_invoke,
  c_normalizer::os_constant,
};
Object co_domcharacterdata(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcharacterdata)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcharacterdata
Variant c_domcharacterdata::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcharacterdata
Variant c_domcharacterdata::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcharacterdata
Variant &c_domcharacterdata::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcharacterdata
void c_domcharacterdata::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domcharacterdata
void c_domcharacterdata::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcharacterdata
Variant c_domcharacterdata::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcharacterdata
Variant c_domcharacterdata::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcharacterdata
Variant c_domcharacterdata::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcharacterdata
bool c_domcharacterdata::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcharacterdata
bool c_domcharacterdata::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcharacterdata
bool c_domcharacterdata::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcharacterdata
Variant c_domcharacterdata::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcharacterdata
Variant c_domcharacterdata::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcharacterdata
Variant c_domcharacterdata::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcharacterdata
Variant& c_domcharacterdata::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcharacterdata
Variant& c_domcharacterdata::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcharacterdata
Variant& c_domcharacterdata::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcharacterdata
Variant c_domcharacterdata::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcharacterdata
IMPLEMENT_CLASS(domcharacterdata)
c_domcharacterdata *c_domcharacterdata::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domcharacterdata::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domcharacterdata::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domcharacterdata::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domcharacterdata::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcharacterdata::cloneImpl() {
  c_domcharacterdata *obj = NEW(c_domcharacterdata)();
  cloneSet(obj);
  return obj;
}
void c_domcharacterdata::cloneSet(c_domcharacterdata *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domcharacterdata::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcharacterdata
Variant c_domcharacterdata::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcharacterdata::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcharacterdata = {
  c_domcharacterdata::os_getInit,
  c_domcharacterdata::os_get,
  c_domcharacterdata::os_lval,
  c_domcharacterdata::os_invoke,
  c_domcharacterdata::os_constant,
};
Object co_domentityreference(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domentityreference)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentityreference
Variant c_domentityreference::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentityreference
Variant c_domentityreference::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentityreference
Variant &c_domentityreference::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domentityreference
void c_domentityreference::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domentityreference
void c_domentityreference::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_domentityreference
Variant c_domentityreference::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentityreference
Variant c_domentityreference::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentityreference
Variant c_domentityreference::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domentityreference
bool c_domentityreference::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentityreference
bool c_domentityreference::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentityreference
bool c_domentityreference::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_domentityreference
Variant c_domentityreference::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentityreference
Variant c_domentityreference::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentityreference
Variant c_domentityreference::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domentityreference
Variant& c_domentityreference::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentityreference
Variant& c_domentityreference::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentityreference
Variant& c_domentityreference::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domentityreference
Variant c_domentityreference::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domentityreference
IMPLEMENT_CLASS(domentityreference)
c_domentityreference *c_domentityreference::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domentityreference::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_domentityreference::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_domentityreference::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domentityreference::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domentityreference::cloneImpl() {
  c_domentityreference *obj = NEW(c_domentityreference)();
  cloneSet(obj);
  return obj;
}
void c_domentityreference::cloneSet(c_domentityreference *clone) {
  c_domnode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
Variant c_domentityreference::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
Variant c_domentityreference::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentityreference
Variant c_domentityreference::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentityreference
Variant c_domentityreference::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domentityreference::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domentityreference = {
  c_domentityreference::os_getInit,
  c_domentityreference::os_get,
  c_domentityreference::os_lval,
  c_domentityreference::os_invoke,
  c_domentityreference::os_constant,
};
Object co_simplexmlelementiterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_simplexmlelementiterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelementiterator
Variant &c_simplexmlelementiterator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelementiterator
void c_simplexmlelementiterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelementiterator
void c_simplexmlelementiterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_simplexmlelementiterator
bool c_simplexmlelementiterator::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelementiterator
bool c_simplexmlelementiterator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelementiterator
bool c_simplexmlelementiterator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelementiterator
IMPLEMENT_CLASS(simplexmlelementiterator)
c_simplexmlelementiterator *c_simplexmlelementiterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_simplexmlelementiterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_simplexmlelementiterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_simplexmlelementiterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_simplexmlelementiterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_simplexmlelementiterator::cloneImpl() {
  c_simplexmlelementiterator *obj = NEW(c_simplexmlelementiterator)();
  cloneSet(obj);
  return obj;
}
void c_simplexmlelementiterator::cloneSet(c_simplexmlelementiterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_simplexmlelementiterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_simplexmlelementiterator = {
  c_simplexmlelementiterator::os_getInit,
  c_simplexmlelementiterator::os_get,
  c_simplexmlelementiterator::os_lval,
  c_simplexmlelementiterator::os_invoke,
  c_simplexmlelementiterator::os_constant,
};
Object co_datetimezone(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_datetimezone)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetimezone
Variant c_datetimezone::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetimezone
Variant c_datetimezone::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetimezone
Variant &c_datetimezone::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_datetimezone
void c_datetimezone::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_datetimezone
void c_datetimezone::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_datetimezone
Variant c_datetimezone::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetimezone
Variant c_datetimezone::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetimezone
Variant c_datetimezone::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_datetimezone
bool c_datetimezone::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetimezone
bool c_datetimezone::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetimezone
bool c_datetimezone::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_datetimezone
Variant c_datetimezone::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetimezone
Variant c_datetimezone::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetimezone
Variant c_datetimezone::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_datetimezone
Variant& c_datetimezone::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetimezone
Variant& c_datetimezone::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetimezone
Variant& c_datetimezone::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_datetimezone
Variant c_datetimezone::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x5213CDB166554802LL, q_datetimezone_AFRICA, "AFRICA");
      break;
    case 10:
      HASH_RETURN(0x1F67AB7044E3CA2ALL, q_datetimezone_EUROPE, "EUROPE");
      break;
    case 12:
      HASH_RETURN(0x76F99914EEA96ECCLL, q_datetimezone_ARCTIC, "ARCTIC");
      break;
    case 13:
      HASH_RETURN(0x338F44565E0C038DLL, q_datetimezone_AMERICA, "AMERICA");
      break;
    case 15:
      HASH_RETURN(0x22CAA6990573E5EFLL, q_datetimezone_PACIFIC, "PACIFIC");
      break;
    case 19:
      HASH_RETURN(0x7879534F49C301F3LL, q_datetimezone_PER_COUNTRY, "PER_COUNTRY");
      break;
    case 20:
      HASH_RETURN(0x6FB9D84AA364CA14LL, q_datetimezone_UTC, "UTC");
      break;
    case 23:
      HASH_RETURN(0x5A01AACAA61E0FF7LL, q_datetimezone_ASIA, "ASIA");
      HASH_RETURN(0x3E74CAEDAD25E137LL, q_datetimezone_INDIAN, "INDIAN");
      break;
    case 24:
      HASH_RETURN(0x0C4F30470A9EEBF8LL, q_datetimezone_ALL, "ALL");
      break;
    case 25:
      HASH_RETURN(0x2BEDCED53E63BC79LL, q_datetimezone_ATLANTIC, "ATLANTIC");
      break;
    case 30:
      HASH_RETURN(0x3C168ED86522549ELL, q_datetimezone_AUSTRALIA, "AUSTRALIA");
      HASH_RETURN(0x690180C3BA732B5ELL, q_datetimezone_ALL_WITH_BC, "ALL_WITH_BC");
      break;
    case 31:
      HASH_RETURN(0x6B29DE65F46EAFDFLL, q_datetimezone_ANTARCTICA, "ANTARCTICA");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_datetimezone
IMPLEMENT_CLASS(datetimezone)
c_datetimezone *c_datetimezone::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_datetimezone::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_datetimezone::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_datetimezone::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_datetimezone::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_datetimezone::cloneImpl() {
  c_datetimezone *obj = NEW(c_datetimezone)();
  cloneSet(obj);
  return obj;
}
void c_datetimezone::cloneSet(c_datetimezone *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
Variant c_datetimezone::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x63D3CF3884CE93F4LL, gettransitions) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getoffset(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
Variant c_datetimezone::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x63D3CF3884CE93F4LL, gettransitions) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetimezone
Variant c_datetimezone::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetimezone
Variant c_datetimezone::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x63D3CF3884CE93F4LL, gettransitions) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_datetimezone::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_datetimezone = {
  c_datetimezone::os_getInit,
  c_datetimezone::os_get,
  c_datetimezone::os_lval,
  c_datetimezone::os_invoke,
  c_datetimezone::os_constant,
};
Object co_domnodeiterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnodeiterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodeiterator
Variant c_domnodeiterator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodeiterator
Variant c_domnodeiterator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodeiterator
Variant &c_domnodeiterator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodeiterator
void c_domnodeiterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodeiterator
void c_domnodeiterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnodeiterator
Variant c_domnodeiterator::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodeiterator
Variant c_domnodeiterator::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodeiterator
Variant c_domnodeiterator::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnodeiterator
bool c_domnodeiterator::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodeiterator
bool c_domnodeiterator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodeiterator
bool c_domnodeiterator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnodeiterator
Variant c_domnodeiterator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodeiterator
Variant c_domnodeiterator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodeiterator
Variant c_domnodeiterator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnodeiterator
Variant& c_domnodeiterator::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodeiterator
Variant& c_domnodeiterator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodeiterator
Variant& c_domnodeiterator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodeiterator
Variant c_domnodeiterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodeiterator
IMPLEMENT_CLASS(domnodeiterator)
c_domnodeiterator *c_domnodeiterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnodeiterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnodeiterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnodeiterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnodeiterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnodeiterator::cloneImpl() {
  c_domnodeiterator *obj = NEW(c_domnodeiterator)();
  cloneSet(obj);
  return obj;
}
void c_domnodeiterator::cloneSet(c_domnodeiterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodeiterator
Variant c_domnodeiterator::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnodeiterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnodeiterator = {
  c_domnodeiterator::os_getInit,
  c_domnodeiterator::os_get,
  c_domnodeiterator::os_lval,
  c_domnodeiterator::os_invoke,
  c_domnodeiterator::os_constant,
};
Object co_domimplementation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domimplementation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domimplementation
Variant c_domimplementation::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domimplementation
Variant c_domimplementation::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domimplementation
Variant &c_domimplementation::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domimplementation
void c_domimplementation::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domimplementation
void c_domimplementation::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_domimplementation
Variant c_domimplementation::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domimplementation
Variant c_domimplementation::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domimplementation
Variant c_domimplementation::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domimplementation
bool c_domimplementation::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domimplementation
bool c_domimplementation::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domimplementation
bool c_domimplementation::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_domimplementation
Variant c_domimplementation::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domimplementation
Variant c_domimplementation::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domimplementation
Variant c_domimplementation::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domimplementation
Variant& c_domimplementation::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domimplementation
Variant& c_domimplementation::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domimplementation
Variant& c_domimplementation::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domimplementation
Variant c_domimplementation::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domimplementation
IMPLEMENT_CLASS(domimplementation)
c_domimplementation *c_domimplementation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domimplementation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domimplementation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domimplementation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domimplementation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domimplementation::cloneImpl() {
  c_domimplementation *obj = NEW(c_domimplementation)();
  cloneSet(obj);
  return obj;
}
void c_domimplementation::cloneSet(c_domimplementation *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
Variant c_domimplementation::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x3CB56A796F3DBAC3LL, createdocumenttype) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocumenttype());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocumenttype(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_createdocumenttype(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createdocumenttype(arg0, arg1, arg2));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x280878EAC306A6A3LL, hasfeature) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_hasfeature(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x30855E95B37D1B4ELL, createdocument) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocument(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_createdocument(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
Variant c_domimplementation::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x3CB56A796F3DBAC3LL, createdocumenttype) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        if (count == 1) return (t_createdocumenttype(a0));
        if (count == 2) return (t_createdocumenttype(a0, a1));
        return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x280878EAC306A6A3LL, hasfeature) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x30855E95B37D1B4ELL, createdocument) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        if (count == 1) return (t_createdocument(a0));
        if (count == 2) return (t_createdocument(a0, a1));
        return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domimplementation
Variant c_domimplementation::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domimplementation
Variant c_domimplementation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x3CB56A796F3DBAC3LL, createdocumenttype) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x280878EAC306A6A3LL, hasfeature) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x30855E95B37D1B4ELL, createdocument) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domimplementation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domimplementation = {
  c_domimplementation::os_getInit,
  c_domimplementation::os_get,
  c_domimplementation::os_lval,
  c_domimplementation::os_invoke,
  c_domimplementation::os_constant,
};
Object co_soapheader(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapheader)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapheader
Variant c_soapheader::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapheader
Variant c_soapheader::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapheader
Variant &c_soapheader::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapheader
void c_soapheader::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapheader
void c_soapheader::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapheader
Variant c_soapheader::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapheader
Variant c_soapheader::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapheader
Variant c_soapheader::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapheader
bool c_soapheader::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapheader
bool c_soapheader::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapheader
bool c_soapheader::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapheader
Variant c_soapheader::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapheader
Variant c_soapheader::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapheader
Variant c_soapheader::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapheader
Variant& c_soapheader::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapheader
Variant& c_soapheader::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapheader
Variant& c_soapheader::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapheader
Variant c_soapheader::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapheader
IMPLEMENT_CLASS(soapheader)
c_soapheader *c_soapheader::create(String a0, String a1, Variant a2, bool a3, Variant a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_soapheader::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_soapheader::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_soapheader::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_soapheader::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapheader::cloneImpl() {
  c_soapheader *obj = NEW(c_soapheader)();
  cloneSet(obj);
  return obj;
}
void c_soapheader::cloneSet(c_soapheader *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
Variant c_soapheader::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
Variant c_soapheader::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapheader
Variant c_soapheader::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapheader
Variant c_soapheader::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapheader::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapheader = {
  c_soapheader::os_getInit,
  c_soapheader::os_get,
  c_soapheader::os_lval,
  c_soapheader::os_invoke,
  c_soapheader::os_constant,
};
Object co_domnotation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnotation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnotation
Variant c_domnotation::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnotation
Variant c_domnotation::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnotation
Variant &c_domnotation::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnotation
void c_domnotation::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnotation
void c_domnotation::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnotation
Variant c_domnotation::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnotation
Variant c_domnotation::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnotation
Variant c_domnotation::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnotation
bool c_domnotation::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnotation
bool c_domnotation::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnotation
bool c_domnotation::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnotation
Variant c_domnotation::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnotation
Variant c_domnotation::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnotation
Variant c_domnotation::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnotation
Variant& c_domnotation::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnotation
Variant& c_domnotation::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnotation
Variant& c_domnotation::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnotation
Variant c_domnotation::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnotation
IMPLEMENT_CLASS(domnotation)
c_domnotation *c_domnotation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnotation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnotation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnotation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnotation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnotation::cloneImpl() {
  c_domnotation *obj = NEW(c_domnotation)();
  cloneSet(obj);
  return obj;
}
void c_domnotation::cloneSet(c_domnotation *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domnotation::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
Variant c_domnotation::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
Variant c_domnotation::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnotation
Variant c_domnotation::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnotation
Variant c_domnotation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnotation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnotation = {
  c_domnotation::os_getInit,
  c_domnotation::os_get,
  c_domnotation::os_lval,
  c_domnotation::os_invoke,
  c_domnotation::os_constant,
};
Object co_debuggerproxy(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_debuggerproxy)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerproxy
Variant c_debuggerproxy::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerproxy
Variant c_debuggerproxy::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerproxy
Variant &c_debuggerproxy::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerproxy
void c_debuggerproxy::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerproxy
void c_debuggerproxy::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_get_debuggerproxy
Variant c_debuggerproxy::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerproxy
Variant c_debuggerproxy::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerproxy
Variant c_debuggerproxy::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_exists_debuggerproxy
bool c_debuggerproxy::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerproxy
bool c_debuggerproxy::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerproxy
bool c_debuggerproxy::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_set_debuggerproxy
Variant c_debuggerproxy::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerproxy
Variant c_debuggerproxy::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerproxy
Variant c_debuggerproxy::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_lval_debuggerproxy
Variant& c_debuggerproxy::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerproxy
Variant& c_debuggerproxy::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerproxy
Variant& c_debuggerproxy::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerproxy
Variant c_debuggerproxy::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_debuggerproxy
IMPLEMENT_CLASS(debuggerproxy)
c_debuggerproxy *c_debuggerproxy::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_debuggerproxy::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_debuggerproxy::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_debuggerproxy::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_debuggerproxy::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_debuggerproxy::cloneImpl() {
  c_debuggerproxy *obj = NEW(c_debuggerproxy)();
  cloneSet(obj);
  return obj;
}
void c_debuggerproxy::cloneSet(c_debuggerproxy *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
Variant c_debuggerproxy::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD(0x3E0170A7802E3888LL, send) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x7B58587A529D270CLL, islocal) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
Variant c_debuggerproxy::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD(0x3E0170A7802E3888LL, send) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x7B58587A529D270CLL, islocal) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_debuggerproxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerproxy
Variant c_debuggerproxy::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_debuggerproxy
Variant c_debuggerproxy::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD(0x3E0170A7802E3888LL, send) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x7B58587A529D270CLL, islocal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_debuggerproxy::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_debuggerproxy = {
  c_debuggerproxy::os_getInit,
  c_debuggerproxy::os_get,
  c_debuggerproxy::os_lval,
  c_debuggerproxy::os_invoke,
  c_debuggerproxy::os_constant,
};
Object co_domcomment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcomment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcomment
Variant c_domcomment::os_getInit(const char *s, int64 hash) {
  return c_domcharacterdata::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcomment
Variant c_domcomment::os_get(const char *s, int64 hash) {
  return c_domcharacterdata::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcomment
Variant &c_domcomment::os_lval(const char *s, int64 hash) {
  return c_domcharacterdata::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcomment
void c_domcomment::o_getArray(Array &props) const {
  c_domcharacterdata::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domcomment
void c_domcomment::o_setArray(CArrRef props) {
  c_domcharacterdata::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcomment
Variant c_domcomment::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcomment
Variant c_domcomment::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domcharacterdata::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcomment
Variant c_domcomment::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcomment
bool c_domcomment::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcomment
bool c_domcomment::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domcharacterdata::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcomment
bool c_domcomment::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcomment
Variant c_domcomment::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcomment
Variant c_domcomment::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domcharacterdata::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcomment
Variant c_domcomment::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcomment
Variant& c_domcomment::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcomment
Variant& c_domcomment::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domcharacterdata::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcomment
Variant& c_domcomment::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcomment
Variant c_domcomment::os_constant(const char *s) {
  return c_domcharacterdata::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcomment
IMPLEMENT_CLASS(domcomment)
c_domcomment *c_domcomment::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domcomment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_domcomment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_domcomment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_domcomment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcomment::cloneImpl() {
  c_domcomment *obj = NEW(c_domcomment)();
  cloneSet(obj);
  return obj;
}
void c_domcomment::cloneSet(c_domcomment *clone) {
  c_domcharacterdata::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
Variant c_domcomment::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
Variant c_domcomment::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcomment
Variant c_domcomment::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcomment
Variant c_domcomment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domcharacterdata::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcomment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domcharacterdata::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcomment = {
  c_domcomment::os_getInit,
  c_domcomment::os_get,
  c_domcomment::os_lval,
  c_domcomment::os_invoke,
  c_domcomment::os_constant,
};
Object co_sqlite3(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3
Variant c_sqlite3::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3
Variant c_sqlite3::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3
Variant &c_sqlite3::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3
void c_sqlite3::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3
void c_sqlite3::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3
Variant c_sqlite3::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3
Variant c_sqlite3::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3
Variant c_sqlite3::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3
bool c_sqlite3::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3
bool c_sqlite3::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3
bool c_sqlite3::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3
Variant c_sqlite3::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3
Variant c_sqlite3::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3
Variant c_sqlite3::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3
Variant& c_sqlite3::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3
Variant& c_sqlite3::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3
Variant& c_sqlite3::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3
Variant c_sqlite3::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3
IMPLEMENT_CLASS(sqlite3)
c_sqlite3 *c_sqlite3::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_sqlite3::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_sqlite3::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_sqlite3::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_sqlite3::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3::cloneImpl() {
  c_sqlite3 *obj = NEW(c_sqlite3)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3::cloneSet(c_sqlite3 *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
Variant c_sqlite3::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD(0x6081F282094466C2LL, lasterrormsg) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD(0x65BD6700742BF3C2LL, openblob) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_openblob(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openblob(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 3:
      HASH_GUARD(0x3AA4CCEC6BD68143LL, createaggregate) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_createaggregate(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createaggregate(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 4:
      HASH_GUARD(0x21F68C010C124BC4LL, open) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_open(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_open(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_open(arg0, arg1, arg2), null);
        }
      }
      break;
    case 10:
      HASH_GUARD(0x632B468FC2FCAB0ALL, lasterrorcode) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 13:
      HASH_GUARD(0x7CECF508291057CDLL, createfunction) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_createfunction(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createfunction(arg0, arg1, arg2));
        }
      }
      break;
    case 25:
      HASH_GUARD(0x64D2BDB189B02819LL, changes) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD(0x1B3CDE890A487664LL, loadextension) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadextension(arg0));
        }
      }
      break;
    case 38:
      HASH_GUARD(0x5024F08DB0FDCBE6LL, lastinsertrowid) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD(0x5AE41239FF63D86ALL, version) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD(0x156B1FAE4132ABEELL, querysingle) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_querysingle(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_querysingle(arg0, arg1));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_prepare(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x607C4C73BB251635LL, escapestring) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_escapestring(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
Variant c_sqlite3::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD(0x6081F282094466C2LL, lasterrormsg) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD(0x65BD6700742BF3C2LL, openblob) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(a0, a1, a2));
        return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD(0x3AA4CCEC6BD68143LL, createaggregate) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD(0x21F68C010C124BC4LL, open) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(a0), null);
        if (count == 2) return (t_open(a0, a1), null);
        return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD(0x632B468FC2FCAB0ALL, lasterrorcode) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x7CECF508291057CDLL, createfunction) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(a0, a1));
        return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD(0x64D2BDB189B02819LL, changes) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD(0x1B3CDE890A487664LL, loadextension) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD(0x5024F08DB0FDCBE6LL, lastinsertrowid) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD(0x5AE41239FF63D86ALL, version) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD(0x156B1FAE4132ABEELL, querysingle) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(a0));
        return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x607C4C73BB251635LL, escapestring) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3
Variant c_sqlite3::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3
Variant c_sqlite3::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD(0x6081F282094466C2LL, lasterrormsg) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrormsg());
      }
      HASH_GUARD(0x65BD6700742BF3C2LL, openblob) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD(0x3AA4CCEC6BD68143LL, createaggregate) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD(0x21F68C010C124BC4LL, open) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD(0x632B468FC2FCAB0ALL, lasterrorcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x7CECF508291057CDLL, createfunction) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD(0x64D2BDB189B02819LL, changes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD(0x1B3CDE890A487664LL, loadextension) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD(0x5024F08DB0FDCBE6LL, lastinsertrowid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD(0x5AE41239FF63D86ALL, version) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD(0x156B1FAE4132ABEELL, querysingle) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x607C4C73BB251635LL, escapestring) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3 = {
  c_sqlite3::os_getInit,
  c_sqlite3::os_get,
  c_sqlite3::os_lval,
  c_sqlite3::os_invoke,
  c_sqlite3::os_constant,
};
Object co_domattr(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domattr)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domattr
Variant c_domattr::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domattr
Variant c_domattr::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domattr
Variant &c_domattr::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domattr
void c_domattr::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domattr
void c_domattr::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_domattr
Variant c_domattr::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domattr
Variant c_domattr::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domattr
Variant c_domattr::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domattr
bool c_domattr::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domattr
bool c_domattr::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domattr
bool c_domattr::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_domattr
Variant c_domattr::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domattr
Variant c_domattr::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domattr
Variant c_domattr::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domattr
Variant& c_domattr::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domattr
Variant& c_domattr::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domattr
Variant& c_domattr::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domattr
Variant c_domattr::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domattr
IMPLEMENT_CLASS(domattr)
c_domattr *c_domattr::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domattr::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domattr::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domattr::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domattr::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domattr::cloneImpl() {
  c_domattr *obj = NEW(c_domattr)();
  cloneSet(obj);
  return obj;
}
void c_domattr::cloneSet(c_domattr *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domattr::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
Variant c_domattr::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      HASH_GUARD(0x30A9329415D17F24LL, isid) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
Variant c_domattr::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD(0x30A9329415D17F24LL, isid) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domattr
Variant c_domattr::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domattr
Variant c_domattr::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD(0x30A9329415D17F24LL, isid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domattr::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domattr = {
  c_domattr::os_getInit,
  c_domattr::os_get,
  c_domattr::os_lval,
  c_domattr::os_invoke,
  c_domattr::os_constant,
};
Object co_soapvar(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapvar)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapvar
Variant c_soapvar::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapvar
Variant c_soapvar::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapvar
Variant &c_soapvar::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapvar
void c_soapvar::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapvar
void c_soapvar::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapvar
Variant c_soapvar::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapvar
Variant c_soapvar::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapvar
Variant c_soapvar::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapvar
bool c_soapvar::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapvar
bool c_soapvar::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapvar
bool c_soapvar::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapvar
Variant c_soapvar::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapvar
Variant c_soapvar::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapvar
Variant c_soapvar::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapvar
Variant& c_soapvar::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapvar
Variant& c_soapvar::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapvar
Variant& c_soapvar::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapvar
Variant c_soapvar::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapvar
IMPLEMENT_CLASS(soapvar)
c_soapvar *c_soapvar::create(Variant a0, Variant a1, String a2, String a3, String a4, String a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_soapvar::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_soapvar::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_soapvar::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_soapvar::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapvar::cloneImpl() {
  c_soapvar *obj = NEW(c_soapvar)();
  cloneSet(obj);
  return obj;
}
void c_soapvar::cloneSet(c_soapvar *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
Variant c_soapvar::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
Variant c_soapvar::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapvar
Variant c_soapvar::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapvar
Variant c_soapvar::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapvar::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapvar = {
  c_soapvar::os_getInit,
  c_soapvar::os_get,
  c_soapvar::os_lval,
  c_soapvar::os_invoke,
  c_soapvar::os_constant,
};
Object co_domnamednodemap(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnamednodemap)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnamednodemap
Variant c_domnamednodemap::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnamednodemap
Variant c_domnamednodemap::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnamednodemap
Variant &c_domnamednodemap::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnamednodemap
void c_domnamednodemap::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnamednodemap
void c_domnamednodemap::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnamednodemap
Variant c_domnamednodemap::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnamednodemap
Variant c_domnamednodemap::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnamednodemap
Variant c_domnamednodemap::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnamednodemap
bool c_domnamednodemap::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnamednodemap
bool c_domnamednodemap::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnamednodemap
bool c_domnamednodemap::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnamednodemap
Variant c_domnamednodemap::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnamednodemap
Variant c_domnamednodemap::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnamednodemap
Variant c_domnamednodemap::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnamednodemap
Variant& c_domnamednodemap::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnamednodemap
Variant& c_domnamednodemap::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnamednodemap
Variant& c_domnamednodemap::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnamednodemap
Variant c_domnamednodemap::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnamednodemap
IMPLEMENT_CLASS(domnamednodemap)
c_domnamednodemap *c_domnamednodemap::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnamednodemap::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnamednodemap::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnamednodemap::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnamednodemap::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnamednodemap::cloneImpl() {
  c_domnamednodemap *obj = NEW(c_domnamednodemap)();
  cloneSet(obj);
  return obj;
}
void c_domnamednodemap::cloneSet(c_domnamednodemap *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnamednodemap::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD(0x5D3CEC627F9ADC3ALL, getnameditem) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnameditem(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD(0x53B4D840FF4F0F1BLL, getnameditemns) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getnameditemns(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x5D3CEC627F9ADC3ALL, getnameditem) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x53B4D840FF4F0F1BLL, getnameditemns) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnamednodemap
Variant c_domnamednodemap::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x5D3CEC627F9ADC3ALL, getnameditem) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x53B4D840FF4F0F1BLL, getnameditemns) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnamednodemap::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnamednodemap = {
  c_domnamednodemap::os_getInit,
  c_domnamednodemap::os_get,
  c_domnamednodemap::os_lval,
  c_domnamednodemap::os_invoke,
  c_domnamednodemap::os_constant,
};
Object co_sqlite3result(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3result)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3result
Variant c_sqlite3result::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3result
Variant c_sqlite3result::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3result
Variant &c_sqlite3result::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3result
void c_sqlite3result::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3result
void c_sqlite3result::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3result
Variant c_sqlite3result::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3result
Variant c_sqlite3result::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3result
Variant c_sqlite3result::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3result
bool c_sqlite3result::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3result
bool c_sqlite3result::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3result
bool c_sqlite3result::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3result
Variant c_sqlite3result::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3result
Variant c_sqlite3result::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3result
Variant c_sqlite3result::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3result
Variant& c_sqlite3result::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3result
Variant& c_sqlite3result::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3result
Variant& c_sqlite3result::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3result
Variant c_sqlite3result::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3result
IMPLEMENT_CLASS(sqlite3result)
c_sqlite3result *c_sqlite3result::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_sqlite3result::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_sqlite3result::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_sqlite3result::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_sqlite3result::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3result::cloneImpl() {
  c_sqlite3result *obj = NEW(c_sqlite3result)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3result::cloneSet(c_sqlite3result *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD(0x4C7702FC22784996LL, numcolumns) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD(0x696EFC04EE7E47F8LL, columnname) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columnname(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD(0x59F73C4DEF1C3A6BLL, fetcharray) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetcharray());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetcharray(arg0));
        }
      }
      break;
    case 12:
      HASH_GUARD(0x32A58B0CE493957CLL, finalize) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD(0x42EDB5CA009D8C6DLL, columntype) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columntype(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD(0x4C7702FC22784996LL, numcolumns) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD(0x696EFC04EE7E47F8LL, columnname) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x59F73C4DEF1C3A6BLL, fetcharray) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD(0x32A58B0CE493957CLL, finalize) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD(0x42EDB5CA009D8C6DLL, columntype) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3result
Variant c_sqlite3result::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD(0x4C7702FC22784996LL, numcolumns) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD(0x696EFC04EE7E47F8LL, columnname) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x59F73C4DEF1C3A6BLL, fetcharray) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD(0x32A58B0CE493957CLL, finalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD(0x42EDB5CA009D8C6DLL, columntype) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3result::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3result = {
  c_sqlite3result::os_getInit,
  c_sqlite3result::os_get,
  c_sqlite3result::os_lval,
  c_sqlite3result::os_invoke,
  c_sqlite3result::os_constant,
};
Object co_simplexmlelement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_simplexmlelement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelement
Variant c_simplexmlelement::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelement
Variant c_simplexmlelement::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelement
Variant &c_simplexmlelement::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelement
void c_simplexmlelement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelement
void c_simplexmlelement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_simplexmlelement
Variant c_simplexmlelement::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelement
Variant c_simplexmlelement::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelement
Variant c_simplexmlelement::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_simplexmlelement
bool c_simplexmlelement::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelement
bool c_simplexmlelement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelement
bool c_simplexmlelement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_simplexmlelement
Variant c_simplexmlelement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelement
Variant c_simplexmlelement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelement
Variant c_simplexmlelement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_simplexmlelement
Variant& c_simplexmlelement::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelement
Variant& c_simplexmlelement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelement
Variant& c_simplexmlelement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelement
Variant c_simplexmlelement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelement
IMPLEMENT_CLASS(simplexmlelement)
c_simplexmlelement *c_simplexmlelement::create(String a0, int64 a1, bool a2, String a3, bool a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_simplexmlelement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_simplexmlelement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_simplexmlelement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_simplexmlelement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_simplexmlelement::cloneImpl() {
  c_simplexmlelement *obj = NEW(c_simplexmlelement)();
  cloneSet(obj);
  return obj;
}
void c_simplexmlelement::cloneSet(c_simplexmlelement *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_simplexmlelement::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x3E6BCFB9742FC700LL, offsetexists) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetexists(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 16:
      HASH_GUARD(0x5CEFA5A265104D10LL, count) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x2DDE12A9866FC794LL, addchild) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addchild(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addchild(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addchild(arg0, arg1, arg2));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD(0x52F7AA6C19BEEAD6LL, addattribute) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addattribute(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addattribute(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addattribute(arg0, arg1, arg2), null);
        }
      }
      break;
    case 24:
      HASH_GUARD(0x61D11ECEF4404498LL, offsetget) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetget(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD(0x0817454F196A9A1BLL, xpath) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xpath(arg0));
        }
      }
      HASH_GUARD(0x04FB7028C9A2079BLL, __unset) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___unset(arg0));
        }
      }
      break;
    case 29:
      HASH_GUARD(0x4B65E1A09A33F21DLL, attributes) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_attributes());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_attributes(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_attributes(arg0, arg1));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD(0x6D9D75B7E3B40FA6LL, getnamespaces) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnamespaces(arg0));
        }
      }
      HASH_GUARD(0x5C09D9345FD864A6LL, asxml) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_asxml());
          CVarRef arg0((ad->getValue(pos)));
          return (t_asxml(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD(0x2B299E949E2E82ADLL, children) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_children());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_children(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_children(arg0, arg1));
        }
      }
      break;
    case 46:
      HASH_GUARD(0x4FE08FDDAE2178EELL, __isset) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___isset(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x0D08AA5F0B2F34F1LL, getdocnamespaces) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getdocnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getdocnamespaces(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD(0x0957F693A48AF738LL, offsetset) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_offsetset(arg0, arg1), null);
        }
      }
      break;
    case 58:
      HASH_GUARD(0x08329980E6369ABALL, offsetunset) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetunset(arg0), null);
        }
      }
      break;
    case 61:
      HASH_GUARD(0x3FE8F6937854F83DLL, registerxpathnamespace) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registerxpathnamespace(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x3E6BCFB9742FC700LL, offsetexists) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD(0x5CEFA5A265104D10LL, count) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x2DDE12A9866FC794LL, addchild) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(a0));
        if (count == 2) return (t_addchild(a0, a1));
        return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x52F7AA6C19BEEAD6LL, addattribute) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(a0), null);
        if (count == 2) return (t_addattribute(a0, a1), null);
        return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD(0x61D11ECEF4404498LL, offsetget) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0817454F196A9A1BLL, xpath) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(a0));
      }
      HASH_GUARD(0x04FB7028C9A2079BLL, __unset) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4B65E1A09A33F21DLL, attributes) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        if (count == 1) return (t_attributes(a0));
        return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD(0x6D9D75B7E3B40FA6LL, getnamespaces) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        return (t_getnamespaces(a0));
      }
      HASH_GUARD(0x5C09D9345FD864A6LL, asxml) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x2B299E949E2E82ADLL, children) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        if (count == 1) return (t_children(a0));
        return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD(0x4FE08FDDAE2178EELL, __isset) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x0D08AA5F0B2F34F1LL, getdocnamespaces) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD(0x0957F693A48AF738LL, offsetset) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD(0x08329980E6369ABALL, offsetunset) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD(0x3FE8F6937854F83DLL, registerxpathnamespace) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelement
Variant c_simplexmlelement::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x3E6BCFB9742FC700LL, offsetexists) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD(0x5CEFA5A265104D10LL, count) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x2DDE12A9866FC794LL, addchild) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x52F7AA6C19BEEAD6LL, addattribute) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD(0x61D11ECEF4404498LL, offsetget) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0817454F196A9A1BLL, xpath) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xpath(a0));
      }
      HASH_GUARD(0x04FB7028C9A2079BLL, __unset) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4B65E1A09A33F21DLL, attributes) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD(0x6D9D75B7E3B40FA6LL, getnamespaces) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      HASH_GUARD(0x5C09D9345FD864A6LL, asxml) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x2B299E949E2E82ADLL, children) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD(0x4FE08FDDAE2178EELL, __isset) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x0D08AA5F0B2F34F1LL, getdocnamespaces) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD(0x0957F693A48AF738LL, offsetset) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD(0x08329980E6369ABALL, offsetunset) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD(0x3FE8F6937854F83DLL, registerxpathnamespace) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_simplexmlelement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_simplexmlelement = {
  c_simplexmlelement::os_getInit,
  c_simplexmlelement::os_get,
  c_simplexmlelement::os_lval,
  c_simplexmlelement::os_invoke,
  c_simplexmlelement::os_constant,
};
Object co_memcache(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_memcache)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_memcache
Variant c_memcache::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_memcache
Variant c_memcache::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_memcache
Variant &c_memcache::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_memcache
void c_memcache::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_memcache
void c_memcache::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_get_memcache
Variant c_memcache::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_memcache
Variant c_memcache::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_memcache
Variant c_memcache::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_exists_memcache
bool c_memcache::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_memcache
bool c_memcache::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_memcache
bool c_memcache::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_set_memcache
Variant c_memcache::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_memcache
Variant c_memcache::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_memcache
Variant c_memcache::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_lval_memcache
Variant& c_memcache::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_memcache
Variant& c_memcache::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_memcache
Variant& c_memcache::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_memcache
Variant c_memcache::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_memcache
IMPLEMENT_CLASS(memcache)
c_memcache *c_memcache::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_memcache::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_memcache::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_memcache::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_memcache::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_memcache::cloneImpl() {
  c_memcache *obj = NEW(c_memcache)();
  cloneSet(obj);
  return obj;
}
void c_memcache::cloneSet(c_memcache *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
Variant c_memcache::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD(0x42FAC655280A6146LL, replace) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_replace(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_replace(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replace(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 7:
      HASH_GUARD(0x39099707DF7945C7LL, increment) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_increment(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_increment(arg0, arg1));
        }
      }
      break;
    case 11:
      HASH_GUARD(0x3BF3710A1661DE0BLL, setoptimeout) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setoptimeout(arg0));
        }
      }
      HASH_GUARD(0x15D34462FC79458BLL, add) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_add(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_add(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_add(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x710DE893BB376C4FLL, getserverstatus) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getserverstatus(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getserverstatus(arg0, arg1));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x030429D528A8EA92LL, setcompressthreshold) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setcompressthreshold(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setcompressthreshold(arg0, arg1));
        }
      }
      break;
    case 19:
      HASH_GUARD(0x1C660E5BFA6F55D3LL, delete) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_delete(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_delete(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD(0x7521E8833BE3D316LL, getversion) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD(0x1CCDC4317CE59BD9LL, getstats) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getstats(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_getstats(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getstats(arg0, arg1, arg2));
        }
      }
      break;
    case 26:
      HASH_GUARD(0x2A733FC12BA4C1DALL, decrement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_decrement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_decrement(arg0, arg1));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x399A6427C2185621LL, set) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_set(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_set(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_set(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 37:
      HASH_GUARD(0x4770E54B86BF7765LL, getextendedstats) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getextendedstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getextendedstats(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_getextendedstats(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getextendedstats(arg0, arg1, arg2));
        }
      }
      break;
    case 38:
      HASH_GUARD(0x56CD24186237AAE6LL, addserver) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addserver(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_addserver(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_addserver(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_addserver(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_addserver(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 6) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5));
          CVarRef arg6((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 7) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
          CVarRef arg7((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 8) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
          CVarRef arg8((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
        }
      }
      break;
    case 40:
      HASH_GUARD(0x25DCCC35D69AD828LL, get) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_get(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t_get(arg0, ref(arg1)));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD(0x742B441E13CD7279LL, pconnect) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_pconnect(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_pconnect(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_pconnect(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_pconnect(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 58:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 61:
      HASH_GUARD(0x1780351E8EFF92BDLL, setserverparams) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setserverparams(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_setserverparams(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_setserverparams(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_setserverparams(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_setserverparams(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setserverparams(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 62:
      HASH_GUARD(0x7032C660AD16D7FELL, connect) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_connect(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_connect(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_connect(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_connect(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
Variant c_memcache::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD(0x42FAC655280A6146LL, replace) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        if (count <= 2) return (t_replace(a0, a1));
        if (count == 3) return (t_replace(a0, a1, a2));
        return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD(0x39099707DF7945C7LL, increment) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        if (count <= 1) return (t_increment(a0));
        return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD(0x3BF3710A1661DE0BLL, setoptimeout) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        return (t_setoptimeout(a0));
      }
      HASH_GUARD(0x15D34462FC79458BLL, add) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        if (count <= 2) return (t_add(a0, a1));
        if (count == 3) return (t_add(a0, a1, a2));
        return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD(0x710DE893BB376C4FLL, getserverstatus) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        if (count <= 1) return (t_getserverstatus(a0));
        return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD(0x030429D528A8EA92LL, setcompressthreshold) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        if (count <= 1) return (t_setcompressthreshold(a0));
        return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD(0x1C660E5BFA6F55D3LL, delete) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        if (count <= 1) return (t_delete(a0));
        return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x7521E8833BE3D316LL, getversion) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD(0x1CCDC4317CE59BD9LL, getstats) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        if (count <= 0) return (t_getstats());
        if (count == 1) return (t_getstats(a0));
        if (count == 2) return (t_getstats(a0, a1));
        return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD(0x2A733FC12BA4C1DALL, decrement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        if (count <= 1) return (t_decrement(a0));
        return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x399A6427C2185621LL, set) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        if (count <= 2) return (t_set(a0, a1));
        if (count == 3) return (t_set(a0, a1, a2));
        return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD(0x4770E54B86BF7765LL, getextendedstats) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        if (count <= 0) return (t_getextendedstats());
        if (count == 1) return (t_getextendedstats(a0));
        if (count == 2) return (t_getextendedstats(a0, a1));
        return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD(0x56CD24186237AAE6LL, addserver) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        if (count <= 1) return (t_addserver(a0));
        if (count == 2) return (t_addserver(a0, a1));
        if (count == 3) return (t_addserver(a0, a1, a2));
        if (count == 4) return (t_addserver(a0, a1, a2, a3));
        if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        return (t_addserver(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 40:
      HASH_GUARD(0x25DCCC35D69AD828LL, get) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        if (count <= 1) return (t_get(a0));
        return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD(0x742B441E13CD7279LL, pconnect) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        if (count <= 1) return (t_pconnect(a0), null);
        if (count == 2) return (t_pconnect(a0, a1), null);
        if (count == 3) return (t_pconnect(a0, a1, a2), null);
        return (t_pconnect(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD(0x1780351E8EFF92BDLL, setserverparams) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        if (count <= 1) return (t_setserverparams(a0));
        if (count == 2) return (t_setserverparams(a0, a1));
        if (count == 3) return (t_setserverparams(a0, a1, a2));
        if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD(0x7032C660AD16D7FELL, connect) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        if (count <= 1) return (t_connect(a0), null);
        if (count == 2) return (t_connect(a0, a1), null);
        if (count == 3) return (t_connect(a0, a1, a2), null);
        return (t_connect(a0, a1, a2, a3), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_memcache
Variant c_memcache::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_memcache
Variant c_memcache::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD(0x42FAC655280A6146LL, replace) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_replace(a0, a1));
        else if (count == 3) return (t_replace(a0, a1, a2));
        else return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD(0x39099707DF7945C7LL, increment) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD(0x3BF3710A1661DE0BLL, setoptimeout) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setoptimeout(a0));
      }
      HASH_GUARD(0x15D34462FC79458BLL, add) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_add(a0, a1));
        else if (count == 3) return (t_add(a0, a1, a2));
        else return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD(0x710DE893BB376C4FLL, getserverstatus) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getserverstatus(a0));
        else return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD(0x030429D528A8EA92LL, setcompressthreshold) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setcompressthreshold(a0));
        else return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD(0x1C660E5BFA6F55D3LL, delete) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x7521E8833BE3D316LL, getversion) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD(0x1CCDC4317CE59BD9LL, getstats) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getstats());
        else if (count == 1) return (t_getstats(a0));
        else if (count == 2) return (t_getstats(a0, a1));
        else return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD(0x2A733FC12BA4C1DALL, decrement) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x399A6427C2185621LL, set) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_set(a0, a1));
        else if (count == 3) return (t_set(a0, a1, a2));
        else return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD(0x4770E54B86BF7765LL, getextendedstats) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getextendedstats());
        else if (count == 1) return (t_getextendedstats(a0));
        else if (count == 2) return (t_getextendedstats(a0, a1));
        else return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD(0x56CD24186237AAE6LL, addserver) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        Variant a6;
        Variant a7;
        Variant a8;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a6 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a7 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a8 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addserver(a0));
        else if (count == 2) return (t_addserver(a0, a1));
        else if (count == 3) return (t_addserver(a0, a1, a2));
        else if (count == 4) return (t_addserver(a0, a1, a2, a3));
        else if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        else if (count == 6) return (t_addserver(a0, a1, a2, a3, a4, a5));
        else if (count == 7) return (t_addserver(a0, a1, a2, a3, a4, a5, a6));
        else if (count == 8) return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7));
        else return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7, a8));
      }
      break;
    case 40:
      HASH_GUARD(0x25DCCC35D69AD828LL, get) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_get(a0));
        else return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD(0x742B441E13CD7279LL, pconnect) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_pconnect(a0), null);
        else if (count == 2) return (t_pconnect(a0, a1), null);
        else if (count == 3) return (t_pconnect(a0, a1, a2), null);
        else return (t_pconnect(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD(0x1780351E8EFF92BDLL, setserverparams) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setserverparams(a0));
        else if (count == 2) return (t_setserverparams(a0, a1));
        else if (count == 3) return (t_setserverparams(a0, a1, a2));
        else if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        else if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        else return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD(0x7032C660AD16D7FELL, connect) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_connect(a0), null);
        else if (count == 2) return (t_connect(a0, a1), null);
        else if (count == 3) return (t_connect(a0, a1, a2), null);
        else return (t_connect(a0, a1, a2, a3), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_memcache::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_memcache = {
  c_memcache::os_getInit,
  c_memcache::os_get,
  c_memcache::os_lval,
  c_memcache::os_invoke,
  c_memcache::os_constant,
};
Object co_domprocessinginstruction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domprocessinginstruction)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domprocessinginstruction
Variant c_domprocessinginstruction::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domprocessinginstruction
Variant c_domprocessinginstruction::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domprocessinginstruction
Variant &c_domprocessinginstruction::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domprocessinginstruction
void c_domprocessinginstruction::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domprocessinginstruction
void c_domprocessinginstruction::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_domprocessinginstruction
Variant c_domprocessinginstruction::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domprocessinginstruction
Variant c_domprocessinginstruction::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domprocessinginstruction
Variant c_domprocessinginstruction::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domprocessinginstruction
bool c_domprocessinginstruction::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domprocessinginstruction
bool c_domprocessinginstruction::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domprocessinginstruction
bool c_domprocessinginstruction::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_domprocessinginstruction
Variant c_domprocessinginstruction::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domprocessinginstruction
Variant c_domprocessinginstruction::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domprocessinginstruction
Variant c_domprocessinginstruction::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domprocessinginstruction
Variant c_domprocessinginstruction::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domprocessinginstruction
IMPLEMENT_CLASS(domprocessinginstruction)
c_domprocessinginstruction *c_domprocessinginstruction::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domprocessinginstruction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domprocessinginstruction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domprocessinginstruction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domprocessinginstruction::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domprocessinginstruction::cloneImpl() {
  c_domprocessinginstruction *obj = NEW(c_domprocessinginstruction)();
  cloneSet(obj);
  return obj;
}
void c_domprocessinginstruction::cloneSet(c_domprocessinginstruction *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domprocessinginstruction::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domprocessinginstruction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domprocessinginstruction = {
  c_domprocessinginstruction::os_getInit,
  c_domprocessinginstruction::os_get,
  c_domprocessinginstruction::os_lval,
  c_domprocessinginstruction::os_invoke,
  c_domprocessinginstruction::os_constant,
};
Object co_pdostatement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdostatement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdostatement
Variant c_pdostatement::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdostatement
Variant c_pdostatement::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdostatement
Variant &c_pdostatement::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdostatement
void c_pdostatement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_pdostatement
void c_pdostatement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdostatement
Variant c_pdostatement::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdostatement
Variant c_pdostatement::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdostatement
Variant c_pdostatement::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdostatement
bool c_pdostatement::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdostatement
bool c_pdostatement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdostatement
bool c_pdostatement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdostatement
Variant c_pdostatement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdostatement
Variant c_pdostatement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdostatement
Variant c_pdostatement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdostatement
Variant& c_pdostatement::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdostatement
Variant& c_pdostatement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdostatement
Variant& c_pdostatement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdostatement
Variant c_pdostatement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdostatement
IMPLEMENT_CLASS(pdostatement)
c_pdostatement *c_pdostatement::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_pdostatement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_pdostatement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_pdostatement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_pdostatement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdostatement::cloneImpl() {
  c_pdostatement *obj = NEW(c_pdostatement)();
  cloneSet(obj);
  return obj;
}
void c_pdostatement::cloneSet(c_pdostatement *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
Variant c_pdostatement::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x5740729B65EB8E41LL, fetchall) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchall());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchall(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fetchall(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetchall(arg0, arg1, arg2));
        }
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 5:
      HASH_GUARD(0x75A2E23098C65C05LL, closecursor) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_execute());
          CVarRef arg0((ad->getValue(pos)));
          return (t_execute(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x32A381ECDC91918FLL, columncount) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 18:
      HASH_GUARD(0x31A8917EC4F2A252LL, nextrowset) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindparam(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_bindparam(arg0, ref(arg1), arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_bindparam(arg0, ref(arg1), arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindparam(arg0, ref(arg1), arg2, arg3, arg4));
        }
      }
      break;
    case 25:
      HASH_GUARD(0x5C38814410C5FFD9LL, fetchcolumn) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchcolumn());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetchcolumn(arg0));
        }
      }
      break;
    case 26:
      HASH_GUARD(0x0D43A7148903299ALL, rowcount) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 29:
      HASH_GUARD(0x1C87AD14A095219DLL, bindcolumn) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          if (count <= 2) return (t_bindcolumn(arg0, ref(arg1)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_bindcolumn(arg0, ref(arg1), arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_bindcolumn(arg0, ref(arg1), arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_bindcolumn(arg0, ref(arg1), arg2, arg3, arg4));
        }
      }
      HASH_GUARD(0x0E1814AA3327229DLL, fetchobject) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchobject());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchobject(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetchobject(arg0, arg1));
        }
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x78C9BF8620136861LL, setfetchmode) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setfetchmode(count, arg0));
          return (t_setfetchmode(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 34:
      HASH_GUARD(0x699F5A1E3BD7B2A2LL, debugdumpparams) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 59:
      HASH_GUARD(0x5B6B980006E717FBLL, getcolumnmeta) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getcolumnmeta(arg0));
        }
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetch());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetch(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fetch(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fetch(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
Variant c_pdostatement::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x5740729B65EB8E41LL, fetchall) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        if (count == 1) return (t_fetchall(a0));
        if (count == 2) return (t_fetchall(a0, a1));
        return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 5:
      HASH_GUARD(0x75A2E23098C65C05LL, closecursor) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x32A381ECDC91918FLL, columncount) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 18:
      HASH_GUARD(0x31A8917EC4F2A252LL, nextrowset) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD(0x5C38814410C5FFD9LL, fetchcolumn) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD(0x0D43A7148903299ALL, rowcount) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 29:
      HASH_GUARD(0x1C87AD14A095219DLL, bindcolumn) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD(0x0E1814AA3327229DLL, fetchobject) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        if (count == 1) return (t_fetchobject(a0));
        return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x78C9BF8620136861LL, setfetchmode) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setfetchmode(count,a0, params));
      }
      break;
    case 34:
      HASH_GUARD(0x699F5A1E3BD7B2A2LL, debugdumpparams) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 59:
      HASH_GUARD(0x5B6B980006E717FBLL, getcolumnmeta) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        if (count == 1) return (t_fetch(a0));
        if (count == 2) return (t_fetch(a0, a1));
        return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdostatement
Variant c_pdostatement::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdostatement
Variant c_pdostatement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x5740729B65EB8E41LL, fetchall) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 5:
      HASH_GUARD(0x75A2E23098C65C05LL, closecursor) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x32A381ECDC91918FLL, columncount) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columncount());
      }
      break;
    case 18:
      HASH_GUARD(0x31A8917EC4F2A252LL, nextrowset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD(0x5C38814410C5FFD9LL, fetchcolumn) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD(0x0D43A7148903299ALL, rowcount) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 29:
      HASH_GUARD(0x1C87AD14A095219DLL, bindcolumn) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD(0x0E1814AA3327229DLL, fetchobject) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x78C9BF8620136861LL, setfetchmode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 34:
      HASH_GUARD(0x699F5A1E3BD7B2A2LL, debugdumpparams) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 59:
      HASH_GUARD(0x5B6B980006E717FBLL, getcolumnmeta) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdostatement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdostatement = {
  c_pdostatement::os_getInit,
  c_pdostatement::os_get,
  c_pdostatement::os_lval,
  c_pdostatement::os_invoke,
  c_pdostatement::os_constant,
};
Object co_soapclient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapclient)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapclient
Variant c_soapclient::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapclient
Variant c_soapclient::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapclient
Variant &c_soapclient::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapclient
void c_soapclient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapclient
void c_soapclient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapclient
Variant c_soapclient::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapclient
Variant c_soapclient::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapclient
Variant c_soapclient::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapclient
bool c_soapclient::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapclient
bool c_soapclient::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapclient
bool c_soapclient::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapclient
Variant c_soapclient::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapclient
Variant c_soapclient::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapclient
Variant c_soapclient::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapclient
Variant& c_soapclient::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapclient
Variant& c_soapclient::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapclient
Variant& c_soapclient::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapclient
Variant c_soapclient::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapclient
IMPLEMENT_CLASS(soapclient)
c_soapclient *c_soapclient::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapclient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_soapclient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_soapclient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_soapclient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapclient::cloneImpl() {
  c_soapclient *obj = NEW(c_soapclient)();
  cloneSet(obj);
  return obj;
}
void c_soapclient::cloneSet(c_soapclient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_soapclient::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
Variant c_soapclient::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD(0x5C5C1E24A140F6E4LL, __getlastrequest) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD(0x3648EE7D3B37DE8CLL, __getlastrequestheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD(0x5D73364F53CEEB6CLL, __call) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___call(arg0, arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD(0x1365B3105FC59871LL, __getfunctions) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x3CA9145031035A54LL, __getlastresponse) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD(0x19A26CEC7E8AAEF5LL, __dorequest) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 4) return (t___dorequest(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___dorequest(arg0, arg1, arg2, arg3, arg4));
        }
      }
      HASH_GUARD(0x52C6ABACCBFD0C75LL, __setcookie) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___setcookie(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___setcookie(arg0, arg1));
        }
      }
      HASH_GUARD(0x628D398E7604B9D5LL, __gettypes) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD(0x4A2F89F662050D99LL, __soapcall) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___soapcall(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___soapcall(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___soapcall(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t___soapcall(arg0, arg1, arg2, arg3, ref(arg4)));
        }
      }
      break;
    case 26:
      HASH_GUARD(0x0C94657A58A82CFALL, __getlastresponseheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD(0x14842228D5E335BBLL, __setsoapheaders) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setsoapheaders());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setsoapheaders(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x232D13904DBC36FFLL, __setlocation) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setlocation());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setlocation(arg0));
        }
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
Variant c_soapclient::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD(0x5C5C1E24A140F6E4LL, __getlastrequest) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD(0x3648EE7D3B37DE8CLL, __getlastrequestheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD(0x5D73364F53CEEB6CLL, __call) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x1365B3105FC59871LL, __getfunctions) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x3CA9145031035A54LL, __getlastresponse) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD(0x19A26CEC7E8AAEF5LL, __dorequest) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD(0x52C6ABACCBFD0C75LL, __setcookie) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(a0));
        return (t___setcookie(a0, a1));
      }
      HASH_GUARD(0x628D398E7604B9D5LL, __gettypes) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD(0x4A2F89F662050D99LL, __soapcall) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(a0, a1));
        if (count == 3) return (t___soapcall(a0, a1, a2));
        if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD(0x0C94657A58A82CFALL, __getlastresponseheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD(0x14842228D5E335BBLL, __setsoapheaders) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x232D13904DBC36FFLL, __setlocation) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        return (t___setlocation(a0));
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapclient
Variant c_soapclient::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapclient
Variant c_soapclient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD(0x5C5C1E24A140F6E4LL, __getlastrequest) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD(0x3648EE7D3B37DE8CLL, __getlastrequestheaders) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequestheaders());
      }
      HASH_GUARD(0x5D73364F53CEEB6CLL, __call) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x1365B3105FC59871LL, __getfunctions) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x3CA9145031035A54LL, __getlastresponse) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD(0x19A26CEC7E8AAEF5LL, __dorequest) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD(0x52C6ABACCBFD0C75LL, __setcookie) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      HASH_GUARD(0x628D398E7604B9D5LL, __gettypes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD(0x4A2F89F662050D99LL, __soapcall) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD(0x0C94657A58A82CFALL, __getlastresponseheaders) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD(0x14842228D5E335BBLL, __setsoapheaders) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x232D13904DBC36FFLL, __setlocation) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapclient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapclient = {
  c_soapclient::os_getInit,
  c_soapclient::os_get,
  c_soapclient::os_lval,
  c_soapclient::os_invoke,
  c_soapclient::os_constant,
};
Object co_soapparam(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapparam)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapparam
Variant c_soapparam::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapparam
Variant c_soapparam::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapparam
Variant &c_soapparam::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapparam
void c_soapparam::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapparam
void c_soapparam::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapparam
Variant c_soapparam::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapparam
Variant c_soapparam::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapparam
Variant c_soapparam::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapparam
bool c_soapparam::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapparam
bool c_soapparam::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapparam
bool c_soapparam::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapparam
Variant c_soapparam::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapparam
Variant c_soapparam::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapparam
Variant c_soapparam::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapparam
Variant& c_soapparam::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapparam
Variant& c_soapparam::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapparam
Variant& c_soapparam::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapparam
Variant c_soapparam::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapparam
IMPLEMENT_CLASS(soapparam)
c_soapparam *c_soapparam::create(Variant a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapparam::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_soapparam::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  }
}
void c_soapparam::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_soapparam::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapparam::cloneImpl() {
  c_soapparam *obj = NEW(c_soapparam)();
  cloneSet(obj);
  return obj;
}
void c_soapparam::cloneSet(c_soapparam *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
Variant c_soapparam::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
Variant c_soapparam::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapparam
Variant c_soapparam::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapparam
Variant c_soapparam::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapparam::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapparam = {
  c_soapparam::os_getInit,
  c_soapparam::os_get,
  c_soapparam::os_lval,
  c_soapparam::os_invoke,
  c_soapparam::os_constant,
};
Object co_datetime(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_datetime)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetime
Variant c_datetime::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetime
Variant c_datetime::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetime
Variant &c_datetime::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_datetime
void c_datetime::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_datetime
void c_datetime::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_datetime
Variant c_datetime::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetime
Variant c_datetime::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetime
Variant c_datetime::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_datetime
bool c_datetime::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetime
bool c_datetime::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetime
bool c_datetime::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_datetime
Variant c_datetime::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetime
Variant c_datetime::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetime
Variant c_datetime::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_datetime
Variant& c_datetime::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetime
Variant& c_datetime::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetime
Variant& c_datetime::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_datetime
Variant c_datetime::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_RETURN(0x65F665B8975D4C44LL, q_datetime_RSS, "RSS");
      break;
    case 5:
      HASH_RETURN(0x4C70260A54584B05LL, q_datetime_ATOM, "ATOM");
      break;
    case 9:
      HASH_RETURN(0x0D93F5DDBEAD7BC9LL, q_datetime_ISO8601, "ISO8601");
      break;
    case 10:
      HASH_RETURN(0x2E8A54E476F8FF8ALL, q_datetime_RFC850, "RFC850");
      break;
    case 12:
      HASH_RETURN(0x2183317DB64F7D2CLL, q_datetime_COOKIE, "COOKIE");
      HASH_RETURN(0x51E9E1D29858652CLL, q_datetime_RFC1036, "RFC1036");
      HASH_RETURN(0x2035891FE861602CLL, q_datetime_RFC3339, "RFC3339");
      break;
    case 23:
      HASH_RETURN(0x1CC8F0E77D83F017LL, q_datetime_RFC2822, "RFC2822");
      break;
    case 27:
      HASH_RETURN(0x64B53064426F891BLL, q_datetime_RFC822, "RFC822");
      HASH_RETURN(0x0D99FD60C002B3DBLL, q_datetime_W3C, "W3C");
      break;
    case 30:
      HASH_RETURN(0x325DE23E7968F7FELL, q_datetime_RFC1123, "RFC1123");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_datetime
IMPLEMENT_CLASS(datetime)
c_datetime *c_datetime::create(String a0, Object a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_datetime::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_datetime::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_datetime::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_datetime::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_datetime::cloneImpl() {
  c_datetime *obj = NEW(c_datetime)();
  cloneSet(obj);
  return obj;
}
void c_datetime::cloneSet(c_datetime *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
Variant c_datetime::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD(0x65A9B2950F080587LL, modify) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_modify(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD(0x67314943DC9D120BLL, setdate) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setdate(arg0, arg1, arg2));
        }
      }
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD(0x688601F33BE7716CLL, gettimezone) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x16D6DBFD6EE55A74LL, setisodate) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_setisodate(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setisodate(arg0, arg1, arg2));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x07CB96AB34F4C258LL, settime) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_settime(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_settime(arg0, arg1, arg2));
        }
      }
      HASH_GUARD(0x3B576E558B957CB8LL, settimezone) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_settimezone(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD(0x1B6DDAF6AAF8CA9BLL, format) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_format(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
Variant c_datetime::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD(0x65A9B2950F080587LL, modify) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x67314943DC9D120BLL, setdate) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD(0x688601F33BE7716CLL, gettimezone) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x16D6DBFD6EE55A74LL, setisodate) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(a0, a1));
        return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD(0x07CB96AB34F4C258LL, settime) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(a0, a1));
        return (t_settime(a0, a1, a2));
      }
      HASH_GUARD(0x3B576E558B957CB8LL, settimezone) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x1B6DDAF6AAF8CA9BLL, format) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetime
Variant c_datetime::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetime
Variant c_datetime::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD(0x65A9B2950F080587LL, modify) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x67314943DC9D120BLL, setdate) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD(0x688601F33BE7716CLL, gettimezone) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x16D6DBFD6EE55A74LL, setisodate) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD(0x07CB96AB34F4C258LL, settime) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      HASH_GUARD(0x3B576E558B957CB8LL, settimezone) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x1B6DDAF6AAF8CA9BLL, format) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_datetime::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_datetime = {
  c_datetime::os_getInit,
  c_datetime::os_get,
  c_datetime::os_lval,
  c_datetime::os_invoke,
  c_datetime::os_constant,
};
Object co_collator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_collator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_collator
Variant c_collator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_collator
Variant c_collator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_collator
Variant &c_collator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_collator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_collator
void c_collator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_collator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_collator
void c_collator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_collator
#ifndef OMIT_JUMP_TABLE_CLASS_get_collator
Variant c_collator::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_collator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_collator
Variant c_collator::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_collator
Variant c_collator::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_collator
bool c_collator::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_collator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_collator
bool c_collator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_collator
bool c_collator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_set_collator
Variant c_collator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_collator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_collator
Variant c_collator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_collator
Variant c_collator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_collator
Variant& c_collator::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_collator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_collator
Variant& c_collator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_collator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_collator
Variant& c_collator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_collator
Variant c_collator::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_RETURN(0x44D1DA387595A403LL, q_collator_SORT_REGULAR, "SORT_REGULAR");
      HASH_RETURN(0x243ECA9F2933DFC3LL, q_collator_ON, "ON");
      break;
    case 4:
      HASH_RETURN(0x2FC0EE2E1B088E44LL, q_collator_NUMERIC_COLLATION, "NUMERIC_COLLATION");
      break;
    case 7:
      HASH_RETURN(0x11D151DDDD2A4107LL, q_collator_HIRAGANA_QUATERNARY_MODE, "HIRAGANA_QUATERNARY_MODE");
      break;
    case 12:
      HASH_RETURN(0x12C49411F55E648CLL, q_collator_QUATERNARY, "QUATERNARY");
      break;
    case 20:
      HASH_RETURN(0x6A7AD33CDF49E8D4LL, q_collator_SORT_NUMERIC, "SORT_NUMERIC");
      HASH_RETURN(0x342F3FCC372ABD54LL, q_collator_NON_IGNORABLE, "NON_IGNORABLE");
      break;
    case 21:
      HASH_RETURN(0x43A7AE36C693E955LL, q_collator_DEFAULT_VALUE, "DEFAULT_VALUE");
      break;
    case 24:
      HASH_RETURN(0x6DED35804EDAD218LL, q_collator_CASE_LEVEL, "CASE_LEVEL");
      HASH_RETURN(0x0AE48A6C6BE5D798LL, q_collator_LOWER_FIRST, "LOWER_FIRST");
      break;
    case 27:
      HASH_RETURN(0x2C6A6D2A478AF4DBLL, q_collator_UPPER_FIRST, "UPPER_FIRST");
      break;
    case 29:
      HASH_RETURN(0x58342E71EC59E4DDLL, q_collator_IDENTICAL, "IDENTICAL");
      break;
    case 32:
      HASH_RETURN(0x092DDC88428C3A20LL, q_collator_PRIMARY, "PRIMARY");
      break;
    case 33:
      HASH_RETURN(0x713FE3D58B4C7661LL, q_collator_FRENCH_COLLATION, "FRENCH_COLLATION");
      HASH_RETURN(0x25FE54F210EC5FE1LL, q_collator_SECONDARY, "SECONDARY");
      HASH_RETURN(0x6E252898020550A1LL, q_collator_TERTIARY, "TERTIARY");
      break;
    case 35:
      HASH_RETURN(0x2C984380FDBF8563LL, q_collator_STRENGTH, "STRENGTH");
      break;
    case 39:
      HASH_RETURN(0x7306AAA31A7C8BE7LL, q_collator_DEFAULT_STRENGTH, "DEFAULT_STRENGTH");
      break;
    case 45:
      HASH_RETURN(0x304F6E12C5B7486DLL, q_collator_CASE_FIRST, "CASE_FIRST");
      break;
    case 52:
      HASH_RETURN(0x395D56BB0A8525F4LL, q_collator_NORMALIZATION_MODE, "NORMALIZATION_MODE");
      break;
    case 53:
      HASH_RETURN(0x595FDD99C9EFE835LL, q_collator_ALTERNATE_HANDLING, "ALTERNATE_HANDLING");
      break;
    case 60:
      HASH_RETURN(0x334AAA38C97C62FCLL, q_collator_SORT_STRING, "SORT_STRING");
      HASH_RETURN(0x0039CBFC3620143CLL, q_collator_SHIFTED, "SHIFTED");
      break;
    case 61:
      HASH_RETURN(0x136402C9E51A75FDLL, q_collator_OFF, "OFF");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_collator
IMPLEMENT_CLASS(collator)
c_collator *c_collator::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_collator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_collator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_collator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_collator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_collator::cloneImpl() {
  c_collator *obj = NEW(c_collator)();
  cloneSet(obj);
  return obj;
}
void c_collator::cloneSet(c_collator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_collator
Variant c_collator::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x43E057044D6296E0LL, geterrorcode) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD(0x2C7E06EB2965CE02LL, getlocale) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getlocale());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getlocale(arg0));
        }
      }
      break;
    case 8:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD(0x1F4984938E1DBB2ALL, sort) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          if (count <= 1) return (t_sort(ref(arg0)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_sort(ref(arg0), arg1));
        }
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 11:
      HASH_GUARD(0x365C573D887803EBLL, sortwithsortkeys) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          return (t_sortwithsortkeys(ref(arg0)));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x790B7C44A3442BEELL, asort) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValueRef(pos)));
          if (count <= 1) return (t_asort(ref(arg0)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_asort(ref(arg0), arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD(0x3B4D97DC8C437CD1LL, geterrormessage) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD(0x1BF74792BDECF352LL, compare) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_compare(arg0, arg1));
        }
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x3A0A2C5D90518456LL, create) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(o_getClassName(), arg0));
        }
      }
      break;
    case 23:
      HASH_GUARD(0x0B7AA0ED4CBF9ED7LL, setstrength) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setstrength(arg0));
        }
      }
      break;
    case 30:
      HASH_GUARD(0x1C15B5A1A05B4C5ELL, getstrength) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_collator
Variant c_collator::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x43E057044D6296E0LL, geterrorcode) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD(0x2C7E06EB2965CE02LL, getlocale) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        if (count <= 0) return (t_getlocale());
        return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x1F4984938E1DBB2ALL, sort) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        if (count <= 1) return (t_sort(ref(a0)));
        return (t_sort(ref(a0), a1));
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD(0x365C573D887803EBLL, sortwithsortkeys) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD(0x790B7C44A3442BEELL, asort) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        if (count <= 1) return (t_asort(ref(a0)));
        return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD(0x3B4D97DC8C437CD1LL, geterrormessage) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD(0x1BF74792BDECF352LL, compare) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x3A0A2C5D90518456LL, create) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD(0x0B7AA0ED4CBF9ED7LL, setstrength) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD(0x1C15B5A1A05B4C5ELL, getstrength) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_collator
Variant c_collator::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x3A0A2C5D90518456LL, create) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(c, arg0));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_collator
Variant c_collator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x43E057044D6296E0LL, geterrorcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD(0x2C7E06EB2965CE02LL, getlocale) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getlocale());
        else return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x1F4984938E1DBB2ALL, sort) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_sort(ref(a0)));
        else return (t_sort(ref(a0), a1));
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD(0x365C573D887803EBLL, sortwithsortkeys) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD(0x790B7C44A3442BEELL, asort) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_asort(ref(a0)));
        else return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD(0x3B4D97DC8C437CD1LL, geterrormessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD(0x1BF74792BDECF352LL, compare) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x3A0A2C5D90518456LL, create) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD(0x0B7AA0ED4CBF9ED7LL, setstrength) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD(0x1C15B5A1A05B4C5ELL, getstrength) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_collator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x3A0A2C5D90518456LL, create) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(c, a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_collator = {
  c_collator::os_getInit,
  c_collator::os_get,
  c_collator::os_lval,
  c_collator::os_invoke,
  c_collator::os_constant,
};
Object co_pdo(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdo)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdo
Variant c_pdo::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdo
Variant c_pdo::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdo
Variant &c_pdo::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdo
void c_pdo::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_pdo
void c_pdo::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdo
Variant c_pdo::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdo
Variant c_pdo::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdo
Variant c_pdo::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdo
bool c_pdo::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdo
bool c_pdo::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdo
bool c_pdo::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdo
Variant c_pdo::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdo
Variant c_pdo::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdo
Variant c_pdo::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdo
Variant& c_pdo::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdo
Variant& c_pdo::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdo
Variant& c_pdo::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdo
Variant c_pdo::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 0:
      HASH_RETURN(0x1800ED92A8884D00LL, q_pdo_ATTR_CASE, "ATTR_CASE");
      break;
    case 2:
      HASH_RETURN(0x07BAFBAE5A431902LL, q_pdo_ATTR_STATEMENT_CLASS, "ATTR_STATEMENT_CLASS");
      break;
    case 4:
      HASH_RETURN(0x0229D662F91D9C04LL, q_pdo_ERRMODE_EXCEPTION, "ERRMODE_EXCEPTION");
      break;
    case 8:
      HASH_RETURN(0x3BE7A02FD980AA08LL, q_pdo_CASE_NATURAL, "CASE_NATURAL");
      break;
    case 13:
      HASH_RETURN(0x099B533427CCC20DLL, q_pdo_FETCH_OBJ, "FETCH_OBJ");
      break;
    case 17:
      HASH_RETURN(0x5FAD218776C6E511LL, q_pdo_FETCH_INTO, "FETCH_INTO");
      break;
    case 25:
      HASH_RETURN(0x78CB81320C710019LL, q_pdo_FETCH_BOUND, "FETCH_BOUND");
      break;
    case 27:
      HASH_RETURN(0x3158D52C3627FE1BLL, q_pdo_MYSQL_ATTR_INIT_COMMAND, "MYSQL_ATTR_INIT_COMMAND");
      break;
    case 28:
      HASH_RETURN(0x03CF598D3CCCD01CLL, q_pdo_ATTR_CLIENT_VERSION, "ATTR_CLIENT_VERSION");
      break;
    case 29:
      HASH_RETURN(0x2BE16C4111A7B41DLL, q_pdo_ATTR_FETCH_CATALOG_NAMES, "ATTR_FETCH_CATALOG_NAMES");
      break;
    case 30:
      HASH_RETURN(0x2A5BA04D0218F11ELL, q_pdo_CASE_LOWER, "CASE_LOWER");
      break;
    case 35:
      HASH_RETURN(0x16B15CF4B0DD7E23LL, q_pdo_FETCH_GROUP, "FETCH_GROUP");
      break;
    case 37:
      HASH_RETURN(0x37F650C462FB6A25LL, q_pdo_CASE_UPPER, "CASE_UPPER");
      break;
    case 42:
      HASH_RETURN(0x262D9BE84029992ALL, q_pdo_PARAM_EVT_FETCH_POST, "PARAM_EVT_FETCH_POST");
      break;
    case 51:
      HASH_RETURN(0x15D2BCCED7726933LL, q_pdo_ATTR_TIMEOUT, "ATTR_TIMEOUT");
      break;
    case 59:
      HASH_RETURN(0x01B17428BEE0243BLL, q_pdo_PARAM_EVT_EXEC_PRE, "PARAM_EVT_EXEC_PRE");
      break;
    case 60:
      HASH_RETURN(0x2739A1D49673D43CLL, q_pdo_ATTR_ERRMODE, "ATTR_ERRMODE");
      HASH_RETURN(0x6AC5C285F4DD863CLL, q_pdo_ATTR_DEFAULT_FETCH_MODE, "ATTR_DEFAULT_FETCH_MODE");
      break;
    case 61:
      HASH_RETURN(0x3E11051E4101D73DLL, q_pdo_ATTR_EMULATE_PREPARES, "ATTR_EMULATE_PREPARES");
      break;
    case 68:
      HASH_RETURN(0x2189354E22363544LL, q_pdo_ATTR_PREFETCH, "ATTR_PREFETCH");
      break;
    case 72:
      HASH_RETURN(0x428D5CA64BB99E48LL, q_pdo_FETCH_UNIQUE, "FETCH_UNIQUE");
      break;
    case 78:
      HASH_RETURN(0x39B4E90F36E93B4ELL, q_pdo_MYSQL_ATTR_READ_DEFAULT_GROUP, "MYSQL_ATTR_READ_DEFAULT_GROUP");
      break;
    case 82:
      HASH_RETURN(0x58A833E2336C6152LL, q_pdo_ATTR_SERVER_INFO, "ATTR_SERVER_INFO");
      break;
    case 86:
      HASH_RETURN(0x57B75F4773C81556LL, q_pdo_PARAM_EVT_NORMALIZE, "PARAM_EVT_NORMALIZE");
      break;
    case 91:
      HASH_RETURN(0x5495020CF262F15BLL, q_pdo_ATTR_CONNECTION_STATUS, "ATTR_CONNECTION_STATUS");
      HASH_RETURN(0x37888F551D85275BLL, q_pdo_ATTR_ORACLE_NULLS, "ATTR_ORACLE_NULLS");
      break;
    case 97:
      HASH_RETURN(0x416A0550A8F12E61LL, q_pdo_MYSQL_ATTR_FOUND_ROWS, "MYSQL_ATTR_FOUND_ROWS");
      break;
    case 101:
      HASH_RETURN(0x15A3522970275465LL, q_pdo_FETCH_ORI_NEXT, "FETCH_ORI_NEXT");
      break;
    case 104:
      HASH_RETURN(0x162EAA2134F1C068LL, q_pdo_ATTR_FETCH_TABLE_NAMES, "ATTR_FETCH_TABLE_NAMES");
      break;
    case 111:
      HASH_RETURN(0x350E9275757FD66FLL, q_pdo_FETCH_ORI_REL, "FETCH_ORI_REL");
      break;
    case 112:
      HASH_RETURN(0x6870D9DE66F43D70LL, q_pdo_FETCH_ASSOC, "FETCH_ASSOC");
      break;
    case 113:
      HASH_RETURN(0x713C8339790FC071LL, q_pdo_ATTR_CURSOR_NAME, "ATTR_CURSOR_NAME");
      break;
    case 116:
      HASH_RETURN(0x1FB97A35B6711374LL, q_pdo_ATTR_MAX_COLUMN_LEN, "ATTR_MAX_COLUMN_LEN");
      break;
    case 117:
      HASH_RETURN(0x0E51487F9370EE75LL, q_pdo_ATTR_AUTOCOMMIT, "ATTR_AUTOCOMMIT");
      break;
    case 121:
      HASH_RETURN(0x630122BA9EC73379LL, q_pdo_PARAM_NULL, "PARAM_NULL");
      HASH_RETURN(0x05B00276031D7D79LL, q_pdo_PARAM_EVT_ALLOC, "PARAM_EVT_ALLOC");
      break;
    case 125:
      HASH_RETURN(0x500C039681520C7DLL, q_pdo_PARAM_BOOL, "PARAM_BOOL");
      break;
    case 126:
      HASH_RETURN(0x5CF4F38A0D7D087ELL, q_pdo_NULL_NATURAL, "NULL_NATURAL");
      break;
    case 131:
      HASH_RETURN(0x3F414F2735132983LL, q_pdo_PARAM_INT, "PARAM_INT");
      break;
    case 132:
      HASH_RETURN(0x2011B5A528057784LL, q_pdo_FETCH_NUM, "FETCH_NUM");
      break;
    case 133:
      HASH_RETURN(0x5451E44C627DD885LL, q_pdo_FETCH_ORI_PRIOR, "FETCH_ORI_PRIOR");
      break;
    case 134:
      HASH_RETURN(0x1B8BA5EEAABCB786LL, q_pdo_PARAM_EVT_EXEC_POST, "PARAM_EVT_EXEC_POST");
      HASH_RETURN(0x1B51C692B91D7486LL, q_pdo_MYSQL_ATTR_USE_BUFFERED_QUERY, "MYSQL_ATTR_USE_BUFFERED_QUERY");
      break;
    case 136:
      HASH_RETURN(0x7E64209D5A925F88LL, q_pdo_PARAM_STR, "PARAM_STR");
      break;
    case 138:
      HASH_RETURN(0x45AB9806DE21EA8ALL, q_pdo_ATTR_CURSOR, "ATTR_CURSOR");
      break;
    case 141:
      HASH_RETURN(0x0EDB017494A81E8DLL, q_pdo_ATTR_DRIVER_NAME, "ATTR_DRIVER_NAME");
      break;
    case 142:
      HASH_RETURN(0x126B3038F3355A8ELL, q_pdo_FETCH_USE_DEFAULT, "FETCH_USE_DEFAULT");
      break;
    case 143:
      HASH_RETURN(0x1F200B094608BE8FLL, q_pdo_ATTR_SERVER_VERSION, "ATTR_SERVER_VERSION");
      HASH_RETURN(0x1175C5F56147488FLL, q_pdo_MYSQL_ATTR_DIRECT_QUERY, "MYSQL_ATTR_DIRECT_QUERY");
      break;
    case 150:
      HASH_RETURN(0x25BE9238386C2796LL, q_pdo_FETCH_PROPS_LATE, "FETCH_PROPS_LATE");
      break;
    case 153:
      HASH_RETURN(0x657BEA5F741C4999LL, q_pdo_FETCH_COLUMN, "FETCH_COLUMN");
      HASH_RETURN(0x18B801DE8D8C9099LL, q_pdo_FETCH_CLASSTYPE, "FETCH_CLASSTYPE");
      break;
    case 156:
      HASH_RETURN(0x1EC178DF86F4FD9CLL, q_pdo_FETCH_SERIALIZE, "FETCH_SERIALIZE");
      break;
    case 160:
      HASH_RETURN(0x052245CE02FBF4A0LL, q_pdo_MYSQL_ATTR_LOCAL_INFILE, "MYSQL_ATTR_LOCAL_INFILE");
      break;
    case 162:
      HASH_RETURN(0x28D5B850B76FEEA2LL, q_pdo_FETCH_BOTH, "FETCH_BOTH");
      HASH_RETURN(0x0D0BCCC6768A88A2LL, q_pdo_FETCH_KEY_PAIR, "FETCH_KEY_PAIR");
      break;
    case 164:
      HASH_RETURN(0x6851B7545234FCA4LL, q_pdo_PARAM_EVT_FETCH_PRE, "PARAM_EVT_FETCH_PRE");
      break;
    case 168:
      HASH_RETURN(0x167DD614E842FAA8LL, q_pdo_CURSOR_FWDONLY, "CURSOR_FWDONLY");
      break;
    case 169:
      HASH_RETURN(0x6AEB66DE7A454FA9LL, q_pdo_FETCH_ORI_FIRST, "FETCH_ORI_FIRST");
      break;
    case 170:
      HASH_RETURN(0x392400A66B305EAALL, q_pdo_CURSOR_SCROLL, "CURSOR_SCROLL");
      break;
    case 171:
      HASH_RETURN(0x2F6AE87AF5701AABLL, q_pdo_FETCH_ORI_LAST, "FETCH_ORI_LAST");
      break;
    case 180:
      HASH_RETURN(0x56D59339A0F5D8B4LL, q_pdo_ATTR_PERSISTENT, "ATTR_PERSISTENT");
      break;
    case 184:
      HASH_RETURN(0x08657D6005DD08B8LL, q_pdo_NULL_EMPTY_STRING, "NULL_EMPTY_STRING");
      break;
    case 197:
      HASH_RETURN(0x60CE39F6493319C5LL, q_pdo_ATTR_STRINGIFY_FETCHES, "ATTR_STRINGIFY_FETCHES");
      break;
    case 198:
      HASH_RETURN(0x61BD1667BB46C9C6LL, q_pdo_MYSQL_ATTR_READ_DEFAULT_FILE, "MYSQL_ATTR_READ_DEFAULT_FILE");
      break;
    case 200:
      HASH_RETURN(0x30D00303975C98C8LL, q_pdo_FETCH_FUNC, "FETCH_FUNC");
      HASH_RETURN(0x47D4494BE4FA26C8LL, q_pdo_FETCH_ORI_ABS, "FETCH_ORI_ABS");
      break;
    case 202:
      HASH_RETURN(0x29B68A596E0615CALL, q_pdo_NULL_TO_STRING, "NULL_TO_STRING");
      break;
    case 203:
      HASH_RETURN(0x73FAA1AA068D19CBLL, q_pdo_MYSQL_ATTR_MAX_BUFFER_SIZE, "MYSQL_ATTR_MAX_BUFFER_SIZE");
      break;
    case 208:
      HASH_RETURN(0x439351C7C64634D0LL, q_pdo_FETCH_CLASS, "FETCH_CLASS");
      break;
    case 209:
      HASH_RETURN(0x5C75BB222F23C4D1LL, q_pdo_FETCH_LAZY, "FETCH_LAZY");
      break;
    case 211:
      HASH_RETURN(0x57F9152D7EC3A5D3LL, q_pdo_MYSQL_ATTR_COMPRESS, "MYSQL_ATTR_COMPRESS");
      break;
    case 220:
      HASH_RETURN(0x4D1DDF7F772C54DCLL, q_pdo_ERRMODE_WARNING, "ERRMODE_WARNING");
      break;
    case 235:
      HASH_RETURN(0x2E4175EAAB1F75EBLL, q_pdo_ERRMODE_SILENT, "ERRMODE_SILENT");
      break;
    case 245:
      HASH_RETURN(0x16017F3F58821EF5LL, q_pdo_ERR_NONE, "ERR_NONE");
      break;
    case 246:
      HASH_RETURN(0x674F9B0D2030C3F6LL, q_pdo_PARAM_LOB, "PARAM_LOB");
      break;
    case 247:
      HASH_RETURN(0x16EC9F213D7F57F7LL, q_pdo_FETCH_NAMED, "FETCH_NAMED");
      break;
    case 248:
      HASH_RETURN(0x6C0021FD5D20A1F8LL, q_pdo_PARAM_INPUT_OUTPUT, "PARAM_INPUT_OUTPUT");
      break;
    case 251:
      HASH_RETURN(0x13EC16B8F7B7B1FBLL, q_pdo_MYSQL_ATTR_IGNORE_SPACE, "MYSQL_ATTR_IGNORE_SPACE");
      break;
    case 253:
      HASH_RETURN(0x51938FCA0AE827FDLL, q_pdo_PARAM_STMT, "PARAM_STMT");
      break;
    case 254:
      HASH_RETURN(0x56335EC3392D8EFELL, q_pdo_PARAM_EVT_FREE, "PARAM_EVT_FREE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdo
IMPLEMENT_CLASS(pdo)
c_pdo *c_pdo::create(String a0, String a1, String a2, Array a3) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3);
  return this;
}
ObjectData *c_pdo::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3));
    } while (false);
  }
  return this;
}
void c_pdo::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_pdo::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
void c_pdo::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdo::cloneImpl() {
  c_pdo *obj = NEW(c_pdo)();
  cloneSet(obj);
  return obj;
}
void c_pdo::cloneSet(c_pdo *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
Variant c_pdo::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD(0x25466EABBA2D7C12LL, lastinsertid) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_lastinsertid());
          CVarRef arg0((ad->getValue(pos)));
          return (t_lastinsertid(arg0));
        }
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 36:
      HASH_GUARD(0x24D23BE465E3F324LL, commit) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD(0x1740B14E849464EELL, quote) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_quote(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_quote(arg0, arg1));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_prepare(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_prepare(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD(0x374B46BC6D79EC36LL, rollback) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    case 59:
      HASH_GUARD(0x0DE392135C33E23BLL, begintransaction) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
Variant c_pdo::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD(0x25466EABBA2D7C12LL, lastinsertid) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD(0x24D23BE465E3F324LL, commit) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD(0x1740B14E849464EELL, quote) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(a0));
        return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(a0));
        return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD(0x374B46BC6D79EC36LL, rollback) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD(0x0DE392135C33E23BLL, begintransaction) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdo
Variant c_pdo::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdo
Variant c_pdo::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD(0x25466EABBA2D7C12LL, lastinsertid) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD(0x24D23BE465E3F324LL, commit) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD(0x1740B14E849464EELL, quote) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD(0x374B46BC6D79EC36LL, rollback) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD(0x0DE392135C33E23BLL, begintransaction) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdo::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdo = {
  c_pdo::os_getInit,
  c_pdo::os_get,
  c_pdo::os_lval,
  c_pdo::os_invoke,
  c_pdo::os_constant,
};
Object co_domentity(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domentity)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentity
Variant c_domentity::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentity
Variant c_domentity::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentity
Variant &c_domentity::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domentity
void c_domentity::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domentity
void c_domentity::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_domentity
Variant c_domentity::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentity
Variant c_domentity::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentity
Variant c_domentity::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domentity
bool c_domentity::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentity
bool c_domentity::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentity
bool c_domentity::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_domentity
Variant c_domentity::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentity
Variant c_domentity::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentity
Variant c_domentity::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domentity
Variant& c_domentity::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentity
Variant& c_domentity::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentity
Variant& c_domentity::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domentity
Variant c_domentity::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domentity
IMPLEMENT_CLASS(domentity)
c_domentity *c_domentity::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domentity::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domentity::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domentity::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domentity::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domentity::cloneImpl() {
  c_domentity *obj = NEW(c_domentity)();
  cloneSet(obj);
  return obj;
}
void c_domentity::cloneSet(c_domentity *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domentity::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
Variant c_domentity::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
Variant c_domentity::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentity
Variant c_domentity::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentity
Variant c_domentity::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domentity::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domentity = {
  c_domentity::os_getInit,
  c_domentity::os_get,
  c_domentity::os_lval,
  c_domentity::os_invoke,
  c_domentity::os_constant,
};
Object co_xmlwriter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_xmlwriter)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_xmlwriter
Variant c_xmlwriter::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_xmlwriter
Variant c_xmlwriter::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_xmlwriter
Variant &c_xmlwriter::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_xmlwriter
void c_xmlwriter::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_xmlwriter
void c_xmlwriter::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_xmlwriter
Variant c_xmlwriter::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_xmlwriter
Variant c_xmlwriter::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_xmlwriter
Variant c_xmlwriter::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_xmlwriter
bool c_xmlwriter::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_xmlwriter
bool c_xmlwriter::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_xmlwriter
bool c_xmlwriter::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_xmlwriter
Variant c_xmlwriter::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_xmlwriter
Variant c_xmlwriter::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_xmlwriter
Variant c_xmlwriter::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_xmlwriter
Variant& c_xmlwriter::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_xmlwriter
Variant& c_xmlwriter::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_xmlwriter
Variant& c_xmlwriter::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_xmlwriter
Variant c_xmlwriter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_xmlwriter
IMPLEMENT_CLASS(xmlwriter)
c_xmlwriter *c_xmlwriter::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_xmlwriter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_xmlwriter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_xmlwriter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_xmlwriter::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_xmlwriter::cloneImpl() {
  c_xmlwriter *obj = NEW(c_xmlwriter)();
  cloneSet(obj);
  return obj;
}
void c_xmlwriter::cloneSet(c_xmlwriter *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD(0x1EBCBEA66B6B0982LL, writecdata) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecdata(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD(0x55E29E84E96ACF83LL, startdtd) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_startdtd(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_startdtd(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdtd(arg0, arg1, arg2));
        }
      }
      break;
    case 8:
      HASH_GUARD(0x7C1FF8A79BAB3608LL, writedtd) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writedtd(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_writedtd(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_writedtd(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtd(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x119CC9E7C3E7EF0ELL, openmemory) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD(0x0A7FE14C41766610LL, endcdata) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD(0x75F8C992981A4093LL, writecomment) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecomment(arg0));
        }
      }
      HASH_GUARD(0x5A7AE5A26994FF13LL, startattribute) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startattribute(arg0));
        }
      }
      break;
    case 28:
      HASH_GUARD(0x337EFFF3783B919CLL, writeelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writeelement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeelement(arg0, arg1));
        }
      }
      break;
    case 29:
      HASH_GUARD(0x4D26D167066BB11DLL, text) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_text(arg0));
        }
      }
      break;
    case 32:
      HASH_GUARD(0x7DF0368A44C01B20LL, startcdata) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD(0x5D49A460168D5C21LL, endpi) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD(0x1D81ABDC9890C5A9LL, writedtdattlist) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdattlist(arg0, arg1));
        }
      }
      break;
    case 43:
      HASH_GUARD(0x0DEAF425F1AD73ABLL, setindentstring) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindentstring(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x78A7A5D96EF2F4AFLL, endelement) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD(0x75B357D89DDE6EB5LL, endcomment) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD(0x4B0F1F6361A59C37LL, writeraw) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writeraw(arg0));
        }
      }
      break;
    case 56:
      HASH_GUARD(0x7FC89CF1AFFB1E38LL, startdocument) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_startdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_startdocument(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_startdocument(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x0D155D1E5C6641BALL, outputmemory) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_outputmemory());
          CVarRef arg0((ad->getValue(pos)));
          return (t_outputmemory(arg0));
        }
      }
      break;
    case 62:
      HASH_GUARD(0x1FBE635680ADB7BELL, openuri) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_openuri(arg0));
        }
      }
      break;
    case 68:
      HASH_GUARD(0x275896BFD7A77144LL, enddtd) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD(0x5D4650E5C0DAEE46LL, writedtdentity) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_writedtdentity(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_writedtdentity(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_writedtdentity(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 71:
      HASH_GUARD(0x017687FD7029CCC7LL, enddtdelement) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD(0x3954A2C0306CCCCBLL, writeattribute) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeattribute(arg0, arg1));
        }
      }
      HASH_GUARD(0x7C43ECE80FF886CBLL, endattribute) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD(0x4F1D890D5B36D24DLL, startattributens) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 82:
      HASH_GUARD(0x1357CA1E92397452LL, writedtdelement) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writedtdelement(arg0, arg1));
        }
      }
      break;
    case 84:
      HASH_GUARD(0x154AE94AEFAC7C54LL, writeattributens) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeattributens(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 86:
      HASH_GUARD(0x4520735705A382D6LL, enddtdentity) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD(0x37D51A94C6EE8F56LL, writepi) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writepi(arg0, arg1));
        }
      }
      break;
    case 88:
      HASH_GUARD(0x24A376E9310BF058LL, writeelementns) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 3) return (t_writeelementns(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_writeelementns(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 89:
      HASH_GUARD(0x390B6C01AE7C4159LL, startpi) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startpi(arg0));
        }
      }
      break;
    case 92:
      HASH_GUARD(0x0DC5AC1E0A2F63DCLL, enddocument) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD(0x75A033B824EA1ADDLL, startdtdentity) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startdtdentity(arg0, arg1));
        }
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD(0x55BFFBE5717EFD62LL, startelement) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startelement(arg0));
        }
      }
      break;
    case 101:
      HASH_GUARD(0x349B7446B5EE65E5LL, setindent) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindent(arg0));
        }
      }
      break;
    case 105:
      HASH_GUARD(0x608A2D39DE12E169LL, startelementns) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_startelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 112:
      HASH_GUARD(0x0CBB10FA542B7D70LL, startdtdattlist) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdattlist(arg0));
        }
      }
      break;
    case 113:
      HASH_GUARD(0x496175DBD52E1771LL, enddtdattlist) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD(0x451436438EBA2AF8LL, startdtdelement) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdelement(arg0));
        }
      }
      break;
    case 122:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 126:
      HASH_GUARD(0x3174CCE00BFB9FFELL, fullendelement) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD(0x6A8CC27A7F0466FFLL, startcomment) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD(0x1EBCBEA66B6B0982LL, writecdata) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x55E29E84E96ACF83LL, startdtd) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(a0));
        if (count == 2) return (t_startdtd(a0, a1));
        return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD(0x7C1FF8A79BAB3608LL, writedtd) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(a0));
        if (count == 2) return (t_writedtd(a0, a1));
        if (count == 3) return (t_writedtd(a0, a1, a2));
        return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x119CC9E7C3E7EF0ELL, openmemory) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD(0x0A7FE14C41766610LL, endcdata) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD(0x75F8C992981A4093LL, writecomment) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(a0));
      }
      HASH_GUARD(0x5A7AE5A26994FF13LL, startattribute) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x337EFFF3783B919CLL, writeelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(a0));
        return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD(0x4D26D167066BB11DLL, text) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD(0x7DF0368A44C01B20LL, startcdata) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD(0x5D49A460168D5C21LL, endpi) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD(0x1D81ABDC9890C5A9LL, writedtdattlist) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD(0x0DEAF425F1AD73ABLL, setindentstring) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x78A7A5D96EF2F4AFLL, endelement) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD(0x75B357D89DDE6EB5LL, endcomment) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD(0x4B0F1F6361A59C37LL, writeraw) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD(0x7FC89CF1AFFB1E38LL, startdocument) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        if (count == 1) return (t_startdocument(a0));
        if (count == 2) return (t_startdocument(a0, a1));
        return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD(0x0D155D1E5C6641BALL, outputmemory) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD(0x1FBE635680ADB7BELL, openuri) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD(0x275896BFD7A77144LL, enddtd) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD(0x5D4650E5C0DAEE46LL, writedtdentity) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(a0, a1));
        if (count == 3) return (t_writedtdentity(a0, a1, a2));
        if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD(0x017687FD7029CCC7LL, enddtdelement) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD(0x3954A2C0306CCCCBLL, writeattribute) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD(0x7C43ECE80FF886CBLL, endattribute) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD(0x4F1D890D5B36D24DLL, startattributens) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD(0x1357CA1E92397452LL, writedtdelement) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD(0x154AE94AEFAC7C54LL, writeattributens) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD(0x4520735705A382D6LL, enddtdentity) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD(0x37D51A94C6EE8F56LL, writepi) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD(0x24A376E9310BF058LL, writeelementns) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD(0x390B6C01AE7C4159LL, startpi) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD(0x0DC5AC1E0A2F63DCLL, enddocument) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD(0x75A033B824EA1ADDLL, startdtdentity) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD(0x55BFFBE5717EFD62LL, startelement) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x349B7446B5EE65E5LL, setindent) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD(0x608A2D39DE12E169LL, startelementns) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD(0x0CBB10FA542B7D70LL, startdtdattlist) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD(0x496175DBD52E1771LL, enddtdattlist) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD(0x451436438EBA2AF8LL, startdtdelement) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x3174CCE00BFB9FFELL, fullendelement) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD(0x6A8CC27A7F0466FFLL, startcomment) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_xmlwriter
Variant c_xmlwriter::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD(0x1EBCBEA66B6B0982LL, writecdata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x55E29E84E96ACF83LL, startdtd) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD(0x7C1FF8A79BAB3608LL, writedtd) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x119CC9E7C3E7EF0ELL, openmemory) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD(0x0A7FE14C41766610LL, endcdata) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD(0x75F8C992981A4093LL, writecomment) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecomment(a0));
      }
      HASH_GUARD(0x5A7AE5A26994FF13LL, startattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x337EFFF3783B919CLL, writeelement) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD(0x4D26D167066BB11DLL, text) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD(0x7DF0368A44C01B20LL, startcdata) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD(0x5D49A460168D5C21LL, endpi) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD(0x1D81ABDC9890C5A9LL, writedtdattlist) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD(0x0DEAF425F1AD73ABLL, setindentstring) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x78A7A5D96EF2F4AFLL, endelement) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD(0x75B357D89DDE6EB5LL, endcomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD(0x4B0F1F6361A59C37LL, writeraw) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD(0x7FC89CF1AFFB1E38LL, startdocument) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD(0x0D155D1E5C6641BALL, outputmemory) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD(0x1FBE635680ADB7BELL, openuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD(0x275896BFD7A77144LL, enddtd) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD(0x5D4650E5C0DAEE46LL, writedtdentity) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD(0x017687FD7029CCC7LL, enddtdelement) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD(0x3954A2C0306CCCCBLL, writeattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD(0x7C43ECE80FF886CBLL, endattribute) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD(0x4F1D890D5B36D24DLL, startattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD(0x1357CA1E92397452LL, writedtdelement) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD(0x154AE94AEFAC7C54LL, writeattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD(0x4520735705A382D6LL, enddtdentity) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdentity());
      }
      HASH_GUARD(0x37D51A94C6EE8F56LL, writepi) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD(0x24A376E9310BF058LL, writeelementns) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD(0x390B6C01AE7C4159LL, startpi) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD(0x0DC5AC1E0A2F63DCLL, enddocument) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD(0x75A033B824EA1ADDLL, startdtdentity) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD(0x55BFFBE5717EFD62LL, startelement) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x349B7446B5EE65E5LL, setindent) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD(0x608A2D39DE12E169LL, startelementns) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD(0x0CBB10FA542B7D70LL, startdtdattlist) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD(0x496175DBD52E1771LL, enddtdattlist) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD(0x451436438EBA2AF8LL, startdtdelement) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x3174CCE00BFB9FFELL, fullendelement) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD(0x6A8CC27A7F0466FFLL, startcomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_xmlwriter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_xmlwriter = {
  c_xmlwriter::os_getInit,
  c_xmlwriter::os_get,
  c_xmlwriter::os_lval,
  c_xmlwriter::os_invoke,
  c_xmlwriter::os_constant,
};
Object co_domexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domexception)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domexception
Variant c_domexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domexception
Variant c_domexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domexception
Variant &c_domexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domexception
void c_domexception::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domexception
void c_domexception::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_domexception
Variant c_domexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domexception
Variant c_domexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domexception
Variant c_domexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domexception
bool c_domexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domexception
bool c_domexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domexception
bool c_domexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_domexception
Variant c_domexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domexception
Variant c_domexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domexception
Variant c_domexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domexception
Variant& c_domexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domexception
Variant& c_domexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domexception
Variant& c_domexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domexception
Variant c_domexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domexception
IMPLEMENT_CLASS(domexception)
c_domexception *c_domexception::create(String a0, int64 a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domexception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domexception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domexception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domexception::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domexception::cloneImpl() {
  c_domexception *obj = NEW(c_domexception)();
  cloneSet(obj);
  return obj;
}
void c_domexception::cloneSet(c_domexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
Variant c_domexception::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
Variant c_domexception::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domexception
Variant c_domexception::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domexception
Variant c_domexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domexception = {
  c_domexception::os_getInit,
  c_domexception::os_get,
  c_domexception::os_lval,
  c_domexception::os_invoke,
  c_domexception::os_constant,
};
Object co_domxpath(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domxpath)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domxpath
Variant c_domxpath::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domxpath
Variant c_domxpath::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domxpath
Variant &c_domxpath::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domxpath
void c_domxpath::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domxpath
void c_domxpath::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_domxpath
Variant c_domxpath::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domxpath
Variant c_domxpath::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domxpath
Variant c_domxpath::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domxpath
bool c_domxpath::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domxpath
bool c_domxpath::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domxpath
bool c_domxpath::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_domxpath
Variant c_domxpath::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domxpath
Variant c_domxpath::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domxpath
Variant c_domxpath::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domxpath
Variant& c_domxpath::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domxpath
Variant& c_domxpath::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domxpath
Variant& c_domxpath::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domxpath
Variant c_domxpath::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domxpath
IMPLEMENT_CLASS(domxpath)
c_domxpath *c_domxpath::create(Variant a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domxpath::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_domxpath::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_domxpath::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domxpath::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domxpath::cloneImpl() {
  c_domxpath *obj = NEW(c_domxpath)();
  cloneSet(obj);
  return obj;
}
void c_domxpath::cloneSet(c_domxpath *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domxpath::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
Variant c_domxpath::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x144FADF6B374AB82LL, registerphpfunctions) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_registerphpfunctions());
          CVarRef arg0((ad->getValue(pos)));
          return (t_registerphpfunctions(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 7:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_query(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_query(arg0, arg1));
        }
      }
      break;
    case 8:
      HASH_GUARD(0x47ACFB6D8681B0E8LL, registernamespace) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registernamespace(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      HASH_GUARD(0x2443593B6F3C912FLL, evaluate) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_evaluate(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_evaluate(arg0, arg1));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
Variant c_domxpath::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x144FADF6B374AB82LL, registerphpfunctions) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(a0));
        return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD(0x47ACFB6D8681B0E8LL, registernamespace) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x2443593B6F3C912FLL, evaluate) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(a0));
        return (t_evaluate(a0, a1));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domxpath
Variant c_domxpath::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domxpath
Variant c_domxpath::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x144FADF6B374AB82LL, registerphpfunctions) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD(0x47ACFB6D8681B0E8LL, registernamespace) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x2443593B6F3C912FLL, evaluate) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domxpath::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domxpath = {
  c_domxpath::os_getInit,
  c_domxpath::os_get,
  c_domxpath::os_lval,
  c_domxpath::os_invoke,
  c_domxpath::os_constant,
};
Object co_soapserver(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapserver)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapserver
Variant c_soapserver::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapserver
Variant c_soapserver::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapserver
Variant &c_soapserver::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapserver
void c_soapserver::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapserver
void c_soapserver::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapserver
Variant c_soapserver::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapserver
Variant c_soapserver::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapserver
Variant c_soapserver::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapserver
bool c_soapserver::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapserver
bool c_soapserver::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapserver
bool c_soapserver::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapserver
Variant c_soapserver::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapserver
Variant c_soapserver::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapserver
Variant c_soapserver::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapserver
Variant& c_soapserver::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapserver
Variant& c_soapserver::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapserver
Variant& c_soapserver::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapserver
Variant c_soapserver::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapserver
IMPLEMENT_CLASS(soapserver)
c_soapserver *c_soapserver::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapserver::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_soapserver::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_soapserver::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_soapserver::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapserver::cloneImpl() {
  c_soapserver *obj = NEW(c_soapserver)();
  cloneSet(obj);
  return obj;
}
void c_soapserver::cloneSet(c_soapserver *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
Variant c_soapserver::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x758A4E04590FE203LL, fault) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_fault(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_fault(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_fault(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fault(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 8:
      HASH_GUARD(0x5E77DD94E0A69328LL, setpersistence) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setpersistence(arg0), null);
        }
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD(0x5C4CA333F4541532LL, handle) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_handle(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t_handle(arg0), null);
        }
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x597B151CC4F70834LL, setclass) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setclass(count, arg0), null);
          return (t_setclass(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 25:
      HASH_GUARD(0x559622F84FE626B9LL, setobject) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setobject(arg0), null);
        }
      }
      break;
    case 30:
      HASH_GUARD(0x278B0E6CCA74963ELL, addsoapheader) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addsoapheader(arg0), null);
        }
      }
      break;
    case 31:
      HASH_GUARD(0x48B5852A397D2D9FLL, addfunction) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addfunction(arg0), null);
        }
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
Variant c_soapserver::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x758A4E04590FE203LL, fault) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(a0, a1), null);
        if (count == 3) return (t_fault(a0, a1, a2), null);
        if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD(0x5E77DD94E0A69328LL, setpersistence) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD(0x5C4CA333F4541532LL, handle) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x597B151CC4F70834LL, setclass) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setclass(count,a0, params), null);
      }
      break;
    case 25:
      HASH_GUARD(0x559622F84FE626B9LL, setobject) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD(0x278B0E6CCA74963ELL, addsoapheader) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD(0x48B5852A397D2D9FLL, addfunction) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(a0), null);
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapserver
Variant c_soapserver::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapserver
Variant c_soapserver::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x758A4E04590FE203LL, fault) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD(0x5E77DD94E0A69328LL, setpersistence) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD(0x5C4CA333F4541532LL, handle) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x597B151CC4F70834LL, setclass) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    case 25:
      HASH_GUARD(0x559622F84FE626B9LL, setobject) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD(0x278B0E6CCA74963ELL, addsoapheader) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD(0x48B5852A397D2D9FLL, addfunction) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addfunction(a0), null);
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapserver::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapserver = {
  c_soapserver::os_getInit,
  c_soapserver::os_get,
  c_soapserver::os_lval,
  c_soapserver::os_invoke,
  c_soapserver::os_constant,
};
Object co_domnode(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnode)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnode
Variant c_domnode::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnode
Variant c_domnode::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnode
Variant &c_domnode::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnode
void c_domnode::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domnode
void c_domnode::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnode
Variant c_domnode::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnode
Variant c_domnode::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnode
Variant c_domnode::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnode
bool c_domnode::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnode
bool c_domnode::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnode
bool c_domnode::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnode
Variant c_domnode::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnode
Variant c_domnode::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnode
Variant c_domnode::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnode
Variant& c_domnode::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnode
Variant& c_domnode::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnode
Variant& c_domnode::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnode
Variant c_domnode::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnode
IMPLEMENT_CLASS(domnode)
c_domnode *c_domnode::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnode::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnode::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnode::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnode::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnode::cloneImpl() {
  c_domnode *obj = NEW(c_domnode)();
  cloneSet(obj);
  return obj;
}
void c_domnode::cloneSet(c_domnode *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnode::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
Variant c_domnode::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
Variant c_domnode::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnode
Variant c_domnode::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnode
Variant c_domnode::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnode::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnode = {
  c_domnode::os_getInit,
  c_domnode::os_get,
  c_domnode::os_lval,
  c_domnode::os_invoke,
  c_domnode::os_constant,
};
Object co_domdocument(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocument)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocument
Variant c_domdocument::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocument
Variant c_domdocument::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocument
Variant &c_domdocument::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocument
void c_domdocument::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocument
void c_domdocument::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocument
Variant c_domdocument::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocument
Variant c_domdocument::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocument
Variant c_domdocument::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocument
bool c_domdocument::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocument
bool c_domdocument::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocument
bool c_domdocument::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocument
Variant c_domdocument::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocument
Variant c_domdocument::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocument
Variant c_domdocument::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocument
Variant& c_domdocument::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocument
Variant& c_domdocument::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocument
Variant& c_domdocument::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocument
Variant c_domdocument::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocument
IMPLEMENT_CLASS(domdocument)
c_domdocument *c_domdocument::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domdocument::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_domdocument::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_domdocument::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domdocument::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocument::cloneImpl() {
  c_domdocument *obj = NEW(c_domdocument)();
  cloneSet(obj);
  return obj;
}
void c_domdocument::cloneSet(c_domdocument *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domdocument::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
Variant c_domdocument::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD(0x515FE7746601E385LL, getelementbyid) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementbyid(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      HASH_GUARD(0x142A28F8CE4A4E8ALL, xinclude) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_xinclude());
          CVarRef arg0((ad->getValue(pos)));
          return (t_xinclude(arg0));
        }
      }
      break;
    case 13:
      HASH_GUARD(0x0D128C363EBF7F0DLL, createcdatasection) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcdatasection(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 17:
      HASH_GUARD(0x69C6F7D584EC5011LL, schemavalidatesource) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidatesource(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 20:
      HASH_GUARD(0x04F8F7CEA46D0514LL, save) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_save(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_save(arg0, arg1));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      HASH_GUARD(0x2FC58024A75AEB15LL, createattributens) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createattributens(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD(0x1A78385D7CD10A1CLL, relaxngvalidate) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidate(arg0));
        }
      }
      break;
    case 34:
      HASH_GUARD(0x1B0F4D437C8404A2LL, loadhtml) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtml(arg0));
        }
      }
      HASH_GUARD(0x4C40B0F935B39FA2LL, createelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createelement(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createelement(arg0, arg1));
        }
      }
      break;
    case 44:
      HASH_GUARD(0x1304C35F6E006FACLL, relaxngvalidatesource) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidatesource(arg0));
        }
      }
      HASH_GUARD(0x2BFDE9CF0FE9A82CLL, createattribute) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createattribute(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x4A6C6D9AB88CD42FLL, importnode) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_importnode(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_importnode(arg0, arg1));
        }
      }
      HASH_GUARD(0x5FE94CA513F14AAFLL, loadhtmlfile) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtmlfile(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x20E2B2FD2B7AE431LL, loadxml) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_loadxml(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_loadxml(arg0, arg1));
        }
      }
      break;
    case 50:
      HASH_GUARD(0x7A9C4709CAD09832LL, createentityreference) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createentityreference(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 55:
      HASH_GUARD(0x1CA408E02262F737LL, validate) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD(0x29C79E90C6FCC0C7LL, createcomment) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcomment(arg0));
        }
      }
      break;
    case 72:
      HASH_GUARD(0x7EB8C68BABDC5648LL, schemavalidate) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidate(arg0));
        }
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      break;
    case 77:
      HASH_GUARD(0x35C0FF513ED3054DLL, savehtmlfile) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_savehtmlfile(arg0));
        }
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 83:
      HASH_GUARD(0x21F3F1C9058310D3LL, savehtml) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      HASH_GUARD(0x79B7A5774A0943DFLL, load) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_load(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_load(arg0, arg1));
        }
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 101:
      HASH_GUARD(0x26D66F56DDDC32E5LL, savexml) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_savexml());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_savexml(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_savexml(arg0, arg1));
        }
      }
      break;
    case 106:
      HASH_GUARD(0x0AC931EAB2FE3D6ALL, normalizedocument) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD(0x05EA36F416B7EBEBLL, createelementns) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t_createelementns(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 109:
      HASH_GUARD(0x2A99431FC6E7BA6DLL, createprocessinginstruction) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createprocessinginstruction(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_createprocessinginstruction(arg0, arg1));
        }
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x615771958E1EB375LL, registernodeclass) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_registernodeclass(arg0, arg1));
        }
      }
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 120:
      HASH_GUARD(0x44FD8C24F4EA46F8LL, createdocumentfragment) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD(0x6056A5BB9855D7FBLL, createtextnode) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createtextnode(arg0));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
Variant c_domdocument::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD(0x515FE7746601E385LL, getelementbyid) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x142A28F8CE4A4E8ALL, xinclude) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x0D128C363EBF7F0DLL, createcdatasection) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD(0x69C6F7D584EC5011LL, schemavalidatesource) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD(0x04F8F7CEA46D0514LL, save) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(a0));
        return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      HASH_GUARD(0x2FC58024A75AEB15LL, createattributens) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD(0x1A78385D7CD10A1CLL, relaxngvalidate) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD(0x1B0F4D437C8404A2LL, loadhtml) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(a0));
      }
      HASH_GUARD(0x4C40B0F935B39FA2LL, createelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(a0));
        return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD(0x1304C35F6E006FACLL, relaxngvalidatesource) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD(0x2BFDE9CF0FE9A82CLL, createattribute) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x4A6C6D9AB88CD42FLL, importnode) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(a0));
        return (t_importnode(a0, a1));
      }
      HASH_GUARD(0x5FE94CA513F14AAFLL, loadhtmlfile) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x20E2B2FD2B7AE431LL, loadxml) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(a0));
        return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD(0x7A9C4709CAD09832LL, createentityreference) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD(0x1CA408E02262F737LL, validate) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD(0x29C79E90C6FCC0C7LL, createcomment) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD(0x7EB8C68BABDC5648LL, schemavalidate) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD(0x35C0FF513ED3054DLL, savehtmlfile) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD(0x21F3F1C9058310D3LL, savehtml) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      HASH_GUARD(0x79B7A5774A0943DFLL, load) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(a0));
        return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x26D66F56DDDC32E5LL, savexml) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        if (count == 1) return (t_savexml(a0));
        return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD(0x0AC931EAB2FE3D6ALL, normalizedocument) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD(0x05EA36F416B7EBEBLL, createelementns) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(a0, a1));
        return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD(0x2A99431FC6E7BA6DLL, createprocessinginstruction) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(a0));
        return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x615771958E1EB375LL, registernodeclass) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD(0x44FD8C24F4EA46F8LL, createdocumentfragment) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD(0x6056A5BB9855D7FBLL, createtextnode) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocument
Variant c_domdocument::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocument
Variant c_domdocument::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD(0x515FE7746601E385LL, getelementbyid) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x142A28F8CE4A4E8ALL, xinclude) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x0D128C363EBF7F0DLL, createcdatasection) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD(0x69C6F7D584EC5011LL, schemavalidatesource) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD(0x04F8F7CEA46D0514LL, save) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      HASH_GUARD(0x2FC58024A75AEB15LL, createattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD(0x1A78385D7CD10A1CLL, relaxngvalidate) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD(0x1B0F4D437C8404A2LL, loadhtml) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtml(a0));
      }
      HASH_GUARD(0x4C40B0F935B39FA2LL, createelement) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD(0x1304C35F6E006FACLL, relaxngvalidatesource) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD(0x2BFDE9CF0FE9A82CLL, createattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x4A6C6D9AB88CD42FLL, importnode) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      HASH_GUARD(0x5FE94CA513F14AAFLL, loadhtmlfile) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD(0x20E2B2FD2B7AE431LL, loadxml) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD(0x7A9C4709CAD09832LL, createentityreference) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD(0x1CA408E02262F737LL, validate) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD(0x29C79E90C6FCC0C7LL, createcomment) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD(0x7EB8C68BABDC5648LL, schemavalidate) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD(0x35C0FF513ED3054DLL, savehtmlfile) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD(0x21F3F1C9058310D3LL, savehtml) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD(0x79B7A5774A0943DFLL, load) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x26D66F56DDDC32E5LL, savexml) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD(0x0AC931EAB2FE3D6ALL, normalizedocument) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD(0x05EA36F416B7EBEBLL, createelementns) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD(0x2A99431FC6E7BA6DLL, createprocessinginstruction) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x615771958E1EB375LL, registernodeclass) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD(0x44FD8C24F4EA46F8LL, createdocumentfragment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD(0x6056A5BB9855D7FBLL, createtextnode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocument::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocument = {
  c_domdocument::os_getInit,
  c_domdocument::os_get,
  c_domdocument::os_lval,
  c_domdocument::os_invoke,
  c_domdocument::os_constant,
};
Object co_libxmlerror(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_libxmlerror)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_libxmlerror
Variant c_libxmlerror::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_libxmlerror
Variant c_libxmlerror::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_libxmlerror
Variant &c_libxmlerror::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_libxmlerror
void c_libxmlerror::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_libxmlerror
void c_libxmlerror::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_libxmlerror
Variant c_libxmlerror::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_libxmlerror
Variant c_libxmlerror::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_libxmlerror
Variant c_libxmlerror::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_libxmlerror
bool c_libxmlerror::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_libxmlerror
bool c_libxmlerror::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_libxmlerror
bool c_libxmlerror::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_libxmlerror
Variant c_libxmlerror::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_libxmlerror
Variant c_libxmlerror::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_libxmlerror
Variant c_libxmlerror::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_libxmlerror
Variant& c_libxmlerror::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_libxmlerror
Variant& c_libxmlerror::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_libxmlerror
Variant& c_libxmlerror::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_libxmlerror
Variant c_libxmlerror::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_libxmlerror
IMPLEMENT_CLASS(libxmlerror)
c_libxmlerror *c_libxmlerror::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_libxmlerror::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_libxmlerror::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_libxmlerror::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_libxmlerror::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_libxmlerror::cloneImpl() {
  c_libxmlerror *obj = NEW(c_libxmlerror)();
  cloneSet(obj);
  return obj;
}
void c_libxmlerror::cloneSet(c_libxmlerror *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_libxmlerror
Variant c_libxmlerror::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_libxmlerror::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_libxmlerror = {
  c_libxmlerror::os_getInit,
  c_libxmlerror::os_get,
  c_libxmlerror::os_lval,
  c_libxmlerror::os_invoke,
  c_libxmlerror::os_constant,
};
Object co_soapfault(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapfault)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapfault
Variant c_soapfault::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapfault
Variant c_soapfault::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapfault
Variant &c_soapfault::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapfault
void c_soapfault::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_soapfault
void c_soapfault::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapfault
Variant c_soapfault::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapfault
Variant c_soapfault::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapfault
Variant c_soapfault::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapfault
bool c_soapfault::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapfault
bool c_soapfault::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapfault
bool c_soapfault::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapfault
Variant c_soapfault::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapfault
Variant c_soapfault::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapfault
Variant c_soapfault::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapfault
Variant& c_soapfault::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapfault
Variant& c_soapfault::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapfault
Variant& c_soapfault::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapfault
Variant c_soapfault::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapfault
IMPLEMENT_CLASS(soapfault)
c_soapfault *c_soapfault::create(Variant a0, String a1, String a2, Variant a3, String a4, Variant a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_soapfault::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_soapfault::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_soapfault::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_soapfault::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapfault::cloneImpl() {
  c_soapfault *obj = NEW(c_soapfault)();
  cloneSet(obj);
  return obj;
}
void c_soapfault::cloneSet(c_soapfault *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
Variant c_soapfault::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
Variant c_soapfault::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapfault
Variant c_soapfault::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapfault
Variant c_soapfault::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapfault::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapfault = {
  c_soapfault::os_getInit,
  c_soapfault::os_get,
  c_soapfault::os_lval,
  c_soapfault::os_invoke,
  c_soapfault::os_constant,
};
Object co_domelement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domelement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domelement
Variant c_domelement::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domelement
Variant c_domelement::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domelement
Variant &c_domelement::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domelement
void c_domelement::o_getArray(Array &props) const {
  c_domnode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domelement
void c_domelement::o_setArray(CArrRef props) {
  c_domnode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_domelement
Variant c_domelement::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domelement
Variant c_domelement::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domelement
Variant c_domelement::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domelement
bool c_domelement::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domelement
bool c_domelement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domelement
bool c_domelement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_domelement
Variant c_domelement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domelement
Variant c_domelement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domelement
Variant c_domelement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domelement
Variant& c_domelement::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domelement
Variant& c_domelement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domelement
Variant& c_domelement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domelement
Variant c_domelement::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domelement
IMPLEMENT_CLASS(domelement)
c_domelement *c_domelement::create(String a0, String a1, String a2) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2);
  return this;
}
ObjectData *c_domelement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2));
    } while (false);
  }
  return this;
}
void c_domelement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2));
  } while (false);
}
void c_domelement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else (t___construct(a0, a1, a2), null);
}
void c_domelement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domelement::cloneImpl() {
  c_domelement *obj = NEW(c_domelement)();
  cloneSet(obj);
  return obj;
}
void c_domelement::cloneSet(c_domelement *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domelement::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
Variant c_domelement::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 16:
      HASH_GUARD(0x710986B01E1A0890LL, removeattributens) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_removeattributens(arg0, arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD(0x31426AC6A851EE11LL, setidattributens) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD(0x6F83EC29E110D616LL, setidattribute) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattribute(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x640FA60DDC80EC18LL, getattributenodens) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getattributenodens(arg0, arg1));
        }
      }
      break;
    case 25:
      HASH_GUARD(0x34E103E06D3F0899LL, getattributens) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getattributens(arg0, arg1));
        }
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD(0x47B96C0FC62E1E2FLL, removeattribute) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattribute(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      HASH_GUARD(0x29D272CBBC0CDA4ALL, setidattributenode) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setidattributenode(arg0, arg1));
        }
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 81:
      HASH_GUARD(0x482E3873306253D1LL, setattributenodens) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenodens(arg0));
        }
      }
      break;
    case 85:
      HASH_GUARD(0x5EF7C3A45311D955LL, hasattributens) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_hasattributens(arg0, arg1));
        }
      }
      break;
    case 87:
      HASH_GUARD(0x62A40E71FAF19157LL, setattributens) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD(0x606827EF5CF34C5CLL, setattributenode) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenode(arg0));
        }
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2), null);
        }
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 106:
      HASH_GUARD(0x1BFDB4272EA150EALL, removeattributenode) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattributenode(arg0));
        }
      }
      break;
    case 108:
      HASH_GUARD(0x6471DF8BB944FFECLL, hasattribute) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasattribute(arg0));
        }
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD(0x343DF562BB5AB1FELL, getattributenode) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattributenode(arg0));
        }
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
Variant c_domelement::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD(0x710986B01E1A0890LL, removeattributens) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x31426AC6A851EE11LL, setidattributens) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x6F83EC29E110D616LL, setidattribute) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x640FA60DDC80EC18LL, getattributenodens) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD(0x34E103E06D3F0899LL, getattributens) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x47B96C0FC62E1E2FLL, removeattribute) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD(0x29D272CBBC0CDA4ALL, setidattributenode) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD(0x482E3873306253D1LL, setattributenodens) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD(0x5EF7C3A45311D955LL, hasattributens) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD(0x62A40E71FAF19157LL, setattributens) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD(0x606827EF5CF34C5CLL, setattributenode) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD(0x1BFDB4272EA150EALL, removeattributenode) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD(0x6471DF8BB944FFECLL, hasattribute) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD(0x343DF562BB5AB1FELL, getattributenode) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domelement
Variant c_domelement::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domelement
Variant c_domelement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD(0x710986B01E1A0890LL, removeattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x31426AC6A851EE11LL, setidattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x6F83EC29E110D616LL, setidattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x640FA60DDC80EC18LL, getattributenodens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD(0x34E103E06D3F0899LL, getattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x47B96C0FC62E1E2FLL, removeattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD(0x29D272CBBC0CDA4ALL, setidattributenode) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD(0x482E3873306253D1LL, setattributenodens) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD(0x5EF7C3A45311D955LL, hasattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD(0x62A40E71FAF19157LL, setattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD(0x606827EF5CF34C5CLL, setattributenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD(0x1BFDB4272EA150EALL, removeattributenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD(0x6471DF8BB944FFECLL, hasattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD(0x343DF562BB5AB1FELL, getattributenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domelement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domelement = {
  c_domelement::os_getInit,
  c_domelement::os_get,
  c_domelement::os_lval,
  c_domelement::os_invoke,
  c_domelement::os_constant,
};
Variant get_builtin_class_var_init(const char *s, const char *var) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_CLASS_VAR_INIT(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_CLASS_VAR_INIT(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_CLASS_VAR_INIT(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 18:
      HASH_GET_CLASS_VAR_INIT(0x78B42582709BAF12LL, debuggerproxy);
      break;
    case 19:
      HASH_GET_CLASS_VAR_INIT(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_CLASS_VAR_INIT(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_CLASS_VAR_INIT(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_CLASS_VAR_INIT(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_CLASS_VAR_INIT(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_CLASS_VAR_INIT(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_CLASS_VAR_INIT(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_CLASS_VAR_INIT(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_CLASS_VAR_INIT(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_CLASS_VAR_INIT(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_CLASS_VAR_INIT(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 61:
      HASH_GET_CLASS_VAR_INIT(0x4C6991D3CF5CA03DLL, collator);
      break;
    case 62:
      HASH_GET_CLASS_VAR_INIT(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_CLASS_VAR_INIT(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_CLASS_VAR_INIT(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_CLASS_VAR_INIT(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_CLASS_VAR_INIT(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_CLASS_VAR_INIT(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_CLASS_VAR_INIT(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_CLASS_VAR_INIT(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_CLASS_VAR_INIT(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_CLASS_VAR_INIT(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_CLASS_VAR_INIT(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_CLASS_VAR_INIT(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_CLASS_VAR_INIT(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_CLASS_VAR_INIT(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_CLASS_VAR_INIT(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_CLASS_VAR_INIT(0x70747A09B3523662LL, domnode);
      break;
    case 99:
      HASH_GET_CLASS_VAR_INIT(0x7D1235273F521A63LL, debuggerclient);
      break;
    case 101:
      HASH_GET_CLASS_VAR_INIT(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_CLASS_VAR_INIT(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_CLASS_VAR_INIT(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_CLASS_VAR_INIT(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_CLASS_VAR_INIT(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_CLASS_VAR_INIT(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_CLASS_VAR_INIT(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 117:
      HASH_GET_CLASS_VAR_INIT(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_CLASS_VAR_INIT(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_CLASS_VAR_INIT(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_CLASS_VAR_INIT(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_CLASS_VAR_INIT(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_CLASS_VAR_INIT(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_CLASS_VAR_INIT(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_CLASS_VAR_INIT(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_CLASS_VAR_INIT(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_CLASS_VAR_INIT(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_CLASS_VAR_INIT(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_CLASS_VAR_INIT(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_CLASS_VAR_INIT(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_CLASS_VAR_INIT(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_CLASS_VAR_INIT(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_CLASS_VAR_INIT(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_CLASS_VAR_INIT(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_CLASS_VAR_INIT(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 170:
      HASH_GET_CLASS_VAR_INIT(0x67E31D42F2DFE4AALL, locale);
      break;
    case 173:
      HASH_GET_CLASS_VAR_INIT(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_CLASS_VAR_INIT(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_CLASS_VAR_INIT(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_CLASS_VAR_INIT(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_CLASS_VAR_INIT(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_CLASS_VAR_INIT(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_CLASS_VAR_INIT(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_CLASS_VAR_INIT(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 208:
      HASH_GET_CLASS_VAR_INIT(0x3C122DF8859C72D0LL, memcache);
      break;
    case 210:
      HASH_GET_CLASS_VAR_INIT(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_CLASS_VAR_INIT(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_CLASS_VAR_INIT(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_CLASS_VAR_INIT(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_CLASS_VAR_INIT(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_CLASS_VAR_INIT(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_CLASS_VAR_INIT(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_CLASS_VAR_INIT(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_CLASS_VAR_INIT(0x297174231D4912F4LL, domattr);
      break;
    case 247:
      HASH_GET_CLASS_VAR_INIT(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_CLASS_VAR_INIT(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_CLASS_VAR_INIT(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_CLASS_VAR_INIT(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Object create_builtin_object(const char *s, CArrRef params, bool init /* = true */,ObjectData* root /* = NULL*/) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_CREATE_OBJECT(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_CREATE_OBJECT(0x4365BE9E5A85E60BLL, domnotation);
      HASH_CREATE_OBJECT(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 18:
      HASH_CREATE_OBJECT(0x78B42582709BAF12LL, debuggerproxy);
      break;
    case 19:
      HASH_CREATE_OBJECT(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_CREATE_OBJECT(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_CREATE_OBJECT(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_CREATE_OBJECT(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_CREATE_OBJECT(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_CREATE_OBJECT(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_CREATE_OBJECT(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_CREATE_OBJECT(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_CREATE_OBJECT(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_CREATE_OBJECT(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_CREATE_OBJECT(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 61:
      HASH_CREATE_OBJECT(0x4C6991D3CF5CA03DLL, collator);
      break;
    case 62:
      HASH_CREATE_OBJECT(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_CREATE_OBJECT(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_CREATE_OBJECT(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_CREATE_OBJECT(0x196F76C9C527B946LL, domnamednodemap);
      HASH_CREATE_OBJECT(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_CREATE_OBJECT(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_CREATE_OBJECT(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_CREATE_OBJECT(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_CREATE_OBJECT(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_CREATE_OBJECT(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_CREATE_OBJECT(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_CREATE_OBJECT(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_CREATE_OBJECT(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_CREATE_OBJECT(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_CREATE_OBJECT(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_CREATE_OBJECT(0x70747A09B3523662LL, domnode);
      break;
    case 99:
      HASH_CREATE_OBJECT(0x7D1235273F521A63LL, debuggerclient);
      break;
    case 101:
      HASH_CREATE_OBJECT(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_CREATE_OBJECT(0x7E07B9C27FE59D68LL, domcomment);
      HASH_CREATE_OBJECT(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_CREATE_OBJECT(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_CREATE_OBJECT(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_CREATE_OBJECT(0x3D5870E53BF89873LL, arrayiterator);
      HASH_CREATE_OBJECT(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 117:
      HASH_CREATE_OBJECT(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_CREATE_OBJECT(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_CREATE_OBJECT(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_CREATE_OBJECT(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_CREATE_OBJECT(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_CREATE_OBJECT(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_CREATE_OBJECT(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_CREATE_OBJECT(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_CREATE_OBJECT(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_CREATE_OBJECT(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_CREATE_OBJECT(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_CREATE_OBJECT(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_CREATE_OBJECT(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_CREATE_OBJECT(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_CREATE_OBJECT(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_CREATE_OBJECT(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_CREATE_OBJECT(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_CREATE_OBJECT(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 170:
      HASH_CREATE_OBJECT(0x67E31D42F2DFE4AALL, locale);
      break;
    case 173:
      HASH_CREATE_OBJECT(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_CREATE_OBJECT(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_CREATE_OBJECT(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_CREATE_OBJECT(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_CREATE_OBJECT(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_CREATE_OBJECT(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_CREATE_OBJECT(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_CREATE_OBJECT(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 208:
      HASH_CREATE_OBJECT(0x3C122DF8859C72D0LL, memcache);
      break;
    case 210:
      HASH_CREATE_OBJECT(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_CREATE_OBJECT(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_CREATE_OBJECT(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_CREATE_OBJECT(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_CREATE_OBJECT(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_CREATE_OBJECT(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_CREATE_OBJECT(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_CREATE_OBJECT(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_CREATE_OBJECT(0x297174231D4912F4LL, domattr);
      break;
    case 247:
      HASH_CREATE_OBJECT(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_CREATE_OBJECT(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_CREATE_OBJECT(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_CREATE_OBJECT(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Variant invoke_builtin_static_method(const char *s, const char *method, CArrRef params, bool fatal) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_INVOKE_STATIC_METHOD(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_INVOKE_STATIC_METHOD(0x4365BE9E5A85E60BLL, domnotation);
      HASH_INVOKE_STATIC_METHOD(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 18:
      HASH_INVOKE_STATIC_METHOD(0x78B42582709BAF12LL, debuggerproxy);
      break;
    case 19:
      HASH_INVOKE_STATIC_METHOD(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_INVOKE_STATIC_METHOD(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_INVOKE_STATIC_METHOD(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_INVOKE_STATIC_METHOD(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_INVOKE_STATIC_METHOD(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_INVOKE_STATIC_METHOD(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_INVOKE_STATIC_METHOD(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_INVOKE_STATIC_METHOD(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_INVOKE_STATIC_METHOD(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_INVOKE_STATIC_METHOD(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_INVOKE_STATIC_METHOD(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 61:
      HASH_INVOKE_STATIC_METHOD(0x4C6991D3CF5CA03DLL, collator);
      break;
    case 62:
      HASH_INVOKE_STATIC_METHOD(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_INVOKE_STATIC_METHOD(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_INVOKE_STATIC_METHOD(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_INVOKE_STATIC_METHOD(0x196F76C9C527B946LL, domnamednodemap);
      HASH_INVOKE_STATIC_METHOD(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_INVOKE_STATIC_METHOD(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_INVOKE_STATIC_METHOD(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_INVOKE_STATIC_METHOD(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_INVOKE_STATIC_METHOD(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_INVOKE_STATIC_METHOD(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_INVOKE_STATIC_METHOD(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_INVOKE_STATIC_METHOD(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_INVOKE_STATIC_METHOD(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_INVOKE_STATIC_METHOD(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_INVOKE_STATIC_METHOD(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_INVOKE_STATIC_METHOD(0x70747A09B3523662LL, domnode);
      break;
    case 99:
      HASH_INVOKE_STATIC_METHOD(0x7D1235273F521A63LL, debuggerclient);
      break;
    case 101:
      HASH_INVOKE_STATIC_METHOD(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_INVOKE_STATIC_METHOD(0x7E07B9C27FE59D68LL, domcomment);
      HASH_INVOKE_STATIC_METHOD(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_INVOKE_STATIC_METHOD(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_INVOKE_STATIC_METHOD(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_INVOKE_STATIC_METHOD(0x3D5870E53BF89873LL, arrayiterator);
      HASH_INVOKE_STATIC_METHOD(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 117:
      HASH_INVOKE_STATIC_METHOD(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_INVOKE_STATIC_METHOD(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_INVOKE_STATIC_METHOD(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_INVOKE_STATIC_METHOD(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_INVOKE_STATIC_METHOD(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_INVOKE_STATIC_METHOD(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_INVOKE_STATIC_METHOD(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_INVOKE_STATIC_METHOD(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_INVOKE_STATIC_METHOD(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_INVOKE_STATIC_METHOD(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_INVOKE_STATIC_METHOD(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_INVOKE_STATIC_METHOD(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_INVOKE_STATIC_METHOD(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_INVOKE_STATIC_METHOD(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_INVOKE_STATIC_METHOD(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_INVOKE_STATIC_METHOD(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_INVOKE_STATIC_METHOD(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_INVOKE_STATIC_METHOD(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 170:
      HASH_INVOKE_STATIC_METHOD(0x67E31D42F2DFE4AALL, locale);
      break;
    case 173:
      HASH_INVOKE_STATIC_METHOD(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_INVOKE_STATIC_METHOD(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_INVOKE_STATIC_METHOD(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_INVOKE_STATIC_METHOD(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_INVOKE_STATIC_METHOD(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_INVOKE_STATIC_METHOD(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_INVOKE_STATIC_METHOD(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_INVOKE_STATIC_METHOD(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 208:
      HASH_INVOKE_STATIC_METHOD(0x3C122DF8859C72D0LL, memcache);
      break;
    case 210:
      HASH_INVOKE_STATIC_METHOD(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_INVOKE_STATIC_METHOD(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_INVOKE_STATIC_METHOD(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_INVOKE_STATIC_METHOD(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_INVOKE_STATIC_METHOD(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_INVOKE_STATIC_METHOD(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_INVOKE_STATIC_METHOD(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_INVOKE_STATIC_METHOD(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_INVOKE_STATIC_METHOD(0x297174231D4912F4LL, domattr);
      break;
    case 247:
      HASH_INVOKE_STATIC_METHOD(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_INVOKE_STATIC_METHOD(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_INVOKE_STATIC_METHOD(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_INVOKE_STATIC_METHOD(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  if (fatal) {
    return throw_missing_class(s);
  } else {
    raise_warning("call_user_func to non-existent class's method %s::%s", s, method);
    return false;
  }
}
const ObjectStaticCallbacks * get_builtin_object_static_callbacks(const char *s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 18:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x78B42582709BAF12LL, debuggerproxy);
      break;
    case 19:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 61:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4C6991D3CF5CA03DLL, collator);
      break;
    case 62:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70747A09B3523662LL, domnode);
      break;
    case 99:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D1235273F521A63LL, debuggerclient);
      break;
    case 101:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 117:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 170:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x67E31D42F2DFE4AALL, locale);
      break;
    case 173:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 208:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3C122DF8859C72D0LL, memcache);
      break;
    case 210:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297174231D4912F4LL, domattr);
      break;
    case 247:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return NULL;
}
Variant get_builtin_static_property(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_get(prop, -1);
  }
  return null;
}
Variant *get_builtin_static_property_lv(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return &cwo->os_lval(prop, -1);
  }
  return NULL;
}
Variant get_builtin_class_constant(const char *s, const char *constant, bool fatal /* = true */) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_constant(constant);
  }
  if (fatal) {
    raise_error("Couldn't find constant %s::%s", s, constant);
  } else {
    raise_warning("Couldn't find constant %s::%s", s, constant);
  }
  return null;
}

///////////////////////////////////////////////////////////////////////////////
}
