/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "thrift/compiler/ast/test/thrift_ast_debug_tree_utils_test.h"

#include <memory>
#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <folly/portability/GFlags.h>

#include <fstream>
#include "thrift/common/tree_printer.h"
#include "thrift/compiler/ast/t_program.h"
#include "thrift/compiler/ast/t_program_bundle.h"
#include "thrift/compiler/ast/thrift_ast_debug_tree_utils.h"
#include "thrift/compiler/parse/parse_ast.h"
#include "thrift/compiler/source_location.h"

DEFINE_string(
    output_test_data_path,
    "",
    "If this flag is set, "
    "the new test data will be written to the specified path, "
    "allowing it to be included in future runs. "
    "This mechanism enables updating the expected values used for testing.");

namespace apache::thrift::compiler {
namespace {

constexpr auto kTestDataHeader =
    "// @"
    "generated"
    R"(
// This file is generated by the following script:
//
//   xplat/thrift/compiler/ast/test/update.sh
//

#pragma once

)";

void maybeUpdateTestData(
    std::string_view variableName, std::string_view content) {
  if (FLAGS_output_test_data_path.empty()) {
    return;
  }

  static std::ofstream fout = std::invoke([] {
    std::ofstream fout(FLAGS_output_test_data_path);
    fout << kTestDataHeader;
    return fout;
  });

  fout << "constexpr auto " << variableName << " = R\"(";
  fout << content;
  fout << ")\";" << std::endl;
}

/**
 * Normalizes memory addresses in the given input, to allow matching for
 * testing.
 *
 * Scans the input string and replaces all memory address patterns (e.g.,
 * `0x519000022b80`) with normalized addresses of the form `0xNORMALIZED_N`,
 * where N is a sequential index. Identical addresses in the input will map to
 * the same normalized address. The null address (0x0) is left unchanged.
 *
 * @param input The string containing memory addresses to normalize
 * @return A new string with all memory addresses normalized
 *
 * Example:
 *   Input:  "Object 0xabc123 references 0xdef456 and 0xabc123"
 *   Output: "Object 0xNORMALIZED_1 references 0xNORMALIZED_2 and
 * 0xNORMALIZED_1"
 */
std::string normalizeMemoryAddresses(const std::string& input) {
  std::string result;
  result.reserve(input.size());

  std::unordered_map<std::string, int> addressMap;
  int nextIndex = 1;

  std::size_t pos = 0;
  while (pos < input.size()) {
    // Look for the pattern "0x" followed by hex digits
    if (pos + 1 < input.size() && input[pos] == '0' && input[pos + 1] == 'x') {
      // Found the start of a memory address
      std::size_t addressStart = pos;
      std::size_t addressEnd = pos + 2; // Start after "0x"

      // Collect hex digits
      while (addressEnd < input.size() &&
             std::isxdigit(static_cast<unsigned char>(input[addressEnd]))) {
        ++addressEnd;
      }

      // Extract the full address (including @0x prefix)
      std::string address =
          input.substr(addressStart, addressEnd - addressStart);

      // Special handing for nullptr, which is consistent across runs.
      if (address == "0x0") {
        result += "0x0";
        pos = addressEnd;
        continue;
      }

      // Look up or assign an index for this address
      auto it = addressMap.find(address);
      int index;
      if (it == addressMap.end()) {
        index = nextIndex++;
        addressMap[address] = index;
      } else {
        index = it->second;
      }

      // Append the normalized address
      result += "0xNORMALIZED_";
      result += std::to_string(index);

      pos = addressEnd;
    } else {
      // Not a memory address, copy the character as-is
      result += input[pos];
      ++pos;
    }
  }

  return result;
}

std::string toNormalizedDebugTreeString(const t_program_bundle& programBundle) {
  return normalizeMemoryAddresses(
      apache::thrift::tree_printer::to_string(
          ThriftAstDebugTreeUtils::createTreeForProgramBundle(programBundle)));
}

} // namespace

TEST(AstTreePrinterTest, toNormalizedDebugTreeString) {
  const t_program_bundle kProgramBundle = []() {
    auto root_program = std::make_unique<t_program>(
        /*path=*/"my/test/path/virtual_test_file.thrift",
        /*full_path=*/"my/test/full_path/virtual_test_file.thrift");
    root_program->set_namespace("py3", "foo.bar");

    return t_program_bundle(std::move(root_program));
  }();

  const std::string actual = toNormalizedDebugTreeString(kProgramBundle);

  EXPECT_EQ(actual, kVirtualTestFileExpected);
  maybeUpdateTestData("kVirtualTestFileExpected", actual);
}

TEST(AstTreePrinterTest, ParseAndDebugPrint) {
  source_manager sourceManager(nullptr /* backend */);
  sourceManager.add_virtual_file(
      "my/virtual/test/path/ParseAndDebugPrint.thrift", R"(
include "thrift/annotation/thrift.thrift"

typedef i32 int

@thrift.Experimental
struct Foo {}

exception TestException {}

service MyService {
  void func1();

  i32 func2(Foo foo) throws (TestException ex);
}
)");
  diagnostics_engine diagnosticsEngine =
      diagnostics_engine::ignore_all(sourceManager);

  std::unique_ptr<t_program_bundle> programBundle = parse_ast(
      sourceManager,
      diagnosticsEngine,
      "my/virtual/test/path/ParseAndDebugPrint.thrift",
      parsing_params{});

  const std::string actual = toNormalizedDebugTreeString(*programBundle);

  EXPECT_EQ(actual, kParseAndDebugPrintExpected);
  maybeUpdateTestData("kParseAndDebugPrintExpected", actual);
}

} // namespace apache::thrift::compiler
