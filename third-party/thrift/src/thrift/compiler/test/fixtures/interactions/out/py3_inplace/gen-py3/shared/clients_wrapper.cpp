/**
 * Autogenerated by Thrift for shared.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <thrift/compiler/test/fixtures/interactions/gen-py3/shared/clients_wrapper.h>

namespace thrift {
namespace shared_interactions {



folly::Future<std::unique_ptr<::thrift::py3::ClientWrapper>>
InteractLocallyClientWrapper::createSharedInteraction() {
  return folly::via(
      channel_->getEventBase(),
      [=, this]() -> std::unique_ptr<::thrift::py3::ClientWrapper> {
        auto interaction_client = static_cast<std::unique_ptr<apache::thrift::GeneratedAsyncClient>>(std::make_unique<InteractLocallyAsyncClient::SharedInteraction>(((InteractLocallyAsyncClient*)async_client_.get())->createSharedInteraction()));
        return static_cast<std::unique_ptr<::thrift::py3::ClientWrapper>>(std::make_unique<SharedInteractionInteractionWrapper>(std::move(interaction_client), channel_));
      }
  );
}

folly::Future<int32_t>
InteractLocallyClientWrapper::SharedInteractionInteractionWrapper::init(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::thrift::shared_interactions::InteractLocallyAsyncClient::SharedInteraction*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int32_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int32_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_init, channel_);
  try {
    client->init(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<int32_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::thrift::shared_interactions::DoSomethingResult>
InteractLocallyClientWrapper::SharedInteractionInteractionWrapper::do_something(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::thrift::shared_interactions::InteractLocallyAsyncClient::SharedInteraction*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::thrift::shared_interactions::DoSomethingResult>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::thrift::shared_interactions::DoSomethingResult>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_do_something, channel_);
  try {
    client->do_something(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<::thrift::shared_interactions::DoSomethingResult>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
InteractLocallyClientWrapper::SharedInteractionInteractionWrapper::tear_down(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::thrift::shared_interactions::InteractLocallyAsyncClient::SharedInteraction*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_tear_down, channel_);
  try {
    client->tear_down(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

} // namespace thrift
} // namespace shared_interactions
