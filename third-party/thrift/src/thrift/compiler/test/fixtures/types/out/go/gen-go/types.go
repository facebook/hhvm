// Autogenerated by Thrift for thrift/compiler/test/fixtures/types/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "fmt"
    "reflect"

    included "included"
    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
)

// (needed to ensure safety because of naive import list construction)
var _ = included.GoUnusedProtection__
var _ = fmt.Printf
var _ = reflect.Ptr
var _ = thrift.VOID

type TBinary = []byte

func NewTBinary() TBinary {
    return []byte("")
}

func WriteTBinary(item TBinary, p thrift.Encoder) error {
    if err := p.WriteBinary(item); err != nil {
        return err
    }
    return nil
}

func ReadTBinary(p thrift.Decoder) (TBinary, error) {
    var decodeResult TBinary
    decodeErr := func() error {
        result, err := p.ReadBinary()
        if err != nil {
            return err
        }
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type IntTypedef = int32

func NewIntTypedef() IntTypedef {
    return 0
}

func WriteIntTypedef(item IntTypedef, p thrift.Encoder) error {
    if err := p.WriteI32(item); err != nil {
        return err
    }
    return nil
}

func ReadIntTypedef(p thrift.Decoder) (IntTypedef, error) {
    var decodeResult IntTypedef
    decodeErr := func() error {
        result, err := p.ReadI32()
        if err != nil {
            return err
        }
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type UintTypedef = IntTypedef

func NewUintTypedef() UintTypedef {
    return NewIntTypedef()
}

func WriteUintTypedef(item UintTypedef, p thrift.Encoder) error {
    err := WriteIntTypedef(item, p)
    if err != nil {
        return err
    }
    return nil
}

func ReadUintTypedef(p thrift.Decoder) (UintTypedef, error) {
    var decodeResult UintTypedef
    decodeErr := func() error {
        result, err := ReadIntTypedef(p)
        if err != nil {
            return err
        }
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type SomeListOfTypeMap_2468 = included.SomeListOfTypeMap

func NewSomeListOfTypeMap_2468() SomeListOfTypeMap_2468 {
    return included.NewSomeListOfTypeMap()
}

func WriteSomeListOfTypeMap_2468(item SomeListOfTypeMap_2468, p thrift.Encoder) error {
    err := included.WriteSomeListOfTypeMap(item, p)
    if err != nil {
        return err
    }
    return nil
}

func ReadSomeListOfTypeMap_2468(p thrift.Decoder) (SomeListOfTypeMap_2468, error) {
    var decodeResult SomeListOfTypeMap_2468
    decodeErr := func() error {
        result, err := included.ReadSomeListOfTypeMap(p)
        if err != nil {
            return err
        }
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type TBinary_8623 = TBinary

func NewTBinary_8623() TBinary_8623 {
    return NewTBinary()
}

func WriteTBinary_8623(item TBinary_8623, p thrift.Encoder) error {
    err := WriteTBinary(item, p)
    if err != nil {
        return err
    }
    return nil
}

func ReadTBinary_8623(p thrift.Decoder) (TBinary_8623, error) {
    var decodeResult TBinary_8623
    decodeErr := func() error {
        result, err := ReadTBinary(p)
        if err != nil {
            return err
        }
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type I32_9314 = int32

func NewI32_9314() I32_9314 {
    return 0
}

func WriteI32_9314(item I32_9314, p thrift.Encoder) error {
    if err := p.WriteI32(item); err != nil {
        return err
    }
    return nil
}

func ReadI32_9314(p thrift.Decoder) (I32_9314, error) {
    var decodeResult I32_9314
    decodeErr := func() error {
        result, err := p.ReadI32()
        if err != nil {
            return err
        }
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type ListI32_9187 = []int32

func NewListI32_9187() ListI32_9187 {
    return make([]int32, 0)
}

func WriteListI32_9187(item ListI32_9187, p thrift.Encoder) error {
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }
    return nil
}

func ReadListI32_9187(p thrift.Decoder) (ListI32_9187, error) {
    var decodeResult ListI32_9187
    decodeErr := func() error {
        _ /* elemType */, size, err := p.ReadListBegin()
        if err != nil {
            return thrift.PrependError("error reading list begin: ", err)
        }
        
        listResult := make([]int32, 0, size)
        for i := 0; i < size; i++ {
            var elem int32
            {
                result, err := p.ReadI32()
                if err != nil {
                    return err
                }
                elem = result
            }
            listResult = append(listResult, elem)
        }
        
        if err := p.ReadListEnd(); err != nil {
            return thrift.PrependError("error reading list end: ", err)
        }
        result := listResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type MapI32I32_9565 = map[int32]int32

func NewMapI32I32_9565() MapI32I32_9565 {
    return make(map[int32]int32)
}

func WriteMapI32I32_9565(item MapI32I32_9565, p thrift.Encoder) error {
    if err := p.WriteMapBegin(thrift.I32, thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range item {
        {
            item := k
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
    }
    return nil
}

func ReadMapI32I32_9565(p thrift.Decoder) (MapI32I32_9565, error) {
    var decodeResult MapI32I32_9565
    decodeErr := func() error {
        _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
        if err != nil {
            return thrift.PrependError("error reading map begin: ", err)
        }
        
        mapResult := make(map[int32]int32, size)
        for i := 0; i < size; i++ {
            var key int32
            {
                result, err := p.ReadI32()
                if err != nil {
                    return err
                }
                key = result
            }
        
            var value int32
            {
                result, err := p.ReadI32()
                if err != nil {
                    return err
                }
                value = result
            }
        
            mapResult[key] = value
        }
        
        if err := p.ReadMapEnd(); err != nil {
            return thrift.PrependError("error reading map end: ", err)
        }
        result := mapResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type MapI32String_1261 = map[int32]string

func NewMapI32String_1261() MapI32String_1261 {
    return make(map[int32]string)
}

func WriteMapI32String_1261(item MapI32String_1261, p thrift.Encoder) error {
    if err := p.WriteMapBegin(thrift.I32, thrift.STRING, len(item)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range item {
        {
            item := k
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    
        {
            item := v
            if err := p.WriteString(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
    }
    return nil
}

func ReadMapI32String_1261(p thrift.Decoder) (MapI32String_1261, error) {
    var decodeResult MapI32String_1261
    decodeErr := func() error {
        _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
        if err != nil {
            return thrift.PrependError("error reading map begin: ", err)
        }
        
        mapResult := make(map[int32]string, size)
        for i := 0; i < size; i++ {
            var key int32
            {
                result, err := p.ReadI32()
                if err != nil {
                    return err
                }
                key = result
            }
        
            var value string
            {
                result, err := p.ReadString()
                if err != nil {
                    return err
                }
                value = result
            }
        
            mapResult[key] = value
        }
        
        if err := p.ReadMapEnd(); err != nil {
            return thrift.PrependError("error reading map end: ", err)
        }
        result := mapResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type SetI32_7070 = []int32

func NewSetI32_7070() SetI32_7070 {
    return make([]int32, 0)
}

func WriteSetI32_7070(item SetI32_7070, p thrift.Encoder) error {
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing set begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteSetEnd(); err != nil {
        return thrift.PrependError("error writing set end: ", err)
    }
    return nil
}

func ReadSetI32_7070(p thrift.Decoder) (SetI32_7070, error) {
    var decodeResult SetI32_7070
    decodeErr := func() error {
        _ /* elemType */, size, err := p.ReadSetBegin()
        if err != nil {
            return thrift.PrependError("error reading set begin: ", err)
        }
        
        setResult := make([]int32, 0, size)
        for i := 0; i < size; i++ {
            var elem int32
            {
                result, err := p.ReadI32()
                if err != nil {
                    return err
                }
                elem = result
            }
            setResult = append(setResult, elem)
        }
        
        if err := p.ReadSetEnd(); err != nil {
            return thrift.PrependError("error reading set end: ", err)
        }
        result := setResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type SetI32_7194 = []int32

func NewSetI32_7194() SetI32_7194 {
    return make([]int32, 0)
}

func WriteSetI32_7194(item SetI32_7194, p thrift.Encoder) error {
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing set begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteSetEnd(); err != nil {
        return thrift.PrependError("error writing set end: ", err)
    }
    return nil
}

func ReadSetI32_7194(p thrift.Decoder) (SetI32_7194, error) {
    var decodeResult SetI32_7194
    decodeErr := func() error {
        _ /* elemType */, size, err := p.ReadSetBegin()
        if err != nil {
            return thrift.PrependError("error reading set begin: ", err)
        }
        
        setResult := make([]int32, 0, size)
        for i := 0; i < size; i++ {
            var elem int32
            {
                result, err := p.ReadI32()
                if err != nil {
                    return err
                }
                elem = result
            }
            setResult = append(setResult, elem)
        }
        
        if err := p.ReadSetEnd(); err != nil {
            return thrift.PrependError("error reading set end: ", err)
        }
        result := setResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type String_5252 = string

func NewString_5252() String_5252 {
    return ""
}

func WriteString_5252(item String_5252, p thrift.Encoder) error {
    if err := p.WriteString(item); err != nil {
        return err
    }
    return nil
}

func ReadString_5252(p thrift.Decoder) (String_5252, error) {
    var decodeResult String_5252
    decodeErr := func() error {
        result, err := p.ReadString()
        if err != nil {
            return err
        }
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type HasBitwiseOps int32

const (
    HasBitwiseOps_none HasBitwiseOps = 0
    HasBitwiseOps_zero HasBitwiseOps = 1
    HasBitwiseOps_one HasBitwiseOps = 2
    HasBitwiseOps_two HasBitwiseOps = 4
    HasBitwiseOps_three HasBitwiseOps = 8
)

// Enum value maps for HasBitwiseOps
var (
    HasBitwiseOpsToName = map[HasBitwiseOps]string {
        HasBitwiseOps_none: "none",
        HasBitwiseOps_zero: "zero",
        HasBitwiseOps_one: "one",
        HasBitwiseOps_two: "two",
        HasBitwiseOps_three: "three",
    }

    HasBitwiseOpsToValue = map[string]HasBitwiseOps {
        "none": HasBitwiseOps_none,
        "zero": HasBitwiseOps_zero,
        "one": HasBitwiseOps_one,
        "two": HasBitwiseOps_two,
        "three": HasBitwiseOps_three,
    }
)

func (x HasBitwiseOps) String() string {
    if v, ok := HasBitwiseOpsToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

// Deprecated: Use HasBitwiseOpsToValue instead (e.g. `x, ok := HasBitwiseOpsToValue["name"]`).
func HasBitwiseOpsFromString(s string) (HasBitwiseOps, error) {
    if v, ok := HasBitwiseOpsToValue[s]; ok {
        return v, nil
    }
    return HasBitwiseOps(0), fmt.Errorf("not a valid HasBitwiseOps string")
}

type IsUnscoped int32

const (
    IsUnscoped_hello IsUnscoped = 0
    IsUnscoped_world IsUnscoped = 1
)

// Enum value maps for IsUnscoped
var (
    IsUnscopedToName = map[IsUnscoped]string {
        IsUnscoped_hello: "hello",
        IsUnscoped_world: "world",
    }

    IsUnscopedToValue = map[string]IsUnscoped {
        "hello": IsUnscoped_hello,
        "world": IsUnscoped_world,
    }
)

func (x IsUnscoped) String() string {
    if v, ok := IsUnscopedToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

// Deprecated: Use IsUnscopedToValue instead (e.g. `x, ok := IsUnscopedToValue["name"]`).
func IsUnscopedFromString(s string) (IsUnscoped, error) {
    if v, ok := IsUnscopedToValue[s]; ok {
        return v, nil
    }
    return IsUnscoped(0), fmt.Errorf("not a valid IsUnscoped string")
}

type MyForwardRefEnum int32

const (
    MyForwardRefEnum_ZERO MyForwardRefEnum = 0
    MyForwardRefEnum_NONZERO MyForwardRefEnum = 12
)

// Enum value maps for MyForwardRefEnum
var (
    MyForwardRefEnumToName = map[MyForwardRefEnum]string {
        MyForwardRefEnum_ZERO: "ZERO",
        MyForwardRefEnum_NONZERO: "NONZERO",
    }

    MyForwardRefEnumToValue = map[string]MyForwardRefEnum {
        "ZERO": MyForwardRefEnum_ZERO,
        "NONZERO": MyForwardRefEnum_NONZERO,
    }
)

func (x MyForwardRefEnum) String() string {
    if v, ok := MyForwardRefEnumToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

// Deprecated: Use MyForwardRefEnumToValue instead (e.g. `x, ok := MyForwardRefEnumToValue["name"]`).
func MyForwardRefEnumFromString(s string) (MyForwardRefEnum, error) {
    if v, ok := MyForwardRefEnumToValue[s]; ok {
        return v, nil
    }
    return MyForwardRefEnum(0), fmt.Errorf("not a valid MyForwardRefEnum string")
}

type EmptyStruct struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*EmptyStruct)(nil)

func NewEmptyStruct() *EmptyStruct {
    return (&EmptyStruct{}).setDefaults()
}



func (x *EmptyStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("empty_struct"); err != nil {
        return thrift.PrependError("EmptyStruct write struct begin error: ", err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("EmptyStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("EmptyStruct write struct end error: ", err)
    }
    return nil
}

func (x *EmptyStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("EmptyStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("EmptyStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("EmptyStruct read struct end error: ", err)
    }

    return nil
}

func (x *EmptyStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *EmptyStruct) setDefaults() *EmptyStruct {
    return x
}

type DecoratedStruct struct {
    Field string `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*DecoratedStruct)(nil)

func NewDecoratedStruct() *DecoratedStruct {
    return (&DecoratedStruct{}).setDefaults()
}

func (x *DecoratedStruct) GetField() string {
    return x.Field
}

func (x *DecoratedStruct) SetFieldNonCompat(value string) *DecoratedStruct {
    x.Field = value
    return x
}

func (x *DecoratedStruct) SetField(value string) *DecoratedStruct {
    x.Field = value
    return x
}

func (x *DecoratedStruct) writeField1(p thrift.Encoder) error {  // Field
    if err := p.WriteFieldBegin("field", thrift.STRING, 1); err != nil {
        return thrift.PrependError("DecoratedStruct write field begin error: ", err)
    }

    item := x.Field
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("DecoratedStruct write field end error: ", err)
    }
    return nil
}

func (x *DecoratedStruct) readField1(p thrift.Decoder) error {  // Field
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.Field = result
    return nil
}



func (x *DecoratedStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("decorated_struct"); err != nil {
        return thrift.PrependError("DecoratedStruct write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("DecoratedStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("DecoratedStruct write struct end error: ", err)
    }
    return nil
}

func (x *DecoratedStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("DecoratedStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("DecoratedStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("DecoratedStruct read struct end error: ", err)
    }

    return nil
}

func (x *DecoratedStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *DecoratedStruct) setDefaults() *DecoratedStruct {
    return x.
        SetFieldNonCompat("")
}

type ContainerStruct struct {
    FieldB []int32 `thrift:"fieldB,2" json:"fieldB" db:"fieldB"`
    FieldC []int32 `thrift:"fieldC,3" json:"fieldC" db:"fieldC"`
    FieldD []int32 `thrift:"fieldD,4" json:"fieldD" db:"fieldD"`
    FieldE []int32 `thrift:"fieldE,5" json:"fieldE" db:"fieldE"`
    FieldF SetI32_7194 `thrift:"fieldF,6" json:"fieldF" db:"fieldF"`
    FieldG MapI32String_1261 `thrift:"fieldG,7" json:"fieldG" db:"fieldG"`
    FieldH included.SomeMap `thrift:"fieldH,8" json:"fieldH" db:"fieldH"`
    FieldA []int32 `thrift:"fieldA,12" json:"fieldA" db:"fieldA"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ContainerStruct)(nil)

func NewContainerStruct() *ContainerStruct {
    return (&ContainerStruct{}).setDefaults()
}

func (x *ContainerStruct) GetFieldB() []int32 {
    if !x.IsSetFieldB() {
        return make([]int32, 0)
    }
    return x.FieldB
}

func (x *ContainerStruct) GetFieldC() []int32 {
    if !x.IsSetFieldC() {
        return make([]int32, 0)
    }
    return x.FieldC
}

func (x *ContainerStruct) GetFieldD() []int32 {
    if !x.IsSetFieldD() {
        return make([]int32, 0)
    }
    return x.FieldD
}

func (x *ContainerStruct) GetFieldE() []int32 {
    if !x.IsSetFieldE() {
        return make([]int32, 0)
    }
    return x.FieldE
}

func (x *ContainerStruct) GetFieldF() SetI32_7194 {
    if !x.IsSetFieldF() {
        return NewSetI32_7194()
    }
    return x.FieldF
}

func (x *ContainerStruct) GetFieldG() MapI32String_1261 {
    if !x.IsSetFieldG() {
        return NewMapI32String_1261()
    }
    return x.FieldG
}

func (x *ContainerStruct) GetFieldH() included.SomeMap {
    if !x.IsSetFieldH() {
        return included.NewSomeMap()
    }
    return x.FieldH
}

func (x *ContainerStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
        return make([]int32, 0)
    }
    return x.FieldA
}

func (x *ContainerStruct) SetFieldBNonCompat(value []int32) *ContainerStruct {
    x.FieldB = value
    return x
}

func (x *ContainerStruct) SetFieldB(value []int32) *ContainerStruct {
    x.FieldB = value
    return x
}

func (x *ContainerStruct) SetFieldCNonCompat(value []int32) *ContainerStruct {
    x.FieldC = value
    return x
}

func (x *ContainerStruct) SetFieldC(value []int32) *ContainerStruct {
    x.FieldC = value
    return x
}

func (x *ContainerStruct) SetFieldDNonCompat(value []int32) *ContainerStruct {
    x.FieldD = value
    return x
}

func (x *ContainerStruct) SetFieldD(value []int32) *ContainerStruct {
    x.FieldD = value
    return x
}

func (x *ContainerStruct) SetFieldENonCompat(value []int32) *ContainerStruct {
    x.FieldE = value
    return x
}

func (x *ContainerStruct) SetFieldE(value []int32) *ContainerStruct {
    x.FieldE = value
    return x
}

func (x *ContainerStruct) SetFieldFNonCompat(value SetI32_7194) *ContainerStruct {
    x.FieldF = value
    return x
}

func (x *ContainerStruct) SetFieldF(value SetI32_7194) *ContainerStruct {
    x.FieldF = value
    return x
}

func (x *ContainerStruct) SetFieldGNonCompat(value MapI32String_1261) *ContainerStruct {
    x.FieldG = value
    return x
}

func (x *ContainerStruct) SetFieldG(value MapI32String_1261) *ContainerStruct {
    x.FieldG = value
    return x
}

func (x *ContainerStruct) SetFieldHNonCompat(value included.SomeMap) *ContainerStruct {
    x.FieldH = value
    return x
}

func (x *ContainerStruct) SetFieldH(value included.SomeMap) *ContainerStruct {
    x.FieldH = value
    return x
}

func (x *ContainerStruct) SetFieldANonCompat(value []int32) *ContainerStruct {
    x.FieldA = value
    return x
}

func (x *ContainerStruct) SetFieldA(value []int32) *ContainerStruct {
    x.FieldA = value
    return x
}

func (x *ContainerStruct) IsSetFieldB() bool {
    return x != nil && x.FieldB != nil
}

func (x *ContainerStruct) IsSetFieldC() bool {
    return x != nil && x.FieldC != nil
}

func (x *ContainerStruct) IsSetFieldD() bool {
    return x != nil && x.FieldD != nil
}

func (x *ContainerStruct) IsSetFieldE() bool {
    return x != nil && x.FieldE != nil
}

func (x *ContainerStruct) IsSetFieldF() bool {
    return x != nil && x.FieldF != nil
}

func (x *ContainerStruct) IsSetFieldG() bool {
    return x != nil && x.FieldG != nil
}

func (x *ContainerStruct) IsSetFieldH() bool {
    return x != nil && x.FieldH != nil
}

func (x *ContainerStruct) IsSetFieldA() bool {
    return x != nil && x.FieldA != nil
}

func (x *ContainerStruct) writeField2(p thrift.Encoder) error {  // FieldB
    if err := p.WriteFieldBegin("fieldB", thrift.LIST, 2); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldB
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) writeField3(p thrift.Encoder) error {  // FieldC
    if err := p.WriteFieldBegin("fieldC", thrift.LIST, 3); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldC
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) writeField4(p thrift.Encoder) error {  // FieldD
    if err := p.WriteFieldBegin("fieldD", thrift.LIST, 4); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldD
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) writeField5(p thrift.Encoder) error {  // FieldE
    if err := p.WriteFieldBegin("fieldE", thrift.LIST, 5); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldE
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) writeField6(p thrift.Encoder) error {  // FieldF
    if err := p.WriteFieldBegin("fieldF", thrift.SET, 6); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldF
    err := WriteSetI32_7194(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) writeField7(p thrift.Encoder) error {  // FieldG
    if err := p.WriteFieldBegin("fieldG", thrift.MAP, 7); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldG
    err := WriteMapI32String_1261(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) writeField8(p thrift.Encoder) error {  // FieldH
    if err := p.WriteFieldBegin("fieldH", thrift.MAP, 8); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldH
    err := included.WriteSomeMap(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) writeField12(p thrift.Encoder) error {  // FieldA
    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 12); err != nil {
        return thrift.PrependError("ContainerStruct write field begin error: ", err)
    }

    item := x.FieldA
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write field end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) readField2(p thrift.Decoder) error {  // FieldB
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int32, 0, size)
    for i := 0; i < size; i++ {
        var elem int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.FieldB = result
    return nil
}

func (x *ContainerStruct) readField3(p thrift.Decoder) error {  // FieldC
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int32, 0, size)
    for i := 0; i < size; i++ {
        var elem int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.FieldC = result
    return nil
}

func (x *ContainerStruct) readField4(p thrift.Decoder) error {  // FieldD
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int32, 0, size)
    for i := 0; i < size; i++ {
        var elem int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.FieldD = result
    return nil
}

func (x *ContainerStruct) readField5(p thrift.Decoder) error {  // FieldE
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int32, 0, size)
    for i := 0; i < size; i++ {
        var elem int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.FieldE = result
    return nil
}

func (x *ContainerStruct) readField6(p thrift.Decoder) error {  // FieldF
    result, err := ReadSetI32_7194(p)
    if err != nil {
        return err
    }

    x.FieldF = result
    return nil
}

func (x *ContainerStruct) readField7(p thrift.Decoder) error {  // FieldG
    result, err := ReadMapI32String_1261(p)
    if err != nil {
        return err
    }

    x.FieldG = result
    return nil
}

func (x *ContainerStruct) readField8(p thrift.Decoder) error {  // FieldH
    result, err := included.ReadSomeMap(p)
    if err != nil {
        return err
    }

    x.FieldH = result
    return nil
}

func (x *ContainerStruct) readField12(p thrift.Decoder) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int32, 0, size)
    for i := 0; i < size; i++ {
        var elem int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.FieldA = result
    return nil
}



func (x *ContainerStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ContainerStruct"); err != nil {
        return thrift.PrependError("ContainerStruct write struct begin error: ", err)
    }

    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }
    if err := x.writeField4(p); err != nil {
        return err
    }
    if err := x.writeField5(p); err != nil {
        return err
    }
    if err := x.writeField6(p); err != nil {
        return err
    }
    if err := x.writeField7(p); err != nil {
        return err
    }
    if err := x.writeField8(p); err != nil {
        return err
    }
    if err := x.writeField12(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ContainerStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ContainerStruct write struct end error: ", err)
    }
    return nil
}

func (x *ContainerStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ContainerStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ContainerStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 2 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "fieldB")):  // fieldB
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "fieldC")):  // fieldC
            fieldReadErr = x.readField3(p)
        case ((id == 4 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "fieldD")):  // fieldD
            fieldReadErr = x.readField4(p)
        case ((id == 5 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "fieldE")):  // fieldE
            fieldReadErr = x.readField5(p)
        case ((id == 6 && wireType == thrift.SET) || (id == thrift.NO_FIELD_ID && fieldName == "fieldF")):  // fieldF
            fieldReadErr = x.readField6(p)
        case ((id == 7 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "fieldG")):  // fieldG
            fieldReadErr = x.readField7(p)
        case ((id == 8 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "fieldH")):  // fieldH
            fieldReadErr = x.readField8(p)
        case ((id == 12 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "fieldA")):  // fieldA
            fieldReadErr = x.readField12(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ContainerStruct read struct end error: ", err)
    }

    return nil
}

func (x *ContainerStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ContainerStruct) setDefaults() *ContainerStruct {
    return x.
        SetFieldBNonCompat(make([]int32, 0)).
        SetFieldCNonCompat(make([]int32, 0)).
        SetFieldDNonCompat(make([]int32, 0)).
        SetFieldENonCompat(make([]int32, 0)).
        SetFieldFNonCompat(NewSetI32_7194()).
        SetFieldGNonCompat(NewMapI32String_1261()).
        SetFieldHNonCompat(included.NewSomeMap()).
        SetFieldANonCompat(make([]int32, 0))
}

type CppTypeStruct struct {
    FieldA []int32 `thrift:"fieldA,1" json:"fieldA" db:"fieldA"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*CppTypeStruct)(nil)

func NewCppTypeStruct() *CppTypeStruct {
    return (&CppTypeStruct{}).setDefaults()
}

func (x *CppTypeStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
        return make([]int32, 0)
    }
    return x.FieldA
}

func (x *CppTypeStruct) SetFieldANonCompat(value []int32) *CppTypeStruct {
    x.FieldA = value
    return x
}

func (x *CppTypeStruct) SetFieldA(value []int32) *CppTypeStruct {
    x.FieldA = value
    return x
}

func (x *CppTypeStruct) IsSetFieldA() bool {
    return x != nil && x.FieldA != nil
}

func (x *CppTypeStruct) writeField1(p thrift.Encoder) error {  // FieldA
    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 1); err != nil {
        return thrift.PrependError("CppTypeStruct write field begin error: ", err)
    }

    item := x.FieldA
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("CppTypeStruct write field end error: ", err)
    }
    return nil
}

func (x *CppTypeStruct) readField1(p thrift.Decoder) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int32, 0, size)
    for i := 0; i < size; i++ {
        var elem int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.FieldA = result
    return nil
}



func (x *CppTypeStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("CppTypeStruct"); err != nil {
        return thrift.PrependError("CppTypeStruct write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("CppTypeStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("CppTypeStruct write struct end error: ", err)
    }
    return nil
}

func (x *CppTypeStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("CppTypeStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("CppTypeStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "fieldA")):  // fieldA
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("CppTypeStruct read struct end error: ", err)
    }

    return nil
}

func (x *CppTypeStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *CppTypeStruct) setDefaults() *CppTypeStruct {
    return x.
        SetFieldANonCompat(make([]int32, 0))
}

type VirtualStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*VirtualStruct)(nil)

func NewVirtualStruct() *VirtualStruct {
    return (&VirtualStruct{}).setDefaults()
}

func (x *VirtualStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *VirtualStruct) SetMyIntFieldNonCompat(value int64) *VirtualStruct {
    x.MyIntField = value
    return x
}

func (x *VirtualStruct) SetMyIntField(value int64) *VirtualStruct {
    x.MyIntField = value
    return x
}

func (x *VirtualStruct) writeField1(p thrift.Encoder) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError("VirtualStruct write field begin error: ", err)
    }

    item := x.MyIntField
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("VirtualStruct write field end error: ", err)
    }
    return nil
}

func (x *VirtualStruct) readField1(p thrift.Decoder) error {  // MyIntField
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.MyIntField = result
    return nil
}



func (x *VirtualStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("VirtualStruct"); err != nil {
        return thrift.PrependError("VirtualStruct write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("VirtualStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("VirtualStruct write struct end error: ", err)
    }
    return nil
}

func (x *VirtualStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("VirtualStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("VirtualStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "MyIntField")):  // MyIntField
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("VirtualStruct read struct end error: ", err)
    }

    return nil
}

func (x *VirtualStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *VirtualStruct) setDefaults() *VirtualStruct {
    return x.
        SetMyIntFieldNonCompat(0)
}

type MyStructWithForwardRefEnum struct {
    A MyForwardRefEnum `thrift:"a,1" json:"a" db:"a"`
    B MyForwardRefEnum `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MyStructWithForwardRefEnum)(nil)

func NewMyStructWithForwardRefEnum() *MyStructWithForwardRefEnum {
    return (&MyStructWithForwardRefEnum{}).setDefaults()
}

func (x *MyStructWithForwardRefEnum) GetA() MyForwardRefEnum {
    return x.A
}

func (x *MyStructWithForwardRefEnum) GetB() MyForwardRefEnum {
    return x.B
}

func (x *MyStructWithForwardRefEnum) SetANonCompat(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.A = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetA(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.A = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetBNonCompat(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.B = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetB(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.B = value
    return x
}

func (x *MyStructWithForwardRefEnum) writeField1(p thrift.Encoder) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum write field begin error: ", err)
    }

    item := x.A
    if err := p.WriteI32(int32(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum write field end error: ", err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) writeField2(p thrift.Encoder) error {  // B
    if err := p.WriteFieldBegin("b", thrift.I32, 2); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum write field begin error: ", err)
    }

    item := x.B
    if err := p.WriteI32(int32(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum write field end error: ", err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) readField1(p thrift.Decoder) error {  // A
    enumResult, err := p.ReadI32()
    if err != nil {
        return err
    }
    result := MyForwardRefEnum(enumResult)

    x.A = result
    return nil
}

func (x *MyStructWithForwardRefEnum) readField2(p thrift.Decoder) error {  // B
    enumResult, err := p.ReadI32()
    if err != nil {
        return err
    }
    result := MyForwardRefEnum(enumResult)

    x.B = result
    return nil
}



func (x *MyStructWithForwardRefEnum) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("MyStructWithForwardRefEnum"); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum write struct end error: ", err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("MyStructWithForwardRefEnum field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "a")):  // a
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "b")):  // b
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("MyStructWithForwardRefEnum read struct end error: ", err)
    }

    return nil
}

func (x *MyStructWithForwardRefEnum) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *MyStructWithForwardRefEnum) setDefaults() *MyStructWithForwardRefEnum {
    return x.
        SetANonCompat(
              MyForwardRefEnum_NONZERO,
          ).
        SetBNonCompat(
              MyForwardRefEnum_NONZERO,
          )
}

type TrivialNumeric struct {
    A int32 `thrift:"a,1" json:"a" db:"a"`
    B bool `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*TrivialNumeric)(nil)

func NewTrivialNumeric() *TrivialNumeric {
    return (&TrivialNumeric{}).setDefaults()
}

func (x *TrivialNumeric) GetA() int32 {
    return x.A
}

func (x *TrivialNumeric) GetB() bool {
    return x.B
}

func (x *TrivialNumeric) SetANonCompat(value int32) *TrivialNumeric {
    x.A = value
    return x
}

func (x *TrivialNumeric) SetA(value int32) *TrivialNumeric {
    x.A = value
    return x
}

func (x *TrivialNumeric) SetBNonCompat(value bool) *TrivialNumeric {
    x.B = value
    return x
}

func (x *TrivialNumeric) SetB(value bool) *TrivialNumeric {
    x.B = value
    return x
}

func (x *TrivialNumeric) writeField1(p thrift.Encoder) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError("TrivialNumeric write field begin error: ", err)
    }

    item := x.A
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("TrivialNumeric write field end error: ", err)
    }
    return nil
}

func (x *TrivialNumeric) writeField2(p thrift.Encoder) error {  // B
    if err := p.WriteFieldBegin("b", thrift.BOOL, 2); err != nil {
        return thrift.PrependError("TrivialNumeric write field begin error: ", err)
    }

    item := x.B
    if err := p.WriteBool(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("TrivialNumeric write field end error: ", err)
    }
    return nil
}

func (x *TrivialNumeric) readField1(p thrift.Decoder) error {  // A
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.A = result
    return nil
}

func (x *TrivialNumeric) readField2(p thrift.Decoder) error {  // B
    result, err := p.ReadBool()
    if err != nil {
        return err
    }

    x.B = result
    return nil
}



func (x *TrivialNumeric) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("TrivialNumeric"); err != nil {
        return thrift.PrependError("TrivialNumeric write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("TrivialNumeric write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("TrivialNumeric write struct end error: ", err)
    }
    return nil
}

func (x *TrivialNumeric) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("TrivialNumeric read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("TrivialNumeric field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "a")):  // a
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.BOOL) || (id == thrift.NO_FIELD_ID && fieldName == "b")):  // b
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("TrivialNumeric read struct end error: ", err)
    }

    return nil
}

func (x *TrivialNumeric) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *TrivialNumeric) setDefaults() *TrivialNumeric {
    return x.
        SetANonCompat(0).
        SetBNonCompat(false)
}

type TrivialNestedWithDefault struct {
    Z int32 `thrift:"z,1" json:"z" db:"z"`
    N *TrivialNumeric `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*TrivialNestedWithDefault)(nil)

func NewTrivialNestedWithDefault() *TrivialNestedWithDefault {
    return (&TrivialNestedWithDefault{}).setDefaults()
}

func (x *TrivialNestedWithDefault) GetZ() int32 {
    return x.Z
}

func (x *TrivialNestedWithDefault) GetN() *TrivialNumeric {
    if !x.IsSetN() {
        return nil
    }
    return x.N
}

func (x *TrivialNestedWithDefault) SetZNonCompat(value int32) *TrivialNestedWithDefault {
    x.Z = value
    return x
}

func (x *TrivialNestedWithDefault) SetZ(value int32) *TrivialNestedWithDefault {
    x.Z = value
    return x
}

func (x *TrivialNestedWithDefault) SetNNonCompat(value *TrivialNumeric) *TrivialNestedWithDefault {
    x.N = value
    return x
}

func (x *TrivialNestedWithDefault) SetN(value *TrivialNumeric) *TrivialNestedWithDefault {
    x.N = value
    return x
}

func (x *TrivialNestedWithDefault) IsSetN() bool {
    return x != nil && x.N != nil
}

func (x *TrivialNestedWithDefault) writeField1(p thrift.Encoder) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.I32, 1); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault write field begin error: ", err)
    }

    item := x.Z
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault write field end error: ", err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) writeField2(p thrift.Encoder) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault write field begin error: ", err)
    }

    item := x.N
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault write field end error: ", err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) readField1(p thrift.Decoder) error {  // Z
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.Z = result
    return nil
}

func (x *TrivialNestedWithDefault) readField2(p thrift.Decoder) error {  // N
    result := NewTrivialNumeric()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.N = result
    return nil
}




func (x *TrivialNestedWithDefault) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("TrivialNestedWithDefault"); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault write struct end error: ", err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("TrivialNestedWithDefault field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "z")):  // z
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "n")):  // n
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("TrivialNestedWithDefault read struct end error: ", err)
    }

    return nil
}

func (x *TrivialNestedWithDefault) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *TrivialNestedWithDefault) setDefaults() *TrivialNestedWithDefault {
    return x.
        SetZNonCompat(int32(4)).
        SetNNonCompat(
              NewTrivialNumeric().
    SetANonCompat(int32(3)).
    SetBNonCompat(true),
          )
}

type ComplexString struct {
    A string `thrift:"a,1" json:"a" db:"a"`
    B map[string]int32 `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ComplexString)(nil)

func NewComplexString() *ComplexString {
    return (&ComplexString{}).setDefaults()
}

func (x *ComplexString) GetA() string {
    return x.A
}

func (x *ComplexString) GetB() map[string]int32 {
    if !x.IsSetB() {
        return make(map[string]int32)
    }
    return x.B
}

func (x *ComplexString) SetANonCompat(value string) *ComplexString {
    x.A = value
    return x
}

func (x *ComplexString) SetA(value string) *ComplexString {
    x.A = value
    return x
}

func (x *ComplexString) SetBNonCompat(value map[string]int32) *ComplexString {
    x.B = value
    return x
}

func (x *ComplexString) SetB(value map[string]int32) *ComplexString {
    x.B = value
    return x
}

func (x *ComplexString) IsSetB() bool {
    return x != nil && x.B != nil
}

func (x *ComplexString) writeField1(p thrift.Encoder) error {  // A
    if err := p.WriteFieldBegin("a", thrift.STRING, 1); err != nil {
        return thrift.PrependError("ComplexString write field begin error: ", err)
    }

    item := x.A
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexString write field end error: ", err)
    }
    return nil
}

func (x *ComplexString) writeField2(p thrift.Encoder) error {  // B
    if err := p.WriteFieldBegin("b", thrift.MAP, 2); err != nil {
        return thrift.PrependError("ComplexString write field begin error: ", err)
    }

    item := x.B
    if err := p.WriteMapBegin(thrift.STRING, thrift.I32, len(item)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range item {
        {
            item := k
            if err := p.WriteString(item); err != nil {
                return err
            }
        }
    
        {
            item := v
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexString write field end error: ", err)
    }
    return nil
}

func (x *ComplexString) readField1(p thrift.Decoder) error {  // A
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.A = result
    return nil
}

func (x *ComplexString) readField2(p thrift.Decoder) error {  // B
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
    if err != nil {
        return thrift.PrependError("error reading map begin: ", err)
    }
    
    mapResult := make(map[string]int32, size)
    for i := 0; i < size; i++ {
        var key string
        {
            result, err := p.ReadString()
            if err != nil {
                return err
            }
            key = result
        }
    
        var value int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            value = result
        }
    
        mapResult[key] = value
    }
    
    if err := p.ReadMapEnd(); err != nil {
        return thrift.PrependError("error reading map end: ", err)
    }
    result := mapResult

    x.B = result
    return nil
}



func (x *ComplexString) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ComplexString"); err != nil {
        return thrift.PrependError("ComplexString write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ComplexString write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ComplexString write struct end error: ", err)
    }
    return nil
}

func (x *ComplexString) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ComplexString read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ComplexString field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "a")):  // a
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "b")):  // b
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ComplexString read struct end error: ", err)
    }

    return nil
}

func (x *ComplexString) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ComplexString) setDefaults() *ComplexString {
    return x.
        SetANonCompat("").
        SetBNonCompat(make(map[string]int32))
}

type ComplexNestedWithDefault struct {
    Z string `thrift:"z,1" json:"z" db:"z"`
    N *ComplexString `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ComplexNestedWithDefault)(nil)

func NewComplexNestedWithDefault() *ComplexNestedWithDefault {
    return (&ComplexNestedWithDefault{}).setDefaults()
}

func (x *ComplexNestedWithDefault) GetZ() string {
    return x.Z
}

func (x *ComplexNestedWithDefault) GetN() *ComplexString {
    if !x.IsSetN() {
        return nil
    }
    return x.N
}

func (x *ComplexNestedWithDefault) SetZNonCompat(value string) *ComplexNestedWithDefault {
    x.Z = value
    return x
}

func (x *ComplexNestedWithDefault) SetZ(value string) *ComplexNestedWithDefault {
    x.Z = value
    return x
}

func (x *ComplexNestedWithDefault) SetNNonCompat(value *ComplexString) *ComplexNestedWithDefault {
    x.N = value
    return x
}

func (x *ComplexNestedWithDefault) SetN(value *ComplexString) *ComplexNestedWithDefault {
    x.N = value
    return x
}

func (x *ComplexNestedWithDefault) IsSetN() bool {
    return x != nil && x.N != nil
}

func (x *ComplexNestedWithDefault) writeField1(p thrift.Encoder) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.STRING, 1); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault write field begin error: ", err)
    }

    item := x.Z
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault write field end error: ", err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) writeField2(p thrift.Encoder) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault write field begin error: ", err)
    }

    item := x.N
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault write field end error: ", err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) readField1(p thrift.Decoder) error {  // Z
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.Z = result
    return nil
}

func (x *ComplexNestedWithDefault) readField2(p thrift.Decoder) error {  // N
    result := NewComplexString()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.N = result
    return nil
}




func (x *ComplexNestedWithDefault) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ComplexNestedWithDefault"); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault write struct end error: ", err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ComplexNestedWithDefault field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "z")):  // z
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "n")):  // n
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ComplexNestedWithDefault read struct end error: ", err)
    }

    return nil
}

func (x *ComplexNestedWithDefault) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ComplexNestedWithDefault) setDefaults() *ComplexNestedWithDefault {
    return x.
        SetZNonCompat("4").
        SetNNonCompat(
              NewComplexString().
    SetANonCompat("3").
    SetBNonCompat(
        map[string]int32{
    "a": int32(3),
},
    ),
          )
}

type MinPadding struct {
    Small int8 `thrift:"small,1,required" json:"small" db:"small"`
    Big int64 `thrift:"big,2,required" json:"big" db:"big"`
    Medium int16 `thrift:"medium,3,required" json:"medium" db:"medium"`
    Biggish int32 `thrift:"biggish,4,required" json:"biggish" db:"biggish"`
    Tiny int8 `thrift:"tiny,5,required" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MinPadding)(nil)

func NewMinPadding() *MinPadding {
    return (&MinPadding{}).setDefaults()
}

func (x *MinPadding) GetSmall() int8 {
    return x.Small
}

func (x *MinPadding) GetBig() int64 {
    return x.Big
}

func (x *MinPadding) GetMedium() int16 {
    return x.Medium
}

func (x *MinPadding) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPadding) GetTiny() int8 {
    return x.Tiny
}

func (x *MinPadding) SetSmallNonCompat(value int8) *MinPadding {
    x.Small = value
    return x
}

func (x *MinPadding) SetSmall(value int8) *MinPadding {
    x.Small = value
    return x
}

func (x *MinPadding) SetBigNonCompat(value int64) *MinPadding {
    x.Big = value
    return x
}

func (x *MinPadding) SetBig(value int64) *MinPadding {
    x.Big = value
    return x
}

func (x *MinPadding) SetMediumNonCompat(value int16) *MinPadding {
    x.Medium = value
    return x
}

func (x *MinPadding) SetMedium(value int16) *MinPadding {
    x.Medium = value
    return x
}

func (x *MinPadding) SetBiggishNonCompat(value int32) *MinPadding {
    x.Biggish = value
    return x
}

func (x *MinPadding) SetBiggish(value int32) *MinPadding {
    x.Biggish = value
    return x
}

func (x *MinPadding) SetTinyNonCompat(value int8) *MinPadding {
    x.Tiny = value
    return x
}

func (x *MinPadding) SetTiny(value int8) *MinPadding {
    x.Tiny = value
    return x
}

func (x *MinPadding) writeField1(p thrift.Encoder) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError("MinPadding write field begin error: ", err)
    }

    item := x.Small
    if err := p.WriteByte(byte(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPadding write field end error: ", err)
    }
    return nil
}

func (x *MinPadding) writeField2(p thrift.Encoder) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 2); err != nil {
        return thrift.PrependError("MinPadding write field begin error: ", err)
    }

    item := x.Big
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPadding write field end error: ", err)
    }
    return nil
}

func (x *MinPadding) writeField3(p thrift.Encoder) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError("MinPadding write field begin error: ", err)
    }

    item := x.Medium
    if err := p.WriteI16(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPadding write field end error: ", err)
    }
    return nil
}

func (x *MinPadding) writeField4(p thrift.Encoder) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 4); err != nil {
        return thrift.PrependError("MinPadding write field begin error: ", err)
    }

    item := x.Biggish
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPadding write field end error: ", err)
    }
    return nil
}

func (x *MinPadding) writeField5(p thrift.Encoder) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError("MinPadding write field begin error: ", err)
    }

    item := x.Tiny
    if err := p.WriteByte(byte(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPadding write field end error: ", err)
    }
    return nil
}

func (x *MinPadding) readField1(p thrift.Decoder) error {  // Small
    resultByte, err := p.ReadByte()
    result := int8(resultByte)
    if err != nil {
        return err
    }

    x.Small = result
    return nil
}

func (x *MinPadding) readField2(p thrift.Decoder) error {  // Big
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.Big = result
    return nil
}

func (x *MinPadding) readField3(p thrift.Decoder) error {  // Medium
    result, err := p.ReadI16()
    if err != nil {
        return err
    }

    x.Medium = result
    return nil
}

func (x *MinPadding) readField4(p thrift.Decoder) error {  // Biggish
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.Biggish = result
    return nil
}

func (x *MinPadding) readField5(p thrift.Decoder) error {  // Tiny
    resultByte, err := p.ReadByte()
    result := int8(resultByte)
    if err != nil {
        return err
    }

    x.Tiny = result
    return nil
}



func (x *MinPadding) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("MinPadding"); err != nil {
        return thrift.PrependError("MinPadding write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }
    if err := x.writeField4(p); err != nil {
        return err
    }
    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("MinPadding write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("MinPadding write struct end error: ", err)
    }
    return nil
}

func (x *MinPadding) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("MinPadding read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("MinPadding field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.BYTE) || (id == thrift.NO_FIELD_ID && fieldName == "small")):  // small
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "big")):  // big
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.I16) || (id == thrift.NO_FIELD_ID && fieldName == "medium")):  // medium
            fieldReadErr = x.readField3(p)
        case ((id == 4 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "biggish")):  // biggish
            fieldReadErr = x.readField4(p)
        case ((id == 5 && wireType == thrift.BYTE) || (id == thrift.NO_FIELD_ID && fieldName == "tiny")):  // tiny
            fieldReadErr = x.readField5(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("MinPadding read struct end error: ", err)
    }

    return nil
}

func (x *MinPadding) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *MinPadding) setDefaults() *MinPadding {
    return x.
        SetSmallNonCompat(0).
        SetBigNonCompat(0).
        SetMediumNonCompat(0).
        SetBiggishNonCompat(0).
        SetTinyNonCompat(0)
}

type MinPaddingWithCustomType struct {
    Small int8 `thrift:"small,1" json:"small" db:"small"`
    Biggish int32 `thrift:"biggish,2" json:"biggish" db:"biggish"`
    Medium int16 `thrift:"medium,3" json:"medium" db:"medium"`
    Big int64 `thrift:"big,4" json:"big" db:"big"`
    Tiny int8 `thrift:"tiny,5" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MinPaddingWithCustomType)(nil)

func NewMinPaddingWithCustomType() *MinPaddingWithCustomType {
    return (&MinPaddingWithCustomType{}).setDefaults()
}

func (x *MinPaddingWithCustomType) GetSmall() int8 {
    return x.Small
}

func (x *MinPaddingWithCustomType) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPaddingWithCustomType) GetMedium() int16 {
    return x.Medium
}

func (x *MinPaddingWithCustomType) GetBig() int64 {
    return x.Big
}

func (x *MinPaddingWithCustomType) GetTiny() int8 {
    return x.Tiny
}

func (x *MinPaddingWithCustomType) SetSmallNonCompat(value int8) *MinPaddingWithCustomType {
    x.Small = value
    return x
}

func (x *MinPaddingWithCustomType) SetSmall(value int8) *MinPaddingWithCustomType {
    x.Small = value
    return x
}

func (x *MinPaddingWithCustomType) SetBiggishNonCompat(value int32) *MinPaddingWithCustomType {
    x.Biggish = value
    return x
}

func (x *MinPaddingWithCustomType) SetBiggish(value int32) *MinPaddingWithCustomType {
    x.Biggish = value
    return x
}

func (x *MinPaddingWithCustomType) SetMediumNonCompat(value int16) *MinPaddingWithCustomType {
    x.Medium = value
    return x
}

func (x *MinPaddingWithCustomType) SetMedium(value int16) *MinPaddingWithCustomType {
    x.Medium = value
    return x
}

func (x *MinPaddingWithCustomType) SetBigNonCompat(value int64) *MinPaddingWithCustomType {
    x.Big = value
    return x
}

func (x *MinPaddingWithCustomType) SetBig(value int64) *MinPaddingWithCustomType {
    x.Big = value
    return x
}

func (x *MinPaddingWithCustomType) SetTinyNonCompat(value int8) *MinPaddingWithCustomType {
    x.Tiny = value
    return x
}

func (x *MinPaddingWithCustomType) SetTiny(value int8) *MinPaddingWithCustomType {
    x.Tiny = value
    return x
}

func (x *MinPaddingWithCustomType) writeField1(p thrift.Encoder) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field begin error: ", err)
    }

    item := x.Small
    if err := p.WriteByte(byte(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field end error: ", err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField2(p thrift.Encoder) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 2); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field begin error: ", err)
    }

    item := x.Biggish
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field end error: ", err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField3(p thrift.Encoder) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field begin error: ", err)
    }

    item := x.Medium
    if err := p.WriteI16(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field end error: ", err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField4(p thrift.Encoder) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 4); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field begin error: ", err)
    }

    item := x.Big
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field end error: ", err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField5(p thrift.Encoder) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field begin error: ", err)
    }

    item := x.Tiny
    if err := p.WriteByte(byte(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field end error: ", err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) readField1(p thrift.Decoder) error {  // Small
    resultByte, err := p.ReadByte()
    result := int8(resultByte)
    if err != nil {
        return err
    }

    x.Small = result
    return nil
}

func (x *MinPaddingWithCustomType) readField2(p thrift.Decoder) error {  // Biggish
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.Biggish = result
    return nil
}

func (x *MinPaddingWithCustomType) readField3(p thrift.Decoder) error {  // Medium
    result, err := p.ReadI16()
    if err != nil {
        return err
    }

    x.Medium = result
    return nil
}

func (x *MinPaddingWithCustomType) readField4(p thrift.Decoder) error {  // Big
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.Big = result
    return nil
}

func (x *MinPaddingWithCustomType) readField5(p thrift.Decoder) error {  // Tiny
    resultByte, err := p.ReadByte()
    result := int8(resultByte)
    if err != nil {
        return err
    }

    x.Tiny = result
    return nil
}



func (x *MinPaddingWithCustomType) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("MinPaddingWithCustomType"); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }
    if err := x.writeField4(p); err != nil {
        return err
    }
    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType write struct end error: ", err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("MinPaddingWithCustomType field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.BYTE) || (id == thrift.NO_FIELD_ID && fieldName == "small")):  // small
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "biggish")):  // biggish
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.I16) || (id == thrift.NO_FIELD_ID && fieldName == "medium")):  // medium
            fieldReadErr = x.readField3(p)
        case ((id == 4 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "big")):  // big
            fieldReadErr = x.readField4(p)
        case ((id == 5 && wireType == thrift.BYTE) || (id == thrift.NO_FIELD_ID && fieldName == "tiny")):  // tiny
            fieldReadErr = x.readField5(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("MinPaddingWithCustomType read struct end error: ", err)
    }

    return nil
}

func (x *MinPaddingWithCustomType) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *MinPaddingWithCustomType) setDefaults() *MinPaddingWithCustomType {
    return x.
        SetSmallNonCompat(0).
        SetBiggishNonCompat(0).
        SetMediumNonCompat(0).
        SetBigNonCompat(0).
        SetTinyNonCompat(0)
}

type MyStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
    MyStringField string `thrift:"MyStringField,2" json:"MyStringField" db:"MyStringField"`
    MajorVer int64 `thrift:"majorVer,3" json:"majorVer" db:"majorVer"`
    Data *MyDataItem `thrift:"data,4" json:"data" db:"data"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MyStruct)(nil)

func NewMyStruct() *MyStruct {
    return (&MyStruct{}).setDefaults()
}

func (x *MyStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyStringField() string {
    return x.MyStringField
}

func (x *MyStruct) GetMajorVer() int64 {
    return x.MajorVer
}

func (x *MyStruct) GetData() *MyDataItem {
    if !x.IsSetData() {
        return nil
    }
    return x.Data
}

func (x *MyStruct) SetMyIntFieldNonCompat(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyIntField(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyStringFieldNonCompat(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMyStringField(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMajorVerNonCompat(value int64) *MyStruct {
    x.MajorVer = value
    return x
}

func (x *MyStruct) SetMajorVer(value int64) *MyStruct {
    x.MajorVer = value
    return x
}

func (x *MyStruct) SetDataNonCompat(value *MyDataItem) *MyStruct {
    x.Data = value
    return x
}

func (x *MyStruct) SetData(value *MyDataItem) *MyStruct {
    x.Data = value
    return x
}

func (x *MyStruct) IsSetData() bool {
    return x != nil && x.Data != nil
}

func (x *MyStruct) writeField1(p thrift.Encoder) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError("MyStruct write field begin error: ", err)
    }

    item := x.MyIntField
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MyStruct write field end error: ", err)
    }
    return nil
}

func (x *MyStruct) writeField2(p thrift.Encoder) error {  // MyStringField
    if err := p.WriteFieldBegin("MyStringField", thrift.STRING, 2); err != nil {
        return thrift.PrependError("MyStruct write field begin error: ", err)
    }

    item := x.MyStringField
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MyStruct write field end error: ", err)
    }
    return nil
}

func (x *MyStruct) writeField3(p thrift.Encoder) error {  // MajorVer
    if err := p.WriteFieldBegin("majorVer", thrift.I64, 3); err != nil {
        return thrift.PrependError("MyStruct write field begin error: ", err)
    }

    item := x.MajorVer
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MyStruct write field end error: ", err)
    }
    return nil
}

func (x *MyStruct) writeField4(p thrift.Encoder) error {  // Data
    if !x.IsSetData() {
        return nil
    }

    if err := p.WriteFieldBegin("data", thrift.STRUCT, 4); err != nil {
        return thrift.PrependError("MyStruct write field begin error: ", err)
    }

    item := x.Data
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("MyStruct write field end error: ", err)
    }
    return nil
}

func (x *MyStruct) readField1(p thrift.Decoder) error {  // MyIntField
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.MyIntField = result
    return nil
}

func (x *MyStruct) readField2(p thrift.Decoder) error {  // MyStringField
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.MyStringField = result
    return nil
}

func (x *MyStruct) readField3(p thrift.Decoder) error {  // MajorVer
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.MajorVer = result
    return nil
}

func (x *MyStruct) readField4(p thrift.Decoder) error {  // Data
    result := NewMyDataItem()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.Data = result
    return nil
}




func (x *MyStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("MyStruct"); err != nil {
        return thrift.PrependError("MyStruct write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }
    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("MyStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("MyStruct write struct end error: ", err)
    }
    return nil
}

func (x *MyStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("MyStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("MyStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "MyIntField")):  // MyIntField
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "MyStringField")):  // MyStringField
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "majorVer")):  // majorVer
            fieldReadErr = x.readField3(p)
        case ((id == 4 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "data")):  // data
            fieldReadErr = x.readField4(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("MyStruct read struct end error: ", err)
    }

    return nil
}

func (x *MyStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *MyStruct) setDefaults() *MyStruct {
    return x.
        SetMyIntFieldNonCompat(0).
        SetMyStringFieldNonCompat("").
        SetMajorVerNonCompat(0).
        SetDataNonCompat(NewMyDataItem())
}

type MyDataItem struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*MyDataItem)(nil)

func NewMyDataItem() *MyDataItem {
    return (&MyDataItem{}).setDefaults()
}



func (x *MyDataItem) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("MyDataItem"); err != nil {
        return thrift.PrependError("MyDataItem write struct begin error: ", err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("MyDataItem write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("MyDataItem write struct end error: ", err)
    }
    return nil
}

func (x *MyDataItem) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("MyDataItem read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("MyDataItem field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("MyDataItem read struct end error: ", err)
    }

    return nil
}

func (x *MyDataItem) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *MyDataItem) setDefaults() *MyDataItem {
    return x
}

type Renaming struct {
    Foo int64 `thrift:"foo,1" json:"foo" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Renaming)(nil)

func NewRenaming() *Renaming {
    return (&Renaming{}).setDefaults()
}

func (x *Renaming) GetFoo() int64 {
    return x.Foo
}

func (x *Renaming) SetFooNonCompat(value int64) *Renaming {
    x.Foo = value
    return x
}

func (x *Renaming) SetFoo(value int64) *Renaming {
    x.Foo = value
    return x
}

func (x *Renaming) writeField1(p thrift.Encoder) error {  // Foo
    if err := p.WriteFieldBegin("foo", thrift.I64, 1); err != nil {
        return thrift.PrependError("Renaming write field begin error: ", err)
    }

    item := x.Foo
    if err := p.WriteI64(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("Renaming write field end error: ", err)
    }
    return nil
}

func (x *Renaming) readField1(p thrift.Decoder) error {  // Foo
    result, err := p.ReadI64()
    if err != nil {
        return err
    }

    x.Foo = result
    return nil
}



func (x *Renaming) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Renaming"); err != nil {
        return thrift.PrependError("Renaming write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("Renaming write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("Renaming write struct end error: ", err)
    }
    return nil
}

func (x *Renaming) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("Renaming read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("Renaming field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I64) || (id == thrift.NO_FIELD_ID && fieldName == "foo")):  // foo
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("Renaming read struct end error: ", err)
    }

    return nil
}

func (x *Renaming) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Renaming) setDefaults() *Renaming {
    return x.
        SetFooNonCompat(0)
}

type AnnotatedTypes struct {
    BinaryField TBinary_8623 `thrift:"binary_field,1" json:"binary_field" db:"binary_field"`
    ListField SomeListOfTypeMap_2468 `thrift:"list_field,2" json:"list_field" db:"list_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AnnotatedTypes)(nil)

func NewAnnotatedTypes() *AnnotatedTypes {
    return (&AnnotatedTypes{}).setDefaults()
}

func (x *AnnotatedTypes) GetBinaryField() TBinary_8623 {
    if !x.IsSetBinaryField() {
        return NewTBinary_8623()
    }
    return x.BinaryField
}

func (x *AnnotatedTypes) GetListField() SomeListOfTypeMap_2468 {
    if !x.IsSetListField() {
        return NewSomeListOfTypeMap_2468()
    }
    return x.ListField
}

func (x *AnnotatedTypes) SetBinaryFieldNonCompat(value TBinary_8623) *AnnotatedTypes {
    x.BinaryField = value
    return x
}

func (x *AnnotatedTypes) SetBinaryField(value TBinary_8623) *AnnotatedTypes {
    x.BinaryField = value
    return x
}

func (x *AnnotatedTypes) SetListFieldNonCompat(value SomeListOfTypeMap_2468) *AnnotatedTypes {
    x.ListField = value
    return x
}

func (x *AnnotatedTypes) SetListField(value SomeListOfTypeMap_2468) *AnnotatedTypes {
    x.ListField = value
    return x
}

func (x *AnnotatedTypes) IsSetBinaryField() bool {
    return x != nil && x.BinaryField != nil
}

func (x *AnnotatedTypes) IsSetListField() bool {
    return x != nil && x.ListField != nil
}

func (x *AnnotatedTypes) writeField1(p thrift.Encoder) error {  // BinaryField
    if err := p.WriteFieldBegin("binary_field", thrift.STRING, 1); err != nil {
        return thrift.PrependError("AnnotatedTypes write field begin error: ", err)
    }

    item := x.BinaryField
    err := WriteTBinary_8623(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AnnotatedTypes write field end error: ", err)
    }
    return nil
}

func (x *AnnotatedTypes) writeField2(p thrift.Encoder) error {  // ListField
    if err := p.WriteFieldBegin("list_field", thrift.LIST, 2); err != nil {
        return thrift.PrependError("AnnotatedTypes write field begin error: ", err)
    }

    item := x.ListField
    err := WriteSomeListOfTypeMap_2468(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AnnotatedTypes write field end error: ", err)
    }
    return nil
}

func (x *AnnotatedTypes) readField1(p thrift.Decoder) error {  // BinaryField
    result, err := ReadTBinary_8623(p)
    if err != nil {
        return err
    }

    x.BinaryField = result
    return nil
}

func (x *AnnotatedTypes) readField2(p thrift.Decoder) error {  // ListField
    result, err := ReadSomeListOfTypeMap_2468(p)
    if err != nil {
        return err
    }

    x.ListField = result
    return nil
}



func (x *AnnotatedTypes) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("AnnotatedTypes"); err != nil {
        return thrift.PrependError("AnnotatedTypes write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("AnnotatedTypes write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("AnnotatedTypes write struct end error: ", err)
    }
    return nil
}

func (x *AnnotatedTypes) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("AnnotatedTypes read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("AnnotatedTypes field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "binary_field")):  // binary_field
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "list_field")):  // list_field
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("AnnotatedTypes read struct end error: ", err)
    }

    return nil
}

func (x *AnnotatedTypes) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *AnnotatedTypes) setDefaults() *AnnotatedTypes {
    return x.
        SetBinaryFieldNonCompat(NewTBinary_8623()).
        SetListFieldNonCompat(NewSomeListOfTypeMap_2468())
}

type ForwardUsageRoot struct {
    ForwardUsageStruct *ForwardUsageStruct `thrift:"ForwardUsageStruct,1,optional" json:"ForwardUsageStruct,omitempty" db:"ForwardUsageStruct"`
    ForwardUsageByRef *ForwardUsageByRef `thrift:"ForwardUsageByRef,2,optional" json:"ForwardUsageByRef,omitempty" db:"ForwardUsageByRef"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ForwardUsageRoot)(nil)

func NewForwardUsageRoot() *ForwardUsageRoot {
    return (&ForwardUsageRoot{}).setDefaults()
}

func (x *ForwardUsageRoot) GetForwardUsageStruct() *ForwardUsageStruct {
    if !x.IsSetForwardUsageStruct() {
        return nil
    }
    return x.ForwardUsageStruct
}

func (x *ForwardUsageRoot) GetForwardUsageByRef() *ForwardUsageByRef {
    if !x.IsSetForwardUsageByRef() {
        return nil
    }
    return x.ForwardUsageByRef
}

func (x *ForwardUsageRoot) SetForwardUsageStructNonCompat(value *ForwardUsageStruct) *ForwardUsageRoot {
    x.ForwardUsageStruct = value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageStruct(value *ForwardUsageStruct) *ForwardUsageRoot {
    x.ForwardUsageStruct = value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageByRefNonCompat(value *ForwardUsageByRef) *ForwardUsageRoot {
    x.ForwardUsageByRef = value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageByRef(value *ForwardUsageByRef) *ForwardUsageRoot {
    x.ForwardUsageByRef = value
    return x
}

func (x *ForwardUsageRoot) IsSetForwardUsageStruct() bool {
    return x != nil && x.ForwardUsageStruct != nil
}

func (x *ForwardUsageRoot) IsSetForwardUsageByRef() bool {
    return x != nil && x.ForwardUsageByRef != nil
}

func (x *ForwardUsageRoot) writeField1(p thrift.Encoder) error {  // ForwardUsageStruct
    if !x.IsSetForwardUsageStruct() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageStruct", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError("ForwardUsageRoot write field begin error: ", err)
    }

    item := x.ForwardUsageStruct
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ForwardUsageRoot write field end error: ", err)
    }
    return nil
}

func (x *ForwardUsageRoot) writeField2(p thrift.Encoder) error {  // ForwardUsageByRef
    if !x.IsSetForwardUsageByRef() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageByRef", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError("ForwardUsageRoot write field begin error: ", err)
    }

    item := x.ForwardUsageByRef
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ForwardUsageRoot write field end error: ", err)
    }
    return nil
}

func (x *ForwardUsageRoot) readField1(p thrift.Decoder) error {  // ForwardUsageStruct
    result := NewForwardUsageStruct()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.ForwardUsageStruct = result
    return nil
}

func (x *ForwardUsageRoot) readField2(p thrift.Decoder) error {  // ForwardUsageByRef
    result := NewForwardUsageByRef()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.ForwardUsageByRef = result
    return nil
}





func (x *ForwardUsageRoot) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ForwardUsageRoot"); err != nil {
        return thrift.PrependError("ForwardUsageRoot write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ForwardUsageRoot write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ForwardUsageRoot write struct end error: ", err)
    }
    return nil
}

func (x *ForwardUsageRoot) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ForwardUsageRoot read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ForwardUsageRoot field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "ForwardUsageStruct")):  // ForwardUsageStruct
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "ForwardUsageByRef")):  // ForwardUsageByRef
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ForwardUsageRoot read struct end error: ", err)
    }

    return nil
}

func (x *ForwardUsageRoot) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ForwardUsageRoot) setDefaults() *ForwardUsageRoot {
    return x
}

type ForwardUsageStruct struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ForwardUsageStruct)(nil)

func NewForwardUsageStruct() *ForwardUsageStruct {
    return (&ForwardUsageStruct{}).setDefaults()
}

func (x *ForwardUsageStruct) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return nil
    }
    return x.Foo
}

func (x *ForwardUsageStruct) SetFooNonCompat(value *ForwardUsageRoot) *ForwardUsageStruct {
    x.Foo = value
    return x
}

func (x *ForwardUsageStruct) SetFoo(value *ForwardUsageRoot) *ForwardUsageStruct {
    x.Foo = value
    return x
}

func (x *ForwardUsageStruct) IsSetFoo() bool {
    return x != nil && x.Foo != nil
}

func (x *ForwardUsageStruct) writeField1(p thrift.Encoder) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError("ForwardUsageStruct write field begin error: ", err)
    }

    item := x.Foo
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ForwardUsageStruct write field end error: ", err)
    }
    return nil
}

func (x *ForwardUsageStruct) readField1(p thrift.Decoder) error {  // Foo
    result := NewForwardUsageRoot()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.Foo = result
    return nil
}




func (x *ForwardUsageStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ForwardUsageStruct"); err != nil {
        return thrift.PrependError("ForwardUsageStruct write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ForwardUsageStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ForwardUsageStruct write struct end error: ", err)
    }
    return nil
}

func (x *ForwardUsageStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ForwardUsageStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ForwardUsageStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "foo")):  // foo
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ForwardUsageStruct read struct end error: ", err)
    }

    return nil
}

func (x *ForwardUsageStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ForwardUsageStruct) setDefaults() *ForwardUsageStruct {
    return x
}

type ForwardUsageByRef struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ForwardUsageByRef)(nil)

func NewForwardUsageByRef() *ForwardUsageByRef {
    return (&ForwardUsageByRef{}).setDefaults()
}

func (x *ForwardUsageByRef) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return nil
    }
    return x.Foo
}

func (x *ForwardUsageByRef) SetFooNonCompat(value *ForwardUsageRoot) *ForwardUsageByRef {
    x.Foo = value
    return x
}

func (x *ForwardUsageByRef) SetFoo(value *ForwardUsageRoot) *ForwardUsageByRef {
    x.Foo = value
    return x
}

func (x *ForwardUsageByRef) IsSetFoo() bool {
    return x != nil && x.Foo != nil
}

func (x *ForwardUsageByRef) writeField1(p thrift.Encoder) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError("ForwardUsageByRef write field begin error: ", err)
    }

    item := x.Foo
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("ForwardUsageByRef write field end error: ", err)
    }
    return nil
}

func (x *ForwardUsageByRef) readField1(p thrift.Decoder) error {  // Foo
    result := NewForwardUsageRoot()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.Foo = result
    return nil
}




func (x *ForwardUsageByRef) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ForwardUsageByRef"); err != nil {
        return thrift.PrependError("ForwardUsageByRef write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("ForwardUsageByRef write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("ForwardUsageByRef write struct end error: ", err)
    }
    return nil
}

func (x *ForwardUsageByRef) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("ForwardUsageByRef read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("ForwardUsageByRef field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "foo")):  // foo
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("ForwardUsageByRef read struct end error: ", err)
    }

    return nil
}

func (x *ForwardUsageByRef) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ForwardUsageByRef) setDefaults() *ForwardUsageByRef {
    return x
}

type IncompleteMap struct {
    Field map[int32]*IncompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteMap)(nil)

func NewIncompleteMap() *IncompleteMap {
    return (&IncompleteMap{}).setDefaults()
}

func (x *IncompleteMap) GetField() map[int32]*IncompleteMapDep {
    if !x.IsSetField() {
        return make(map[int32]*IncompleteMapDep)
    }
    return x.Field
}

func (x *IncompleteMap) SetFieldNonCompat(value map[int32]*IncompleteMapDep) *IncompleteMap {
    x.Field = value
    return x
}

func (x *IncompleteMap) SetField(value map[int32]*IncompleteMapDep) *IncompleteMap {
    x.Field = value
    return x
}

func (x *IncompleteMap) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *IncompleteMap) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError("IncompleteMap write field begin error: ", err)
    }

    item := x.Field
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range item {
        {
            item := k
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    
        {
            item := v
            if err := item.Write(p); err != nil {
                return err
            }
        }
    }
    if err := p.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("IncompleteMap write field end error: ", err)
    }
    return nil
}

func (x *IncompleteMap) readField1(p thrift.Decoder) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
    if err != nil {
        return thrift.PrependError("error reading map begin: ", err)
    }
    
    mapResult := make(map[int32]*IncompleteMapDep, size)
    for i := 0; i < size; i++ {
        var key int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            key = result
        }
    
        var value *IncompleteMapDep
        {
            result := NewIncompleteMapDep()
            err := result.Read(p)
            if err != nil {
                return err
            }
            value = result
        }
    
        mapResult[key] = value
    }
    
    if err := p.ReadMapEnd(); err != nil {
        return thrift.PrependError("error reading map end: ", err)
    }
    result := mapResult

    x.Field = result
    return nil
}



func (x *IncompleteMap) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("IncompleteMap"); err != nil {
        return thrift.PrependError("IncompleteMap write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("IncompleteMap write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("IncompleteMap write struct end error: ", err)
    }
    return nil
}

func (x *IncompleteMap) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("IncompleteMap read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("IncompleteMap field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("IncompleteMap read struct end error: ", err)
    }

    return nil
}

func (x *IncompleteMap) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *IncompleteMap) setDefaults() *IncompleteMap {
    return x
}

type IncompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteMapDep)(nil)

func NewIncompleteMapDep() *IncompleteMapDep {
    return (&IncompleteMapDep{}).setDefaults()
}



func (x *IncompleteMapDep) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("IncompleteMapDep"); err != nil {
        return thrift.PrependError("IncompleteMapDep write struct begin error: ", err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("IncompleteMapDep write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("IncompleteMapDep write struct end error: ", err)
    }
    return nil
}

func (x *IncompleteMapDep) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("IncompleteMapDep read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("IncompleteMapDep field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("IncompleteMapDep read struct end error: ", err)
    }

    return nil
}

func (x *IncompleteMapDep) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *IncompleteMapDep) setDefaults() *IncompleteMapDep {
    return x
}

type CompleteMap struct {
    Field map[int32]*CompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteMap)(nil)

func NewCompleteMap() *CompleteMap {
    return (&CompleteMap{}).setDefaults()
}

func (x *CompleteMap) GetField() map[int32]*CompleteMapDep {
    if !x.IsSetField() {
        return make(map[int32]*CompleteMapDep)
    }
    return x.Field
}

func (x *CompleteMap) SetFieldNonCompat(value map[int32]*CompleteMapDep) *CompleteMap {
    x.Field = value
    return x
}

func (x *CompleteMap) SetField(value map[int32]*CompleteMapDep) *CompleteMap {
    x.Field = value
    return x
}

func (x *CompleteMap) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *CompleteMap) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError("CompleteMap write field begin error: ", err)
    }

    item := x.Field
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range item {
        {
            item := k
            if err := p.WriteI32(item); err != nil {
                return err
            }
        }
    
        {
            item := v
            if err := item.Write(p); err != nil {
                return err
            }
        }
    }
    if err := p.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("CompleteMap write field end error: ", err)
    }
    return nil
}

func (x *CompleteMap) readField1(p thrift.Decoder) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
    if err != nil {
        return thrift.PrependError("error reading map begin: ", err)
    }
    
    mapResult := make(map[int32]*CompleteMapDep, size)
    for i := 0; i < size; i++ {
        var key int32
        {
            result, err := p.ReadI32()
            if err != nil {
                return err
            }
            key = result
        }
    
        var value *CompleteMapDep
        {
            result := NewCompleteMapDep()
            err := result.Read(p)
            if err != nil {
                return err
            }
            value = result
        }
    
        mapResult[key] = value
    }
    
    if err := p.ReadMapEnd(); err != nil {
        return thrift.PrependError("error reading map end: ", err)
    }
    result := mapResult

    x.Field = result
    return nil
}



func (x *CompleteMap) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("CompleteMap"); err != nil {
        return thrift.PrependError("CompleteMap write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("CompleteMap write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("CompleteMap write struct end error: ", err)
    }
    return nil
}

func (x *CompleteMap) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("CompleteMap read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("CompleteMap field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("CompleteMap read struct end error: ", err)
    }

    return nil
}

func (x *CompleteMap) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *CompleteMap) setDefaults() *CompleteMap {
    return x
}

type CompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteMapDep)(nil)

func NewCompleteMapDep() *CompleteMapDep {
    return (&CompleteMapDep{}).setDefaults()
}



func (x *CompleteMapDep) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("CompleteMapDep"); err != nil {
        return thrift.PrependError("CompleteMapDep write struct begin error: ", err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("CompleteMapDep write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("CompleteMapDep write struct end error: ", err)
    }
    return nil
}

func (x *CompleteMapDep) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("CompleteMapDep read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("CompleteMapDep field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("CompleteMapDep read struct end error: ", err)
    }

    return nil
}

func (x *CompleteMapDep) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *CompleteMapDep) setDefaults() *CompleteMapDep {
    return x
}

type IncompleteList struct {
    Field []*IncompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteList)(nil)

func NewIncompleteList() *IncompleteList {
    return (&IncompleteList{}).setDefaults()
}

func (x *IncompleteList) GetField() []*IncompleteListDep {
    if !x.IsSetField() {
        return make([]*IncompleteListDep, 0)
    }
    return x.Field
}

func (x *IncompleteList) SetFieldNonCompat(value []*IncompleteListDep) *IncompleteList {
    x.Field = value
    return x
}

func (x *IncompleteList) SetField(value []*IncompleteListDep) *IncompleteList {
    x.Field = value
    return x
}

func (x *IncompleteList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *IncompleteList) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError("IncompleteList write field begin error: ", err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := item.Write(p); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("IncompleteList write field end error: ", err)
    }
    return nil
}

func (x *IncompleteList) readField1(p thrift.Decoder) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]*IncompleteListDep, 0, size)
    for i := 0; i < size; i++ {
        var elem *IncompleteListDep
        {
            result := NewIncompleteListDep()
            err := result.Read(p)
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.Field = result
    return nil
}



func (x *IncompleteList) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("IncompleteList"); err != nil {
        return thrift.PrependError("IncompleteList write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("IncompleteList write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("IncompleteList write struct end error: ", err)
    }
    return nil
}

func (x *IncompleteList) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("IncompleteList read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("IncompleteList field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("IncompleteList read struct end error: ", err)
    }

    return nil
}

func (x *IncompleteList) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *IncompleteList) setDefaults() *IncompleteList {
    return x
}

type IncompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteListDep)(nil)

func NewIncompleteListDep() *IncompleteListDep {
    return (&IncompleteListDep{}).setDefaults()
}



func (x *IncompleteListDep) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("IncompleteListDep"); err != nil {
        return thrift.PrependError("IncompleteListDep write struct begin error: ", err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("IncompleteListDep write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("IncompleteListDep write struct end error: ", err)
    }
    return nil
}

func (x *IncompleteListDep) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("IncompleteListDep read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("IncompleteListDep field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("IncompleteListDep read struct end error: ", err)
    }

    return nil
}

func (x *IncompleteListDep) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *IncompleteListDep) setDefaults() *IncompleteListDep {
    return x
}

type CompleteList struct {
    Field []*CompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteList)(nil)

func NewCompleteList() *CompleteList {
    return (&CompleteList{}).setDefaults()
}

func (x *CompleteList) GetField() []*CompleteListDep {
    if !x.IsSetField() {
        return make([]*CompleteListDep, 0)
    }
    return x.Field
}

func (x *CompleteList) SetFieldNonCompat(value []*CompleteListDep) *CompleteList {
    x.Field = value
    return x
}

func (x *CompleteList) SetField(value []*CompleteListDep) *CompleteList {
    x.Field = value
    return x
}

func (x *CompleteList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *CompleteList) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError("CompleteList write field begin error: ", err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := item.Write(p); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("CompleteList write field end error: ", err)
    }
    return nil
}

func (x *CompleteList) readField1(p thrift.Decoder) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]*CompleteListDep, 0, size)
    for i := 0; i < size; i++ {
        var elem *CompleteListDep
        {
            result := NewCompleteListDep()
            err := result.Read(p)
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.Field = result
    return nil
}



func (x *CompleteList) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("CompleteList"); err != nil {
        return thrift.PrependError("CompleteList write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("CompleteList write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("CompleteList write struct end error: ", err)
    }
    return nil
}

func (x *CompleteList) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("CompleteList read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("CompleteList field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("CompleteList read struct end error: ", err)
    }

    return nil
}

func (x *CompleteList) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *CompleteList) setDefaults() *CompleteList {
    return x
}

type CompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteListDep)(nil)

func NewCompleteListDep() *CompleteListDep {
    return (&CompleteListDep{}).setDefaults()
}



func (x *CompleteListDep) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("CompleteListDep"); err != nil {
        return thrift.PrependError("CompleteListDep write struct begin error: ", err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("CompleteListDep write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("CompleteListDep write struct end error: ", err)
    }
    return nil
}

func (x *CompleteListDep) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("CompleteListDep read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("CompleteListDep field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("CompleteListDep read struct end error: ", err)
    }

    return nil
}

func (x *CompleteListDep) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *CompleteListDep) setDefaults() *CompleteListDep {
    return x
}

type AdaptedList struct {
    Field []*AdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AdaptedList)(nil)

func NewAdaptedList() *AdaptedList {
    return (&AdaptedList{}).setDefaults()
}

func (x *AdaptedList) GetField() []*AdaptedListDep {
    if !x.IsSetField() {
        return make([]*AdaptedListDep, 0)
    }
    return x.Field
}

func (x *AdaptedList) SetFieldNonCompat(value []*AdaptedListDep) *AdaptedList {
    x.Field = value
    return x
}

func (x *AdaptedList) SetField(value []*AdaptedListDep) *AdaptedList {
    x.Field = value
    return x
}

func (x *AdaptedList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *AdaptedList) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError("AdaptedList write field begin error: ", err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := item.Write(p); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AdaptedList write field end error: ", err)
    }
    return nil
}

func (x *AdaptedList) readField1(p thrift.Decoder) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]*AdaptedListDep, 0, size)
    for i := 0; i < size; i++ {
        var elem *AdaptedListDep
        {
            result := NewAdaptedListDep()
            err := result.Read(p)
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.Field = result
    return nil
}



func (x *AdaptedList) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("AdaptedList"); err != nil {
        return thrift.PrependError("AdaptedList write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("AdaptedList write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("AdaptedList write struct end error: ", err)
    }
    return nil
}

func (x *AdaptedList) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("AdaptedList read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("AdaptedList field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("AdaptedList read struct end error: ", err)
    }

    return nil
}

func (x *AdaptedList) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *AdaptedList) setDefaults() *AdaptedList {
    return x
}

type AdaptedListDep struct {
    Field *AdaptedList `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AdaptedListDep)(nil)

func NewAdaptedListDep() *AdaptedListDep {
    return (&AdaptedListDep{}).setDefaults()
}

func (x *AdaptedListDep) GetField() *AdaptedList {
    if !x.IsSetField() {
        return nil
    }
    return x.Field
}

func (x *AdaptedListDep) SetFieldNonCompat(value *AdaptedList) *AdaptedListDep {
    x.Field = value
    return x
}

func (x *AdaptedListDep) SetField(value *AdaptedList) *AdaptedListDep {
    x.Field = value
    return x
}

func (x *AdaptedListDep) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *AdaptedListDep) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError("AdaptedListDep write field begin error: ", err)
    }

    item := x.Field
    if err := item.Write(p); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AdaptedListDep write field end error: ", err)
    }
    return nil
}

func (x *AdaptedListDep) readField1(p thrift.Decoder) error {  // Field
    result := NewAdaptedList()
    err := result.Read(p)
    if err != nil {
        return err
    }

    x.Field = result
    return nil
}




func (x *AdaptedListDep) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("AdaptedListDep"); err != nil {
        return thrift.PrependError("AdaptedListDep write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("AdaptedListDep write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("AdaptedListDep write struct end error: ", err)
    }
    return nil
}

func (x *AdaptedListDep) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("AdaptedListDep read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("AdaptedListDep field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRUCT) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("AdaptedListDep read struct end error: ", err)
    }

    return nil
}

func (x *AdaptedListDep) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *AdaptedListDep) setDefaults() *AdaptedListDep {
    return x.
        SetFieldNonCompat(NewAdaptedList())
}

type DependentAdaptedList struct {
    Field []*DependentAdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*DependentAdaptedList)(nil)

func NewDependentAdaptedList() *DependentAdaptedList {
    return (&DependentAdaptedList{}).setDefaults()
}

func (x *DependentAdaptedList) GetField() []*DependentAdaptedListDep {
    if !x.IsSetField() {
        return make([]*DependentAdaptedListDep, 0)
    }
    return x.Field
}

func (x *DependentAdaptedList) SetFieldNonCompat(value []*DependentAdaptedListDep) *DependentAdaptedList {
    x.Field = value
    return x
}

func (x *DependentAdaptedList) SetField(value []*DependentAdaptedListDep) *DependentAdaptedList {
    x.Field = value
    return x
}

func (x *DependentAdaptedList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *DependentAdaptedList) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError("DependentAdaptedList write field begin error: ", err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := item.Write(p); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("DependentAdaptedList write field end error: ", err)
    }
    return nil
}

func (x *DependentAdaptedList) readField1(p thrift.Decoder) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]*DependentAdaptedListDep, 0, size)
    for i := 0; i < size; i++ {
        var elem *DependentAdaptedListDep
        {
            result := NewDependentAdaptedListDep()
            err := result.Read(p)
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.Field = result
    return nil
}



func (x *DependentAdaptedList) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("DependentAdaptedList"); err != nil {
        return thrift.PrependError("DependentAdaptedList write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("DependentAdaptedList write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("DependentAdaptedList write struct end error: ", err)
    }
    return nil
}

func (x *DependentAdaptedList) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("DependentAdaptedList read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("DependentAdaptedList field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("DependentAdaptedList read struct end error: ", err)
    }

    return nil
}

func (x *DependentAdaptedList) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *DependentAdaptedList) setDefaults() *DependentAdaptedList {
    return x
}

type DependentAdaptedListDep struct {
    Field *int16 `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*DependentAdaptedListDep)(nil)

func NewDependentAdaptedListDep() *DependentAdaptedListDep {
    return (&DependentAdaptedListDep{}).setDefaults()
}

func (x *DependentAdaptedListDep) GetField() int16 {
    if !x.IsSetField() {
        return 0
    }
    return *x.Field
}

func (x *DependentAdaptedListDep) SetFieldNonCompat(value int16) *DependentAdaptedListDep {
    x.Field = &value
    return x
}

func (x *DependentAdaptedListDep) SetField(value *int16) *DependentAdaptedListDep {
    x.Field = value
    return x
}

func (x *DependentAdaptedListDep) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *DependentAdaptedListDep) writeField1(p thrift.Encoder) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.I16, 1); err != nil {
        return thrift.PrependError("DependentAdaptedListDep write field begin error: ", err)
    }

    item := *x.Field
    if err := p.WriteI16(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("DependentAdaptedListDep write field end error: ", err)
    }
    return nil
}

func (x *DependentAdaptedListDep) readField1(p thrift.Decoder) error {  // Field
    result, err := p.ReadI16()
    if err != nil {
        return err
    }

    x.Field = &result
    return nil
}




func (x *DependentAdaptedListDep) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("DependentAdaptedListDep"); err != nil {
        return thrift.PrependError("DependentAdaptedListDep write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("DependentAdaptedListDep write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("DependentAdaptedListDep write struct end error: ", err)
    }
    return nil
}

func (x *DependentAdaptedListDep) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("DependentAdaptedListDep read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("DependentAdaptedListDep field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I16) || (id == thrift.NO_FIELD_ID && fieldName == "field")):  // field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("DependentAdaptedListDep read struct end error: ", err)
    }

    return nil
}

func (x *DependentAdaptedListDep) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *DependentAdaptedListDep) setDefaults() *DependentAdaptedListDep {
    return x
}

type AllocatorAware struct {
    AaList ListI32_9187 `thrift:"aa_list,1" json:"aa_list" db:"aa_list"`
    AaSet SetI32_7070 `thrift:"aa_set,2" json:"aa_set" db:"aa_set"`
    AaMap MapI32I32_9565 `thrift:"aa_map,3" json:"aa_map" db:"aa_map"`
    AaString String_5252 `thrift:"aa_string,4" json:"aa_string" db:"aa_string"`
    NotAContainer int32 `thrift:"not_a_container,5" json:"not_a_container" db:"not_a_container"`
    AaUnique I32_9314 `thrift:"aa_unique,6" json:"aa_unique" db:"aa_unique"`
    AaShared I32_9314 `thrift:"aa_shared,7" json:"aa_shared" db:"aa_shared"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AllocatorAware)(nil)

func NewAllocatorAware() *AllocatorAware {
    return (&AllocatorAware{}).setDefaults()
}

func (x *AllocatorAware) GetAaList() ListI32_9187 {
    if !x.IsSetAaList() {
        return NewListI32_9187()
    }
    return x.AaList
}

func (x *AllocatorAware) GetAaSet() SetI32_7070 {
    if !x.IsSetAaSet() {
        return NewSetI32_7070()
    }
    return x.AaSet
}

func (x *AllocatorAware) GetAaMap() MapI32I32_9565 {
    if !x.IsSetAaMap() {
        return NewMapI32I32_9565()
    }
    return x.AaMap
}

func (x *AllocatorAware) GetAaString() String_5252 {
    return x.AaString
}

func (x *AllocatorAware) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware) GetAaUnique() I32_9314 {
    return x.AaUnique
}

func (x *AllocatorAware) GetAaShared() I32_9314 {
    return x.AaShared
}

func (x *AllocatorAware) SetAaListNonCompat(value ListI32_9187) *AllocatorAware {
    x.AaList = value
    return x
}

func (x *AllocatorAware) SetAaList(value ListI32_9187) *AllocatorAware {
    x.AaList = value
    return x
}

func (x *AllocatorAware) SetAaSetNonCompat(value SetI32_7070) *AllocatorAware {
    x.AaSet = value
    return x
}

func (x *AllocatorAware) SetAaSet(value SetI32_7070) *AllocatorAware {
    x.AaSet = value
    return x
}

func (x *AllocatorAware) SetAaMapNonCompat(value MapI32I32_9565) *AllocatorAware {
    x.AaMap = value
    return x
}

func (x *AllocatorAware) SetAaMap(value MapI32I32_9565) *AllocatorAware {
    x.AaMap = value
    return x
}

func (x *AllocatorAware) SetAaStringNonCompat(value String_5252) *AllocatorAware {
    x.AaString = value
    return x
}

func (x *AllocatorAware) SetAaString(value String_5252) *AllocatorAware {
    x.AaString = value
    return x
}

func (x *AllocatorAware) SetNotAContainerNonCompat(value int32) *AllocatorAware {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware) SetNotAContainer(value int32) *AllocatorAware {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware) SetAaUniqueNonCompat(value I32_9314) *AllocatorAware {
    x.AaUnique = value
    return x
}

func (x *AllocatorAware) SetAaUnique(value I32_9314) *AllocatorAware {
    x.AaUnique = value
    return x
}

func (x *AllocatorAware) SetAaSharedNonCompat(value I32_9314) *AllocatorAware {
    x.AaShared = value
    return x
}

func (x *AllocatorAware) SetAaShared(value I32_9314) *AllocatorAware {
    x.AaShared = value
    return x
}

func (x *AllocatorAware) IsSetAaList() bool {
    return x != nil && x.AaList != nil
}

func (x *AllocatorAware) IsSetAaSet() bool {
    return x != nil && x.AaSet != nil
}

func (x *AllocatorAware) IsSetAaMap() bool {
    return x != nil && x.AaMap != nil
}

func (x *AllocatorAware) writeField1(p thrift.Encoder) error {  // AaList
    if err := p.WriteFieldBegin("aa_list", thrift.LIST, 1); err != nil {
        return thrift.PrependError("AllocatorAware write field begin error: ", err)
    }

    item := x.AaList
    err := WriteListI32_9187(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) writeField2(p thrift.Encoder) error {  // AaSet
    if err := p.WriteFieldBegin("aa_set", thrift.SET, 2); err != nil {
        return thrift.PrependError("AllocatorAware write field begin error: ", err)
    }

    item := x.AaSet
    err := WriteSetI32_7070(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) writeField3(p thrift.Encoder) error {  // AaMap
    if err := p.WriteFieldBegin("aa_map", thrift.MAP, 3); err != nil {
        return thrift.PrependError("AllocatorAware write field begin error: ", err)
    }

    item := x.AaMap
    err := WriteMapI32I32_9565(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) writeField4(p thrift.Encoder) error {  // AaString
    if err := p.WriteFieldBegin("aa_string", thrift.STRING, 4); err != nil {
        return thrift.PrependError("AllocatorAware write field begin error: ", err)
    }

    item := x.AaString
    err := WriteString_5252(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) writeField5(p thrift.Encoder) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 5); err != nil {
        return thrift.PrependError("AllocatorAware write field begin error: ", err)
    }

    item := x.NotAContainer
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) writeField6(p thrift.Encoder) error {  // AaUnique
    if err := p.WriteFieldBegin("aa_unique", thrift.I32, 6); err != nil {
        return thrift.PrependError("AllocatorAware write field begin error: ", err)
    }

    item := x.AaUnique
    err := WriteI32_9314(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) writeField7(p thrift.Encoder) error {  // AaShared
    if err := p.WriteFieldBegin("aa_shared", thrift.I32, 7); err != nil {
        return thrift.PrependError("AllocatorAware write field begin error: ", err)
    }

    item := x.AaShared
    err := WriteI32_9314(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) readField1(p thrift.Decoder) error {  // AaList
    result, err := ReadListI32_9187(p)
    if err != nil {
        return err
    }

    x.AaList = result
    return nil
}

func (x *AllocatorAware) readField2(p thrift.Decoder) error {  // AaSet
    result, err := ReadSetI32_7070(p)
    if err != nil {
        return err
    }

    x.AaSet = result
    return nil
}

func (x *AllocatorAware) readField3(p thrift.Decoder) error {  // AaMap
    result, err := ReadMapI32I32_9565(p)
    if err != nil {
        return err
    }

    x.AaMap = result
    return nil
}

func (x *AllocatorAware) readField4(p thrift.Decoder) error {  // AaString
    result, err := ReadString_5252(p)
    if err != nil {
        return err
    }

    x.AaString = result
    return nil
}

func (x *AllocatorAware) readField5(p thrift.Decoder) error {  // NotAContainer
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.NotAContainer = result
    return nil
}

func (x *AllocatorAware) readField6(p thrift.Decoder) error {  // AaUnique
    result, err := ReadI32_9314(p)
    if err != nil {
        return err
    }

    x.AaUnique = result
    return nil
}

func (x *AllocatorAware) readField7(p thrift.Decoder) error {  // AaShared
    result, err := ReadI32_9314(p)
    if err != nil {
        return err
    }

    x.AaShared = result
    return nil
}



func (x *AllocatorAware) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("AllocatorAware"); err != nil {
        return thrift.PrependError("AllocatorAware write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }
    if err := x.writeField4(p); err != nil {
        return err
    }
    if err := x.writeField5(p); err != nil {
        return err
    }
    if err := x.writeField6(p); err != nil {
        return err
    }
    if err := x.writeField7(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("AllocatorAware write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("AllocatorAware write struct end error: ", err)
    }
    return nil
}

func (x *AllocatorAware) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("AllocatorAware read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("AllocatorAware field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "aa_list")):  // aa_list
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.SET) || (id == thrift.NO_FIELD_ID && fieldName == "aa_set")):  // aa_set
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "aa_map")):  // aa_map
            fieldReadErr = x.readField3(p)
        case ((id == 4 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "aa_string")):  // aa_string
            fieldReadErr = x.readField4(p)
        case ((id == 5 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "not_a_container")):  // not_a_container
            fieldReadErr = x.readField5(p)
        case ((id == 6 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "aa_unique")):  // aa_unique
            fieldReadErr = x.readField6(p)
        case ((id == 7 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "aa_shared")):  // aa_shared
            fieldReadErr = x.readField7(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("AllocatorAware read struct end error: ", err)
    }

    return nil
}

func (x *AllocatorAware) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *AllocatorAware) setDefaults() *AllocatorAware {
    return x.
        SetAaListNonCompat(NewListI32_9187()).
        SetAaSetNonCompat(NewSetI32_7070()).
        SetAaMapNonCompat(NewMapI32I32_9565()).
        SetAaStringNonCompat(NewString_5252()).
        SetNotAContainerNonCompat(0).
        SetAaUniqueNonCompat(NewI32_9314()).
        SetAaSharedNonCompat(NewI32_9314())
}

type AllocatorAware2 struct {
    NotAContainer int32 `thrift:"not_a_container,1" json:"not_a_container" db:"not_a_container"`
    BoxField *int32 `thrift:"box_field,2,optional" json:"box_field,omitempty" db:"box_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AllocatorAware2)(nil)

func NewAllocatorAware2() *AllocatorAware2 {
    return (&AllocatorAware2{}).setDefaults()
}

func (x *AllocatorAware2) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware2) GetBoxField() int32 {
    if !x.IsSetBoxField() {
        return 0
    }
    return *x.BoxField
}

func (x *AllocatorAware2) SetNotAContainerNonCompat(value int32) *AllocatorAware2 {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware2) SetNotAContainer(value int32) *AllocatorAware2 {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware2) SetBoxFieldNonCompat(value int32) *AllocatorAware2 {
    x.BoxField = &value
    return x
}

func (x *AllocatorAware2) SetBoxField(value *int32) *AllocatorAware2 {
    x.BoxField = value
    return x
}

func (x *AllocatorAware2) IsSetBoxField() bool {
    return x != nil && x.BoxField != nil
}

func (x *AllocatorAware2) writeField1(p thrift.Encoder) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 1); err != nil {
        return thrift.PrependError("AllocatorAware2 write field begin error: ", err)
    }

    item := x.NotAContainer
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware2 write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware2) writeField2(p thrift.Encoder) error {  // BoxField
    if !x.IsSetBoxField() {
        return nil
    }

    if err := p.WriteFieldBegin("box_field", thrift.I32, 2); err != nil {
        return thrift.PrependError("AllocatorAware2 write field begin error: ", err)
    }

    item := *x.BoxField
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("AllocatorAware2 write field end error: ", err)
    }
    return nil
}

func (x *AllocatorAware2) readField1(p thrift.Decoder) error {  // NotAContainer
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.NotAContainer = result
    return nil
}

func (x *AllocatorAware2) readField2(p thrift.Decoder) error {  // BoxField
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.BoxField = &result
    return nil
}




func (x *AllocatorAware2) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("AllocatorAware2"); err != nil {
        return thrift.PrependError("AllocatorAware2 write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("AllocatorAware2 write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("AllocatorAware2 write struct end error: ", err)
    }
    return nil
}

func (x *AllocatorAware2) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("AllocatorAware2 read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("AllocatorAware2 field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "not_a_container")):  // not_a_container
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "box_field")):  // box_field
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("AllocatorAware2 read struct end error: ", err)
    }

    return nil
}

func (x *AllocatorAware2) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *AllocatorAware2) setDefaults() *AllocatorAware2 {
    return x.
        SetNotAContainerNonCompat(0)
}

type TypedefStruct struct {
    I32Field int32 `thrift:"i32_field,1" json:"i32_field" db:"i32_field"`
    IntTypedefField IntTypedef `thrift:"IntTypedef_field,2" json:"IntTypedef_field" db:"IntTypedef_field"`
    UintTypedefField UintTypedef `thrift:"UintTypedef_field,3" json:"UintTypedef_field" db:"UintTypedef_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*TypedefStruct)(nil)

func NewTypedefStruct() *TypedefStruct {
    return (&TypedefStruct{}).setDefaults()
}

func (x *TypedefStruct) GetI32Field() int32 {
    return x.I32Field
}

func (x *TypedefStruct) GetIntTypedefField() IntTypedef {
    return x.IntTypedefField
}

func (x *TypedefStruct) GetUintTypedefField() UintTypedef {
    return x.UintTypedefField
}

func (x *TypedefStruct) SetI32FieldNonCompat(value int32) *TypedefStruct {
    x.I32Field = value
    return x
}

func (x *TypedefStruct) SetI32Field(value int32) *TypedefStruct {
    x.I32Field = value
    return x
}

func (x *TypedefStruct) SetIntTypedefFieldNonCompat(value IntTypedef) *TypedefStruct {
    x.IntTypedefField = value
    return x
}

func (x *TypedefStruct) SetIntTypedefField(value IntTypedef) *TypedefStruct {
    x.IntTypedefField = value
    return x
}

func (x *TypedefStruct) SetUintTypedefFieldNonCompat(value UintTypedef) *TypedefStruct {
    x.UintTypedefField = value
    return x
}

func (x *TypedefStruct) SetUintTypedefField(value UintTypedef) *TypedefStruct {
    x.UintTypedefField = value
    return x
}

func (x *TypedefStruct) writeField1(p thrift.Encoder) error {  // I32Field
    if err := p.WriteFieldBegin("i32_field", thrift.I32, 1); err != nil {
        return thrift.PrependError("TypedefStruct write field begin error: ", err)
    }

    item := x.I32Field
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("TypedefStruct write field end error: ", err)
    }
    return nil
}

func (x *TypedefStruct) writeField2(p thrift.Encoder) error {  // IntTypedefField
    if err := p.WriteFieldBegin("IntTypedef_field", thrift.I32, 2); err != nil {
        return thrift.PrependError("TypedefStruct write field begin error: ", err)
    }

    item := x.IntTypedefField
    err := WriteIntTypedef(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("TypedefStruct write field end error: ", err)
    }
    return nil
}

func (x *TypedefStruct) writeField3(p thrift.Encoder) error {  // UintTypedefField
    if err := p.WriteFieldBegin("UintTypedef_field", thrift.I32, 3); err != nil {
        return thrift.PrependError("TypedefStruct write field begin error: ", err)
    }

    item := x.UintTypedefField
    err := WriteUintTypedef(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("TypedefStruct write field end error: ", err)
    }
    return nil
}

func (x *TypedefStruct) readField1(p thrift.Decoder) error {  // I32Field
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x.I32Field = result
    return nil
}

func (x *TypedefStruct) readField2(p thrift.Decoder) error {  // IntTypedefField
    result, err := ReadIntTypedef(p)
    if err != nil {
        return err
    }

    x.IntTypedefField = result
    return nil
}

func (x *TypedefStruct) readField3(p thrift.Decoder) error {  // UintTypedefField
    result, err := ReadUintTypedef(p)
    if err != nil {
        return err
    }

    x.UintTypedefField = result
    return nil
}



func (x *TypedefStruct) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("TypedefStruct"); err != nil {
        return thrift.PrependError("TypedefStruct write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("TypedefStruct write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("TypedefStruct write struct end error: ", err)
    }
    return nil
}

func (x *TypedefStruct) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("TypedefStruct read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("TypedefStruct field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "i32_field")):  // i32_field
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "IntTypedef_field")):  // IntTypedef_field
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "UintTypedef_field")):  // UintTypedef_field
            fieldReadErr = x.readField3(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("TypedefStruct read struct end error: ", err)
    }

    return nil
}

func (x *TypedefStruct) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *TypedefStruct) setDefaults() *TypedefStruct {
    return x.
        SetI32FieldNonCompat(0).
        SetIntTypedefFieldNonCompat(NewIntTypedef()).
        SetUintTypedefFieldNonCompat(NewUintTypedef())
}

type StructWithDoubleUnderscores struct {
    _Field int32 `thrift:"__field,1" json:"__field" db:"__field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*StructWithDoubleUnderscores)(nil)

func NewStructWithDoubleUnderscores() *StructWithDoubleUnderscores {
    return (&StructWithDoubleUnderscores{}).setDefaults()
}

func (x *StructWithDoubleUnderscores) Get_Field() int32 {
    return x._Field
}

func (x *StructWithDoubleUnderscores) Set_FieldNonCompat(value int32) *StructWithDoubleUnderscores {
    x._Field = value
    return x
}

func (x *StructWithDoubleUnderscores) Set_Field(value int32) *StructWithDoubleUnderscores {
    x._Field = value
    return x
}

func (x *StructWithDoubleUnderscores) writeField1(p thrift.Encoder) error {  // _Field
    if err := p.WriteFieldBegin("__field", thrift.I32, 1); err != nil {
        return thrift.PrependError("StructWithDoubleUnderscores write field begin error: ", err)
    }

    item := x._Field
    if err := p.WriteI32(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("StructWithDoubleUnderscores write field end error: ", err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) readField1(p thrift.Decoder) error {  // _Field
    result, err := p.ReadI32()
    if err != nil {
        return err
    }

    x._Field = result
    return nil
}



func (x *StructWithDoubleUnderscores) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("StructWithDoubleUnderscores"); err != nil {
        return thrift.PrependError("StructWithDoubleUnderscores write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("StructWithDoubleUnderscores write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("StructWithDoubleUnderscores write struct end error: ", err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("StructWithDoubleUnderscores read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("StructWithDoubleUnderscores field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "__field")):  // __field
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("StructWithDoubleUnderscores read struct end error: ", err)
    }

    return nil
}

func (x *StructWithDoubleUnderscores) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *StructWithDoubleUnderscores) setDefaults() *StructWithDoubleUnderscores {
    return x.
        Set_FieldNonCompat(0)
}

type reqSomeServiceBounceMap struct {
    M included.SomeMap `thrift:"m,1" json:"m" db:"m"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*reqSomeServiceBounceMap)(nil)

// Deprecated: SomeServiceBounceMapArgsDeprecated is deprecated, since it is supposed to be internal.
type SomeServiceBounceMapArgsDeprecated = reqSomeServiceBounceMap

func newReqSomeServiceBounceMap() *reqSomeServiceBounceMap {
    return (&reqSomeServiceBounceMap{}).setDefaults()
}

func (x *reqSomeServiceBounceMap) GetM() included.SomeMap {
    if !x.IsSetM() {
        return included.NewSomeMap()
    }
    return x.M
}

func (x *reqSomeServiceBounceMap) SetMNonCompat(value included.SomeMap) *reqSomeServiceBounceMap {
    x.M = value
    return x
}

func (x *reqSomeServiceBounceMap) SetM(value included.SomeMap) *reqSomeServiceBounceMap {
    x.M = value
    return x
}

func (x *reqSomeServiceBounceMap) IsSetM() bool {
    return x != nil && x.M != nil
}

func (x *reqSomeServiceBounceMap) writeField1(p thrift.Encoder) error {  // M
    if err := p.WriteFieldBegin("m", thrift.MAP, 1); err != nil {
        return thrift.PrependError("reqSomeServiceBounceMap write field begin error: ", err)
    }

    item := x.M
    err := included.WriteSomeMap(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("reqSomeServiceBounceMap write field end error: ", err)
    }
    return nil
}

func (x *reqSomeServiceBounceMap) readField1(p thrift.Decoder) error {  // M
    result, err := included.ReadSomeMap(p)
    if err != nil {
        return err
    }

    x.M = result
    return nil
}



func (x *reqSomeServiceBounceMap) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("reqSomeServiceBounceMap"); err != nil {
        return thrift.PrependError("reqSomeServiceBounceMap write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("reqSomeServiceBounceMap write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("reqSomeServiceBounceMap write struct end error: ", err)
    }
    return nil
}

func (x *reqSomeServiceBounceMap) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("reqSomeServiceBounceMap read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("reqSomeServiceBounceMap field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "m")):  // m
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("reqSomeServiceBounceMap read struct end error: ", err)
    }

    return nil
}

func (x *reqSomeServiceBounceMap) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *reqSomeServiceBounceMap) setDefaults() *reqSomeServiceBounceMap {
    return x.
        SetMNonCompat(included.NewSomeMap())
}

type respSomeServiceBounceMap struct {
    Success included.SomeMap `thrift:"success,0,optional" json:"success,omitempty" db:"success"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*respSomeServiceBounceMap)(nil)
var _ thrift.WritableResult = (*respSomeServiceBounceMap)(nil)

// Deprecated: SomeServiceBounceMapResultDeprecated is deprecated, since it is supposed to be internal.
type SomeServiceBounceMapResultDeprecated = respSomeServiceBounceMap

func newRespSomeServiceBounceMap() *respSomeServiceBounceMap {
    return (&respSomeServiceBounceMap{}).setDefaults()
}

func (x *respSomeServiceBounceMap) GetSuccess() included.SomeMap {
    if !x.IsSetSuccess() {
        return included.NewSomeMap()
    }
    return x.Success
}

func (x *respSomeServiceBounceMap) SetSuccessNonCompat(value included.SomeMap) *respSomeServiceBounceMap {
    x.Success = value
    return x
}

func (x *respSomeServiceBounceMap) SetSuccess(value included.SomeMap) *respSomeServiceBounceMap {
    x.Success = value
    return x
}

func (x *respSomeServiceBounceMap) IsSetSuccess() bool {
    return x != nil && x.Success != nil
}

func (x *respSomeServiceBounceMap) writeField0(p thrift.Encoder) error {  // Success
    if !x.IsSetSuccess() {
        return nil
    }

    if err := p.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
        return thrift.PrependError("respSomeServiceBounceMap write field begin error: ", err)
    }

    item := x.Success
    err := included.WriteSomeMap(item, p)
    if err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("respSomeServiceBounceMap write field end error: ", err)
    }
    return nil
}

func (x *respSomeServiceBounceMap) readField0(p thrift.Decoder) error {  // Success
    result, err := included.ReadSomeMap(p)
    if err != nil {
        return err
    }

    x.Success = result
    return nil
}



func (x *respSomeServiceBounceMap) Exception() thrift.WritableException {
    return nil
}

func (x *respSomeServiceBounceMap) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("respSomeServiceBounceMap"); err != nil {
        return thrift.PrependError("respSomeServiceBounceMap write struct begin error: ", err)
    }

    if err := x.writeField0(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("respSomeServiceBounceMap write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("respSomeServiceBounceMap write struct end error: ", err)
    }
    return nil
}

func (x *respSomeServiceBounceMap) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("respSomeServiceBounceMap read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("respSomeServiceBounceMap field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 0 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "success")):  // success
            fieldReadErr = x.readField0(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("respSomeServiceBounceMap read struct end error: ", err)
    }

    return nil
}

func (x *respSomeServiceBounceMap) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *respSomeServiceBounceMap) setDefaults() *respSomeServiceBounceMap {
    return x
}

type reqSomeServiceBinaryKeyedMap struct {
    R []int64 `thrift:"r,1" json:"r" db:"r"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*reqSomeServiceBinaryKeyedMap)(nil)

// Deprecated: SomeServiceBinaryKeyedMapArgsDeprecated is deprecated, since it is supposed to be internal.
type SomeServiceBinaryKeyedMapArgsDeprecated = reqSomeServiceBinaryKeyedMap

func newReqSomeServiceBinaryKeyedMap() *reqSomeServiceBinaryKeyedMap {
    return (&reqSomeServiceBinaryKeyedMap{}).setDefaults()
}

func (x *reqSomeServiceBinaryKeyedMap) GetR() []int64 {
    if !x.IsSetR() {
        return make([]int64, 0)
    }
    return x.R
}

func (x *reqSomeServiceBinaryKeyedMap) SetRNonCompat(value []int64) *reqSomeServiceBinaryKeyedMap {
    x.R = value
    return x
}

func (x *reqSomeServiceBinaryKeyedMap) SetR(value []int64) *reqSomeServiceBinaryKeyedMap {
    x.R = value
    return x
}

func (x *reqSomeServiceBinaryKeyedMap) IsSetR() bool {
    return x != nil && x.R != nil
}

func (x *reqSomeServiceBinaryKeyedMap) writeField1(p thrift.Encoder) error {  // R
    if err := p.WriteFieldBegin("r", thrift.LIST, 1); err != nil {
        return thrift.PrependError("reqSomeServiceBinaryKeyedMap write field begin error: ", err)
    }

    item := x.R
    if err := p.WriteListBegin(thrift.I64, len(item)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range item {
        {
            item := v
            if err := p.WriteI64(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("reqSomeServiceBinaryKeyedMap write field end error: ", err)
    }
    return nil
}

func (x *reqSomeServiceBinaryKeyedMap) readField1(p thrift.Decoder) error {  // R
    _ /* elemType */, size, err := p.ReadListBegin()
    if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
    }
    
    listResult := make([]int64, 0, size)
    for i := 0; i < size; i++ {
        var elem int64
        {
            result, err := p.ReadI64()
            if err != nil {
                return err
            }
            elem = result
        }
        listResult = append(listResult, elem)
    }
    
    if err := p.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
    }
    result := listResult

    x.R = result
    return nil
}



func (x *reqSomeServiceBinaryKeyedMap) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("reqSomeServiceBinaryKeyedMap"); err != nil {
        return thrift.PrependError("reqSomeServiceBinaryKeyedMap write struct begin error: ", err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("reqSomeServiceBinaryKeyedMap write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("reqSomeServiceBinaryKeyedMap write struct end error: ", err)
    }
    return nil
}

func (x *reqSomeServiceBinaryKeyedMap) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("reqSomeServiceBinaryKeyedMap read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("reqSomeServiceBinaryKeyedMap field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.LIST) || (id == thrift.NO_FIELD_ID && fieldName == "r")):  // r
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("reqSomeServiceBinaryKeyedMap read struct end error: ", err)
    }

    return nil
}

func (x *reqSomeServiceBinaryKeyedMap) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *reqSomeServiceBinaryKeyedMap) setDefaults() *reqSomeServiceBinaryKeyedMap {
    return x.
        SetRNonCompat(make([]int64, 0))
}

type respSomeServiceBinaryKeyedMap struct {
    Success map[*TBinary]int64 `thrift:"success,0,optional" json:"success,omitempty" db:"success"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*respSomeServiceBinaryKeyedMap)(nil)
var _ thrift.WritableResult = (*respSomeServiceBinaryKeyedMap)(nil)

// Deprecated: SomeServiceBinaryKeyedMapResultDeprecated is deprecated, since it is supposed to be internal.
type SomeServiceBinaryKeyedMapResultDeprecated = respSomeServiceBinaryKeyedMap

func newRespSomeServiceBinaryKeyedMap() *respSomeServiceBinaryKeyedMap {
    return (&respSomeServiceBinaryKeyedMap{}).setDefaults()
}

func (x *respSomeServiceBinaryKeyedMap) GetSuccess() map[*TBinary]int64 {
    if !x.IsSetSuccess() {
        return make(map[*TBinary]int64)
    }
    return x.Success
}

func (x *respSomeServiceBinaryKeyedMap) SetSuccessNonCompat(value map[*TBinary]int64) *respSomeServiceBinaryKeyedMap {
    x.Success = value
    return x
}

func (x *respSomeServiceBinaryKeyedMap) SetSuccess(value map[*TBinary]int64) *respSomeServiceBinaryKeyedMap {
    x.Success = value
    return x
}

func (x *respSomeServiceBinaryKeyedMap) IsSetSuccess() bool {
    return x != nil && x.Success != nil
}

func (x *respSomeServiceBinaryKeyedMap) writeField0(p thrift.Encoder) error {  // Success
    if !x.IsSetSuccess() {
        return nil
    }

    if err := p.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
        return thrift.PrependError("respSomeServiceBinaryKeyedMap write field begin error: ", err)
    }

    item := x.Success
    if err := p.WriteMapBegin(thrift.STRING, thrift.I64, len(item)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range item {
        if k == nil {
            return fmt.Errorf("%T write map: nil key is not allowed.", item)
        }
    
        {
            item := *k
            err := WriteTBinary(item, p)
            if err != nil {
                return err
            }
        }
    
        {
            item := v
            if err := p.WriteI64(item); err != nil {
                return err
            }
        }
    }
    if err := p.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError("respSomeServiceBinaryKeyedMap write field end error: ", err)
    }
    return nil
}

func (x *respSomeServiceBinaryKeyedMap) readField0(p thrift.Decoder) error {  // Success
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
    if err != nil {
        return thrift.PrependError("error reading map begin: ", err)
    }
    
    mapResult := make(map[*TBinary]int64, size)
    for i := 0; i < size; i++ {
        var key *TBinary
        {
            result, err := ReadTBinary(p)
            if err != nil {
                return err
            }
            key = &result
        }
    
        var value int64
        {
            result, err := p.ReadI64()
            if err != nil {
                return err
            }
            value = result
        }
    
        mapResult[key] = value
    }
    
    if err := p.ReadMapEnd(); err != nil {
        return thrift.PrependError("error reading map end: ", err)
    }
    result := mapResult

    x.Success = result
    return nil
}



func (x *respSomeServiceBinaryKeyedMap) Exception() thrift.WritableException {
    return nil
}

func (x *respSomeServiceBinaryKeyedMap) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("respSomeServiceBinaryKeyedMap"); err != nil {
        return thrift.PrependError("respSomeServiceBinaryKeyedMap write struct begin error: ", err)
    }

    if err := x.writeField0(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError("respSomeServiceBinaryKeyedMap write field stop error: ", err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError("respSomeServiceBinaryKeyedMap write struct end error: ", err)
    }
    return nil
}

func (x *respSomeServiceBinaryKeyedMap) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError("respSomeServiceBinaryKeyedMap read error: ", err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("respSomeServiceBinaryKeyedMap field %d ('%s') read error: ", id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 0 && wireType == thrift.MAP) || (id == thrift.NO_FIELD_ID && fieldName == "success")):  // success
            fieldReadErr = x.readField0(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError("respSomeServiceBinaryKeyedMap read struct end error: ", err)
    }

    return nil
}

func (x *respSomeServiceBinaryKeyedMap) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *respSomeServiceBinaryKeyedMap) setDefaults() *respSomeServiceBinaryKeyedMap {
    return x
}


// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("apache.org/thrift/fixtures/types/empty_struct", func() any { return NewEmptyStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/decorated_struct", func() any { return NewDecoratedStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ContainerStruct", func() any { return NewContainerStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CppTypeStruct", func() any { return NewCppTypeStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/VirtualStruct", func() any { return NewVirtualStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyStructWithForwardRefEnum", func() any { return NewMyStructWithForwardRefEnum() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TrivialNumeric", func() any { return NewTrivialNumeric() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TrivialNestedWithDefault", func() any { return NewTrivialNestedWithDefault() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ComplexString", func() any { return NewComplexString() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ComplexNestedWithDefault", func() any { return NewComplexNestedWithDefault() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MinPadding", func() any { return NewMinPadding() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MinPaddingWithCustomType", func() any { return NewMinPaddingWithCustomType() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyStruct", func() any { return NewMyStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyDataItem", func() any { return NewMyDataItem() })
    registry.RegisterType("apache.org/thrift/fixtures/types/Renaming", func() any { return NewRenaming() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AnnotatedTypes", func() any { return NewAnnotatedTypes() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageRoot", func() any { return NewForwardUsageRoot() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageStruct", func() any { return NewForwardUsageStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageByRef", func() any { return NewForwardUsageByRef() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteMap", func() any { return NewIncompleteMap() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteMapDep", func() any { return NewIncompleteMapDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteMap", func() any { return NewCompleteMap() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteMapDep", func() any { return NewCompleteMapDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteList", func() any { return NewIncompleteList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteListDep", func() any { return NewIncompleteListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteList", func() any { return NewCompleteList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteListDep", func() any { return NewCompleteListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AdaptedList", func() any { return NewAdaptedList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AdaptedListDep", func() any { return NewAdaptedListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/DependentAdaptedList", func() any { return NewDependentAdaptedList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/DependentAdaptedListDep", func() any { return NewDependentAdaptedListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AllocatorAware", func() any { return NewAllocatorAware() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AllocatorAware2", func() any { return NewAllocatorAware2() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TypedefStruct", func() any { return NewTypedefStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/StructWithDoubleUnderscores", func() any { return NewStructWithDoubleUnderscores() })

    registry.RegisterType("apache.org/thrift/fixtures/types/has_bitwise_ops", func() any { return HasBitwiseOps(0) })
    registry.RegisterType("apache.org/thrift/fixtures/types/is_unscoped", func() any { return IsUnscoped(0) })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyForwardRefEnum", func() any { return MyForwardRefEnum(0) })
}
