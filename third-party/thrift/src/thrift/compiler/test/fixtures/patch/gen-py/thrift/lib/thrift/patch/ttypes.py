#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.lib.thrift.standard.ttypes
import thrift.lib.thrift.id.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass

def __EXPAND_THRIFT_SPEC(spec):
    next_id = 0
    for item in spec:
        if next_id >= 0 and item[0] < 0:
            next_id = item[0]
        if item[0] != next_id:
            for _ in range(next_id, item[0]):
                yield None
        yield item
        next_id = item[0] + 1

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'GeneratePatch', 'AssignOnlyPatch', 'BoolPatch', 'BytePatch', 'I16Patch', 'I32Patch', 'I64Patch', 'FloatPatch', 'DoublePatch', 'StringPatch', 'BinaryPatch', 'FieldId', 'FieldIdList']

class GeneratePatch:
  r"""
  An annotation that indicates a patch representation should be generated for
  the associated definition.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GeneratePatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.GeneratePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.GeneratePatch, self)

  def _to_py_deprecated(self):
    return self

class AssignOnlyPatch:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AssignOnlyPatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AssignOnlyPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AssignOnlyPatch, self)

  def _to_py_deprecated(self):
    return self

class BoolPatch:
  r"""
  A patch for a boolean value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - invert: If the bool value should be inverted.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.assign = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.invert = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BoolPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.BOOL, 1)
      oprot.writeBool(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.invert != None:
      oprot.writeFieldBegin('invert', TType.BOOL, 9)
      oprot.writeBool(self.invert)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'invert' in json_obj and json_obj['invert'] is not None:
      self.invert = json_obj['invert']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.invert is not None:
      value = pprint.pformat(self.invert, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    invert=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'invert',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BoolPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BoolPatch, self)

  def _to_py_deprecated(self):
    return self

class BytePatch:
  r"""
  A patch for an 8-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.assign = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.add = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BytePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.BYTE, 1)
      oprot.writeByte(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BYTE, 8)
      oprot.writeByte(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7f or self.assign < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7f or self.add < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BytePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BytePatch, self)

  def _to_py_deprecated(self):
    return self

class I16Patch:
  r"""
  A patch for a 16-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.assign = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.add = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I16Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I16, 1)
      oprot.writeI16(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I16, 8)
      oprot.writeI16(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7fff or self.assign < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7fff or self.add < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I16Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I16Patch, self)

  def _to_py_deprecated(self):
    return self

class I32Patch:
  r"""
  A patch for a 32-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clears any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.add = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I32Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I32, 8)
      oprot.writeI32(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7fffffff or self.assign < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7fffffff or self.add < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I32Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I32Patch, self)

  def _to_py_deprecated(self):
    return self

class I64Patch:
  r"""
  A patch for a 64-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.assign = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.add = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I64Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I64, 1)
      oprot.writeI64(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I64, 8)
      oprot.writeI64(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = long(json_obj['assign'])
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = long(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I64Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I64Patch, self)

  def _to_py_deprecated(self):
    return self

class FloatPatch:
  r"""
  A patch for a 32-bit floating point value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.assign = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.FLOAT:
          self.add = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FloatPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.FLOAT, 1)
      oprot.writeFloat(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.FLOAT, 8)
      oprot.writeFloat(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = float(json_obj['assign'])
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = float(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.FloatPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.FloatPatch, self)

  def _to_py_deprecated(self):
    return self

class DoublePatch:
  r"""
  A patch for an 64-bit floating point value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.assign = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.add = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DoublePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.DOUBLE, 1)
      oprot.writeDouble(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.DOUBLE, 8)
      oprot.writeDouble(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = float(json_obj['assign'])
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = float(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DoublePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DoublePatch, self)

  def _to_py_deprecated(self):
    return self

class StringPatch:
  r"""
  A patch for a string value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear a given string.
   - prepend: Prepend to a given value.
   - append: Append to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.assign = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.prepend = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.append = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StringPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRING, 1)
      oprot.writeString(self.assign.encode('utf-8')) if UTF8STRINGS and not isinstance(self.assign, bytes) else oprot.writeString(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.STRING, 8)
      oprot.writeString(self.prepend.encode('utf-8')) if UTF8STRINGS and not isinstance(self.prepend, bytes) else oprot.writeString(self.prepend)
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.STRING, 9)
      oprot.writeString(self.append.encode('utf-8')) if UTF8STRINGS and not isinstance(self.append, bytes) else oprot.writeString(self.append)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = json_obj['prepend']
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = json_obj['append']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'prepend',
      'append',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StringPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StringPatch, self)

  def _to_py_deprecated(self):
    return self

class BinaryPatch:
  r"""
  A patch for a binary value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear a given binary.
   - prepend: Prepend to a given value.
   - append: Append to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.assign = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.prepend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.append = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BinaryPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRING, 1)
      oprot.writeString(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.STRING, 8)
      oprot.writeString(self.prepend)
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.STRING, 9)
      oprot.writeString(self.append)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = json_obj['prepend']
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = json_obj['append']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'prepend',
      'append',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BinaryPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BinaryPatch, self)

  def _to_py_deprecated(self):
    return self

FieldId = thrift.lib.thrift.id.ttypes.FieldId
FieldIdList = UnimplementedTypedef()
all_structs.append(GeneratePatch)
GeneratePatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

GeneratePatch.thrift_struct_annotations = {
}
GeneratePatch.thrift_field_annotations = {
}

all_structs.append(AssignOnlyPatch)
AssignOnlyPatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

AssignOnlyPatch.thrift_struct_annotations = {
}
AssignOnlyPatch.thrift_field_annotations = {
}

all_structs.append(BoolPatch)
BoolPatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BOOL, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (9, TType.BOOL, 'invert', None, None, 3, ), # 9
)))

BoolPatch.thrift_struct_annotations = {
}
BoolPatch.thrift_field_annotations = {
}

def BoolPatch__init__(self, assign=None, clear=None, invert=None,):
  self.assign = assign
  self.clear = clear
  self.invert = invert

BoolPatch.__init__ = BoolPatch__init__

def BoolPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('invert', None)
  self.__dict__ = state

BoolPatch.__getstate__ = lambda self: self.__dict__.copy()
BoolPatch.__setstate__ = BoolPatch__setstate__

all_structs.append(BytePatch)
BytePatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BYTE, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.BYTE, 'add', None, None, 3, ), # 8
)))

BytePatch.thrift_struct_annotations = {
}
BytePatch.thrift_field_annotations = {
}

def BytePatch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

BytePatch.__init__ = BytePatch__init__

def BytePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

BytePatch.__getstate__ = lambda self: self.__dict__.copy()
BytePatch.__setstate__ = BytePatch__setstate__

all_structs.append(I16Patch)
I16Patch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I16, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.I16, 'add', None, None, 3, ), # 8
)))

I16Patch.thrift_struct_annotations = {
}
I16Patch.thrift_field_annotations = {
}

def I16Patch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

I16Patch.__init__ = I16Patch__init__

def I16Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

I16Patch.__getstate__ = lambda self: self.__dict__.copy()
I16Patch.__setstate__ = I16Patch__setstate__

all_structs.append(I32Patch)
I32Patch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.I32, 'add', None, None, 3, ), # 8
)))

I32Patch.thrift_struct_annotations = {
}
I32Patch.thrift_field_annotations = {
}

def I32Patch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

I32Patch.__init__ = I32Patch__init__

def I32Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

I32Patch.__getstate__ = lambda self: self.__dict__.copy()
I32Patch.__setstate__ = I32Patch__setstate__

all_structs.append(I64Patch)
I64Patch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.I64, 'add', None, None, 3, ), # 8
)))

I64Patch.thrift_struct_annotations = {
}
I64Patch.thrift_field_annotations = {
}

def I64Patch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

I64Patch.__init__ = I64Patch__init__

def I64Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

I64Patch.__getstate__ = lambda self: self.__dict__.copy()
I64Patch.__setstate__ = I64Patch__setstate__

all_structs.append(FloatPatch)
FloatPatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.FLOAT, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.FLOAT, 'add', None, None, 3, ), # 8
)))

FloatPatch.thrift_struct_annotations = {
}
FloatPatch.thrift_field_annotations = {
}

def FloatPatch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

FloatPatch.__init__ = FloatPatch__init__

def FloatPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

FloatPatch.__getstate__ = lambda self: self.__dict__.copy()
FloatPatch.__setstate__ = FloatPatch__setstate__

all_structs.append(DoublePatch)
DoublePatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.DOUBLE, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.DOUBLE, 'add', None, None, 3, ), # 8
)))

DoublePatch.thrift_struct_annotations = {
}
DoublePatch.thrift_field_annotations = {
}

def DoublePatch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

DoublePatch.__init__ = DoublePatch__init__

def DoublePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

DoublePatch.__getstate__ = lambda self: self.__dict__.copy()
DoublePatch.__setstate__ = DoublePatch__setstate__

all_structs.append(StringPatch)
StringPatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'assign', True, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.STRING, 'prepend', True, None, 3, ), # 8
  (9, TType.STRING, 'append', True, None, 3, ), # 9
)))

StringPatch.thrift_struct_annotations = {
}
StringPatch.thrift_field_annotations = {
}

def StringPatch__init__(self, assign=None, clear=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.prepend = prepend
  self.append = append

StringPatch.__init__ = StringPatch__init__

def StringPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

StringPatch.__getstate__ = lambda self: self.__dict__.copy()
StringPatch.__setstate__ = StringPatch__setstate__

all_structs.append(BinaryPatch)
BinaryPatch.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'assign', False, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (8, TType.STRING, 'prepend', False, None, 3, ), # 8
  (9, TType.STRING, 'append', False, None, 3, ), # 9
)))

BinaryPatch.thrift_struct_annotations = {
}
BinaryPatch.thrift_field_annotations = {
}

def BinaryPatch__init__(self, assign=None, clear=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.prepend = prepend
  self.append = append

BinaryPatch.__init__ = BinaryPatch__init__

def BinaryPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

BinaryPatch.__getstate__ = lambda self: self.__dict__.copy()
BinaryPatch.__setstate__ = BinaryPatch__setstate__

fix_spec(all_structs)
del all_structs
