<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

type StructWithWrapper = \MyStructWrapper<\thrift_adapted_types\StructWithWrapper>;
type i64WithAdapter = \MyAdapterInt::THackType;
type i64WithWrapper = \MyTypeIntWrapper<\detail\i64WithWrapper>;
type AdaptedMap = \MyAdapter1::THackType;
type AdaptedStruct = \MyAdapter1::THackType;
/**
 * Original thrift struct:-
 * AnnotationStruct
 */
class AnnotationStruct implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public static function fromMap_DEPRECATED(@KeyedContainer<string, mixed> $map)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'AnnotationStruct';
  }

  public function clearTerseFields()[write_props]: void {
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "include.AnnotationStruct",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\Transitive' => \thrift\annotation\Transitive::fromShape(
          shape(
          )
        ),
        '\thrift\annotation\hack\Wrapper' => \thrift\annotation\hack\Wrapper::fromShape(
          shape(
            "name" => "\\MyFieldWrapper",
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __stringifyMapKeys<T>(dict<arraykey, T> $m)[]: dict<string, T> {
    return Dict\map_keys($m, $key ==> (string)$key);
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * MyStruct
 */
class MyStruct implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishAsyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'nested_struct',
      'type' => \TType::STRUCT,
      'class' => MyNestedStruct::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'nested_struct' => 1,
  ];

  const type TConstructorShape = shape(
    ?'nested_struct' => ?MyNestedStruct,
  );

  const type TShape = shape(
    ?'nested_struct' => ?MyNestedStruct::TShape,
  );
  const int STRUCTURAL_ID = 6466034702854646588;
  /**
   * Original thrift field:-
   * 1: include.MyNestedStruct nested_struct
   */
  public ?MyNestedStruct $nested_struct;

  public function __construct(?MyNestedStruct $nested_struct = null)[] {
    $this->nested_struct = $nested_struct;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'nested_struct'),
    );
  }

  public static function fromMap_DEPRECATED(@KeyedContainer<string, mixed> $map)[]: this {
    return new static(
      HH\FIXME\UNSAFE_CAST<mixed, MyNestedStruct>(idx($map, 'nested_struct'), 'map value is mixed'),
    );
  }

  public function getName()[]: string {
    return 'MyStruct';
  }

  public function clearTerseFields()[write_props]: void {
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "include.MyStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.MyNestedStruct",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "include.MyNestedStruct",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "nested_struct",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function __stringifyMapKeys<T>(dict<arraykey, T> $m)[]: dict<string, T> {
    return Dict\map_keys($m, $key ==> (string)$key);
  }

  public static async function __genFromShape(self::TShape $shape): Awaitable<this> {
    $obj = new static();
    $nested_struct = Shapes::idx($shape, 'nested_struct');
    if ($nested_struct !== null) {
      $obj->nested_struct = await MyNestedStruct::__genFromShape($nested_struct);
    }
    return $obj;
  }

  public async function __genToShape(): Awaitable<self::TShape> {
    return shape(
      'nested_struct' => await ($this->nested_struct === null 
        ? null 
        : (
        $this->nested_struct->__genToShape()
        )
      ),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'nested_struct') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, MyNestedStruct>($parsed['nested_struct']));
      $_tmp1 = MyNestedStruct::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->nested_struct = $_tmp1;
    }
  }

}

/**
 * Original thrift struct:-
 * MyNestedStruct
 */
class MyNestedStruct implements \IThriftAsyncStruct, \IThriftStructMetadata, \IThriftShapishAsyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'wrapped_field',
      'is_wrapped' => true,
      'type' => \TType::I64,
    ),
    2 => shape(
      'var' => 'annotated_field',
      'is_wrapped' => true,
      'type' => \TType::I64,
    ),
    3 => shape(
      'var' => 'adapted_type',
      'adapter' => \MyAdapter1::class,
      'type' => \TType::I64,
    ),
    4 => shape(
      'var' => 'adapted__and_wrapped_type',
      'is_wrapped' => true,
      'adapter' => \MyAdapter1::class,
      'type' => \TType::I64,
    ),
    5 => shape(
      'var' => 'optional_adapted_and_wrapped_type',
      'is_wrapped' => true,
      'adapter' => \MyAdapterInt::class,
      'type' => \TType::I64,
    ),
    7 => shape(
      'var' => 'wrapped_type_int',
      'is_wrapped' => true,
      'is_type_wrapped' => true,
      'type' => \TType::I64,
    ),
    8 => shape(
      'var' => 'double_wrapped_struct',
      'is_wrapped' => true,
      'is_type_wrapped' => true,
      'type' => \TType::STRUCT,
      'class' => \thrift_adapted_types\StructWithWrapper::class,
    ),
    9 => shape(
      'var' => 'optional_adapted_and_wrapped_type_map',
      'is_wrapped' => true,
      'adapter' => \MyAdapter1::class,
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRUCT,
        'class' => MyStruct::class,
      ),
      'format' => 'harray',
    ),
    10 => shape(
      'var' => 'optional_adapted_and_wrapped_type_struct',
      'is_wrapped' => true,
      'adapter' => \MyAdapter1::class,
      'type' => \TType::STRUCT,
      'class' => MyStruct::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'wrapped_field' => 1,
    'annotated_field' => 2,
    'adapted_type' => 3,
    'adapted__and_wrapped_type' => 4,
    'optional_adapted_and_wrapped_type' => 5,
    'wrapped_type_int' => 7,
    'double_wrapped_struct' => 8,
    'optional_adapted_and_wrapped_type_map' => 9,
    'optional_adapted_and_wrapped_type_struct' => 10,
  ];

  const type TConstructorShape = shape(
    ?'wrapped_field' => ?int,
    ?'annotated_field' => ?int,
    ?'adapted_type' => ?\MyAdapter1::THackType,
    ?'adapted__and_wrapped_type' => ?\MyAdapter1::THackType,
    ?'optional_adapted_and_wrapped_type' => ?i64WithAdapter,
    ?'wrapped_type_int' => ?\detail\i64WithWrapper,
    ?'double_wrapped_struct' => ?\thrift_adapted_types\StructWithWrapper,
    ?'optional_adapted_and_wrapped_type_map' => ?AdaptedMap,
    ?'optional_adapted_and_wrapped_type_struct' => ?AdaptedStruct,
  );

  const type TShape = shape(
    'wrapped_field' => int,
    'annotated_field' => int,
    'adapted_type' => \MyAdapter1::THackType,
    'adapted__and_wrapped_type' => \MyAdapter1::THackType,
    ?'optional_adapted_and_wrapped_type' => ?i64WithAdapter,
    'wrapped_type_int' => \detail\i64WithWrapper,
    ?'double_wrapped_struct' => ?\thrift_adapted_types\StructWithWrapper::TShape,
    ?'optional_adapted_and_wrapped_type_map' => ?AdaptedMap,
    ?'optional_adapted_and_wrapped_type_struct' => ?AdaptedStruct,
  );
  const int STRUCTURAL_ID = 4891388107170377575;
  /**
   * Original thrift field:-
   * 1: i64 wrapped_field
   */
  private ?\MyFieldWrapper<int, MyNestedStruct> $wrapped_field;

  public function get_wrapped_field()[]: \MyFieldWrapper<int, MyNestedStruct> {
    return $this->wrapped_field as nonnull;
  }

  /**
   * Original thrift field:-
   * 2: i64 annotated_field
   */
  private ?\MyFieldWrapper<int, MyNestedStruct> $annotated_field;

  public function get_annotated_field()[]: \MyFieldWrapper<int, MyNestedStruct> {
    return $this->annotated_field as nonnull;
  }

  /**
   * Original thrift field:-
   * 3: i64 adapted_type
   */
  public \MyAdapter1::THackType $adapted_type;
  /**
   * Original thrift field:-
   * 4: i64 adapted__and_wrapped_type
   */
  private ?\MyFieldWrapper<\MyAdapter1::THackType, MyNestedStruct> $adapted__and_wrapped_type;

  public function get_adapted__and_wrapped_type()[]: \MyFieldWrapper<\MyAdapter1::THackType, MyNestedStruct> {
    return $this->adapted__and_wrapped_type as nonnull;
  }

  /**
   * Original thrift field:-
   * 5: include.i64WithAdapter optional_adapted_and_wrapped_type
   */
  private ?\MyFieldWrapper<?i64WithAdapter, MyNestedStruct> $optional_adapted_and_wrapped_type;

  public function get_optional_adapted_and_wrapped_type()[]: \MyFieldWrapper<?i64WithAdapter, MyNestedStruct> {
    return $this->optional_adapted_and_wrapped_type as nonnull;
  }

  /**
   * Original thrift field:-
   * 7: include.i64WithWrapper wrapped_type_int
   */
  private ?\MyFieldWrapper<i64WithWrapper, MyNestedStruct> $wrapped_type_int;

  public function get_wrapped_type_int()[]: \MyFieldWrapper<i64WithWrapper, MyNestedStruct> {
    return $this->wrapped_type_int as nonnull;
  }


  public function set_wrapped_type_int_DO_NOT_USE_THRIFT_INTERNAL(int $wrapped_type_int)[write_props]: void {
    $wrapped_type_int = \MyTypeIntWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<\detail\i64WithWrapper>($wrapped_type_int);
    $this->get_wrapped_type_int()->setValue_DO_NOT_USE_THRIFT_INTERNAL($wrapped_type_int);
  }

  /**
   * Original thrift field:-
   * 8: include.StructWithWrapper double_wrapped_struct
   */
  private ?\MyFieldWrapper<?StructWithWrapper, MyNestedStruct> $double_wrapped_struct;

  public function get_double_wrapped_struct()[]: \MyFieldWrapper<?StructWithWrapper, MyNestedStruct> {
    return $this->double_wrapped_struct as nonnull;
  }


  public function set_double_wrapped_struct_DO_NOT_USE_THRIFT_INTERNAL(\thrift_adapted_types\StructWithWrapper $double_wrapped_struct)[write_props]: void {
    $double_wrapped_struct = \MyStructWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<\thrift_adapted_types\StructWithWrapper>($double_wrapped_struct);
    $this->get_double_wrapped_struct()->setValue_DO_NOT_USE_THRIFT_INTERNAL($double_wrapped_struct);
  }

  /**
   * Original thrift field:-
   * 9: include.AdaptedMap optional_adapted_and_wrapped_type_map
   */
  private ?\MyFieldWrapper<?AdaptedMap, MyNestedStruct> $optional_adapted_and_wrapped_type_map;

  public function get_optional_adapted_and_wrapped_type_map()[]: \MyFieldWrapper<?AdaptedMap, MyNestedStruct> {
    return $this->optional_adapted_and_wrapped_type_map as nonnull;
  }

  /**
   * Original thrift field:-
   * 10: include.AdaptedStruct optional_adapted_and_wrapped_type_struct
   */
  private ?\MyFieldWrapper<?AdaptedStruct, MyNestedStruct> $optional_adapted_and_wrapped_type_struct;

  public function get_optional_adapted_and_wrapped_type_struct()[]: \MyFieldWrapper<?AdaptedStruct, MyNestedStruct> {
    return $this->optional_adapted_and_wrapped_type_struct as nonnull;
  }


  public function __construct()[] {
    $this->adapted_type = \MyAdapter1::fromThrift(0);
    $this->wrapped_field = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<int, MyNestedStruct>(0, 1, $this);
    $this->annotated_field = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<int, MyNestedStruct>(0, 2, $this);
    $this->adapted__and_wrapped_type = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<\MyAdapter1::THackType, MyNestedStruct>(\MyAdapter1::fromThrift(0), 4, $this);
    $this->optional_adapted_and_wrapped_type = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<?\MyAdapterInt::THackType, MyNestedStruct>(null, 5, $this);
    $this->wrapped_type_int = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<i64WithWrapper, MyNestedStruct>(\MyTypeIntWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<\detail\i64WithWrapper>(0), 7, $this);
    $this->double_wrapped_struct = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<?StructWithWrapper, MyNestedStruct>(null, 8, $this);
    $this->optional_adapted_and_wrapped_type_map = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<?\MyAdapter1::THackType, MyNestedStruct>(null, 9, $this);
    $this->optional_adapted_and_wrapped_type_struct = \MyFieldWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<?\MyAdapter1::THackType, MyNestedStruct>(null, 10, $this);
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static async function genFromShape(self::TConstructorShape $shape)[zoned_shallow]: Awaitable<this> {
    $obj = new static();
    $wrapped_field = Shapes::idx($shape, 'wrapped_field');
    if ($wrapped_field !== null) {
      await $obj->get_wrapped_field()->genWrap($wrapped_field);
    }
    $annotated_field = Shapes::idx($shape, 'annotated_field');
    if ($annotated_field !== null) {
      await $obj->get_annotated_field()->genWrap($annotated_field);
    }
    $adapted_type = Shapes::idx($shape, 'adapted_type');
    if ($adapted_type !== null) {
      $obj->adapted_type = $adapted_type;
    }
    $adapted__and_wrapped_type = Shapes::idx($shape, 'adapted__and_wrapped_type');
    if ($adapted__and_wrapped_type !== null) {
      await $obj->get_adapted__and_wrapped_type()->genWrap($adapted__and_wrapped_type);
    }
    $optional_adapted_and_wrapped_type = Shapes::idx($shape, 'optional_adapted_and_wrapped_type');
    if ($optional_adapted_and_wrapped_type !== null) {
      await $obj->get_optional_adapted_and_wrapped_type()->genWrap($optional_adapted_and_wrapped_type);
    }
    $wrapped_type_int = Shapes::idx($shape, 'wrapped_type_int');
    if ($wrapped_type_int !== null) {
      $wrapped_type_int = await \MyTypeIntWrapper::genFromThrift<\detail\i64WithWrapper>($wrapped_type_int);
      await $obj->get_wrapped_type_int()->genWrap($wrapped_type_int);
    }
    $double_wrapped_struct = Shapes::idx($shape, 'double_wrapped_struct');
    if ($double_wrapped_struct !== null) {
      $double_wrapped_struct = await \MyStructWrapper::genFromThrift<\thrift_adapted_types\StructWithWrapper>($double_wrapped_struct);
      await $obj->get_double_wrapped_struct()->genWrap($double_wrapped_struct);
    }
    $optional_adapted_and_wrapped_type_map = Shapes::idx($shape, 'optional_adapted_and_wrapped_type_map');
    if ($optional_adapted_and_wrapped_type_map !== null) {
      await $obj->get_optional_adapted_and_wrapped_type_map()->genWrap($optional_adapted_and_wrapped_type_map);
    }
    $optional_adapted_and_wrapped_type_struct = Shapes::idx($shape, 'optional_adapted_and_wrapped_type_struct');
    if ($optional_adapted_and_wrapped_type_struct !== null) {
      await $obj->get_optional_adapted_and_wrapped_type_struct()->genWrap($optional_adapted_and_wrapped_type_struct);
    }
    return $obj;
  }

  public static async function genFromMap_DEPRECATED(@KeyedContainer<string, mixed> $map): Awaitable<this> {
    $obj = new static();
    $wrapped_field = idx($map, 'wrapped_field');
    if ($wrapped_field !== null) {
      await $obj->get_wrapped_field()->genWrap(HH\FIXME\UNSAFE_CAST<mixed, int>($wrapped_field, 'Map value is mixed'));
    }
    $annotated_field = idx($map, 'annotated_field');
    if ($annotated_field !== null) {
      await $obj->get_annotated_field()->genWrap(HH\FIXME\UNSAFE_CAST<mixed, int>($annotated_field, 'Map value is mixed'));
    }
    $adapted_type = idx($map, 'adapted_type');
    if ($adapted_type !== null) {
      $obj->adapted_type = HH\FIXME\UNSAFE_CAST<mixed, int>($adapted_type, 'Map value is mixed');
    }
    $adapted__and_wrapped_type = idx($map, 'adapted__and_wrapped_type');
    if ($adapted__and_wrapped_type !== null) {
      await $obj->get_adapted__and_wrapped_type()->genWrap(HH\FIXME\UNSAFE_CAST<mixed, int>($adapted__and_wrapped_type, 'Map value is mixed'));
    }
    $optional_adapted_and_wrapped_type = idx($map, 'optional_adapted_and_wrapped_type');
    if ($optional_adapted_and_wrapped_type !== null) {
      await $obj->get_optional_adapted_and_wrapped_type()->genWrap(HH\FIXME\UNSAFE_CAST<mixed, i64WithAdapter>($optional_adapted_and_wrapped_type, 'Map value is mixed'));
    }
    $wrapped_type_int = idx($map, 'wrapped_type_int');
    if ($wrapped_type_int !== null) {
      $wrapped_type_int = await \MyTypeIntWrapper::genFromThrift<\detail\i64WithWrapper>(HH\FIXME\UNSAFE_CAST<mixed, \detail\i64WithWrapper>($wrapped_type_int, 'Map value is mixed'));
      await $obj->get_wrapped_type_int()->genWrap($wrapped_type_int);
    }
    $double_wrapped_struct = idx($map, 'double_wrapped_struct');
    if ($double_wrapped_struct !== null) {
      $double_wrapped_struct = await \MyStructWrapper::genFromThrift<\thrift_adapted_types\StructWithWrapper>(HH\FIXME\UNSAFE_CAST<mixed, \thrift_adapted_types\StructWithWrapper>($double_wrapped_struct, 'Map value is mixed'));
      await $obj->get_double_wrapped_struct()->genWrap($double_wrapped_struct);
    }
    $optional_adapted_and_wrapped_type_map = idx($map, 'optional_adapted_and_wrapped_type_map');
    if ($optional_adapted_and_wrapped_type_map !== null) {
      await $obj->get_optional_adapted_and_wrapped_type_map()->genWrap(HH\FIXME\UNSAFE_CAST<mixed, AdaptedMap>($optional_adapted_and_wrapped_type_map, 'Map value is mixed'));
    }
    $optional_adapted_and_wrapped_type_struct = idx($map, 'optional_adapted_and_wrapped_type_struct');
    if ($optional_adapted_and_wrapped_type_struct !== null) {
      await $obj->get_optional_adapted_and_wrapped_type_struct()->genWrap(HH\FIXME\UNSAFE_CAST<mixed, AdaptedStruct>($optional_adapted_and_wrapped_type_struct, 'Map value is mixed'));
    }
    return $obj;
  }

  public function getName()[]: string {
    return 'MyNestedStruct';
  }

  public function clearTerseFields()[write_props]: void {
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "include.MyNestedStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "wrapped_field",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "annotated_field",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "adapted_type",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "adapted__and_wrapped_type",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 5,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.i64WithAdapter",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "optional_adapted_and_wrapped_type",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 7,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.i64WithWrapper",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "wrapped_type_int",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.StructWithWrapper",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "include.StructWithWrapper",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "double_wrapped_struct",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 9,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.AdaptedMap",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_struct" => tmeta_ThriftStructType::fromShape(
                                    shape(
                                      "name" => "include.MyStruct",
                                    )
                                  ),
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "optional_adapted_and_wrapped_type_map",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 10,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.AdaptedStruct",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "include.MyStruct",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "optional_adapted_and_wrapped_type_struct",
              "is_optional" => true,
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'wrapped_field' => shape(
          'field' => dict[
            '\thrift\annotation\hack\FieldWrapper' => \thrift\annotation\hack\FieldWrapper::fromShape(
              shape(
                "name" => "\\MyFieldWrapper",
              )
            ),
          ],
          'type' => dict[],
        ),
        'annotated_field' => shape(
          'field' => dict[
            'AnnotationStruct' => AnnotationStruct::fromShape(
              shape(
              )
            ),
          ],
          'type' => dict[],
        ),
        'adapted_type' => shape(
          'field' => dict[
            '\thrift\annotation\hack\Adapter' => \thrift\annotation\hack\Adapter::fromShape(
              shape(
                "name" => "\\MyAdapter1",
              )
            ),
          ],
          'type' => dict[],
        ),
        'adapted__and_wrapped_type' => shape(
          'field' => dict[
            '\thrift\annotation\hack\FieldWrapper' => \thrift\annotation\hack\FieldWrapper::fromShape(
              shape(
                "name" => "\\MyFieldWrapper",
              )
            ),
            '\thrift\annotation\hack\Adapter' => \thrift\annotation\hack\Adapter::fromShape(
              shape(
                "name" => "\\MyAdapter1",
              )
            ),
          ],
          'type' => dict[],
        ),
        'optional_adapted_and_wrapped_type' => shape(
          'field' => dict[
            '\thrift\annotation\hack\FieldWrapper' => \thrift\annotation\hack\FieldWrapper::fromShape(
              shape(
                "name" => "\\MyFieldWrapper",
              )
            ),
          ],
          'type' => dict[
            '\thrift\annotation\hack\Adapter' => \thrift\annotation\hack\Adapter::fromShape(
              shape(
                "name" => "\\MyAdapterInt",
              )
            ),
          ],
        ),
        'wrapped_type_int' => shape(
          'field' => dict[
            '\thrift\annotation\hack\FieldWrapper' => \thrift\annotation\hack\FieldWrapper::fromShape(
              shape(
                "name" => "\\MyFieldWrapper",
              )
            ),
          ],
          'type' => dict[
            '\thrift\annotation\hack\Wrapper' => \thrift\annotation\hack\Wrapper::fromShape(
              shape(
                "name" => "\\MyTypeIntWrapper",
                "extraNamespace" => "detail",
              )
            ),
          ],
        ),
        'double_wrapped_struct' => shape(
          'field' => dict[
            '\thrift\annotation\hack\FieldWrapper' => \thrift\annotation\hack\FieldWrapper::fromShape(
              shape(
                "name" => "\\MyFieldWrapper",
              )
            ),
          ],
          'type' => dict[
            '\thrift\annotation\hack\Wrapper' => \thrift\annotation\hack\Wrapper::fromShape(
              shape(
                "name" => "\\MyStructWrapper",
              )
            ),
          ],
        ),
        'optional_adapted_and_wrapped_type_map' => shape(
          'field' => dict[
            '\thrift\annotation\hack\FieldWrapper' => \thrift\annotation\hack\FieldWrapper::fromShape(
              shape(
                "name" => "\\MyFieldWrapper",
              )
            ),
          ],
          'type' => dict[
            '\thrift\annotation\hack\Adapter' => \thrift\annotation\hack\Adapter::fromShape(
              shape(
                "name" => "\\MyAdapter1",
              )
            ),
          ],
        ),
        'optional_adapted_and_wrapped_type_struct' => shape(
          'field' => dict[
            '\thrift\annotation\hack\FieldWrapper' => \thrift\annotation\hack\FieldWrapper::fromShape(
              shape(
                "name" => "\\MyFieldWrapper",
              )
            ),
          ],
          'type' => dict[
            '\thrift\annotation\hack\Adapter' => \thrift\annotation\hack\Adapter::fromShape(
              shape(
                "name" => "\\MyAdapter1",
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __stringifyMapKeys<T>(dict<arraykey, T> $m)[]: dict<string, T> {
    return Dict\map_keys($m, $key ==> (string)$key);
  }

  public static async function __genFromShape(self::TShape $shape): Awaitable<this> {
    $obj = new static();
    await $obj->get_wrapped_field()->genWrap($shape['wrapped_field']);
    await $obj->get_annotated_field()->genWrap($shape['annotated_field']);
    $obj->adapted_type = $shape['adapted_type'];
    await $obj->get_adapted__and_wrapped_type()->genWrap($shape['adapted__and_wrapped_type']);
    $optional_adapted_and_wrapped_type = Shapes::idx($shape, 'optional_adapted_and_wrapped_type');
    if ($optional_adapted_and_wrapped_type !== null) {
      await $obj->get_optional_adapted_and_wrapped_type()->genWrap($optional_adapted_and_wrapped_type);
    }
    $wrapped_type_int = await \MyTypeIntWrapper::genFromThrift<\detail\i64WithWrapper>($shape['wrapped_type_int']);
    await $obj->get_wrapped_type_int()->genWrap($wrapped_type_int);
    $double_wrapped_struct = Shapes::idx($shape, 'double_wrapped_struct');
    if ($double_wrapped_struct !== null) {
      $double_wrapped_struct = await \MyStructWrapper::genFromThrift<\thrift_adapted_types\StructWithWrapper>(\thrift_adapted_types\StructWithWrapper::__fromShape($double_wrapped_struct));
      await $obj->get_double_wrapped_struct()->genWrap($double_wrapped_struct);
    }
    $optional_adapted_and_wrapped_type_map = Shapes::idx($shape, 'optional_adapted_and_wrapped_type_map');
    if ($optional_adapted_and_wrapped_type_map !== null) {
      await $obj->get_optional_adapted_and_wrapped_type_map()->genWrap($optional_adapted_and_wrapped_type_map);
    }
    $optional_adapted_and_wrapped_type_struct = Shapes::idx($shape, 'optional_adapted_and_wrapped_type_struct');
    if ($optional_adapted_and_wrapped_type_struct !== null) {
      await $obj->get_optional_adapted_and_wrapped_type_struct()->genWrap($optional_adapted_and_wrapped_type_struct);
    }
    return $obj;
  }

  public async function __genToShape(): Awaitable<self::TShape> {
    $wrapped_field = await ($this->wrapped_field as nonnull)->genUnwrap();
    $annotated_field = await ($this->annotated_field as nonnull)->genUnwrap();
    $adapted__and_wrapped_type = await ($this->adapted__and_wrapped_type as nonnull)->genUnwrap();
    $optional_adapted_and_wrapped_type = await ($this->optional_adapted_and_wrapped_type as nonnull)->genUnwrap();
    $wrapped_type_int = await ($this->wrapped_type_int as nonnull)->genUnwrap();
    $wrapped_type_int = await $wrapped_type_int->genUnwrap();
    $double_wrapped_struct = await ($this->double_wrapped_struct as nonnull)->genUnwrap();
    $double_wrapped_struct = await $double_wrapped_struct?->genUnwrap();
    $optional_adapted_and_wrapped_type_map = await ($this->optional_adapted_and_wrapped_type_map as nonnull)->genUnwrap();
    $optional_adapted_and_wrapped_type_struct = await ($this->optional_adapted_and_wrapped_type_struct as nonnull)->genUnwrap();
    return shape(
      'wrapped_field' => $wrapped_field,
      'annotated_field' => $annotated_field,
      'adapted_type' => $this->adapted_type,
      'adapted__and_wrapped_type' => $adapted__and_wrapped_type,
      'optional_adapted_and_wrapped_type' => $optional_adapted_and_wrapped_type,
      'wrapped_type_int' => $wrapped_type_int,
      'double_wrapped_struct' => ($double_wrapped_struct === null 
        ? null 
        : (
        $double_wrapped_struct->__toShape()
        )
      ),
      'optional_adapted_and_wrapped_type_map' => await ($optional_adapted_and_wrapped_type_map === null 
        ? null 
        : (
        Dict\map_async(
        $optional_adapted_and_wrapped_type_map,
        async $val0 ==> 
          await $val0->__genToShape()
      )
        )
      ),
      'optional_adapted_and_wrapped_type_struct' => await ($optional_adapted_and_wrapped_type_struct === null 
        ? null 
        : (
        $optional_adapted_and_wrapped_type_struct->__genToShape()
        )
      ),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'wrapped_field') !== null) {
      $this->wrapped_field = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['wrapped_field']);
    }
    if (idx($parsed, 'annotated_field') !== null) {
      $this->annotated_field = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['annotated_field']);
    }
    if (idx($parsed, 'adapted_type') !== null) {
      $this->adapted_type = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['adapted_type']);
    }
    if (idx($parsed, 'adapted__and_wrapped_type') !== null) {
      $this->adapted__and_wrapped_type = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['adapted__and_wrapped_type']);
    }
    if (idx($parsed, 'optional_adapted_and_wrapped_type') !== null) {
      $this->optional_adapted_and_wrapped_type = HH\FIXME\UNSAFE_CAST<mixed, i64WithAdapter>($parsed['optional_adapted_and_wrapped_type']);
    }
    if (idx($parsed, 'wrapped_type_int') !== null) {
      $this->wrapped_type_int = HH\FIXME\UNSAFE_CAST<mixed, i64WithWrapper>($parsed['wrapped_type_int']);
    }
    if (idx($parsed, 'double_wrapped_struct') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, StructWithWrapper>($parsed['double_wrapped_struct']));
      $_tmp1 = StructWithWrapper::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->double_wrapped_struct = $_tmp1;
    }
    if (idx($parsed, 'optional_adapted_and_wrapped_type_map') !== null) {
      $_json5 = HH\FIXME\UNSAFE_CAST<mixed, AdaptedMap>($parsed['optional_adapted_and_wrapped_type_map']);
      $_container6 = dict[];
      foreach($_json5 as $_key3 => $_value4) {
        $_value7 = MyStruct::withDefaultValues();
        $_tmp8 = \json_encode($_value4);
        $_tmp9 = MyStruct::withDefaultValues();
        $_tmp9->readFromJson($_tmp8);
        $_value7 = $_tmp9;
        $_container6[$_key3] = $_value7;
      }
      $this->optional_adapted_and_wrapped_type_map = $_container6;
    }
    if (idx($parsed, 'optional_adapted_and_wrapped_type_struct') !== null) {
      $_tmp10 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, AdaptedStruct>($parsed['optional_adapted_and_wrapped_type_struct']));
      $_tmp11 = MyStruct::withDefaultValues();
      $_tmp11->readFromJson($_tmp10);
      $this->optional_adapted_and_wrapped_type_struct = $_tmp11;
    }
  }

  private static function __hackAdapterTypeChecks()[]: void {
    \ThriftUtil::requireSameType<\MyAdapter1::TThriftType, MyStruct>();
    \ThriftUtil::requireSameType<\MyAdapter1::TThriftType, dict<string, MyStruct>>();
    \ThriftUtil::requireSameType<\MyAdapter1::TThriftType, int>();
    \ThriftUtil::requireSameType<\MyAdapterInt::TThriftType, int>();
  }

}

/**
 * Original thrift struct:-
 * MyComplexStruct
 */
class MyComplexStruct implements \IThriftAsyncStruct, \IThriftStructMetadata, \IThriftShapishAsyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'map_of_string_to_MyStruct',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRUCT,
        'class' => MyStruct::class,
      ),
      'format' => 'harray',
    ),
    2 => shape(
      'var' => 'map_of_string_to_list_of_MyStruct',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::LST,
        'etype' => \TType::STRUCT,
        'elem' => shape(
          'type' => \TType::STRUCT,
          'class' => MyStruct::class,
        ),
        'format' => 'harray',
      ),
      'format' => 'harray',
    ),
    3 => shape(
      'var' => 'map_of_string_to_map_of_string_to_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::MAP,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::I32,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'harray',
      ),
      'format' => 'harray',
    ),
    4 => shape(
      'var' => 'map_of_string_to_map_of_string_to_MyStruct',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::MAP,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::STRUCT,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::STRUCT,
          'class' => MyStruct::class,
        ),
        'format' => 'harray',
      ),
      'format' => 'harray',
    ),
    5 => shape(
      'var' => 'list_of_map_of_string_to_list_of_MyStruct',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::LST,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::LST,
          'etype' => \TType::STRUCT,
          'elem' => shape(
            'type' => \TType::STRUCT,
            'class' => MyStruct::class,
          ),
          'format' => 'harray',
        ),
        'format' => 'harray',
      ),
      'format' => 'harray',
    ),
    6 => shape(
      'var' => 'list_of_map_of_string_to_MyStruct',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::STRUCT,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::STRUCT,
          'class' => MyStruct::class,
        ),
        'format' => 'harray',
      ),
      'format' => 'harray',
    ),
    7 => shape(
      'var' => 'list_of_map_of_string_to_StructWithWrapper',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::STRUCT,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'is_type_wrapped' => true,
          'type' => \TType::STRUCT,
          'class' => \thrift_adapted_types\StructWithWrapper::class,
        ),
        'format' => 'harray',
      ),
      'format' => 'harray',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'map_of_string_to_MyStruct' => 1,
    'map_of_string_to_list_of_MyStruct' => 2,
    'map_of_string_to_map_of_string_to_i32' => 3,
    'map_of_string_to_map_of_string_to_MyStruct' => 4,
    'list_of_map_of_string_to_list_of_MyStruct' => 5,
    'list_of_map_of_string_to_MyStruct' => 6,
    'list_of_map_of_string_to_StructWithWrapper' => 7,
  ];

  const type TConstructorShape = shape(
    ?'map_of_string_to_MyStruct' => ?dict<string, MyStruct>,
    ?'map_of_string_to_list_of_MyStruct' => ?dict<string, vec<MyStruct>>,
    ?'map_of_string_to_map_of_string_to_i32' => ?dict<string, dict<string, int>>,
    ?'map_of_string_to_map_of_string_to_MyStruct' => ?dict<string, dict<string, MyStruct>>,
    ?'list_of_map_of_string_to_list_of_MyStruct' => ?vec<dict<string, vec<MyStruct>>>,
    ?'list_of_map_of_string_to_MyStruct' => ?vec<dict<string, MyStruct>>,
    ?'list_of_map_of_string_to_StructWithWrapper' => ?vec<dict<string, \thrift_adapted_types\StructWithWrapper>>,
  );

  const type TShape = shape(
    'map_of_string_to_MyStruct' => dict<arraykey, MyStruct::TShape>,
    'map_of_string_to_list_of_MyStruct' => dict<arraykey, vec<MyStruct::TShape>>,
    'map_of_string_to_map_of_string_to_i32' => dict<arraykey, dict<arraykey, int>>,
    'map_of_string_to_map_of_string_to_MyStruct' => dict<arraykey, dict<arraykey, MyStruct::TShape>>,
    'list_of_map_of_string_to_list_of_MyStruct' => vec<dict<arraykey, vec<MyStruct::TShape>>>,
    'list_of_map_of_string_to_MyStruct' => vec<dict<arraykey, MyStruct::TShape>>,
    'list_of_map_of_string_to_StructWithWrapper' => vec<dict<arraykey, \thrift_adapted_types\StructWithWrapper::TShape>>,
  );
  const int STRUCTURAL_ID = 6139035146599508839;
  /**
   * Original thrift field:-
   * 1: map<string, include.MyStruct> map_of_string_to_MyStruct
   */
  public dict<string, MyStruct> $map_of_string_to_MyStruct;
  /**
   * Original thrift field:-
   * 2: map<string, list<include.MyStruct>> map_of_string_to_list_of_MyStruct
   */
  public dict<string, vec<MyStruct>> $map_of_string_to_list_of_MyStruct;
  /**
   * Original thrift field:-
   * 3: map<string, map<string, i32>> map_of_string_to_map_of_string_to_i32
   */
  public dict<string, dict<string, int>> $map_of_string_to_map_of_string_to_i32;
  /**
   * Original thrift field:-
   * 4: map<string, map<string, include.MyStruct>> map_of_string_to_map_of_string_to_MyStruct
   */
  public dict<string, dict<string, MyStruct>> $map_of_string_to_map_of_string_to_MyStruct;
  /**
   * Original thrift field:-
   * 5: list<map<string, list<include.MyStruct>>> list_of_map_of_string_to_list_of_MyStruct
   */
  public vec<dict<string, vec<MyStruct>>> $list_of_map_of_string_to_list_of_MyStruct;
  /**
   * Original thrift field:-
   * 6: list<map<string, include.MyStruct>> list_of_map_of_string_to_MyStruct
   */
  public vec<dict<string, MyStruct>> $list_of_map_of_string_to_MyStruct;
  /**
   * Original thrift field:-
   * 7: list<map<string, include.StructWithWrapper>> list_of_map_of_string_to_StructWithWrapper
   */
  public vec<dict<string, StructWithWrapper>> $list_of_map_of_string_to_StructWithWrapper;

  public function set_list_of_map_of_string_to_StructWithWrapper_DO_NOT_USE_THRIFT_INTERNAL(vec<dict<string, \thrift_adapted_types\StructWithWrapper>> $list_of_map_of_string_to_StructWithWrapper)[write_props]: void {
    $this->list_of_map_of_string_to_StructWithWrapper = Vec\map(
      $list_of_map_of_string_to_StructWithWrapper,
      $val0 ==> 
        Dict\map(
          $val0,
          $val1 ==> 
            \MyStructWrapper::fromThrift_DO_NOT_USE_THRIFT_INTERNAL<\thrift_adapted_types\StructWithWrapper>($val1)
        )
    );
  }


  public function __construct()[] {
    $this->map_of_string_to_MyStruct = dict[];
    $this->map_of_string_to_list_of_MyStruct = dict[];
    $this->map_of_string_to_map_of_string_to_i32 = dict[];
    $this->map_of_string_to_map_of_string_to_MyStruct = dict[];
    $this->list_of_map_of_string_to_list_of_MyStruct = vec[];
    $this->list_of_map_of_string_to_MyStruct = vec[];
    $this->list_of_map_of_string_to_StructWithWrapper = vec[];
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static async function genFromShape(self::TConstructorShape $shape)[zoned_shallow]: Awaitable<this> {
    $obj = new static();
    $map_of_string_to_MyStruct = Shapes::idx($shape, 'map_of_string_to_MyStruct');
    if ($map_of_string_to_MyStruct !== null) {
      $obj->map_of_string_to_MyStruct = $map_of_string_to_MyStruct;
    }
    $map_of_string_to_list_of_MyStruct = Shapes::idx($shape, 'map_of_string_to_list_of_MyStruct');
    if ($map_of_string_to_list_of_MyStruct !== null) {
      $obj->map_of_string_to_list_of_MyStruct = $map_of_string_to_list_of_MyStruct;
    }
    $map_of_string_to_map_of_string_to_i32 = Shapes::idx($shape, 'map_of_string_to_map_of_string_to_i32');
    if ($map_of_string_to_map_of_string_to_i32 !== null) {
      $obj->map_of_string_to_map_of_string_to_i32 = $map_of_string_to_map_of_string_to_i32;
    }
    $map_of_string_to_map_of_string_to_MyStruct = Shapes::idx($shape, 'map_of_string_to_map_of_string_to_MyStruct');
    if ($map_of_string_to_map_of_string_to_MyStruct !== null) {
      $obj->map_of_string_to_map_of_string_to_MyStruct = $map_of_string_to_map_of_string_to_MyStruct;
    }
    $list_of_map_of_string_to_list_of_MyStruct = Shapes::idx($shape, 'list_of_map_of_string_to_list_of_MyStruct');
    if ($list_of_map_of_string_to_list_of_MyStruct !== null) {
      $obj->list_of_map_of_string_to_list_of_MyStruct = $list_of_map_of_string_to_list_of_MyStruct;
    }
    $list_of_map_of_string_to_MyStruct = Shapes::idx($shape, 'list_of_map_of_string_to_MyStruct');
    if ($list_of_map_of_string_to_MyStruct !== null) {
      $obj->list_of_map_of_string_to_MyStruct = $list_of_map_of_string_to_MyStruct;
    }
    $list_of_map_of_string_to_StructWithWrapper = Shapes::idx($shape, 'list_of_map_of_string_to_StructWithWrapper');
    if ($list_of_map_of_string_to_StructWithWrapper !== null) {
      $obj->list_of_map_of_string_to_StructWithWrapper = await Vec\map_async(
        $list_of_map_of_string_to_StructWithWrapper,
        async $val0 ==> 
          await Dict\map_async(
            $val0,
            async $val1 ==> 
              await \MyStructWrapper::genFromThrift<\thrift_adapted_types\StructWithWrapper>($val1)
          )
      );
    }
    return $obj;
  }

  public static async function genFromMap_DEPRECATED(@KeyedContainer<string, mixed> $map): Awaitable<this> {
    $obj = new static();
    $map_of_string_to_MyStruct = idx($map, 'map_of_string_to_MyStruct');
    if ($map_of_string_to_MyStruct !== null) {
      $obj->map_of_string_to_MyStruct = HH\FIXME\UNSAFE_CAST<mixed, dict<string, MyStruct>>($map_of_string_to_MyStruct, 'Map value is mixed');
    }
    $map_of_string_to_list_of_MyStruct = idx($map, 'map_of_string_to_list_of_MyStruct');
    if ($map_of_string_to_list_of_MyStruct !== null) {
      $obj->map_of_string_to_list_of_MyStruct = HH\FIXME\UNSAFE_CAST<mixed, dict<string, vec<MyStruct>>>($map_of_string_to_list_of_MyStruct, 'Map value is mixed');
    }
    $map_of_string_to_map_of_string_to_i32 = idx($map, 'map_of_string_to_map_of_string_to_i32');
    if ($map_of_string_to_map_of_string_to_i32 !== null) {
      $obj->map_of_string_to_map_of_string_to_i32 = HH\FIXME\UNSAFE_CAST<mixed, dict<string, dict<string, int>>>($map_of_string_to_map_of_string_to_i32, 'Map value is mixed');
    }
    $map_of_string_to_map_of_string_to_MyStruct = idx($map, 'map_of_string_to_map_of_string_to_MyStruct');
    if ($map_of_string_to_map_of_string_to_MyStruct !== null) {
      $obj->map_of_string_to_map_of_string_to_MyStruct = HH\FIXME\UNSAFE_CAST<mixed, dict<string, dict<string, MyStruct>>>($map_of_string_to_map_of_string_to_MyStruct, 'Map value is mixed');
    }
    $list_of_map_of_string_to_list_of_MyStruct = idx($map, 'list_of_map_of_string_to_list_of_MyStruct');
    if ($list_of_map_of_string_to_list_of_MyStruct !== null) {
      $obj->list_of_map_of_string_to_list_of_MyStruct = HH\FIXME\UNSAFE_CAST<mixed, vec<dict<string, vec<MyStruct>>>>($list_of_map_of_string_to_list_of_MyStruct, 'Map value is mixed');
    }
    $list_of_map_of_string_to_MyStruct = idx($map, 'list_of_map_of_string_to_MyStruct');
    if ($list_of_map_of_string_to_MyStruct !== null) {
      $obj->list_of_map_of_string_to_MyStruct = HH\FIXME\UNSAFE_CAST<mixed, vec<dict<string, MyStruct>>>($list_of_map_of_string_to_MyStruct, 'Map value is mixed');
    }
    $list_of_map_of_string_to_StructWithWrapper = idx($map, 'list_of_map_of_string_to_StructWithWrapper');
    if ($list_of_map_of_string_to_StructWithWrapper !== null) {
      $obj->list_of_map_of_string_to_StructWithWrapper = await Vec\map_async(
        HH\FIXME\UNSAFE_CAST<mixed, vec<dict<string, \thrift_adapted_types\StructWithWrapper>>>($list_of_map_of_string_to_StructWithWrapper, 'Map value is mixed'),
        async $val0 ==> 
          await Dict\map_async(
            $val0,
            async $val1 ==> 
              await \MyStructWrapper::genFromThrift<\thrift_adapted_types\StructWithWrapper>($val1)
          )
      );
    }
    return $obj;
  }

  public function getName()[]: string {
    return 'MyComplexStruct';
  }

  public function clearTerseFields()[write_props]: void {
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "include.MyComplexStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "include.MyStruct",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "map_of_string_to_MyStruct",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_list" => tmeta_ThriftListType::fromShape(
                            shape(
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_struct" => tmeta_ThriftStructType::fromShape(
                                    shape(
                                      "name" => "include.MyStruct",
                                    )
                                  ),
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "map_of_string_to_list_of_MyStruct",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "map_of_string_to_map_of_string_to_i32",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_struct" => tmeta_ThriftStructType::fromShape(
                                    shape(
                                      "name" => "include.MyStruct",
                                    )
                                  ),
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "map_of_string_to_map_of_string_to_MyStruct",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 5,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_list" => tmeta_ThriftListType::fromShape(
                                    shape(
                                      "valueType" => tmeta_ThriftType::fromShape(
                                        shape(
                                          "t_struct" => tmeta_ThriftStructType::fromShape(
                                            shape(
                                              "name" => "include.MyStruct",
                                            )
                                          ),
                                        )
                                      ),
                                    )
                                  ),
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "list_of_map_of_string_to_list_of_MyStruct",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_struct" => tmeta_ThriftStructType::fromShape(
                                    shape(
                                      "name" => "include.MyStruct",
                                    )
                                  ),
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "list_of_map_of_string_to_MyStruct",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 7,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                                    shape(
                                      "name" => "include.StructWithWrapper",
                                      "underlyingType" => tmeta_ThriftType::fromShape(
                                        shape(
                                          "t_struct" => tmeta_ThriftStructType::fromShape(
                                            shape(
                                              "name" => "include.StructWithWrapper",
                                            )
                                          ),
                                        )
                                      ),
                                    )
                                  ),
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "list_of_map_of_string_to_StructWithWrapper",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function __stringifyMapKeys<T>(dict<arraykey, T> $m)[]: dict<string, T> {
    return Dict\map_keys($m, $key ==> (string)$key);
  }

  public static async function __genFromShape(self::TShape $shape): Awaitable<this> {
    $obj = new static();
    $obj->map_of_string_to_MyStruct = self::__stringifyMapKeys(
      await Dict\map_async(
        $shape['map_of_string_to_MyStruct'],
        async $val0 ==> 
          await MyStruct::__genFromShape($val0)
      )
    );
    $obj->map_of_string_to_list_of_MyStruct = self::__stringifyMapKeys(
      await Dict\map_async(
        $shape['map_of_string_to_list_of_MyStruct'],
        async $val1 ==> 
          await Vec\map_async(
            $val1,
            async $val2 ==> 
              await MyStruct::__genFromShape($val2)
          )
      )
    );
    $obj->map_of_string_to_map_of_string_to_i32 = self::__stringifyMapKeys(
      Dict\map(
        $shape['map_of_string_to_map_of_string_to_i32'],
        $val3 ==> 
          self::__stringifyMapKeys(
            $val3
          )
      )
    );
    $obj->map_of_string_to_map_of_string_to_MyStruct = self::__stringifyMapKeys(
      await Dict\map_async(
        $shape['map_of_string_to_map_of_string_to_MyStruct'],
        async $val4 ==> 
          self::__stringifyMapKeys(
            await Dict\map_async(
              $val4,
              async $val5 ==> 
                await MyStruct::__genFromShape($val5)
            )
          )
      )
    );
    $obj->list_of_map_of_string_to_list_of_MyStruct = await Vec\map_async(
      $shape['list_of_map_of_string_to_list_of_MyStruct'],
      async $val6 ==> 
        self::__stringifyMapKeys(
          await Dict\map_async(
            $val6,
            async $val7 ==> 
              await Vec\map_async(
                $val7,
                async $val8 ==> 
                  await MyStruct::__genFromShape($val8)
              )
          )
        )
    );
    $obj->list_of_map_of_string_to_MyStruct = await Vec\map_async(
      $shape['list_of_map_of_string_to_MyStruct'],
      async $val9 ==> 
        self::__stringifyMapKeys(
          await Dict\map_async(
            $val9,
            async $val10 ==> 
              await MyStruct::__genFromShape($val10)
          )
        )
    );
    $obj->list_of_map_of_string_to_StructWithWrapper = await Vec\map_async(
      $shape['list_of_map_of_string_to_StructWithWrapper'],
      async $val11 ==> 
        self::__stringifyMapKeys(
          await Dict\map_async(
            $val11,
            async $val12 ==> 
              await \MyStructWrapper::genFromThrift<\thrift_adapted_types\StructWithWrapper>(\thrift_adapted_types\StructWithWrapper::__fromShape($val12))
          )
        )
    );
    return $obj;
  }

  public async function __genToShape(): Awaitable<self::TShape> {
    return shape(
      'map_of_string_to_MyStruct' => await Dict\map_async(
        $this->map_of_string_to_MyStruct,
        async $val0 ==> 
          await $val0->__genToShape()
      ),
      'map_of_string_to_list_of_MyStruct' => await Dict\map_async(
        $this->map_of_string_to_list_of_MyStruct,
        async $val0 ==> 
          await Vec\map_async(
            $val0,
            async $val1 ==> 
              await $val1->__genToShape()
          )
      ),
      'map_of_string_to_map_of_string_to_i32' => Dict\map(
        $this->map_of_string_to_map_of_string_to_i32,
        $val0 ==> 
          dict($val0)
      ),
      'map_of_string_to_map_of_string_to_MyStruct' => await Dict\map_async(
        $this->map_of_string_to_map_of_string_to_MyStruct,
        async $val0 ==> 
          await Dict\map_async(
            $val0,
            async $val1 ==> 
              await $val1->__genToShape()
          )
      ),
      'list_of_map_of_string_to_list_of_MyStruct' => await Vec\map_async(
        $this->list_of_map_of_string_to_list_of_MyStruct,
        async $val0 ==> 
          await Dict\map_async(
            $val0,
            async $val1 ==> 
              await Vec\map_async(
                $val1,
                async $val2 ==> 
                  await $val2->__genToShape()
              )
          )
      ),
      'list_of_map_of_string_to_MyStruct' => await Vec\map_async(
        $this->list_of_map_of_string_to_MyStruct,
        async $val0 ==> 
          await Dict\map_async(
            $val0,
            async $val1 ==> 
              await $val1->__genToShape()
          )
      ),
      'list_of_map_of_string_to_StructWithWrapper' => await Vec\map_async(
        $this->list_of_map_of_string_to_StructWithWrapper,
        async $val0 ==> 
          await Dict\map_async(
            $val0,
            async $val1 ==> 
              {
                $val1 = await $val1->genUnwrap();
                return $val1->__toShape();
              }
          )
      ),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'map_of_string_to_MyStruct') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, dict<string, MyStruct>>($parsed['map_of_string_to_MyStruct']);
      $_container4 = dict[];
      foreach($_json3 as $_key1 => $_value2) {
        $_value5 = MyStruct::withDefaultValues();
        $_tmp6 = \json_encode($_value2);
        $_tmp7 = MyStruct::withDefaultValues();
        $_tmp7->readFromJson($_tmp6);
        $_value5 = $_tmp7;
        $_container4[$_key1] = $_value5;
      }
      $this->map_of_string_to_MyStruct = $_container4;
    }
    if (idx($parsed, 'map_of_string_to_list_of_MyStruct') !== null) {
      $_json11 = HH\FIXME\UNSAFE_CAST<mixed, dict<string, vec<MyStruct>>>($parsed['map_of_string_to_list_of_MyStruct']);
      $_container12 = dict[];
      foreach($_json11 as $_key9 => $_value10) {
        $_value13 = vec[];
        $_json17 = $_value10;
        $_container18 = vec[];
        foreach($_json17 as $_key15 => $_value16) {
          $_elem19 = MyStruct::withDefaultValues();
          $_tmp20 = \json_encode($_value16);
          $_tmp21 = MyStruct::withDefaultValues();
          $_tmp21->readFromJson($_tmp20);
          $_elem19 = $_tmp21;
          $_container18 []= $_elem19;
        }
        $_value13 = $_container18;
        $_container12[$_key9] = $_value13;
      }
      $this->map_of_string_to_list_of_MyStruct = $_container12;
    }
    if (idx($parsed, 'map_of_string_to_map_of_string_to_i32') !== null) {
      $_json25 = HH\FIXME\UNSAFE_CAST<mixed, dict<string, dict<string, int>>>($parsed['map_of_string_to_map_of_string_to_i32']);
      $_container26 = dict[];
      foreach($_json25 as $_key23 => $_value24) {
        $_value27 = dict[];
        $_json31 = $_value24;
        $_container32 = dict[];
        foreach($_json31 as $_key29 => $_value30) {
          $_value33 = 0;
          $_tmp34 = (int)$_value30;
          if ($_tmp34 > 0x7fffffff) {
            throw new \TProtocolException("number exceeds limit in field");
          } else {
            $_value33 = (int)$_tmp34;
          }
          $_container32[$_key29] = $_value33;
        }
        $_value27 = $_container32;
        $_container26[$_key23] = $_value27;
      }
      $this->map_of_string_to_map_of_string_to_i32 = $_container26;
    }
    if (idx($parsed, 'map_of_string_to_map_of_string_to_MyStruct') !== null) {
      $_json38 = HH\FIXME\UNSAFE_CAST<mixed, dict<string, dict<string, MyStruct>>>($parsed['map_of_string_to_map_of_string_to_MyStruct']);
      $_container39 = dict[];
      foreach($_json38 as $_key36 => $_value37) {
        $_value40 = dict[];
        $_json44 = $_value37;
        $_container45 = dict[];
        foreach($_json44 as $_key42 => $_value43) {
          $_value46 = MyStruct::withDefaultValues();
          $_tmp47 = \json_encode($_value43);
          $_tmp48 = MyStruct::withDefaultValues();
          $_tmp48->readFromJson($_tmp47);
          $_value46 = $_tmp48;
          $_container45[$_key42] = $_value46;
        }
        $_value40 = $_container45;
        $_container39[$_key36] = $_value40;
      }
      $this->map_of_string_to_map_of_string_to_MyStruct = $_container39;
    }
    if (idx($parsed, 'list_of_map_of_string_to_list_of_MyStruct') !== null) {
      $_json52 = HH\FIXME\UNSAFE_CAST<mixed, vec<dict<string, vec<MyStruct>>>>($parsed['list_of_map_of_string_to_list_of_MyStruct']);
      $_container53 = vec[];
      foreach($_json52 as $_key50 => $_value51) {
        $_elem54 = dict[];
        $_json58 = $_value51;
        $_container59 = dict[];
        foreach($_json58 as $_key56 => $_value57) {
          $_value60 = vec[];
          $_json64 = $_value57;
          $_container65 = vec[];
          foreach($_json64 as $_key62 => $_value63) {
            $_elem66 = MyStruct::withDefaultValues();
            $_tmp67 = \json_encode($_value63);
            $_tmp68 = MyStruct::withDefaultValues();
            $_tmp68->readFromJson($_tmp67);
            $_elem66 = $_tmp68;
            $_container65 []= $_elem66;
          }
          $_value60 = $_container65;
          $_container59[$_key56] = $_value60;
        }
        $_elem54 = $_container59;
        $_container53 []= $_elem54;
      }
      $this->list_of_map_of_string_to_list_of_MyStruct = $_container53;
    }
    if (idx($parsed, 'list_of_map_of_string_to_MyStruct') !== null) {
      $_json72 = HH\FIXME\UNSAFE_CAST<mixed, vec<dict<string, MyStruct>>>($parsed['list_of_map_of_string_to_MyStruct']);
      $_container73 = vec[];
      foreach($_json72 as $_key70 => $_value71) {
        $_elem74 = dict[];
        $_json78 = $_value71;
        $_container79 = dict[];
        foreach($_json78 as $_key76 => $_value77) {
          $_value80 = MyStruct::withDefaultValues();
          $_tmp81 = \json_encode($_value77);
          $_tmp82 = MyStruct::withDefaultValues();
          $_tmp82->readFromJson($_tmp81);
          $_value80 = $_tmp82;
          $_container79[$_key76] = $_value80;
        }
        $_elem74 = $_container79;
        $_container73 []= $_elem74;
      }
      $this->list_of_map_of_string_to_MyStruct = $_container73;
    }
    if (idx($parsed, 'list_of_map_of_string_to_StructWithWrapper') !== null) {
      $_json86 = HH\FIXME\UNSAFE_CAST<mixed, vec<dict<string, StructWithWrapper>>>($parsed['list_of_map_of_string_to_StructWithWrapper']);
      $_container87 = vec[];
      foreach($_json86 as $_key84 => $_value85) {
        $_elem88 = dict[];
        $_json92 = $_value85;
        $_container93 = dict[];
        foreach($_json92 as $_key90 => $_value91) {
          $_value94 = StructWithWrapper::withDefaultValues();
          $_tmp95 = \json_encode($_value91);
          $_tmp96 = StructWithWrapper::withDefaultValues();
          $_tmp96->readFromJson($_tmp95);
          $_value94 = $_tmp96;
          $_container93[$_key90] = $_value94;
        }
        $_elem88 = $_container93;
        $_container87 []= $_elem88;
      }
      $this->list_of_map_of_string_to_StructWithWrapper = $_container87;
    }
  }

}

