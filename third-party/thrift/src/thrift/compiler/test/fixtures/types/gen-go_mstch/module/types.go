// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package module // [[[ program thrift source path ]]]

import (
    "fmt"

    included "included"
    cpp "thrift/annotation/cpp"
    thrift0 "thrift/annotation/thrift"
    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

var _ = included.GoUnusedProtection__
var _ = cpp.GoUnusedProtection__
var _ = thrift0.GoUnusedProtection__

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = thrift.ZERO


type TBinary = []byte

func NewTBinary() TBinary {
  return []byte("")
}

func WriteTBinary(item TBinary, p thrift.Protocol) error {
  if err := p.WriteBinary(item); err != nil {
    return err
}
  return nil
}

func ReadTBinary(p thrift.Protocol) (TBinary, error) {
  var decodeResult TBinary
  decodeErr := func() error {
    result, err := p.ReadBinary()
if err != nil {
    return err
}
    decodeResult = result
    return nil
  }()
  return decodeResult, decodeErr
}

type IntTypedef = int32

func NewIntTypedef() IntTypedef {
  return 0
}

func WriteIntTypedef(item IntTypedef, p thrift.Protocol) error {
  if err := p.WriteI32(item); err != nil {
    return err
}
  return nil
}

func ReadIntTypedef(p thrift.Protocol) (IntTypedef, error) {
  var decodeResult IntTypedef
  decodeErr := func() error {
    result, err := p.ReadI32()
if err != nil {
    return err
}
    decodeResult = result
    return nil
  }()
  return decodeResult, decodeErr
}

type UintTypedef = IntTypedef

func NewUintTypedef() UintTypedef {
  return NewIntTypedef()
}

func WriteUintTypedef(item UintTypedef, p thrift.Protocol) error {
  err := WriteIntTypedef(item, p)
if err != nil {
    return err
}
  return nil
}

func ReadUintTypedef(p thrift.Protocol) (UintTypedef, error) {
  var decodeResult UintTypedef
  decodeErr := func() error {
    result, err := ReadIntTypedef(p)
if err != nil {
    return err
}
    decodeResult = result
    return nil
  }()
  return decodeResult, decodeErr
}

type HasBitwiseOps int32

const (
    HasBitwiseOps_none HasBitwiseOps = 0
    HasBitwiseOps_zero HasBitwiseOps = 1
    HasBitwiseOps_one HasBitwiseOps = 2
    HasBitwiseOps_two HasBitwiseOps = 4
    HasBitwiseOps_three HasBitwiseOps = 8
)

// Enum value maps for HasBitwiseOps
var (
    HasBitwiseOpsToName = map[HasBitwiseOps]string {
        HasBitwiseOps_none: "none",
        HasBitwiseOps_zero: "zero",
        HasBitwiseOps_one: "one",
        HasBitwiseOps_two: "two",
        HasBitwiseOps_three: "three",
    }

    HasBitwiseOpsToValue = map[string]HasBitwiseOps {
        "none": HasBitwiseOps_none,
        "zero": HasBitwiseOps_zero,
        "one": HasBitwiseOps_one,
        "two": HasBitwiseOps_two,
        "three": HasBitwiseOps_three,
    }

    HasBitwiseOpsNames = []string{
        "none",
        "zero",
        "one",
        "two",
        "three",
    }

    HasBitwiseOpsValues = []HasBitwiseOps{
        HasBitwiseOps_none,
        HasBitwiseOps_zero,
        HasBitwiseOps_one,
        HasBitwiseOps_two,
        HasBitwiseOps_three,
    }
)

func (x HasBitwiseOps) String() string {
    if v, ok := HasBitwiseOpsToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x HasBitwiseOps) Ptr() *HasBitwiseOps {
    return &x
}

// Deprecated: Use HasBitwiseOpsToValue instead (e.g. `x, ok := HasBitwiseOpsToValue["name"]`).
func HasBitwiseOpsFromString(s string) (HasBitwiseOps, error) {
    if v, ok := HasBitwiseOpsToValue[s]; ok {
        return v, nil
    }
    return HasBitwiseOps(0), fmt.Errorf("not a valid HasBitwiseOps string")
}

// Deprecated: Use HasBitwiseOps.Ptr() instead.
func HasBitwiseOpsPtr(v HasBitwiseOps) *HasBitwiseOps {
    return &v
}


type IsUnscoped int32

const (
    IsUnscoped_hello IsUnscoped = 0
    IsUnscoped_world IsUnscoped = 1
)

// Enum value maps for IsUnscoped
var (
    IsUnscopedToName = map[IsUnscoped]string {
        IsUnscoped_hello: "hello",
        IsUnscoped_world: "world",
    }

    IsUnscopedToValue = map[string]IsUnscoped {
        "hello": IsUnscoped_hello,
        "world": IsUnscoped_world,
    }

    IsUnscopedNames = []string{
        "hello",
        "world",
    }

    IsUnscopedValues = []IsUnscoped{
        IsUnscoped_hello,
        IsUnscoped_world,
    }
)

func (x IsUnscoped) String() string {
    if v, ok := IsUnscopedToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x IsUnscoped) Ptr() *IsUnscoped {
    return &x
}

// Deprecated: Use IsUnscopedToValue instead (e.g. `x, ok := IsUnscopedToValue["name"]`).
func IsUnscopedFromString(s string) (IsUnscoped, error) {
    if v, ok := IsUnscopedToValue[s]; ok {
        return v, nil
    }
    return IsUnscoped(0), fmt.Errorf("not a valid IsUnscoped string")
}

// Deprecated: Use IsUnscoped.Ptr() instead.
func IsUnscopedPtr(v IsUnscoped) *IsUnscoped {
    return &v
}


type MyForwardRefEnum int32

const (
    MyForwardRefEnum_ZERO MyForwardRefEnum = 0
    MyForwardRefEnum_NONZERO MyForwardRefEnum = 12
)

// Enum value maps for MyForwardRefEnum
var (
    MyForwardRefEnumToName = map[MyForwardRefEnum]string {
        MyForwardRefEnum_ZERO: "ZERO",
        MyForwardRefEnum_NONZERO: "NONZERO",
    }

    MyForwardRefEnumToValue = map[string]MyForwardRefEnum {
        "ZERO": MyForwardRefEnum_ZERO,
        "NONZERO": MyForwardRefEnum_NONZERO,
    }

    MyForwardRefEnumNames = []string{
        "ZERO",
        "NONZERO",
    }

    MyForwardRefEnumValues = []MyForwardRefEnum{
        MyForwardRefEnum_ZERO,
        MyForwardRefEnum_NONZERO,
    }
)

func (x MyForwardRefEnum) String() string {
    if v, ok := MyForwardRefEnumToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x MyForwardRefEnum) Ptr() *MyForwardRefEnum {
    return &x
}

// Deprecated: Use MyForwardRefEnumToValue instead (e.g. `x, ok := MyForwardRefEnumToValue["name"]`).
func MyForwardRefEnumFromString(s string) (MyForwardRefEnum, error) {
    if v, ok := MyForwardRefEnumToValue[s]; ok {
        return v, nil
    }
    return MyForwardRefEnum(0), fmt.Errorf("not a valid MyForwardRefEnum string")
}

// Deprecated: Use MyForwardRefEnum.Ptr() instead.
func MyForwardRefEnumPtr(v MyForwardRefEnum) *MyForwardRefEnum {
    return &v
}


type EmptyStruct struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &EmptyStruct{}


func NewEmptyStruct() *EmptyStruct {
    return (&EmptyStruct{})
}

func (x *EmptyStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use EmptyStruct.Set* methods instead or set the fields directly.
type EmptyStructBuilder struct {
    obj *EmptyStruct
}

func NewEmptyStructBuilder() *EmptyStructBuilder {
    return &EmptyStructBuilder{
        obj: NewEmptyStruct(),
    }
}

func (x *EmptyStructBuilder) Emit() *EmptyStruct {
    var objCopy EmptyStruct = *x.obj
    return &objCopy
}

func (x *EmptyStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("empty_struct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *EmptyStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type DecoratedStruct struct {
    Field string `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DecoratedStruct{}


func NewDecoratedStruct() *DecoratedStruct {
    return (&DecoratedStruct{})
}

func (x *DecoratedStruct) GetFieldNonCompat() string {
    return x.Field
}

func (x *DecoratedStruct) GetField() string {
    return x.Field
}

func (x *DecoratedStruct) SetField(value string) *DecoratedStruct {
    x.Field = value
    return x
}


func (x *DecoratedStruct) writeField1(p thrift.Protocol) error {  // Field
    if err := p.WriteFieldBegin("field", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DecoratedStruct) readField1(p thrift.Protocol) error {  // Field
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetField(result)
    return nil
}

func (x *DecoratedStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use DecoratedStruct.Set* methods instead or set the fields directly.
type DecoratedStructBuilder struct {
    obj *DecoratedStruct
}

func NewDecoratedStructBuilder() *DecoratedStructBuilder {
    return &DecoratedStructBuilder{
        obj: NewDecoratedStruct(),
    }
}

func (x *DecoratedStructBuilder) Field(value string) *DecoratedStructBuilder {
    x.obj.Field = value
    return x
}

func (x *DecoratedStructBuilder) Emit() *DecoratedStruct {
    var objCopy DecoratedStruct = *x.obj
    return &objCopy
}

func (x *DecoratedStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("decorated_struct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DecoratedStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type ContainerStruct struct {
    FieldA []int32 `thrift:"fieldA,12" json:"fieldA" db:"fieldA"`
    FieldB []int32 `thrift:"fieldB,2" json:"fieldB" db:"fieldB"`
    FieldC []int32 `thrift:"fieldC,3" json:"fieldC" db:"fieldC"`
    FieldD []int32 `thrift:"fieldD,4" json:"fieldD" db:"fieldD"`
    FieldE []int32 `thrift:"fieldE,5" json:"fieldE" db:"fieldE"`
    FieldF []int32 `thrift:"fieldF,6" json:"fieldF" db:"fieldF"`
    FieldG map[int32]string `thrift:"fieldG,7" json:"fieldG" db:"fieldG"`
    FieldH included.SomeMap `thrift:"fieldH,8" json:"fieldH" db:"fieldH"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ContainerStruct{}


func NewContainerStruct() *ContainerStruct {
    return (&ContainerStruct{})
}

func (x *ContainerStruct) GetFieldANonCompat() []int32 {
    return x.FieldA
}

func (x *ContainerStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
      return nil
    }

    return x.FieldA
}

func (x *ContainerStruct) GetFieldBNonCompat() []int32 {
    return x.FieldB
}

func (x *ContainerStruct) GetFieldB() []int32 {
    if !x.IsSetFieldB() {
      return nil
    }

    return x.FieldB
}

func (x *ContainerStruct) GetFieldCNonCompat() []int32 {
    return x.FieldC
}

func (x *ContainerStruct) GetFieldC() []int32 {
    if !x.IsSetFieldC() {
      return nil
    }

    return x.FieldC
}

func (x *ContainerStruct) GetFieldDNonCompat() []int32 {
    return x.FieldD
}

func (x *ContainerStruct) GetFieldD() []int32 {
    if !x.IsSetFieldD() {
      return nil
    }

    return x.FieldD
}

func (x *ContainerStruct) GetFieldENonCompat() []int32 {
    return x.FieldE
}

func (x *ContainerStruct) GetFieldE() []int32 {
    if !x.IsSetFieldE() {
      return nil
    }

    return x.FieldE
}

func (x *ContainerStruct) GetFieldFNonCompat() []int32 {
    return x.FieldF
}

func (x *ContainerStruct) GetFieldF() []int32 {
    if !x.IsSetFieldF() {
      return nil
    }

    return x.FieldF
}

func (x *ContainerStruct) GetFieldGNonCompat() map[int32]string {
    return x.FieldG
}

func (x *ContainerStruct) GetFieldG() map[int32]string {
    if !x.IsSetFieldG() {
      return nil
    }

    return x.FieldG
}

func (x *ContainerStruct) GetFieldHNonCompat() included.SomeMap {
    return x.FieldH
}

func (x *ContainerStruct) GetFieldH() included.SomeMap {
    if !x.IsSetFieldH() {
      return included.NewSomeMap()
    }

    return x.FieldH
}

func (x *ContainerStruct) SetFieldA(value []int32) *ContainerStruct {
    x.FieldA = value
    return x
}

func (x *ContainerStruct) SetFieldB(value []int32) *ContainerStruct {
    x.FieldB = value
    return x
}

func (x *ContainerStruct) SetFieldC(value []int32) *ContainerStruct {
    x.FieldC = value
    return x
}

func (x *ContainerStruct) SetFieldD(value []int32) *ContainerStruct {
    x.FieldD = value
    return x
}

func (x *ContainerStruct) SetFieldE(value []int32) *ContainerStruct {
    x.FieldE = value
    return x
}

func (x *ContainerStruct) SetFieldF(value []int32) *ContainerStruct {
    x.FieldF = value
    return x
}

func (x *ContainerStruct) SetFieldG(value map[int32]string) *ContainerStruct {
    x.FieldG = value
    return x
}

func (x *ContainerStruct) SetFieldH(value included.SomeMap) *ContainerStruct {
    x.FieldH = value
    return x
}

func (x *ContainerStruct) IsSetFieldA() bool {
    return x.FieldA != nil
}

func (x *ContainerStruct) IsSetFieldB() bool {
    return x.FieldB != nil
}

func (x *ContainerStruct) IsSetFieldC() bool {
    return x.FieldC != nil
}

func (x *ContainerStruct) IsSetFieldD() bool {
    return x.FieldD != nil
}

func (x *ContainerStruct) IsSetFieldE() bool {
    return x.FieldE != nil
}

func (x *ContainerStruct) IsSetFieldF() bool {
    return x.FieldF != nil
}

func (x *ContainerStruct) IsSetFieldG() bool {
    return x.FieldG != nil
}

func (x *ContainerStruct) IsSetFieldH() bool {
    return x.FieldH != nil
}

func (x *ContainerStruct) writeField12(p thrift.Protocol) error {  // FieldA
    if !x.IsSetFieldA() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 12); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldANonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField2(p thrift.Protocol) error {  // FieldB
    if !x.IsSetFieldB() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldB", thrift.LIST, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldBNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField3(p thrift.Protocol) error {  // FieldC
    if !x.IsSetFieldC() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldC", thrift.LIST, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldCNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField4(p thrift.Protocol) error {  // FieldD
    if !x.IsSetFieldD() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldD", thrift.LIST, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldDNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField5(p thrift.Protocol) error {  // FieldE
    if !x.IsSetFieldE() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldE", thrift.LIST, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldENonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField6(p thrift.Protocol) error {  // FieldF
    if !x.IsSetFieldF() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldF", thrift.SET, 6); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldFNonCompat()
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteSetEnd(); err != nil {
    return thrift.PrependError("error writing set end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField7(p thrift.Protocol) error {  // FieldG
    if !x.IsSetFieldG() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldG", thrift.MAP, 7); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldGNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.STRING, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteString(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField8(p thrift.Protocol) error {  // FieldH
    if !x.IsSetFieldH() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldH", thrift.MAP, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldHNonCompat()
    err := included.WriteSomeMap(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) readField12(p thrift.Protocol) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldA(result)
    return nil
}

func (x *ContainerStruct) readField2(p thrift.Protocol) error {  // FieldB
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldB(result)
    return nil
}

func (x *ContainerStruct) readField3(p thrift.Protocol) error {  // FieldC
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldC(result)
    return nil
}

func (x *ContainerStruct) readField4(p thrift.Protocol) error {  // FieldD
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldD(result)
    return nil
}

func (x *ContainerStruct) readField5(p thrift.Protocol) error {  // FieldE
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldE(result)
    return nil
}

func (x *ContainerStruct) readField6(p thrift.Protocol) error {  // FieldF
    _ /* elemType */, size, err := p.ReadSetBegin()
if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
}

setResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    setResult = append(setResult, elem)
}

if err := p.ReadSetEnd(); err != nil {
    return thrift.PrependError("error reading set end: ", err)
}
result := setResult

    x.SetFieldF(result)
    return nil
}

func (x *ContainerStruct) readField7(p thrift.Protocol) error {  // FieldG
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]string, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value string
    {
        result, err := p.ReadString()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetFieldG(result)
    return nil
}

func (x *ContainerStruct) readField8(p thrift.Protocol) error {  // FieldH
    result, err := included.ReadSomeMap(p)
if err != nil {
    return err
}

    x.SetFieldH(result)
    return nil
}

func (x *ContainerStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use ContainerStruct.Set* methods instead or set the fields directly.
type ContainerStructBuilder struct {
    obj *ContainerStruct
}

func NewContainerStructBuilder() *ContainerStructBuilder {
    return &ContainerStructBuilder{
        obj: NewContainerStruct(),
    }
}

func (x *ContainerStructBuilder) FieldA(value []int32) *ContainerStructBuilder {
    x.obj.FieldA = value
    return x
}

func (x *ContainerStructBuilder) FieldB(value []int32) *ContainerStructBuilder {
    x.obj.FieldB = value
    return x
}

func (x *ContainerStructBuilder) FieldC(value []int32) *ContainerStructBuilder {
    x.obj.FieldC = value
    return x
}

func (x *ContainerStructBuilder) FieldD(value []int32) *ContainerStructBuilder {
    x.obj.FieldD = value
    return x
}

func (x *ContainerStructBuilder) FieldE(value []int32) *ContainerStructBuilder {
    x.obj.FieldE = value
    return x
}

func (x *ContainerStructBuilder) FieldF(value []int32) *ContainerStructBuilder {
    x.obj.FieldF = value
    return x
}

func (x *ContainerStructBuilder) FieldG(value map[int32]string) *ContainerStructBuilder {
    x.obj.FieldG = value
    return x
}

func (x *ContainerStructBuilder) FieldH(value included.SomeMap) *ContainerStructBuilder {
    x.obj.FieldH = value
    return x
}

func (x *ContainerStructBuilder) Emit() *ContainerStruct {
    var objCopy ContainerStruct = *x.obj
    return &objCopy
}

func (x *ContainerStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ContainerStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField12(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := x.writeField6(p); err != nil {
        return err
    }

    if err := x.writeField7(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 12:  // fieldA
            if err := x.readField12(p); err != nil {
                return err
            }
        case 2:  // fieldB
            if err := x.readField2(p); err != nil {
                return err
            }
        case 3:  // fieldC
            if err := x.readField3(p); err != nil {
                return err
            }
        case 4:  // fieldD
            if err := x.readField4(p); err != nil {
                return err
            }
        case 5:  // fieldE
            if err := x.readField5(p); err != nil {
                return err
            }
        case 6:  // fieldF
            if err := x.readField6(p); err != nil {
                return err
            }
        case 7:  // fieldG
            if err := x.readField7(p); err != nil {
                return err
            }
        case 8:  // fieldH
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type CppTypeStruct struct {
    FieldA []int32 `thrift:"fieldA,1" json:"fieldA" db:"fieldA"`
}
// Compile time interface enforcer
var _ thrift.Struct = &CppTypeStruct{}


func NewCppTypeStruct() *CppTypeStruct {
    return (&CppTypeStruct{})
}

func (x *CppTypeStruct) GetFieldANonCompat() []int32 {
    return x.FieldA
}

func (x *CppTypeStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
      return nil
    }

    return x.FieldA
}

func (x *CppTypeStruct) SetFieldA(value []int32) *CppTypeStruct {
    x.FieldA = value
    return x
}

func (x *CppTypeStruct) IsSetFieldA() bool {
    return x.FieldA != nil
}

func (x *CppTypeStruct) writeField1(p thrift.Protocol) error {  // FieldA
    if !x.IsSetFieldA() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldANonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CppTypeStruct) readField1(p thrift.Protocol) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldA(result)
    return nil
}

func (x *CppTypeStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use CppTypeStruct.Set* methods instead or set the fields directly.
type CppTypeStructBuilder struct {
    obj *CppTypeStruct
}

func NewCppTypeStructBuilder() *CppTypeStructBuilder {
    return &CppTypeStructBuilder{
        obj: NewCppTypeStruct(),
    }
}

func (x *CppTypeStructBuilder) FieldA(value []int32) *CppTypeStructBuilder {
    x.obj.FieldA = value
    return x
}

func (x *CppTypeStructBuilder) Emit() *CppTypeStruct {
    var objCopy CppTypeStruct = *x.obj
    return &objCopy
}

func (x *CppTypeStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CppTypeStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CppTypeStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // fieldA
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type VirtualStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
}
// Compile time interface enforcer
var _ thrift.Struct = &VirtualStruct{}


func NewVirtualStruct() *VirtualStruct {
    return (&VirtualStruct{})
}

func (x *VirtualStruct) GetMyIntFieldNonCompat() int64 {
    return x.MyIntField
}

func (x *VirtualStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *VirtualStruct) SetMyIntField(value int64) *VirtualStruct {
    x.MyIntField = value
    return x
}


func (x *VirtualStruct) writeField1(p thrift.Protocol) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyIntFieldNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *VirtualStruct) readField1(p thrift.Protocol) error {  // MyIntField
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetMyIntField(result)
    return nil
}

func (x *VirtualStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use VirtualStruct.Set* methods instead or set the fields directly.
type VirtualStructBuilder struct {
    obj *VirtualStruct
}

func NewVirtualStructBuilder() *VirtualStructBuilder {
    return &VirtualStructBuilder{
        obj: NewVirtualStruct(),
    }
}

func (x *VirtualStructBuilder) MyIntField(value int64) *VirtualStructBuilder {
    x.obj.MyIntField = value
    return x
}

func (x *VirtualStructBuilder) Emit() *VirtualStruct {
    var objCopy VirtualStruct = *x.obj
    return &objCopy
}

func (x *VirtualStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("VirtualStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *VirtualStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // MyIntField
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type MyStructWithForwardRefEnum struct {
    A MyForwardRefEnum `thrift:"a,1" json:"a" db:"a"`
    B MyForwardRefEnum `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MyStructWithForwardRefEnum{}


func NewMyStructWithForwardRefEnum() *MyStructWithForwardRefEnum {
    return (&MyStructWithForwardRefEnum{}).
        SetA(
            MyForwardRefEnum_NONZERO,
        ).
        SetB(
            MyForwardRefEnum_NONZERO,
        )
}

func (x *MyStructWithForwardRefEnum) GetANonCompat() MyForwardRefEnum {
    return x.A
}

func (x *MyStructWithForwardRefEnum) GetA() MyForwardRefEnum {
    return x.A
}

func (x *MyStructWithForwardRefEnum) GetBNonCompat() MyForwardRefEnum {
    return x.B
}

func (x *MyStructWithForwardRefEnum) GetB() MyForwardRefEnum {
    return x.B
}

func (x *MyStructWithForwardRefEnum) SetA(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.A = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetB(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.B = value
    return x
}



func (x *MyStructWithForwardRefEnum) writeField1(p thrift.Protocol) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetANonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) writeField2(p thrift.Protocol) error {  // B
    if err := p.WriteFieldBegin("b", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) readField1(p thrift.Protocol) error {  // A
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := MyForwardRefEnum(enumResult)

    x.SetA(result)
    return nil
}

func (x *MyStructWithForwardRefEnum) readField2(p thrift.Protocol) error {  // B
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := MyForwardRefEnum(enumResult)

    x.SetB(result)
    return nil
}

func (x *MyStructWithForwardRefEnum) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use MyStructWithForwardRefEnum.Set* methods instead or set the fields directly.
type MyStructWithForwardRefEnumBuilder struct {
    obj *MyStructWithForwardRefEnum
}

func NewMyStructWithForwardRefEnumBuilder() *MyStructWithForwardRefEnumBuilder {
    return &MyStructWithForwardRefEnumBuilder{
        obj: NewMyStructWithForwardRefEnum(),
    }
}

func (x *MyStructWithForwardRefEnumBuilder) A(value MyForwardRefEnum) *MyStructWithForwardRefEnumBuilder {
    x.obj.A = value
    return x
}

func (x *MyStructWithForwardRefEnumBuilder) B(value MyForwardRefEnum) *MyStructWithForwardRefEnumBuilder {
    x.obj.B = value
    return x
}

func (x *MyStructWithForwardRefEnumBuilder) Emit() *MyStructWithForwardRefEnum {
    var objCopy MyStructWithForwardRefEnum = *x.obj
    return &objCopy
}

func (x *MyStructWithForwardRefEnum) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MyStructWithForwardRefEnum"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // a
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // b
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type TrivialNumeric struct {
    A int32 `thrift:"a,1" json:"a" db:"a"`
    B bool `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = &TrivialNumeric{}


func NewTrivialNumeric() *TrivialNumeric {
    return (&TrivialNumeric{})
}

func (x *TrivialNumeric) GetANonCompat() int32 {
    return x.A
}

func (x *TrivialNumeric) GetA() int32 {
    return x.A
}

func (x *TrivialNumeric) GetBNonCompat() bool {
    return x.B
}

func (x *TrivialNumeric) GetB() bool {
    return x.B
}

func (x *TrivialNumeric) SetA(value int32) *TrivialNumeric {
    x.A = value
    return x
}

func (x *TrivialNumeric) SetB(value bool) *TrivialNumeric {
    x.B = value
    return x
}



func (x *TrivialNumeric) writeField1(p thrift.Protocol) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetANonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) writeField2(p thrift.Protocol) error {  // B
    if err := p.WriteFieldBegin("b", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) readField1(p thrift.Protocol) error {  // A
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetA(result)
    return nil
}

func (x *TrivialNumeric) readField2(p thrift.Protocol) error {  // B
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetB(result)
    return nil
}

func (x *TrivialNumeric) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use TrivialNumeric.Set* methods instead or set the fields directly.
type TrivialNumericBuilder struct {
    obj *TrivialNumeric
}

func NewTrivialNumericBuilder() *TrivialNumericBuilder {
    return &TrivialNumericBuilder{
        obj: NewTrivialNumeric(),
    }
}

func (x *TrivialNumericBuilder) A(value int32) *TrivialNumericBuilder {
    x.obj.A = value
    return x
}

func (x *TrivialNumericBuilder) B(value bool) *TrivialNumericBuilder {
    x.obj.B = value
    return x
}

func (x *TrivialNumericBuilder) Emit() *TrivialNumeric {
    var objCopy TrivialNumeric = *x.obj
    return &objCopy
}

func (x *TrivialNumeric) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TrivialNumeric"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // a
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // b
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type TrivialNestedWithDefault struct {
    Z int32 `thrift:"z,1" json:"z" db:"z"`
    N *TrivialNumeric `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = &TrivialNestedWithDefault{}


func NewTrivialNestedWithDefault() *TrivialNestedWithDefault {
    return (&TrivialNestedWithDefault{}).
        SetZ(4).
        SetN(
            *NewTrivialNumeric().
    SetA(3).
    SetB(true),
        )
}

// Deprecated: Use NewTrivialNestedWithDefault().N instead.
var TrivialNestedWithDefault_N_DEFAULT = NewTrivialNestedWithDefault().N

func (x *TrivialNestedWithDefault) GetZNonCompat() int32 {
    return x.Z
}

func (x *TrivialNestedWithDefault) GetZ() int32 {
    return x.Z
}

func (x *TrivialNestedWithDefault) GetNNonCompat() *TrivialNumeric {
    return x.N
}

func (x *TrivialNestedWithDefault) GetN() *TrivialNumeric {
    if !x.IsSetN() {
      return NewTrivialNumeric()
    }

    return x.N
}

func (x *TrivialNestedWithDefault) SetZ(value int32) *TrivialNestedWithDefault {
    x.Z = value
    return x
}

func (x *TrivialNestedWithDefault) SetN(value TrivialNumeric) *TrivialNestedWithDefault {
    x.N = &value
    return x
}


func (x *TrivialNestedWithDefault) IsSetN() bool {
    return x.N != nil
}

func (x *TrivialNestedWithDefault) writeField1(p thrift.Protocol) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetZNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) writeField2(p thrift.Protocol) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) readField1(p thrift.Protocol) error {  // Z
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetZ(result)
    return nil
}

func (x *TrivialNestedWithDefault) readField2(p thrift.Protocol) error {  // N
    result := *NewTrivialNumeric()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetN(result)
    return nil
}

func (x *TrivialNestedWithDefault) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use TrivialNestedWithDefault.Set* methods instead or set the fields directly.
type TrivialNestedWithDefaultBuilder struct {
    obj *TrivialNestedWithDefault
}

func NewTrivialNestedWithDefaultBuilder() *TrivialNestedWithDefaultBuilder {
    return &TrivialNestedWithDefaultBuilder{
        obj: NewTrivialNestedWithDefault(),
    }
}

func (x *TrivialNestedWithDefaultBuilder) Z(value int32) *TrivialNestedWithDefaultBuilder {
    x.obj.Z = value
    return x
}

func (x *TrivialNestedWithDefaultBuilder) N(value *TrivialNumeric) *TrivialNestedWithDefaultBuilder {
    x.obj.N = value
    return x
}

func (x *TrivialNestedWithDefaultBuilder) Emit() *TrivialNestedWithDefault {
    var objCopy TrivialNestedWithDefault = *x.obj
    return &objCopy
}

func (x *TrivialNestedWithDefault) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TrivialNestedWithDefault"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // z
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // n
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type ComplexString struct {
    A string `thrift:"a,1" json:"a" db:"a"`
    B map[string]int32 `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ComplexString{}


func NewComplexString() *ComplexString {
    return (&ComplexString{})
}

func (x *ComplexString) GetANonCompat() string {
    return x.A
}

func (x *ComplexString) GetA() string {
    return x.A
}

func (x *ComplexString) GetBNonCompat() map[string]int32 {
    return x.B
}

func (x *ComplexString) GetB() map[string]int32 {
    if !x.IsSetB() {
      return nil
    }

    return x.B
}

func (x *ComplexString) SetA(value string) *ComplexString {
    x.A = value
    return x
}

func (x *ComplexString) SetB(value map[string]int32) *ComplexString {
    x.B = value
    return x
}


func (x *ComplexString) IsSetB() bool {
    return x.B != nil
}

func (x *ComplexString) writeField1(p thrift.Protocol) error {  // A
    if err := p.WriteFieldBegin("a", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetANonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) writeField2(p thrift.Protocol) error {  // B
    if !x.IsSetB() {
        return nil
    }

    if err := p.WriteFieldBegin("b", thrift.MAP, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBNonCompat()
    if err := p.WriteMapBegin(thrift.STRING, thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteString(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) readField1(p thrift.Protocol) error {  // A
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetA(result)
    return nil
}

func (x *ComplexString) readField2(p thrift.Protocol) error {  // B
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[string]int32, size)
for i := 0; i < size; i++ {
    var key string
    {
        result, err := p.ReadString()
if err != nil {
    return err
}
        key = result
    }

    var value int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetB(result)
    return nil
}

func (x *ComplexString) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use ComplexString.Set* methods instead or set the fields directly.
type ComplexStringBuilder struct {
    obj *ComplexString
}

func NewComplexStringBuilder() *ComplexStringBuilder {
    return &ComplexStringBuilder{
        obj: NewComplexString(),
    }
}

func (x *ComplexStringBuilder) A(value string) *ComplexStringBuilder {
    x.obj.A = value
    return x
}

func (x *ComplexStringBuilder) B(value map[string]int32) *ComplexStringBuilder {
    x.obj.B = value
    return x
}

func (x *ComplexStringBuilder) Emit() *ComplexString {
    var objCopy ComplexString = *x.obj
    return &objCopy
}

func (x *ComplexString) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ComplexString"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // a
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // b
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type ComplexNestedWithDefault struct {
    Z string `thrift:"z,1" json:"z" db:"z"`
    N *ComplexString `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ComplexNestedWithDefault{}


func NewComplexNestedWithDefault() *ComplexNestedWithDefault {
    return (&ComplexNestedWithDefault{}).
        SetZ("4").
        SetN(
            *NewComplexString().
    SetA("3").
    SetB(
        map[string]int32{
    "a": 3,
},
    ),
        )
}

// Deprecated: Use NewComplexNestedWithDefault().N instead.
var ComplexNestedWithDefault_N_DEFAULT = NewComplexNestedWithDefault().N

func (x *ComplexNestedWithDefault) GetZNonCompat() string {
    return x.Z
}

func (x *ComplexNestedWithDefault) GetZ() string {
    return x.Z
}

func (x *ComplexNestedWithDefault) GetNNonCompat() *ComplexString {
    return x.N
}

func (x *ComplexNestedWithDefault) GetN() *ComplexString {
    if !x.IsSetN() {
      return NewComplexString()
    }

    return x.N
}

func (x *ComplexNestedWithDefault) SetZ(value string) *ComplexNestedWithDefault {
    x.Z = value
    return x
}

func (x *ComplexNestedWithDefault) SetN(value ComplexString) *ComplexNestedWithDefault {
    x.N = &value
    return x
}


func (x *ComplexNestedWithDefault) IsSetN() bool {
    return x.N != nil
}

func (x *ComplexNestedWithDefault) writeField1(p thrift.Protocol) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetZNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) writeField2(p thrift.Protocol) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) readField1(p thrift.Protocol) error {  // Z
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetZ(result)
    return nil
}

func (x *ComplexNestedWithDefault) readField2(p thrift.Protocol) error {  // N
    result := *NewComplexString()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetN(result)
    return nil
}

func (x *ComplexNestedWithDefault) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use ComplexNestedWithDefault.Set* methods instead or set the fields directly.
type ComplexNestedWithDefaultBuilder struct {
    obj *ComplexNestedWithDefault
}

func NewComplexNestedWithDefaultBuilder() *ComplexNestedWithDefaultBuilder {
    return &ComplexNestedWithDefaultBuilder{
        obj: NewComplexNestedWithDefault(),
    }
}

func (x *ComplexNestedWithDefaultBuilder) Z(value string) *ComplexNestedWithDefaultBuilder {
    x.obj.Z = value
    return x
}

func (x *ComplexNestedWithDefaultBuilder) N(value *ComplexString) *ComplexNestedWithDefaultBuilder {
    x.obj.N = value
    return x
}

func (x *ComplexNestedWithDefaultBuilder) Emit() *ComplexNestedWithDefault {
    var objCopy ComplexNestedWithDefault = *x.obj
    return &objCopy
}

func (x *ComplexNestedWithDefault) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ComplexNestedWithDefault"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // z
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // n
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type MinPadding struct {
    Small byte `thrift:"small,1,required" json:"small" db:"small"`
    Big int64 `thrift:"big,2,required" json:"big" db:"big"`
    Medium int16 `thrift:"medium,3,required" json:"medium" db:"medium"`
    Biggish int32 `thrift:"biggish,4,required" json:"biggish" db:"biggish"`
    Tiny byte `thrift:"tiny,5,required" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MinPadding{}


func NewMinPadding() *MinPadding {
    return (&MinPadding{})
}

func (x *MinPadding) GetSmallNonCompat() byte {
    return x.Small
}

func (x *MinPadding) GetSmall() byte {
    return x.Small
}

func (x *MinPadding) GetBigNonCompat() int64 {
    return x.Big
}

func (x *MinPadding) GetBig() int64 {
    return x.Big
}

func (x *MinPadding) GetMediumNonCompat() int16 {
    return x.Medium
}

func (x *MinPadding) GetMedium() int16 {
    return x.Medium
}

func (x *MinPadding) GetBiggishNonCompat() int32 {
    return x.Biggish
}

func (x *MinPadding) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPadding) GetTinyNonCompat() byte {
    return x.Tiny
}

func (x *MinPadding) GetTiny() byte {
    return x.Tiny
}

func (x *MinPadding) SetSmall(value byte) *MinPadding {
    x.Small = value
    return x
}

func (x *MinPadding) SetBig(value int64) *MinPadding {
    x.Big = value
    return x
}

func (x *MinPadding) SetMedium(value int16) *MinPadding {
    x.Medium = value
    return x
}

func (x *MinPadding) SetBiggish(value int32) *MinPadding {
    x.Biggish = value
    return x
}

func (x *MinPadding) SetTiny(value byte) *MinPadding {
    x.Tiny = value
    return x
}






func (x *MinPadding) writeField1(p thrift.Protocol) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetSmallNonCompat()
    if err := p.WriteByte(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField2(p thrift.Protocol) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBigNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField3(p thrift.Protocol) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMediumNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField4(p thrift.Protocol) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBiggishNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField5(p thrift.Protocol) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTinyNonCompat()
    if err := p.WriteByte(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) readField1(p thrift.Protocol) error {  // Small
    result, err := p.ReadByte()
if err != nil {
    return err
}

    x.SetSmall(result)
    return nil
}

func (x *MinPadding) readField2(p thrift.Protocol) error {  // Big
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetBig(result)
    return nil
}

func (x *MinPadding) readField3(p thrift.Protocol) error {  // Medium
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetMedium(result)
    return nil
}

func (x *MinPadding) readField4(p thrift.Protocol) error {  // Biggish
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetBiggish(result)
    return nil
}

func (x *MinPadding) readField5(p thrift.Protocol) error {  // Tiny
    result, err := p.ReadByte()
if err != nil {
    return err
}

    x.SetTiny(result)
    return nil
}

func (x *MinPadding) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use MinPadding.Set* methods instead or set the fields directly.
type MinPaddingBuilder struct {
    obj *MinPadding
}

func NewMinPaddingBuilder() *MinPaddingBuilder {
    return &MinPaddingBuilder{
        obj: NewMinPadding(),
    }
}

func (x *MinPaddingBuilder) Small(value byte) *MinPaddingBuilder {
    x.obj.Small = value
    return x
}

func (x *MinPaddingBuilder) Big(value int64) *MinPaddingBuilder {
    x.obj.Big = value
    return x
}

func (x *MinPaddingBuilder) Medium(value int16) *MinPaddingBuilder {
    x.obj.Medium = value
    return x
}

func (x *MinPaddingBuilder) Biggish(value int32) *MinPaddingBuilder {
    x.obj.Biggish = value
    return x
}

func (x *MinPaddingBuilder) Tiny(value byte) *MinPaddingBuilder {
    x.obj.Tiny = value
    return x
}

func (x *MinPaddingBuilder) Emit() *MinPadding {
    var objCopy MinPadding = *x.obj
    return &objCopy
}

func (x *MinPadding) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MinPadding"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // small
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // big
            if err := x.readField2(p); err != nil {
                return err
            }
        case 3:  // medium
            if err := x.readField3(p); err != nil {
                return err
            }
        case 4:  // biggish
            if err := x.readField4(p); err != nil {
                return err
            }
        case 5:  // tiny
            if err := x.readField5(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type MinPaddingWithCustomType struct {
    Small byte `thrift:"small,1" json:"small" db:"small"`
    Big int64 `thrift:"big,2" json:"big" db:"big"`
    Medium int16 `thrift:"medium,3" json:"medium" db:"medium"`
    Biggish int32 `thrift:"biggish,4" json:"biggish" db:"biggish"`
    Tiny byte `thrift:"tiny,5" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MinPaddingWithCustomType{}


func NewMinPaddingWithCustomType() *MinPaddingWithCustomType {
    return (&MinPaddingWithCustomType{})
}

func (x *MinPaddingWithCustomType) GetSmallNonCompat() byte {
    return x.Small
}

func (x *MinPaddingWithCustomType) GetSmall() byte {
    return x.Small
}

func (x *MinPaddingWithCustomType) GetBigNonCompat() int64 {
    return x.Big
}

func (x *MinPaddingWithCustomType) GetBig() int64 {
    return x.Big
}

func (x *MinPaddingWithCustomType) GetMediumNonCompat() int16 {
    return x.Medium
}

func (x *MinPaddingWithCustomType) GetMedium() int16 {
    return x.Medium
}

func (x *MinPaddingWithCustomType) GetBiggishNonCompat() int32 {
    return x.Biggish
}

func (x *MinPaddingWithCustomType) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPaddingWithCustomType) GetTinyNonCompat() byte {
    return x.Tiny
}

func (x *MinPaddingWithCustomType) GetTiny() byte {
    return x.Tiny
}

func (x *MinPaddingWithCustomType) SetSmall(value byte) *MinPaddingWithCustomType {
    x.Small = value
    return x
}

func (x *MinPaddingWithCustomType) SetBig(value int64) *MinPaddingWithCustomType {
    x.Big = value
    return x
}

func (x *MinPaddingWithCustomType) SetMedium(value int16) *MinPaddingWithCustomType {
    x.Medium = value
    return x
}

func (x *MinPaddingWithCustomType) SetBiggish(value int32) *MinPaddingWithCustomType {
    x.Biggish = value
    return x
}

func (x *MinPaddingWithCustomType) SetTiny(value byte) *MinPaddingWithCustomType {
    x.Tiny = value
    return x
}






func (x *MinPaddingWithCustomType) writeField1(p thrift.Protocol) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetSmallNonCompat()
    if err := p.WriteByte(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField2(p thrift.Protocol) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBigNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField3(p thrift.Protocol) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMediumNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField4(p thrift.Protocol) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBiggishNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField5(p thrift.Protocol) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTinyNonCompat()
    if err := p.WriteByte(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) readField1(p thrift.Protocol) error {  // Small
    result, err := p.ReadByte()
if err != nil {
    return err
}

    x.SetSmall(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField2(p thrift.Protocol) error {  // Big
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetBig(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField3(p thrift.Protocol) error {  // Medium
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetMedium(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField4(p thrift.Protocol) error {  // Biggish
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetBiggish(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField5(p thrift.Protocol) error {  // Tiny
    result, err := p.ReadByte()
if err != nil {
    return err
}

    x.SetTiny(result)
    return nil
}

func (x *MinPaddingWithCustomType) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use MinPaddingWithCustomType.Set* methods instead or set the fields directly.
type MinPaddingWithCustomTypeBuilder struct {
    obj *MinPaddingWithCustomType
}

func NewMinPaddingWithCustomTypeBuilder() *MinPaddingWithCustomTypeBuilder {
    return &MinPaddingWithCustomTypeBuilder{
        obj: NewMinPaddingWithCustomType(),
    }
}

func (x *MinPaddingWithCustomTypeBuilder) Small(value byte) *MinPaddingWithCustomTypeBuilder {
    x.obj.Small = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Big(value int64) *MinPaddingWithCustomTypeBuilder {
    x.obj.Big = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Medium(value int16) *MinPaddingWithCustomTypeBuilder {
    x.obj.Medium = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Biggish(value int32) *MinPaddingWithCustomTypeBuilder {
    x.obj.Biggish = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Tiny(value byte) *MinPaddingWithCustomTypeBuilder {
    x.obj.Tiny = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Emit() *MinPaddingWithCustomType {
    var objCopy MinPaddingWithCustomType = *x.obj
    return &objCopy
}

func (x *MinPaddingWithCustomType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MinPaddingWithCustomType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // small
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // big
            if err := x.readField2(p); err != nil {
                return err
            }
        case 3:  // medium
            if err := x.readField3(p); err != nil {
                return err
            }
        case 4:  // biggish
            if err := x.readField4(p); err != nil {
                return err
            }
        case 5:  // tiny
            if err := x.readField5(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type MyStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
    MyStringField string `thrift:"MyStringField,2" json:"MyStringField" db:"MyStringField"`
    MajorVer int64 `thrift:"majorVer,3" json:"majorVer" db:"majorVer"`
    Data *MyDataItem `thrift:"data,4" json:"data" db:"data"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MyStruct{}


func NewMyStruct() *MyStruct {
    return (&MyStruct{})
}

// Deprecated: Use NewMyStruct().Data instead.
var MyStruct_Data_DEFAULT = NewMyStruct().Data

func (x *MyStruct) GetMyIntFieldNonCompat() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyStringFieldNonCompat() string {
    return x.MyStringField
}

func (x *MyStruct) GetMyStringField() string {
    return x.MyStringField
}

func (x *MyStruct) GetMajorVerNonCompat() int64 {
    return x.MajorVer
}

func (x *MyStruct) GetMajorVer() int64 {
    return x.MajorVer
}

func (x *MyStruct) GetDataNonCompat() *MyDataItem {
    return x.Data
}

func (x *MyStruct) GetData() *MyDataItem {
    if !x.IsSetData() {
      return NewMyDataItem()
    }

    return x.Data
}

func (x *MyStruct) SetMyIntField(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyStringField(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMajorVer(value int64) *MyStruct {
    x.MajorVer = value
    return x
}

func (x *MyStruct) SetData(value MyDataItem) *MyStruct {
    x.Data = &value
    return x
}




func (x *MyStruct) IsSetData() bool {
    return x.Data != nil
}

func (x *MyStruct) writeField1(p thrift.Protocol) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyIntFieldNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField2(p thrift.Protocol) error {  // MyStringField
    if err := p.WriteFieldBegin("MyStringField", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyStringFieldNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField3(p thrift.Protocol) error {  // MajorVer
    if err := p.WriteFieldBegin("majorVer", thrift.I64, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMajorVerNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField4(p thrift.Protocol) error {  // Data
    if !x.IsSetData() {
        return nil
    }

    if err := p.WriteFieldBegin("data", thrift.STRUCT, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetDataNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) readField1(p thrift.Protocol) error {  // MyIntField
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetMyIntField(result)
    return nil
}

func (x *MyStruct) readField2(p thrift.Protocol) error {  // MyStringField
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetMyStringField(result)
    return nil
}

func (x *MyStruct) readField3(p thrift.Protocol) error {  // MajorVer
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetMajorVer(result)
    return nil
}

func (x *MyStruct) readField4(p thrift.Protocol) error {  // Data
    result := *NewMyDataItem()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetData(result)
    return nil
}

func (x *MyStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use MyStruct.Set* methods instead or set the fields directly.
type MyStructBuilder struct {
    obj *MyStruct
}

func NewMyStructBuilder() *MyStructBuilder {
    return &MyStructBuilder{
        obj: NewMyStruct(),
    }
}

func (x *MyStructBuilder) MyIntField(value int64) *MyStructBuilder {
    x.obj.MyIntField = value
    return x
}

func (x *MyStructBuilder) MyStringField(value string) *MyStructBuilder {
    x.obj.MyStringField = value
    return x
}

func (x *MyStructBuilder) MajorVer(value int64) *MyStructBuilder {
    x.obj.MajorVer = value
    return x
}

func (x *MyStructBuilder) Data(value *MyDataItem) *MyStructBuilder {
    x.obj.Data = value
    return x
}

func (x *MyStructBuilder) Emit() *MyStruct {
    var objCopy MyStruct = *x.obj
    return &objCopy
}

func (x *MyStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MyStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // MyIntField
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // MyStringField
            if err := x.readField2(p); err != nil {
                return err
            }
        case 3:  // majorVer
            if err := x.readField3(p); err != nil {
                return err
            }
        case 4:  // data
            if err := x.readField4(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type MyDataItem struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &MyDataItem{}


func NewMyDataItem() *MyDataItem {
    return (&MyDataItem{})
}

func (x *MyDataItem) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use MyDataItem.Set* methods instead or set the fields directly.
type MyDataItemBuilder struct {
    obj *MyDataItem
}

func NewMyDataItemBuilder() *MyDataItemBuilder {
    return &MyDataItemBuilder{
        obj: NewMyDataItem(),
    }
}

func (x *MyDataItemBuilder) Emit() *MyDataItem {
    var objCopy MyDataItem = *x.obj
    return &objCopy
}

func (x *MyDataItem) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MyDataItem"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyDataItem) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type Renaming struct {
    Foo int64 `thrift:"foo,1" json:"foo" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Renaming{}


func NewRenaming() *Renaming {
    return (&Renaming{})
}

func (x *Renaming) GetFooNonCompat() int64 {
    return x.Foo
}

func (x *Renaming) GetFoo() int64 {
    return x.Foo
}

func (x *Renaming) SetFoo(value int64) *Renaming {
    x.Foo = value
    return x
}


func (x *Renaming) writeField1(p thrift.Protocol) error {  // Foo
    if err := p.WriteFieldBegin("foo", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFooNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Renaming) readField1(p thrift.Protocol) error {  // Foo
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetFoo(result)
    return nil
}

func (x *Renaming) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use Renaming.Set* methods instead or set the fields directly.
type RenamingBuilder struct {
    obj *Renaming
}

func NewRenamingBuilder() *RenamingBuilder {
    return &RenamingBuilder{
        obj: NewRenaming(),
    }
}

func (x *RenamingBuilder) Foo(value int64) *RenamingBuilder {
    x.obj.Foo = value
    return x
}

func (x *RenamingBuilder) Emit() *Renaming {
    var objCopy Renaming = *x.obj
    return &objCopy
}

func (x *Renaming) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Renaming"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Renaming) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // foo
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type AnnotatedTypes struct {
    BinaryField TBinary `thrift:"binary_field,1" json:"binary_field" db:"binary_field"`
    ListField included.SomeListOfTypeMap `thrift:"list_field,2" json:"list_field" db:"list_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AnnotatedTypes{}


func NewAnnotatedTypes() *AnnotatedTypes {
    return (&AnnotatedTypes{})
}

func (x *AnnotatedTypes) GetBinaryFieldNonCompat() TBinary {
    return x.BinaryField
}

func (x *AnnotatedTypes) GetBinaryField() TBinary {
    if !x.IsSetBinaryField() {
      return NewTBinary()
    }

    return x.BinaryField
}

func (x *AnnotatedTypes) GetListFieldNonCompat() included.SomeListOfTypeMap {
    return x.ListField
}

func (x *AnnotatedTypes) GetListField() included.SomeListOfTypeMap {
    if !x.IsSetListField() {
      return included.NewSomeListOfTypeMap()
    }

    return x.ListField
}

func (x *AnnotatedTypes) SetBinaryField(value TBinary) *AnnotatedTypes {
    x.BinaryField = value
    return x
}

func (x *AnnotatedTypes) SetListField(value included.SomeListOfTypeMap) *AnnotatedTypes {
    x.ListField = value
    return x
}

func (x *AnnotatedTypes) IsSetBinaryField() bool {
    return x.BinaryField != nil
}

func (x *AnnotatedTypes) IsSetListField() bool {
    return x.ListField != nil
}

func (x *AnnotatedTypes) writeField1(p thrift.Protocol) error {  // BinaryField
    if !x.IsSetBinaryField() {
        return nil
    }

    if err := p.WriteFieldBegin("binary_field", thrift.BINARY, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBinaryFieldNonCompat()
    err := WriteTBinary(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) writeField2(p thrift.Protocol) error {  // ListField
    if !x.IsSetListField() {
        return nil
    }

    if err := p.WriteFieldBegin("list_field", thrift.LIST, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetListFieldNonCompat()
    err := included.WriteSomeListOfTypeMap(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) readField1(p thrift.Protocol) error {  // BinaryField
    result, err := ReadTBinary(p)
if err != nil {
    return err
}

    x.SetBinaryField(result)
    return nil
}

func (x *AnnotatedTypes) readField2(p thrift.Protocol) error {  // ListField
    result, err := included.ReadSomeListOfTypeMap(p)
if err != nil {
    return err
}

    x.SetListField(result)
    return nil
}

func (x *AnnotatedTypes) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use AnnotatedTypes.Set* methods instead or set the fields directly.
type AnnotatedTypesBuilder struct {
    obj *AnnotatedTypes
}

func NewAnnotatedTypesBuilder() *AnnotatedTypesBuilder {
    return &AnnotatedTypesBuilder{
        obj: NewAnnotatedTypes(),
    }
}

func (x *AnnotatedTypesBuilder) BinaryField(value TBinary) *AnnotatedTypesBuilder {
    x.obj.BinaryField = value
    return x
}

func (x *AnnotatedTypesBuilder) ListField(value included.SomeListOfTypeMap) *AnnotatedTypesBuilder {
    x.obj.ListField = value
    return x
}

func (x *AnnotatedTypesBuilder) Emit() *AnnotatedTypes {
    var objCopy AnnotatedTypes = *x.obj
    return &objCopy
}

func (x *AnnotatedTypes) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AnnotatedTypes"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // binary_field
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // list_field
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type ForwardUsageRoot struct {
    ForwardUsageStruct *ForwardUsageStruct `thrift:"ForwardUsageStruct,1,optional" json:"ForwardUsageStruct,omitempty" db:"ForwardUsageStruct"`
    ForwardUsageByRef *ForwardUsageByRef `thrift:"ForwardUsageByRef,2,optional" json:"ForwardUsageByRef,omitempty" db:"ForwardUsageByRef"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ForwardUsageRoot{}


func NewForwardUsageRoot() *ForwardUsageRoot {
    return (&ForwardUsageRoot{})
}

// Deprecated: Use NewForwardUsageRoot().ForwardUsageStruct instead.
var ForwardUsageRoot_ForwardUsageStruct_DEFAULT = NewForwardUsageRoot().ForwardUsageStruct

// Deprecated: Use NewForwardUsageRoot().ForwardUsageByRef instead.
var ForwardUsageRoot_ForwardUsageByRef_DEFAULT = NewForwardUsageRoot().ForwardUsageByRef

func (x *ForwardUsageRoot) GetForwardUsageStructNonCompat() *ForwardUsageStruct {
    return x.ForwardUsageStruct
}

func (x *ForwardUsageRoot) GetForwardUsageStruct() *ForwardUsageStruct {
    if !x.IsSetForwardUsageStruct() {
      return NewForwardUsageStruct()
    }

    return x.ForwardUsageStruct
}

func (x *ForwardUsageRoot) GetForwardUsageByRefNonCompat() *ForwardUsageByRef {
    return x.ForwardUsageByRef
}

func (x *ForwardUsageRoot) GetForwardUsageByRef() *ForwardUsageByRef {
    if !x.IsSetForwardUsageByRef() {
      return NewForwardUsageByRef()
    }

    return x.ForwardUsageByRef
}

func (x *ForwardUsageRoot) SetForwardUsageStruct(value ForwardUsageStruct) *ForwardUsageRoot {
    x.ForwardUsageStruct = &value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageByRef(value ForwardUsageByRef) *ForwardUsageRoot {
    x.ForwardUsageByRef = &value
    return x
}

func (x *ForwardUsageRoot) IsSetForwardUsageStruct() bool {
    return x.ForwardUsageStruct != nil
}

func (x *ForwardUsageRoot) IsSetForwardUsageByRef() bool {
    return x.ForwardUsageByRef != nil
}

func (x *ForwardUsageRoot) writeField1(p thrift.Protocol) error {  // ForwardUsageStruct
    if !x.IsSetForwardUsageStruct() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageStruct", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetForwardUsageStructNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) writeField2(p thrift.Protocol) error {  // ForwardUsageByRef
    if !x.IsSetForwardUsageByRef() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageByRef", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetForwardUsageByRefNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) readField1(p thrift.Protocol) error {  // ForwardUsageStruct
    result := *NewForwardUsageStruct()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetForwardUsageStruct(result)
    return nil
}

func (x *ForwardUsageRoot) readField2(p thrift.Protocol) error {  // ForwardUsageByRef
    result := *NewForwardUsageByRef()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetForwardUsageByRef(result)
    return nil
}

func (x *ForwardUsageRoot) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use ForwardUsageRoot.Set* methods instead or set the fields directly.
type ForwardUsageRootBuilder struct {
    obj *ForwardUsageRoot
}

func NewForwardUsageRootBuilder() *ForwardUsageRootBuilder {
    return &ForwardUsageRootBuilder{
        obj: NewForwardUsageRoot(),
    }
}

func (x *ForwardUsageRootBuilder) ForwardUsageStruct(value *ForwardUsageStruct) *ForwardUsageRootBuilder {
    x.obj.ForwardUsageStruct = value
    return x
}

func (x *ForwardUsageRootBuilder) ForwardUsageByRef(value *ForwardUsageByRef) *ForwardUsageRootBuilder {
    x.obj.ForwardUsageByRef = value
    return x
}

func (x *ForwardUsageRootBuilder) Emit() *ForwardUsageRoot {
    var objCopy ForwardUsageRoot = *x.obj
    return &objCopy
}

func (x *ForwardUsageRoot) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ForwardUsageRoot"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // ForwardUsageStruct
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // ForwardUsageByRef
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type ForwardUsageStruct struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ForwardUsageStruct{}


func NewForwardUsageStruct() *ForwardUsageStruct {
    return (&ForwardUsageStruct{})
}

// Deprecated: Use NewForwardUsageStruct().Foo instead.
var ForwardUsageStruct_Foo_DEFAULT = NewForwardUsageStruct().Foo

func (x *ForwardUsageStruct) GetFooNonCompat() *ForwardUsageRoot {
    return x.Foo
}

func (x *ForwardUsageStruct) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
      return NewForwardUsageRoot()
    }

    return x.Foo
}

func (x *ForwardUsageStruct) SetFoo(value ForwardUsageRoot) *ForwardUsageStruct {
    x.Foo = &value
    return x
}

func (x *ForwardUsageStruct) IsSetFoo() bool {
    return x.Foo != nil
}

func (x *ForwardUsageStruct) writeField1(p thrift.Protocol) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFooNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageStruct) readField1(p thrift.Protocol) error {  // Foo
    result := *NewForwardUsageRoot()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetFoo(result)
    return nil
}

func (x *ForwardUsageStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use ForwardUsageStruct.Set* methods instead or set the fields directly.
type ForwardUsageStructBuilder struct {
    obj *ForwardUsageStruct
}

func NewForwardUsageStructBuilder() *ForwardUsageStructBuilder {
    return &ForwardUsageStructBuilder{
        obj: NewForwardUsageStruct(),
    }
}

func (x *ForwardUsageStructBuilder) Foo(value *ForwardUsageRoot) *ForwardUsageStructBuilder {
    x.obj.Foo = value
    return x
}

func (x *ForwardUsageStructBuilder) Emit() *ForwardUsageStruct {
    var objCopy ForwardUsageStruct = *x.obj
    return &objCopy
}

func (x *ForwardUsageStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ForwardUsageStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // foo
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type ForwardUsageByRef struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ForwardUsageByRef{}


func NewForwardUsageByRef() *ForwardUsageByRef {
    return (&ForwardUsageByRef{})
}

// Deprecated: Use NewForwardUsageByRef().Foo instead.
var ForwardUsageByRef_Foo_DEFAULT = NewForwardUsageByRef().Foo

func (x *ForwardUsageByRef) GetFooNonCompat() *ForwardUsageRoot {
    return x.Foo
}

func (x *ForwardUsageByRef) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
      return NewForwardUsageRoot()
    }

    return x.Foo
}

func (x *ForwardUsageByRef) SetFoo(value ForwardUsageRoot) *ForwardUsageByRef {
    x.Foo = &value
    return x
}

func (x *ForwardUsageByRef) IsSetFoo() bool {
    return x.Foo != nil
}

func (x *ForwardUsageByRef) writeField1(p thrift.Protocol) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFooNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageByRef) readField1(p thrift.Protocol) error {  // Foo
    result := *NewForwardUsageRoot()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetFoo(result)
    return nil
}

func (x *ForwardUsageByRef) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use ForwardUsageByRef.Set* methods instead or set the fields directly.
type ForwardUsageByRefBuilder struct {
    obj *ForwardUsageByRef
}

func NewForwardUsageByRefBuilder() *ForwardUsageByRefBuilder {
    return &ForwardUsageByRefBuilder{
        obj: NewForwardUsageByRef(),
    }
}

func (x *ForwardUsageByRefBuilder) Foo(value *ForwardUsageRoot) *ForwardUsageByRefBuilder {
    x.obj.Foo = value
    return x
}

func (x *ForwardUsageByRefBuilder) Emit() *ForwardUsageByRef {
    var objCopy ForwardUsageByRef = *x.obj
    return &objCopy
}

func (x *ForwardUsageByRef) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ForwardUsageByRef"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageByRef) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // foo
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type IncompleteMap struct {
    Field map[int32]*IncompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteMap{}


func NewIncompleteMap() *IncompleteMap {
    return (&IncompleteMap{})
}

func (x *IncompleteMap) GetFieldNonCompat() map[int32]*IncompleteMapDep {
    return x.Field
}

func (x *IncompleteMap) GetField() map[int32]*IncompleteMapDep {
    if !x.IsSetField() {
      return nil
    }

    return x.Field
}

func (x *IncompleteMap) SetField(value map[int32]*IncompleteMapDep) *IncompleteMap {
    x.Field = value
    return x
}

func (x *IncompleteMap) IsSetField() bool {
    return x.Field != nil
}

func (x *IncompleteMap) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMap) readField1(p thrift.Protocol) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]*IncompleteMapDep, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value *IncompleteMapDep
    {
        result := *NewIncompleteMapDep()
err := result.Read(p)
if err != nil {
    return err
}
        value = &result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetField(result)
    return nil
}

func (x *IncompleteMap) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use IncompleteMap.Set* methods instead or set the fields directly.
type IncompleteMapBuilder struct {
    obj *IncompleteMap
}

func NewIncompleteMapBuilder() *IncompleteMapBuilder {
    return &IncompleteMapBuilder{
        obj: NewIncompleteMap(),
    }
}

func (x *IncompleteMapBuilder) Field(value map[int32]*IncompleteMapDep) *IncompleteMapBuilder {
    x.obj.Field = value
    return x
}

func (x *IncompleteMapBuilder) Emit() *IncompleteMap {
    var objCopy IncompleteMap = *x.obj
    return &objCopy
}

func (x *IncompleteMap) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteMap"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMap) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type IncompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteMapDep{}


func NewIncompleteMapDep() *IncompleteMapDep {
    return (&IncompleteMapDep{})
}

func (x *IncompleteMapDep) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use IncompleteMapDep.Set* methods instead or set the fields directly.
type IncompleteMapDepBuilder struct {
    obj *IncompleteMapDep
}

func NewIncompleteMapDepBuilder() *IncompleteMapDepBuilder {
    return &IncompleteMapDepBuilder{
        obj: NewIncompleteMapDep(),
    }
}

func (x *IncompleteMapDepBuilder) Emit() *IncompleteMapDep {
    var objCopy IncompleteMapDep = *x.obj
    return &objCopy
}

func (x *IncompleteMapDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteMapDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMapDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type CompleteMap struct {
    Field map[int32]*CompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteMap{}


func NewCompleteMap() *CompleteMap {
    return (&CompleteMap{})
}

func (x *CompleteMap) GetFieldNonCompat() map[int32]*CompleteMapDep {
    return x.Field
}

func (x *CompleteMap) GetField() map[int32]*CompleteMapDep {
    if !x.IsSetField() {
      return nil
    }

    return x.Field
}

func (x *CompleteMap) SetField(value map[int32]*CompleteMapDep) *CompleteMap {
    x.Field = value
    return x
}

func (x *CompleteMap) IsSetField() bool {
    return x.Field != nil
}

func (x *CompleteMap) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CompleteMap) readField1(p thrift.Protocol) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]*CompleteMapDep, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value *CompleteMapDep
    {
        result := *NewCompleteMapDep()
err := result.Read(p)
if err != nil {
    return err
}
        value = &result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetField(result)
    return nil
}

func (x *CompleteMap) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use CompleteMap.Set* methods instead or set the fields directly.
type CompleteMapBuilder struct {
    obj *CompleteMap
}

func NewCompleteMapBuilder() *CompleteMapBuilder {
    return &CompleteMapBuilder{
        obj: NewCompleteMap(),
    }
}

func (x *CompleteMapBuilder) Field(value map[int32]*CompleteMapDep) *CompleteMapBuilder {
    x.obj.Field = value
    return x
}

func (x *CompleteMapBuilder) Emit() *CompleteMap {
    var objCopy CompleteMap = *x.obj
    return &objCopy
}

func (x *CompleteMap) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteMap"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteMap) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type CompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteMapDep{}


func NewCompleteMapDep() *CompleteMapDep {
    return (&CompleteMapDep{})
}

func (x *CompleteMapDep) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use CompleteMapDep.Set* methods instead or set the fields directly.
type CompleteMapDepBuilder struct {
    obj *CompleteMapDep
}

func NewCompleteMapDepBuilder() *CompleteMapDepBuilder {
    return &CompleteMapDepBuilder{
        obj: NewCompleteMapDep(),
    }
}

func (x *CompleteMapDepBuilder) Emit() *CompleteMapDep {
    var objCopy CompleteMapDep = *x.obj
    return &objCopy
}

func (x *CompleteMapDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteMapDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteMapDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type IncompleteList struct {
    Field []*IncompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteList{}


func NewIncompleteList() *IncompleteList {
    return (&IncompleteList{})
}

func (x *IncompleteList) GetFieldNonCompat() []*IncompleteListDep {
    return x.Field
}

func (x *IncompleteList) GetField() []*IncompleteListDep {
    if !x.IsSetField() {
      return nil
    }

    return x.Field
}

func (x *IncompleteList) SetField(value []*IncompleteListDep) *IncompleteList {
    x.Field = value
    return x
}

func (x *IncompleteList) IsSetField() bool {
    return x.Field != nil
}

func (x *IncompleteList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *IncompleteList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*IncompleteListDep, 0, size)
for i := 0; i < size; i++ {
    var elem IncompleteListDep
    {
        result := *NewIncompleteListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetField(result)
    return nil
}

func (x *IncompleteList) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use IncompleteList.Set* methods instead or set the fields directly.
type IncompleteListBuilder struct {
    obj *IncompleteList
}

func NewIncompleteListBuilder() *IncompleteListBuilder {
    return &IncompleteListBuilder{
        obj: NewIncompleteList(),
    }
}

func (x *IncompleteListBuilder) Field(value []*IncompleteListDep) *IncompleteListBuilder {
    x.obj.Field = value
    return x
}

func (x *IncompleteListBuilder) Emit() *IncompleteList {
    var objCopy IncompleteList = *x.obj
    return &objCopy
}

func (x *IncompleteList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type IncompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteListDep{}


func NewIncompleteListDep() *IncompleteListDep {
    return (&IncompleteListDep{})
}

func (x *IncompleteListDep) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use IncompleteListDep.Set* methods instead or set the fields directly.
type IncompleteListDepBuilder struct {
    obj *IncompleteListDep
}

func NewIncompleteListDepBuilder() *IncompleteListDepBuilder {
    return &IncompleteListDepBuilder{
        obj: NewIncompleteListDep(),
    }
}

func (x *IncompleteListDepBuilder) Emit() *IncompleteListDep {
    var objCopy IncompleteListDep = *x.obj
    return &objCopy
}

func (x *IncompleteListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type CompleteList struct {
    Field []*CompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteList{}


func NewCompleteList() *CompleteList {
    return (&CompleteList{})
}

func (x *CompleteList) GetFieldNonCompat() []*CompleteListDep {
    return x.Field
}

func (x *CompleteList) GetField() []*CompleteListDep {
    if !x.IsSetField() {
      return nil
    }

    return x.Field
}

func (x *CompleteList) SetField(value []*CompleteListDep) *CompleteList {
    x.Field = value
    return x
}

func (x *CompleteList) IsSetField() bool {
    return x.Field != nil
}

func (x *CompleteList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CompleteList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*CompleteListDep, 0, size)
for i := 0; i < size; i++ {
    var elem CompleteListDep
    {
        result := *NewCompleteListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetField(result)
    return nil
}

func (x *CompleteList) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use CompleteList.Set* methods instead or set the fields directly.
type CompleteListBuilder struct {
    obj *CompleteList
}

func NewCompleteListBuilder() *CompleteListBuilder {
    return &CompleteListBuilder{
        obj: NewCompleteList(),
    }
}

func (x *CompleteListBuilder) Field(value []*CompleteListDep) *CompleteListBuilder {
    x.obj.Field = value
    return x
}

func (x *CompleteListBuilder) Emit() *CompleteList {
    var objCopy CompleteList = *x.obj
    return &objCopy
}

func (x *CompleteList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type CompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteListDep{}


func NewCompleteListDep() *CompleteListDep {
    return (&CompleteListDep{})
}

func (x *CompleteListDep) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use CompleteListDep.Set* methods instead or set the fields directly.
type CompleteListDepBuilder struct {
    obj *CompleteListDep
}

func NewCompleteListDepBuilder() *CompleteListDepBuilder {
    return &CompleteListDepBuilder{
        obj: NewCompleteListDep(),
    }
}

func (x *CompleteListDepBuilder) Emit() *CompleteListDep {
    var objCopy CompleteListDep = *x.obj
    return &objCopy
}

func (x *CompleteListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type AdaptedList struct {
    Field []*AdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AdaptedList{}


func NewAdaptedList() *AdaptedList {
    return (&AdaptedList{})
}

func (x *AdaptedList) GetFieldNonCompat() []*AdaptedListDep {
    return x.Field
}

func (x *AdaptedList) GetField() []*AdaptedListDep {
    if !x.IsSetField() {
      return nil
    }

    return x.Field
}

func (x *AdaptedList) SetField(value []*AdaptedListDep) *AdaptedList {
    x.Field = value
    return x
}

func (x *AdaptedList) IsSetField() bool {
    return x.Field != nil
}

func (x *AdaptedList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AdaptedList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*AdaptedListDep, 0, size)
for i := 0; i < size; i++ {
    var elem AdaptedListDep
    {
        result := *NewAdaptedListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetField(result)
    return nil
}

func (x *AdaptedList) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use AdaptedList.Set* methods instead or set the fields directly.
type AdaptedListBuilder struct {
    obj *AdaptedList
}

func NewAdaptedListBuilder() *AdaptedListBuilder {
    return &AdaptedListBuilder{
        obj: NewAdaptedList(),
    }
}

func (x *AdaptedListBuilder) Field(value []*AdaptedListDep) *AdaptedListBuilder {
    x.obj.Field = value
    return x
}

func (x *AdaptedListBuilder) Emit() *AdaptedList {
    var objCopy AdaptedList = *x.obj
    return &objCopy
}

func (x *AdaptedList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AdaptedList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AdaptedList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type AdaptedListDep struct {
    Field *AdaptedList `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AdaptedListDep{}


func NewAdaptedListDep() *AdaptedListDep {
    return (&AdaptedListDep{})
}

// Deprecated: Use NewAdaptedListDep().Field instead.
var AdaptedListDep_Field_DEFAULT = NewAdaptedListDep().Field

func (x *AdaptedListDep) GetFieldNonCompat() *AdaptedList {
    return x.Field
}

func (x *AdaptedListDep) GetField() *AdaptedList {
    if !x.IsSetField() {
      return NewAdaptedList()
    }

    return x.Field
}

func (x *AdaptedListDep) SetField(value AdaptedList) *AdaptedListDep {
    x.Field = &value
    return x
}

func (x *AdaptedListDep) IsSetField() bool {
    return x.Field != nil
}

func (x *AdaptedListDep) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AdaptedListDep) readField1(p thrift.Protocol) error {  // Field
    result := *NewAdaptedList()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetField(result)
    return nil
}

func (x *AdaptedListDep) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use AdaptedListDep.Set* methods instead or set the fields directly.
type AdaptedListDepBuilder struct {
    obj *AdaptedListDep
}

func NewAdaptedListDepBuilder() *AdaptedListDepBuilder {
    return &AdaptedListDepBuilder{
        obj: NewAdaptedListDep(),
    }
}

func (x *AdaptedListDepBuilder) Field(value *AdaptedList) *AdaptedListDepBuilder {
    x.obj.Field = value
    return x
}

func (x *AdaptedListDepBuilder) Emit() *AdaptedListDep {
    var objCopy AdaptedListDep = *x.obj
    return &objCopy
}

func (x *AdaptedListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AdaptedListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AdaptedListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type DependentAdaptedList struct {
    Field []*DependentAdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DependentAdaptedList{}


func NewDependentAdaptedList() *DependentAdaptedList {
    return (&DependentAdaptedList{})
}

func (x *DependentAdaptedList) GetFieldNonCompat() []*DependentAdaptedListDep {
    return x.Field
}

func (x *DependentAdaptedList) GetField() []*DependentAdaptedListDep {
    if !x.IsSetField() {
      return nil
    }

    return x.Field
}

func (x *DependentAdaptedList) SetField(value []*DependentAdaptedListDep) *DependentAdaptedList {
    x.Field = value
    return x
}

func (x *DependentAdaptedList) IsSetField() bool {
    return x.Field != nil
}

func (x *DependentAdaptedList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*DependentAdaptedListDep, 0, size)
for i := 0; i < size; i++ {
    var elem DependentAdaptedListDep
    {
        result := *NewDependentAdaptedListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetField(result)
    return nil
}

func (x *DependentAdaptedList) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use DependentAdaptedList.Set* methods instead or set the fields directly.
type DependentAdaptedListBuilder struct {
    obj *DependentAdaptedList
}

func NewDependentAdaptedListBuilder() *DependentAdaptedListBuilder {
    return &DependentAdaptedListBuilder{
        obj: NewDependentAdaptedList(),
    }
}

func (x *DependentAdaptedListBuilder) Field(value []*DependentAdaptedListDep) *DependentAdaptedListBuilder {
    x.obj.Field = value
    return x
}

func (x *DependentAdaptedListBuilder) Emit() *DependentAdaptedList {
    var objCopy DependentAdaptedList = *x.obj
    return &objCopy
}

func (x *DependentAdaptedList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DependentAdaptedList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type DependentAdaptedListDep struct {
    Field *int16 `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DependentAdaptedListDep{}


func NewDependentAdaptedListDep() *DependentAdaptedListDep {
    return (&DependentAdaptedListDep{})
}

// Deprecated: Use NewDependentAdaptedListDep().Field instead.
var DependentAdaptedListDep_Field_DEFAULT = NewDependentAdaptedListDep().Field

func (x *DependentAdaptedListDep) GetFieldNonCompat() *int16 {
    return x.Field
}

func (x *DependentAdaptedListDep) GetField() int16 {
    if !x.IsSetField() {
      return 0
    }

    return *x.Field
}

func (x *DependentAdaptedListDep) SetField(value int16) *DependentAdaptedListDep {
    x.Field = &value
    return x
}

func (x *DependentAdaptedListDep) IsSetField() bool {
    return x.Field != nil
}

func (x *DependentAdaptedListDep) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.I16, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetFieldNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedListDep) readField1(p thrift.Protocol) error {  // Field
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetField(result)
    return nil
}

func (x *DependentAdaptedListDep) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use DependentAdaptedListDep.Set* methods instead or set the fields directly.
type DependentAdaptedListDepBuilder struct {
    obj *DependentAdaptedListDep
}

func NewDependentAdaptedListDepBuilder() *DependentAdaptedListDepBuilder {
    return &DependentAdaptedListDepBuilder{
        obj: NewDependentAdaptedListDep(),
    }
}

func (x *DependentAdaptedListDepBuilder) Field(value *int16) *DependentAdaptedListDepBuilder {
    x.obj.Field = value
    return x
}

func (x *DependentAdaptedListDepBuilder) Emit() *DependentAdaptedListDep {
    var objCopy DependentAdaptedListDep = *x.obj
    return &objCopy
}

func (x *DependentAdaptedListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DependentAdaptedListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type AllocatorAware struct {
    AaList []int32 `thrift:"aa_list,1" json:"aa_list" db:"aa_list"`
    AaSet []int32 `thrift:"aa_set,2" json:"aa_set" db:"aa_set"`
    AaMap map[int32]int32 `thrift:"aa_map,3" json:"aa_map" db:"aa_map"`
    AaString string `thrift:"aa_string,4" json:"aa_string" db:"aa_string"`
    NotAContainer int32 `thrift:"not_a_container,5" json:"not_a_container" db:"not_a_container"`
    AaUnique int32 `thrift:"aa_unique,6" json:"aa_unique" db:"aa_unique"`
    AaShared int32 `thrift:"aa_shared,7" json:"aa_shared" db:"aa_shared"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AllocatorAware{}


func NewAllocatorAware() *AllocatorAware {
    return (&AllocatorAware{})
}

func (x *AllocatorAware) GetAaListNonCompat() []int32 {
    return x.AaList
}

func (x *AllocatorAware) GetAaList() []int32 {
    if !x.IsSetAaList() {
      return nil
    }

    return x.AaList
}

func (x *AllocatorAware) GetAaSetNonCompat() []int32 {
    return x.AaSet
}

func (x *AllocatorAware) GetAaSet() []int32 {
    if !x.IsSetAaSet() {
      return nil
    }

    return x.AaSet
}

func (x *AllocatorAware) GetAaMapNonCompat() map[int32]int32 {
    return x.AaMap
}

func (x *AllocatorAware) GetAaMap() map[int32]int32 {
    if !x.IsSetAaMap() {
      return nil
    }

    return x.AaMap
}

func (x *AllocatorAware) GetAaStringNonCompat() string {
    return x.AaString
}

func (x *AllocatorAware) GetAaString() string {
    return x.AaString
}

func (x *AllocatorAware) GetNotAContainerNonCompat() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware) GetAaUniqueNonCompat() int32 {
    return x.AaUnique
}

func (x *AllocatorAware) GetAaUnique() int32 {
    return x.AaUnique
}

func (x *AllocatorAware) GetAaSharedNonCompat() int32 {
    return x.AaShared
}

func (x *AllocatorAware) GetAaShared() int32 {
    return x.AaShared
}

func (x *AllocatorAware) SetAaList(value []int32) *AllocatorAware {
    x.AaList = value
    return x
}

func (x *AllocatorAware) SetAaSet(value []int32) *AllocatorAware {
    x.AaSet = value
    return x
}

func (x *AllocatorAware) SetAaMap(value map[int32]int32) *AllocatorAware {
    x.AaMap = value
    return x
}

func (x *AllocatorAware) SetAaString(value string) *AllocatorAware {
    x.AaString = value
    return x
}

func (x *AllocatorAware) SetNotAContainer(value int32) *AllocatorAware {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware) SetAaUnique(value int32) *AllocatorAware {
    x.AaUnique = value
    return x
}

func (x *AllocatorAware) SetAaShared(value int32) *AllocatorAware {
    x.AaShared = value
    return x
}

func (x *AllocatorAware) IsSetAaList() bool {
    return x.AaList != nil
}

func (x *AllocatorAware) IsSetAaSet() bool {
    return x.AaSet != nil
}

func (x *AllocatorAware) IsSetAaMap() bool {
    return x.AaMap != nil
}





func (x *AllocatorAware) writeField1(p thrift.Protocol) error {  // AaList
    if !x.IsSetAaList() {
        return nil
    }

    if err := p.WriteFieldBegin("aa_list", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaListNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField2(p thrift.Protocol) error {  // AaSet
    if !x.IsSetAaSet() {
        return nil
    }

    if err := p.WriteFieldBegin("aa_set", thrift.SET, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaSetNonCompat()
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteSetEnd(); err != nil {
    return thrift.PrependError("error writing set end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField3(p thrift.Protocol) error {  // AaMap
    if !x.IsSetAaMap() {
        return nil
    }

    if err := p.WriteFieldBegin("aa_map", thrift.MAP, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaMapNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField4(p thrift.Protocol) error {  // AaString
    if err := p.WriteFieldBegin("aa_string", thrift.STRING, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaStringNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField5(p thrift.Protocol) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNotAContainerNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField6(p thrift.Protocol) error {  // AaUnique
    if err := p.WriteFieldBegin("aa_unique", thrift.I32, 6); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaUniqueNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField7(p thrift.Protocol) error {  // AaShared
    if err := p.WriteFieldBegin("aa_shared", thrift.I32, 7); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaSharedNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) readField1(p thrift.Protocol) error {  // AaList
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetAaList(result)
    return nil
}

func (x *AllocatorAware) readField2(p thrift.Protocol) error {  // AaSet
    _ /* elemType */, size, err := p.ReadSetBegin()
if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
}

setResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    setResult = append(setResult, elem)
}

if err := p.ReadSetEnd(); err != nil {
    return thrift.PrependError("error reading set end: ", err)
}
result := setResult

    x.SetAaSet(result)
    return nil
}

func (x *AllocatorAware) readField3(p thrift.Protocol) error {  // AaMap
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]int32, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetAaMap(result)
    return nil
}

func (x *AllocatorAware) readField4(p thrift.Protocol) error {  // AaString
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAaString(result)
    return nil
}

func (x *AllocatorAware) readField5(p thrift.Protocol) error {  // NotAContainer
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetNotAContainer(result)
    return nil
}

func (x *AllocatorAware) readField6(p thrift.Protocol) error {  // AaUnique
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAaUnique(result)
    return nil
}

func (x *AllocatorAware) readField7(p thrift.Protocol) error {  // AaShared
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAaShared(result)
    return nil
}

func (x *AllocatorAware) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use AllocatorAware.Set* methods instead or set the fields directly.
type AllocatorAwareBuilder struct {
    obj *AllocatorAware
}

func NewAllocatorAwareBuilder() *AllocatorAwareBuilder {
    return &AllocatorAwareBuilder{
        obj: NewAllocatorAware(),
    }
}

func (x *AllocatorAwareBuilder) AaList(value []int32) *AllocatorAwareBuilder {
    x.obj.AaList = value
    return x
}

func (x *AllocatorAwareBuilder) AaSet(value []int32) *AllocatorAwareBuilder {
    x.obj.AaSet = value
    return x
}

func (x *AllocatorAwareBuilder) AaMap(value map[int32]int32) *AllocatorAwareBuilder {
    x.obj.AaMap = value
    return x
}

func (x *AllocatorAwareBuilder) AaString(value string) *AllocatorAwareBuilder {
    x.obj.AaString = value
    return x
}

func (x *AllocatorAwareBuilder) NotAContainer(value int32) *AllocatorAwareBuilder {
    x.obj.NotAContainer = value
    return x
}

func (x *AllocatorAwareBuilder) AaUnique(value int32) *AllocatorAwareBuilder {
    x.obj.AaUnique = value
    return x
}

func (x *AllocatorAwareBuilder) AaShared(value int32) *AllocatorAwareBuilder {
    x.obj.AaShared = value
    return x
}

func (x *AllocatorAwareBuilder) Emit() *AllocatorAware {
    var objCopy AllocatorAware = *x.obj
    return &objCopy
}

func (x *AllocatorAware) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AllocatorAware"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := x.writeField6(p); err != nil {
        return err
    }

    if err := x.writeField7(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // aa_list
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // aa_set
            if err := x.readField2(p); err != nil {
                return err
            }
        case 3:  // aa_map
            if err := x.readField3(p); err != nil {
                return err
            }
        case 4:  // aa_string
            if err := x.readField4(p); err != nil {
                return err
            }
        case 5:  // not_a_container
            if err := x.readField5(p); err != nil {
                return err
            }
        case 6:  // aa_unique
            if err := x.readField6(p); err != nil {
                return err
            }
        case 7:  // aa_shared
            if err := x.readField7(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type AllocatorAware2 struct {
    NotAContainer int32 `thrift:"not_a_container,1" json:"not_a_container" db:"not_a_container"`
    BoxField *int32 `thrift:"box_field,2,optional" json:"box_field,omitempty" db:"box_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AllocatorAware2{}


func NewAllocatorAware2() *AllocatorAware2 {
    return (&AllocatorAware2{})
}

// Deprecated: Use NewAllocatorAware2().BoxField instead.
var AllocatorAware2_BoxField_DEFAULT = NewAllocatorAware2().BoxField

func (x *AllocatorAware2) GetNotAContainerNonCompat() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware2) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware2) GetBoxFieldNonCompat() *int32 {
    return x.BoxField
}

func (x *AllocatorAware2) GetBoxField() int32 {
    if !x.IsSetBoxField() {
      return 0
    }

    return *x.BoxField
}

func (x *AllocatorAware2) SetNotAContainer(value int32) *AllocatorAware2 {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware2) SetBoxField(value int32) *AllocatorAware2 {
    x.BoxField = &value
    return x
}


func (x *AllocatorAware2) IsSetBoxField() bool {
    return x.BoxField != nil
}

func (x *AllocatorAware2) writeField1(p thrift.Protocol) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNotAContainerNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) writeField2(p thrift.Protocol) error {  // BoxField
    if !x.IsSetBoxField() {
        return nil
    }

    if err := p.WriteFieldBegin("box_field", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetBoxFieldNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) readField1(p thrift.Protocol) error {  // NotAContainer
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetNotAContainer(result)
    return nil
}

func (x *AllocatorAware2) readField2(p thrift.Protocol) error {  // BoxField
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetBoxField(result)
    return nil
}

func (x *AllocatorAware2) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use AllocatorAware2.Set* methods instead or set the fields directly.
type AllocatorAware2Builder struct {
    obj *AllocatorAware2
}

func NewAllocatorAware2Builder() *AllocatorAware2Builder {
    return &AllocatorAware2Builder{
        obj: NewAllocatorAware2(),
    }
}

func (x *AllocatorAware2Builder) NotAContainer(value int32) *AllocatorAware2Builder {
    x.obj.NotAContainer = value
    return x
}

func (x *AllocatorAware2Builder) BoxField(value *int32) *AllocatorAware2Builder {
    x.obj.BoxField = value
    return x
}

func (x *AllocatorAware2Builder) Emit() *AllocatorAware2 {
    var objCopy AllocatorAware2 = *x.obj
    return &objCopy
}

func (x *AllocatorAware2) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AllocatorAware2"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // not_a_container
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // box_field
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type TypedefStruct struct {
    I32Field int32 `thrift:"i32_field,1" json:"i32_field" db:"i32_field"`
    IntTypedefField IntTypedef `thrift:"IntTypedef_field,2" json:"IntTypedef_field" db:"IntTypedef_field"`
    UintTypedefField UintTypedef `thrift:"UintTypedef_field,3" json:"UintTypedef_field" db:"UintTypedef_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &TypedefStruct{}


func NewTypedefStruct() *TypedefStruct {
    return (&TypedefStruct{})
}

func (x *TypedefStruct) GetI32FieldNonCompat() int32 {
    return x.I32Field
}

func (x *TypedefStruct) GetI32Field() int32 {
    return x.I32Field
}

func (x *TypedefStruct) GetIntTypedefFieldNonCompat() IntTypedef {
    return x.IntTypedefField
}

func (x *TypedefStruct) GetIntTypedefField() IntTypedef {
    return x.IntTypedefField
}

func (x *TypedefStruct) GetUintTypedefFieldNonCompat() UintTypedef {
    return x.UintTypedefField
}

func (x *TypedefStruct) GetUintTypedefField() UintTypedef {
    return x.UintTypedefField
}

func (x *TypedefStruct) SetI32Field(value int32) *TypedefStruct {
    x.I32Field = value
    return x
}

func (x *TypedefStruct) SetIntTypedefField(value IntTypedef) *TypedefStruct {
    x.IntTypedefField = value
    return x
}

func (x *TypedefStruct) SetUintTypedefField(value UintTypedef) *TypedefStruct {
    x.UintTypedefField = value
    return x
}




func (x *TypedefStruct) writeField1(p thrift.Protocol) error {  // I32Field
    if err := p.WriteFieldBegin("i32_field", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetI32FieldNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) writeField2(p thrift.Protocol) error {  // IntTypedefField
    if err := p.WriteFieldBegin("IntTypedef_field", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetIntTypedefFieldNonCompat()
    err := WriteIntTypedef(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) writeField3(p thrift.Protocol) error {  // UintTypedefField
    if err := p.WriteFieldBegin("UintTypedef_field", thrift.I32, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetUintTypedefFieldNonCompat()
    err := WriteUintTypedef(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) readField1(p thrift.Protocol) error {  // I32Field
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetI32Field(result)
    return nil
}

func (x *TypedefStruct) readField2(p thrift.Protocol) error {  // IntTypedefField
    result, err := ReadIntTypedef(p)
if err != nil {
    return err
}

    x.SetIntTypedefField(result)
    return nil
}

func (x *TypedefStruct) readField3(p thrift.Protocol) error {  // UintTypedefField
    result, err := ReadUintTypedef(p)
if err != nil {
    return err
}

    x.SetUintTypedefField(result)
    return nil
}

func (x *TypedefStruct) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use TypedefStruct.Set* methods instead or set the fields directly.
type TypedefStructBuilder struct {
    obj *TypedefStruct
}

func NewTypedefStructBuilder() *TypedefStructBuilder {
    return &TypedefStructBuilder{
        obj: NewTypedefStruct(),
    }
}

func (x *TypedefStructBuilder) I32Field(value int32) *TypedefStructBuilder {
    x.obj.I32Field = value
    return x
}

func (x *TypedefStructBuilder) IntTypedefField(value IntTypedef) *TypedefStructBuilder {
    x.obj.IntTypedefField = value
    return x
}

func (x *TypedefStructBuilder) UintTypedefField(value UintTypedef) *TypedefStructBuilder {
    x.obj.UintTypedefField = value
    return x
}

func (x *TypedefStructBuilder) Emit() *TypedefStruct {
    var objCopy TypedefStruct = *x.obj
    return &objCopy
}

func (x *TypedefStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TypedefStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // i32_field
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // IntTypedef_field
            if err := x.readField2(p); err != nil {
                return err
            }
        case 3:  // UintTypedef_field
            if err := x.readField3(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}


type StructWithDoubleUnderscores struct {
    _Field int32 `thrift:"__field,1" json:"__field" db:"__field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &StructWithDoubleUnderscores{}


func NewStructWithDoubleUnderscores() *StructWithDoubleUnderscores {
    return (&StructWithDoubleUnderscores{})
}

func (x *StructWithDoubleUnderscores) Get_FieldNonCompat() int32 {
    return x._Field
}

func (x *StructWithDoubleUnderscores) Get_Field() int32 {
    return x._Field
}

func (x *StructWithDoubleUnderscores) Set_Field(value int32) *StructWithDoubleUnderscores {
    x._Field = value
    return x
}


func (x *StructWithDoubleUnderscores) writeField1(p thrift.Protocol) error {  // _Field
    if err := p.WriteFieldBegin("__field", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Get_FieldNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) readField1(p thrift.Protocol) error {  // _Field
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.Set_Field(result)
    return nil
}

func (x *StructWithDoubleUnderscores) String() string {
    return fmt.Sprintf("%+v", x)
}


// Deprecated: Use StructWithDoubleUnderscores.Set* methods instead or set the fields directly.
type StructWithDoubleUnderscoresBuilder struct {
    obj *StructWithDoubleUnderscores
}

func NewStructWithDoubleUnderscoresBuilder() *StructWithDoubleUnderscoresBuilder {
    return &StructWithDoubleUnderscoresBuilder{
        obj: NewStructWithDoubleUnderscores(),
    }
}

func (x *StructWithDoubleUnderscoresBuilder) _Field(value int32) *StructWithDoubleUnderscoresBuilder {
    x.obj._Field = value
    return x
}

func (x *StructWithDoubleUnderscoresBuilder) Emit() *StructWithDoubleUnderscores {
    var objCopy StructWithDoubleUnderscores = *x.obj
    return &objCopy
}

func (x *StructWithDoubleUnderscores) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("StructWithDoubleUnderscores"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // __field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

