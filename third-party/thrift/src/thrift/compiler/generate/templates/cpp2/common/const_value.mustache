{{!

  Copyright (c) Meta Platforms, Inc. and affiliates.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}

{{! Primitive Constant Value }}
{{#let export partial primitive |value|}}
{{#pragma ignore-newlines}}
  {{#if value.bool?}}
{{value.bool_value}}
  {{#else if value.integer?}}
static_cast<{{value.const_type.cpp_standard_type}}>({{value.integer_value}})
  {{#else if value.double?}}
static_cast<{{value.const_type.cpp_standard_type}}>({{value.double_value}})
  {{#else if value.string?}}
"{{value.string_value}}"
  {{#else if value.enum?}}
    {{#if value.enum_value?}}
 ::{{value.const_type.qualified_namespace}}::{{value.const_type.cpp_name}}::{{value.enum_value.cpp_name}}
    {{#else}}
static_cast< ::{{value.const_type.qualified_namespace}}::{{value.const_type.cpp_name}}>({{value.integer_value}})
    {{/if value.enum_value?}}
  {{/if value.bool?}}
{{/let partial}}

{{#let export partial iterate_const_values |value root_const| captures |primitive|}}
{{#pragma ignore-newlines}}
  {{!
    These are NESTED PARTIALS - i.e. only available within the scope of `iterate_const_values`.
    The reason they are nested, rather than top-level partials, is because they have a circular
    dependency with `iterate_const_values` - e.g. `iterate_const_values` renders list values which
    use `iterate_const_values_adapted_nested`, which in turn renders `iterate_const_values`.
    It is impossible to express a circular dependency between top-level partials, but a nested
    partial can capture and render its parent.
  }}
  {{! Used by list/map values }}
  {{#let partial iterate_const_values_adapted_nested |value| captures |iterate_const_values root_const|}}
{{#pragma ignore-newlines}}
{{#if value.const_type.cpp_adapter}}{{value.const_type.cpp_adapter}}::fromThrift({{value.const_type.cpp_standard_type}}({{/if}}
{{#partial iterate_const_values value=value root_const=root_const}}
{{#if value.const_type.cpp_adapter}})){{/if}}
  {{/let partial}}{{! end of `iterate_const_values_adapted_nested` nested partial }}

  {{!
    List/maps are rendered using nested partials because they need to render line breaks.
    The outer partial is much more readable if we isolate these two small cases which render
    line breaks, while leveraging `#pragma ignore-newlines` for the bulk of the template vs
    commenting every line break we don't want to emit.
  }}
  {{#let partial list_value captures |iterate_const_values_adapted_nested value|}}
std::initializer_list<{{value.const_type.true_type.elem_type.cpp_type}}>{{!
  }}{ {{#each (array.enumerate value.list_elements with_last=true) as |i elem last?|}}{{!
}}{{#partial iterate_const_values_adapted_nested value=elem}}{{#if (not last?)}},
  {{/if (not last?)}}{{/each}} }{{!
}}{{/let partial}}{{! end of `list_value` nested partial }}

  {{#let partial map_value captures |iterate_const_values_adapted_nested value|}}
std::initializer_list<{{value.const_type.cpp_type}}::value_type>{{!
  }}{ {{#each (array.enumerate value.map_elements with_last=true) as |i elem last?|}}{{!
}}{ {{#partial iterate_const_values_adapted_nested value=elem.key}}, {{!
}}{{#partial iterate_const_values_adapted_nested value=elem.value}} }{{#if (not last?)}},
  {{/if (not last?)}}{{/each}} }{{!
}}{{/let partial}}{{! end of `map_value` nested partial }}


{{! End of nested partials; start of main `iterate_const_values` content }}
  {{#if value.string?}}
apache::thrift::StringTraits<{{value.const_type.cpp_standard_type}}>::fromStringLiteral({{#partial primitive value=value}})
  {{#else if (not value.container?)}}
    {{! Any non-string primitive or enum type }}
{{#partial primitive value=value}}
  {{#else if (and (value.referenceable_from? root_const) (or value.owner.external? (cpp_enable_same_program_const_referencing?)))}}
    {{! Reference other constants:
        This is allowed when a value is considered referenceable AND the const to be
        referenced is defined in an external program (i.e. external? is true), or same
        program const referencing is enabled in the current context. }}
::{{value.owner.program.qualified_namespace}}::{{value.owner.program.name}}_constants::{{value.owner.name}}()
  {{#else if value.structured?}}
    {{! Struct/union values }}
::apache::thrift::detail::make_structured_constant<{{value.const_type.cpp_standard_type}}>(
    {{#each (array.enumerate value.structured_elements with_last=true) as |i elem last?|}}
      {{#let cpp_first_adapter = elem.field.cpp_first_adapter}}
::apache::thrift::detail::wrap_struct_argument<::apache::thrift::ident::{{elem.field.cpp_name}}
{{#if (object.notnull? cpp_first_adapter)}}, {{cpp_first_adapter}}, ::apache::thrift::FieldId{ {{elem.field.id}} }{{/if}}>(
{{#partial iterate_const_values value=elem.value root_const=root_const}}){{#if (not last?)}}, {{/if}}
    {{/each}}
)

  {{#else if (and value.list? (or value.const_type.list? value.const_type.set?))}}
{{#partial list_value}}
  {{#else if value.map?}}
{{#partial map_value}}
  {{/if value.string?}}
{{/let partial}}

{{! This has the same implementation as `iterate_const_values_adapted_nested`, but
    exported for use in `module_constants`. }}
{{#let export partial iterate_const_values_adapted |value root_const| captures |iterate_const_values|}}
{{#pragma ignore-newlines}}
{{#if value.const_type.cpp_adapter}}{{value.const_type.cpp_adapter}}::fromThrift({{value.const_type.cpp_standard_type}}({{/if}}
{{#partial iterate_const_values value=value root_const=root_const}}
{{#if value.const_type.cpp_adapter}})){{/if}}
{{/let partial}}
