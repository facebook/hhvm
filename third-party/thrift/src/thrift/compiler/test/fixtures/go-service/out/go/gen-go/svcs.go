// Autogenerated by Thrift for thrift/compiler/test/fixtures/go-service/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "context"
    "errors"
    "fmt"
    "io"
    "reflect"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = io.EOF
var _ = reflect.Ptr
var _ = thrift.VOID
var _ = metadata.GoUnusedProtection__


type GetEntity interface {
    GetEntity(ctx context.Context, r *GetEntityRequest) (*GetEntityResponse, error)
    GetBool(ctx context.Context) (bool, error)
    GetByte(ctx context.Context) (int8, error)
    GetI16(ctx context.Context) (int16, error)
    GetI32(ctx context.Context) (int32, error)
    GetI64(ctx context.Context) (int64, error)
    GetDouble(ctx context.Context) (float64, error)
    GetString(ctx context.Context) (string, error)
    GetBinary(ctx context.Context) ([]byte, error)
    GetMap(ctx context.Context) (map[string]string, error)
    GetSet(ctx context.Context) ([]string, error)
    GetList(ctx context.Context) ([]string, error)
    GetLegacyStuff(ctx context.Context, numPos int64, numNeg1 int64, numNeg2 int64) (int32, error)
    GetCtxCollision(ctx1 context.Context, ctx int64) (int32, error)
    GetCtx1Collision(ctx2 context.Context, ctx int64, ctx1 int64) (int32, error)
    GetContextCollision(ctx context.Context, context_ int64) (int32, error)
    GetOutCollision(ctx context.Context, out int64) (int32, error)
    GetOut1Collision(ctx context.Context, out int64, out1 int64) (int32, error)
    GetInCollision(ctx context.Context, in int64) (int32, error)
    GetIn1Collision(ctx context.Context, in int64, in1 int64) (int32, error)
    GetErrCollision(ctx context.Context, err int64) (int32, error)
    GetErr1Collision(ctx context.Context, err int64, err1 int64) (int32, error)
    MyMethodWithConflictingParamAccessors(ctx context.Context, setFoo bool, foo string) (error)
}

type GetEntityClientInterface interface {
    io.Closer
    GetEntity(ctx context.Context, r *GetEntityRequest) (*GetEntityResponse, error)
    GetBool(ctx context.Context) (bool, error)
    GetByte(ctx context.Context) (int8, error)
    GetI16(ctx context.Context) (int16, error)
    GetI32(ctx context.Context) (int32, error)
    GetI64(ctx context.Context) (int64, error)
    GetDouble(ctx context.Context) (float64, error)
    GetString(ctx context.Context) (string, error)
    GetBinary(ctx context.Context) ([]byte, error)
    GetMap(ctx context.Context) (map[string]string, error)
    GetSet(ctx context.Context) ([]string, error)
    GetList(ctx context.Context) ([]string, error)
    GetLegacyStuff(ctx context.Context, numPos int64, numNeg1 int64, numNeg2 int64) (int32, error)
    GetCtxCollision(ctx1 context.Context, ctx int64) (int32, error)
    GetCtx1Collision(ctx2 context.Context, ctx int64, ctx1 int64) (int32, error)
    GetContextCollision(ctx context.Context, context_ int64) (int32, error)
    GetOutCollision(ctx context.Context, out int64) (int32, error)
    GetOut1Collision(ctx context.Context, out int64, out1 int64) (int32, error)
    GetInCollision(ctx context.Context, in int64) (int32, error)
    GetIn1Collision(ctx context.Context, in int64, in1 int64) (int32, error)
    GetErrCollision(ctx context.Context, err int64) (int32, error)
    GetErr1Collision(ctx context.Context, err int64, err1 int64) (int32, error)
    MyMethodWithConflictingParamAccessors(ctx context.Context, setFoo bool, foo string) (error)
}

type getEntityClientImpl struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ GetEntityClientInterface = (*getEntityClientImpl)(nil)

// Deprecated: this type is deprecated, please use GetEntityClientInterface instead.
type GetEntityClient = getEntityClientImpl

func NewGetEntityChannelClient(channel thrift.RequestChannel) *getEntityClientImpl {
    return &getEntityClientImpl{
        ch: channel,
    }
}

func (c *getEntityClientImpl) Close() error {
    return c.ch.Close()
}

func (c *getEntityClientImpl) GetEntity(ctx context.Context, r *GetEntityRequest) (*GetEntityResponse, error) {
    fbthriftReq := &reqGetEntityGetEntity{
        R: r,
    }
    fbthriftResp := newRespGetEntityGetEntity()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getEntity", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetBool(ctx context.Context) (bool, error) {
    fbthriftReq := &reqGetEntityGetBool{
    }
    fbthriftResp := newRespGetEntityGetBool()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getBool", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return false, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return false, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetByte(ctx context.Context) (int8, error) {
    fbthriftReq := &reqGetEntityGetByte{
    }
    fbthriftResp := newRespGetEntityGetByte()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getByte", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetI16(ctx context.Context) (int16, error) {
    fbthriftReq := &reqGetEntityGetI16{
    }
    fbthriftResp := newRespGetEntityGetI16()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getI16", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetI32(ctx context.Context) (int32, error) {
    fbthriftReq := &reqGetEntityGetI32{
    }
    fbthriftResp := newRespGetEntityGetI32()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getI32", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetI64(ctx context.Context) (int64, error) {
    fbthriftReq := &reqGetEntityGetI64{
    }
    fbthriftResp := newRespGetEntityGetI64()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getI64", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetDouble(ctx context.Context) (float64, error) {
    fbthriftReq := &reqGetEntityGetDouble{
    }
    fbthriftResp := newRespGetEntityGetDouble()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getDouble", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0.0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0.0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetString(ctx context.Context) (string, error) {
    fbthriftReq := &reqGetEntityGetString{
    }
    fbthriftResp := newRespGetEntityGetString()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getString", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return "", fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return "", fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetBinary(ctx context.Context) ([]byte, error) {
    fbthriftReq := &reqGetEntityGetBinary{
    }
    fbthriftResp := newRespGetEntityGetBinary()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getBinary", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetMap(ctx context.Context) (map[string]string, error) {
    fbthriftReq := &reqGetEntityGetMap{
    }
    fbthriftResp := newRespGetEntityGetMap()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getMap", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetSet(ctx context.Context) ([]string, error) {
    fbthriftReq := &reqGetEntityGetSet{
    }
    fbthriftResp := newRespGetEntityGetSet()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getSet", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetList(ctx context.Context) ([]string, error) {
    fbthriftReq := &reqGetEntityGetList{
    }
    fbthriftResp := newRespGetEntityGetList()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getList", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetLegacyStuff(ctx context.Context, numPos int64, numNeg1 int64, numNeg2 int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetLegacyStuff{
        NumPos: numPos,
        NumNeg1: numNeg1,
        NumNeg2: numNeg2,
    }
    fbthriftResp := newRespGetEntityGetLegacyStuff()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getLegacyStuff", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetCtxCollision(ctx1 context.Context, ctx int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetCtxCollision{
        Ctx: ctx,
    }
    fbthriftResp := newRespGetEntityGetCtxCollision()
    fbthriftErr := c.ch.SendRequestResponse(ctx1, "getCtxCollision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetCtx1Collision(ctx2 context.Context, ctx int64, ctx1 int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetCtx1Collision{
        Ctx: ctx,
        Ctx1: ctx1,
    }
    fbthriftResp := newRespGetEntityGetCtx1Collision()
    fbthriftErr := c.ch.SendRequestResponse(ctx2, "getCtx1Collision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetContextCollision(ctx context.Context, context_ int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetContextCollision{
        Context: context_,
    }
    fbthriftResp := newRespGetEntityGetContextCollision()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getContextCollision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetOutCollision(ctx context.Context, out int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetOutCollision{
        Out: out,
    }
    fbthriftResp := newRespGetEntityGetOutCollision()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getOutCollision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetOut1Collision(ctx context.Context, out int64, out1 int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetOut1Collision{
        Out: out,
        Out1: out1,
    }
    fbthriftResp := newRespGetEntityGetOut1Collision()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getOut1Collision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetInCollision(ctx context.Context, in int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetInCollision{
        In: in,
    }
    fbthriftResp := newRespGetEntityGetInCollision()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getInCollision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetIn1Collision(ctx context.Context, in int64, in1 int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetIn1Collision{
        In: in,
        In1: in1,
    }
    fbthriftResp := newRespGetEntityGetIn1Collision()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getIn1Collision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetErrCollision(ctx context.Context, err int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetErrCollision{
        Err: err,
    }
    fbthriftResp := newRespGetEntityGetErrCollision()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getErrCollision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) GetErr1Collision(ctx context.Context, err int64, err1 int64) (int32, error) {
    fbthriftReq := &reqGetEntityGetErr1Collision{
        Err: err,
        Err1: err1,
    }
    fbthriftResp := newRespGetEntityGetErr1Collision()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "getErr1Collision", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return 0, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return 0, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), nil
}

func (c *getEntityClientImpl) MyMethodWithConflictingParamAccessors(ctx context.Context, setFoo bool, foo string) (error) {
    fbthriftReq := &reqGetEntityMyMethodWithConflictingParamAccessors{
        SetFoo: setFoo,
        Foo: foo,
    }
    fbthriftResp := newRespGetEntityMyMethodWithConflictingParamAccessors()
    fbthriftErr := c.ch.SendRequestResponse(ctx, "myMethodWithConflictingParamAccessors", fbthriftReq, fbthriftResp)
    if fbthriftErr != nil {
        return fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        return fbthriftEx
    }
    return nil
}


type GetEntityProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler              GetEntity
}

func NewGetEntityProcessor(handler GetEntity) *GetEntityProcessor {
    p := &GetEntityProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("getEntity", &procFuncGetEntityGetEntity{handler: handler})
    p.AddToProcessorFunctionMap("getBool", &procFuncGetEntityGetBool{handler: handler})
    p.AddToProcessorFunctionMap("getByte", &procFuncGetEntityGetByte{handler: handler})
    p.AddToProcessorFunctionMap("getI16", &procFuncGetEntityGetI16{handler: handler})
    p.AddToProcessorFunctionMap("getI32", &procFuncGetEntityGetI32{handler: handler})
    p.AddToProcessorFunctionMap("getI64", &procFuncGetEntityGetI64{handler: handler})
    p.AddToProcessorFunctionMap("getDouble", &procFuncGetEntityGetDouble{handler: handler})
    p.AddToProcessorFunctionMap("getString", &procFuncGetEntityGetString{handler: handler})
    p.AddToProcessorFunctionMap("getBinary", &procFuncGetEntityGetBinary{handler: handler})
    p.AddToProcessorFunctionMap("getMap", &procFuncGetEntityGetMap{handler: handler})
    p.AddToProcessorFunctionMap("getSet", &procFuncGetEntityGetSet{handler: handler})
    p.AddToProcessorFunctionMap("getList", &procFuncGetEntityGetList{handler: handler})
    p.AddToProcessorFunctionMap("getLegacyStuff", &procFuncGetEntityGetLegacyStuff{handler: handler})
    p.AddToProcessorFunctionMap("getCtxCollision", &procFuncGetEntityGetCtxCollision{handler: handler})
    p.AddToProcessorFunctionMap("getCtx1Collision", &procFuncGetEntityGetCtx1Collision{handler: handler})
    p.AddToProcessorFunctionMap("getContextCollision", &procFuncGetEntityGetContextCollision{handler: handler})
    p.AddToProcessorFunctionMap("getOutCollision", &procFuncGetEntityGetOutCollision{handler: handler})
    p.AddToProcessorFunctionMap("getOut1Collision", &procFuncGetEntityGetOut1Collision{handler: handler})
    p.AddToProcessorFunctionMap("getInCollision", &procFuncGetEntityGetInCollision{handler: handler})
    p.AddToProcessorFunctionMap("getIn1Collision", &procFuncGetEntityGetIn1Collision{handler: handler})
    p.AddToProcessorFunctionMap("getErrCollision", &procFuncGetEntityGetErrCollision{handler: handler})
    p.AddToProcessorFunctionMap("getErr1Collision", &procFuncGetEntityGetErr1Collision{handler: handler})
    p.AddToProcessorFunctionMap("myMethodWithConflictingParamAccessors", &procFuncGetEntityMyMethodWithConflictingParamAccessors{handler: handler})
    p.AddToFunctionServiceMap("getEntity", "GetEntity")
    p.AddToFunctionServiceMap("getBool", "GetEntity")
    p.AddToFunctionServiceMap("getByte", "GetEntity")
    p.AddToFunctionServiceMap("getI16", "GetEntity")
    p.AddToFunctionServiceMap("getI32", "GetEntity")
    p.AddToFunctionServiceMap("getI64", "GetEntity")
    p.AddToFunctionServiceMap("getDouble", "GetEntity")
    p.AddToFunctionServiceMap("getString", "GetEntity")
    p.AddToFunctionServiceMap("getBinary", "GetEntity")
    p.AddToFunctionServiceMap("getMap", "GetEntity")
    p.AddToFunctionServiceMap("getSet", "GetEntity")
    p.AddToFunctionServiceMap("getList", "GetEntity")
    p.AddToFunctionServiceMap("getLegacyStuff", "GetEntity")
    p.AddToFunctionServiceMap("getCtxCollision", "GetEntity")
    p.AddToFunctionServiceMap("getCtx1Collision", "GetEntity")
    p.AddToFunctionServiceMap("getContextCollision", "GetEntity")
    p.AddToFunctionServiceMap("getOutCollision", "GetEntity")
    p.AddToFunctionServiceMap("getOut1Collision", "GetEntity")
    p.AddToFunctionServiceMap("getInCollision", "GetEntity")
    p.AddToFunctionServiceMap("getIn1Collision", "GetEntity")
    p.AddToFunctionServiceMap("getErrCollision", "GetEntity")
    p.AddToFunctionServiceMap("getErr1Collision", "GetEntity")
    p.AddToFunctionServiceMap("myMethodWithConflictingParamAccessors", "GetEntity")

    return p
}

func (p *GetEntityProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *GetEntityProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *GetEntityProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *GetEntityProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *GetEntityProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *GetEntityProcessor) PackageName() string {
    return "module"
}

func (p *GetEntityProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.GetEntity")
}


type procFuncGetEntityGetEntity struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetEntity)(nil)

func (p *procFuncGetEntityGetEntity) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetEntity()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetEntity) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getEntity", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetEntity) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetEntity)
    result := newRespGetEntityGetEntity()
    retval, err := p.handler.GetEntity(ctx, args.R)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetEntity: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetBool struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetBool)(nil)

func (p *procFuncGetEntityGetBool) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetBool()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetBool) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getBool", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetBool) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetBool()
    retval, err := p.handler.GetBool(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetBool: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetByte struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetByte)(nil)

func (p *procFuncGetEntityGetByte) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetByte()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetByte) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getByte", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetByte) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetByte()
    retval, err := p.handler.GetByte(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetByte: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetI16 struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetI16)(nil)

func (p *procFuncGetEntityGetI16) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetI16()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetI16) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getI16", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetI16) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetI16()
    retval, err := p.handler.GetI16(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetI16: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetI32 struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetI32)(nil)

func (p *procFuncGetEntityGetI32) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetI32()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetI32) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getI32", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetI32) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetI32()
    retval, err := p.handler.GetI32(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetI32: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetI64 struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetI64)(nil)

func (p *procFuncGetEntityGetI64) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetI64()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetI64) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getI64", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetI64) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetI64()
    retval, err := p.handler.GetI64(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetI64: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetDouble struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetDouble)(nil)

func (p *procFuncGetEntityGetDouble) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetDouble()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetDouble) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getDouble", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetDouble) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetDouble()
    retval, err := p.handler.GetDouble(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetDouble: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetString struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetString)(nil)

func (p *procFuncGetEntityGetString) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetString()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetString) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getString", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetString) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetString()
    retval, err := p.handler.GetString(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetString: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetBinary struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetBinary)(nil)

func (p *procFuncGetEntityGetBinary) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetBinary()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetBinary) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getBinary", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetBinary) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetBinary()
    retval, err := p.handler.GetBinary(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetBinary: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetMap struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetMap)(nil)

func (p *procFuncGetEntityGetMap) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetMap()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetMap) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getMap", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetMap) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetMap()
    retval, err := p.handler.GetMap(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetMap: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetSet struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetSet)(nil)

func (p *procFuncGetEntityGetSet) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetSet()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetSet) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getSet", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetSet) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetSet()
    retval, err := p.handler.GetSet(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetSet: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetList struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetList)(nil)

func (p *procFuncGetEntityGetList) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetList()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetList) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getList", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetList) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    result := newRespGetEntityGetList()
    retval, err := p.handler.GetList(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetList: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetLegacyStuff struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetLegacyStuff)(nil)

func (p *procFuncGetEntityGetLegacyStuff) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetLegacyStuff()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetLegacyStuff) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getLegacyStuff", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetLegacyStuff) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetLegacyStuff)
    result := newRespGetEntityGetLegacyStuff()
    retval, err := p.handler.GetLegacyStuff(ctx, args.NumPos, args.NumNeg1, args.NumNeg2)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetLegacyStuff: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetCtxCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetCtxCollision)(nil)

func (p *procFuncGetEntityGetCtxCollision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetCtxCollision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetCtxCollision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getCtxCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetCtxCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetCtxCollision)
    result := newRespGetEntityGetCtxCollision()
    retval, err := p.handler.GetCtxCollision(ctx, args.Ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetCtxCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetCtx1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetCtx1Collision)(nil)

func (p *procFuncGetEntityGetCtx1Collision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetCtx1Collision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetCtx1Collision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getCtx1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetCtx1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetCtx1Collision)
    result := newRespGetEntityGetCtx1Collision()
    retval, err := p.handler.GetCtx1Collision(ctx, args.Ctx, args.Ctx1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetCtx1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetContextCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetContextCollision)(nil)

func (p *procFuncGetEntityGetContextCollision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetContextCollision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetContextCollision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getContextCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetContextCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetContextCollision)
    result := newRespGetEntityGetContextCollision()
    retval, err := p.handler.GetContextCollision(ctx, args.Context)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetContextCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetOutCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetOutCollision)(nil)

func (p *procFuncGetEntityGetOutCollision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetOutCollision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetOutCollision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getOutCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetOutCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetOutCollision)
    result := newRespGetEntityGetOutCollision()
    retval, err := p.handler.GetOutCollision(ctx, args.Out)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetOutCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetOut1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetOut1Collision)(nil)

func (p *procFuncGetEntityGetOut1Collision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetOut1Collision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetOut1Collision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getOut1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetOut1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetOut1Collision)
    result := newRespGetEntityGetOut1Collision()
    retval, err := p.handler.GetOut1Collision(ctx, args.Out, args.Out1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetOut1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetInCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetInCollision)(nil)

func (p *procFuncGetEntityGetInCollision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetInCollision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetInCollision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getInCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetInCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetInCollision)
    result := newRespGetEntityGetInCollision()
    retval, err := p.handler.GetInCollision(ctx, args.In)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetInCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetIn1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetIn1Collision)(nil)

func (p *procFuncGetEntityGetIn1Collision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetIn1Collision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetIn1Collision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getIn1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetIn1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetIn1Collision)
    result := newRespGetEntityGetIn1Collision()
    retval, err := p.handler.GetIn1Collision(ctx, args.In, args.In1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetIn1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetErrCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetErrCollision)(nil)

func (p *procFuncGetEntityGetErrCollision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetErrCollision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetErrCollision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getErrCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetErrCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetErrCollision)
    result := newRespGetEntityGetErrCollision()
    retval, err := p.handler.GetErrCollision(ctx, args.Err)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetErrCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetErr1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetErr1Collision)(nil)

func (p *procFuncGetEntityGetErr1Collision) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityGetErr1Collision()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetErr1Collision) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("getErr1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetErr1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityGetErr1Collision)
    result := newRespGetEntityGetErr1Collision()
    retval, err := p.handler.GetErr1Collision(ctx, args.Err, args.Err1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetErr1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityMyMethodWithConflictingParamAccessors struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityMyMethodWithConflictingParamAccessors)(nil)

func (p *procFuncGetEntityMyMethodWithConflictingParamAccessors) Read(decoder thrift.Decoder) (thrift.Struct, error) {
    args := newReqGetEntityMyMethodWithConflictingParamAccessors()
    if err := args.Read(decoder); err != nil {
        return nil, err
    }
    decoder.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityMyMethodWithConflictingParamAccessors) Write(seqId int32, result thrift.WritableStruct, encoder thrift.Encoder) (err error) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationExceptionIf:
        messageType = thrift.EXCEPTION
    }

    if err2 = encoder.WriteMessageBegin("myMethodWithConflictingParamAccessors", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(encoder); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = encoder.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityMyMethodWithConflictingParamAccessors) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationExceptionIf) {
    args := reqStruct.(*reqGetEntityMyMethodWithConflictingParamAccessors)
    result := newRespGetEntityMyMethodWithConflictingParamAccessors()
    err := p.handler.MyMethodWithConflictingParamAccessors(ctx, args.SetFoo, args.Foo)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing MyMethodWithConflictingParamAccessors: " + err.Error(), err)
        return x, x
    }

    return result, nil
}


