// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package cpp // [[[ program thrift source path ]]]

import (
    "fmt"
    "strings"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = strings.Split
var _ = thrift.ZERO


type RefType int32

const (
    RefType_Unique RefType = 0
    RefType_Shared RefType = 1
    RefType_SharedMutable RefType = 2
)

// Enum value maps for RefType
var (
    RefTypeToName = map[RefType]string {
        RefType_Unique: "Unique",
        RefType_Shared: "Shared",
        RefType_SharedMutable: "SharedMutable",
    }

    RefTypeToValue = map[string]RefType {
        "Unique": RefType_Unique,
        "Shared": RefType_Shared,
        "SharedMutable": RefType_SharedMutable,
    }

    RefTypeNames = []string{
        "Unique",
        "Shared",
        "SharedMutable",
    }

    RefTypeValues = []RefType{
        RefType_Unique,
        RefType_Shared,
        RefType_SharedMutable,
    }
)

func (x RefType) String() string {
    if v, ok := RefTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x RefType) Ptr() *RefType {
    return &x
}

// Deprecated: Use RefTypeToValue instead (e.g. `x, ok := RefTypeToValue["name"]`).
func RefTypeFromString(s string) (RefType, error) {
    if v, ok := RefTypeToValue[s]; ok {
        return v, nil
    }
    return RefType(0), fmt.Errorf("not a valid RefType string")
}

// Deprecated: Use RefType.Ptr() instead.
func RefTypePtr(v RefType) *RefType {
    return &v
}


type EnumUnderlyingType int32

const (
    EnumUnderlyingType_I8 EnumUnderlyingType = 0
    EnumUnderlyingType_U8 EnumUnderlyingType = 1
    EnumUnderlyingType_I16 EnumUnderlyingType = 2
    EnumUnderlyingType_U16 EnumUnderlyingType = 3
    EnumUnderlyingType_U32 EnumUnderlyingType = 4
)

// Enum value maps for EnumUnderlyingType
var (
    EnumUnderlyingTypeToName = map[EnumUnderlyingType]string {
        EnumUnderlyingType_I8: "I8",
        EnumUnderlyingType_U8: "U8",
        EnumUnderlyingType_I16: "I16",
        EnumUnderlyingType_U16: "U16",
        EnumUnderlyingType_U32: "U32",
    }

    EnumUnderlyingTypeToValue = map[string]EnumUnderlyingType {
        "I8": EnumUnderlyingType_I8,
        "U8": EnumUnderlyingType_U8,
        "I16": EnumUnderlyingType_I16,
        "U16": EnumUnderlyingType_U16,
        "U32": EnumUnderlyingType_U32,
    }

    EnumUnderlyingTypeNames = []string{
        "I8",
        "U8",
        "I16",
        "U16",
        "U32",
    }

    EnumUnderlyingTypeValues = []EnumUnderlyingType{
        EnumUnderlyingType_I8,
        EnumUnderlyingType_U8,
        EnumUnderlyingType_I16,
        EnumUnderlyingType_U16,
        EnumUnderlyingType_U32,
    }
)

func (x EnumUnderlyingType) String() string {
    if v, ok := EnumUnderlyingTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x EnumUnderlyingType) Ptr() *EnumUnderlyingType {
    return &x
}

// Deprecated: Use EnumUnderlyingTypeToValue instead (e.g. `x, ok := EnumUnderlyingTypeToValue["name"]`).
func EnumUnderlyingTypeFromString(s string) (EnumUnderlyingType, error) {
    if v, ok := EnumUnderlyingTypeToValue[s]; ok {
        return v, nil
    }
    return EnumUnderlyingType(0), fmt.Errorf("not a valid EnumUnderlyingType string")
}

// Deprecated: Use EnumUnderlyingType.Ptr() instead.
func EnumUnderlyingTypePtr(v EnumUnderlyingType) *EnumUnderlyingType {
    return &v
}


type Type struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    Template string `thrift:"template,2" json:"template" db:"template"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Type{}

func NewType() *Type {
    return (&Type{}).
        SetNameNonCompat("").
        SetTemplateNonCompat("")
}

func (x *Type) GetNameNonCompat() string {
    return x.Name
}

func (x *Type) GetName() string {
    return x.Name
}

func (x *Type) GetTemplateNonCompat() string {
    return x.Template
}

func (x *Type) GetTemplate() string {
    return x.Template
}

func (x *Type) SetNameNonCompat(value string) *Type {
    x.Name = value
    return x
}

func (x *Type) SetName(value string) *Type {
    x.Name = value
    return x
}

func (x *Type) SetTemplateNonCompat(value string) *Type {
    x.Template = value
    return x
}

func (x *Type) SetTemplate(value string) *Type {
    x.Template = value
    return x
}

func (x *Type) writeField1(p thrift.Protocol) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNameNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Type) writeField2(p thrift.Protocol) error {  // Template
    if err := p.WriteFieldBegin("template", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTemplateNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Type) readField1(p thrift.Protocol) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetNameNonCompat(result)
    return nil
}

func (x *Type) readField2(p thrift.Protocol) error {  // Template
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetTemplateNonCompat(result)
    return nil
}

func (x *Type) toString1() string {  // Name
    return fmt.Sprintf("%v", x.GetNameNonCompat())
}

func (x *Type) toString2() string {  // Template
    return fmt.Sprintf("%v", x.GetTemplateNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewType().Set<FieldNameFoo>().Set<FieldNameBar>()
type TypeBuilder struct {
    obj *Type
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewType().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewTypeBuilder() *TypeBuilder {
    return &TypeBuilder{
        obj: NewType(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewType().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *TypeBuilder) Name(value string) *TypeBuilder {
    x.obj.Name = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewType().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *TypeBuilder) Template(value string) *TypeBuilder {
    x.obj.Template = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewType().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *TypeBuilder) Emit() *Type {
    var objCopy Type = *x.obj
    return &objCopy
}

func (x *Type) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Type"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Type) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // name
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // template
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Type) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Type({")
    sb.WriteString(fmt.Sprintf("Name:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Template:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type Ref struct {
    Type RefType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Ref{}

func NewRef() *Ref {
    return (&Ref{}).
        SetTypeNonCompat(0)
}

func (x *Ref) GetTypeNonCompat() RefType {
    return x.Type
}

func (x *Ref) GetType() RefType {
    return x.Type
}

func (x *Ref) SetTypeNonCompat(value RefType) *Ref {
    x.Type = value
    return x
}

func (x *Ref) SetType(value RefType) *Ref {
    x.Type = value
    return x
}

func (x *Ref) writeField1(p thrift.Protocol) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTypeNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Ref) readField1(p thrift.Protocol) error {  // Type
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := RefType(enumResult)

    x.SetTypeNonCompat(result)
    return nil
}

func (x *Ref) toString1() string {  // Type
    return fmt.Sprintf("%v", x.GetTypeNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewRef().Set<FieldNameFoo>().Set<FieldNameBar>()
type RefBuilder struct {
    obj *Ref
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewRef().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewRefBuilder() *RefBuilder {
    return &RefBuilder{
        obj: NewRef(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewRef().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *RefBuilder) Type(value RefType) *RefBuilder {
    x.obj.Type = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewRef().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *RefBuilder) Emit() *Ref {
    var objCopy Ref = *x.obj
    return &objCopy
}

func (x *Ref) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Ref"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Ref) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // type
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Ref) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Ref({")
    sb.WriteString(fmt.Sprintf("Type:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type Lazy struct {
    Ref bool `thrift:"ref,1" json:"ref" db:"ref"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Lazy{}

func NewLazy() *Lazy {
    return (&Lazy{}).
        SetRefNonCompat(false)
}

func (x *Lazy) GetRefNonCompat() bool {
    return x.Ref
}

func (x *Lazy) GetRef() bool {
    return x.Ref
}

func (x *Lazy) SetRefNonCompat(value bool) *Lazy {
    x.Ref = value
    return x
}

func (x *Lazy) SetRef(value bool) *Lazy {
    x.Ref = value
    return x
}

func (x *Lazy) writeField1(p thrift.Protocol) error {  // Ref
    if err := p.WriteFieldBegin("ref", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetRefNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Lazy) readField1(p thrift.Protocol) error {  // Ref
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetRefNonCompat(result)
    return nil
}

func (x *Lazy) toString1() string {  // Ref
    return fmt.Sprintf("%v", x.GetRefNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewLazy().Set<FieldNameFoo>().Set<FieldNameBar>()
type LazyBuilder struct {
    obj *Lazy
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewLazy().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewLazyBuilder() *LazyBuilder {
    return &LazyBuilder{
        obj: NewLazy(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewLazy().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *LazyBuilder) Ref(value bool) *LazyBuilder {
    x.obj.Ref = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewLazy().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *LazyBuilder) Emit() *Lazy {
    var objCopy Lazy = *x.obj
    return &objCopy
}

func (x *Lazy) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Lazy"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Lazy) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // ref
            expectedType := thrift.Type(thrift.BOOL)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Lazy) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Lazy({")
    sb.WriteString(fmt.Sprintf("Ref:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type DisableLazyChecksum struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &DisableLazyChecksum{}

func NewDisableLazyChecksum() *DisableLazyChecksum {
    return (&DisableLazyChecksum{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewDisableLazyChecksum().Set<FieldNameFoo>().Set<FieldNameBar>()
type DisableLazyChecksumBuilder struct {
    obj *DisableLazyChecksum
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewDisableLazyChecksum().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewDisableLazyChecksumBuilder() *DisableLazyChecksumBuilder {
    return &DisableLazyChecksumBuilder{
        obj: NewDisableLazyChecksum(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewDisableLazyChecksum().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *DisableLazyChecksumBuilder) Emit() *DisableLazyChecksum {
    var objCopy DisableLazyChecksum = *x.obj
    return &objCopy
}

func (x *DisableLazyChecksum) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DisableLazyChecksum"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DisableLazyChecksum) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DisableLazyChecksum) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DisableLazyChecksum({")
    sb.WriteString("})")

    return sb.String()
}

type Adapter struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    AdaptedType string `thrift:"adaptedType,2" json:"adaptedType" db:"adaptedType"`
    UnderlyingName string `thrift:"underlyingName,3" json:"underlyingName" db:"underlyingName"`
    ExtraNamespace string `thrift:"extraNamespace,4" json:"extraNamespace" db:"extraNamespace"`
    MoveOnly bool `thrift:"moveOnly,5" json:"moveOnly" db:"moveOnly"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Adapter{}

func NewAdapter() *Adapter {
    return (&Adapter{}).
        SetNameNonCompat("").
        SetAdaptedTypeNonCompat("").
        SetUnderlyingNameNonCompat("").
        SetExtraNamespaceNonCompat("").
        SetMoveOnlyNonCompat(false)
}

func (x *Adapter) GetNameNonCompat() string {
    return x.Name
}

func (x *Adapter) GetName() string {
    return x.Name
}

func (x *Adapter) GetAdaptedTypeNonCompat() string {
    return x.AdaptedType
}

func (x *Adapter) GetAdaptedType() string {
    return x.AdaptedType
}

func (x *Adapter) GetUnderlyingNameNonCompat() string {
    return x.UnderlyingName
}

func (x *Adapter) GetUnderlyingName() string {
    return x.UnderlyingName
}

func (x *Adapter) GetExtraNamespaceNonCompat() string {
    return x.ExtraNamespace
}

func (x *Adapter) GetExtraNamespace() string {
    return x.ExtraNamespace
}

func (x *Adapter) GetMoveOnlyNonCompat() bool {
    return x.MoveOnly
}

func (x *Adapter) GetMoveOnly() bool {
    return x.MoveOnly
}

func (x *Adapter) SetNameNonCompat(value string) *Adapter {
    x.Name = value
    return x
}

func (x *Adapter) SetName(value string) *Adapter {
    x.Name = value
    return x
}

func (x *Adapter) SetAdaptedTypeNonCompat(value string) *Adapter {
    x.AdaptedType = value
    return x
}

func (x *Adapter) SetAdaptedType(value string) *Adapter {
    x.AdaptedType = value
    return x
}

func (x *Adapter) SetUnderlyingNameNonCompat(value string) *Adapter {
    x.UnderlyingName = value
    return x
}

func (x *Adapter) SetUnderlyingName(value string) *Adapter {
    x.UnderlyingName = value
    return x
}

func (x *Adapter) SetExtraNamespaceNonCompat(value string) *Adapter {
    x.ExtraNamespace = value
    return x
}

func (x *Adapter) SetExtraNamespace(value string) *Adapter {
    x.ExtraNamespace = value
    return x
}

func (x *Adapter) SetMoveOnlyNonCompat(value bool) *Adapter {
    x.MoveOnly = value
    return x
}

func (x *Adapter) SetMoveOnly(value bool) *Adapter {
    x.MoveOnly = value
    return x
}

func (x *Adapter) writeField1(p thrift.Protocol) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNameNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField2(p thrift.Protocol) error {  // AdaptedType
    if err := p.WriteFieldBegin("adaptedType", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAdaptedTypeNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField3(p thrift.Protocol) error {  // UnderlyingName
    if err := p.WriteFieldBegin("underlyingName", thrift.STRING, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetUnderlyingNameNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField4(p thrift.Protocol) error {  // ExtraNamespace
    if err := p.WriteFieldBegin("extraNamespace", thrift.STRING, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetExtraNamespaceNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField5(p thrift.Protocol) error {  // MoveOnly
    if err := p.WriteFieldBegin("moveOnly", thrift.BOOL, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMoveOnlyNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) readField1(p thrift.Protocol) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetNameNonCompat(result)
    return nil
}

func (x *Adapter) readField2(p thrift.Protocol) error {  // AdaptedType
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAdaptedTypeNonCompat(result)
    return nil
}

func (x *Adapter) readField3(p thrift.Protocol) error {  // UnderlyingName
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetUnderlyingNameNonCompat(result)
    return nil
}

func (x *Adapter) readField4(p thrift.Protocol) error {  // ExtraNamespace
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetExtraNamespaceNonCompat(result)
    return nil
}

func (x *Adapter) readField5(p thrift.Protocol) error {  // MoveOnly
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetMoveOnlyNonCompat(result)
    return nil
}

func (x *Adapter) toString1() string {  // Name
    return fmt.Sprintf("%v", x.GetNameNonCompat())
}

func (x *Adapter) toString2() string {  // AdaptedType
    return fmt.Sprintf("%v", x.GetAdaptedTypeNonCompat())
}

func (x *Adapter) toString3() string {  // UnderlyingName
    return fmt.Sprintf("%v", x.GetUnderlyingNameNonCompat())
}

func (x *Adapter) toString4() string {  // ExtraNamespace
    return fmt.Sprintf("%v", x.GetExtraNamespaceNonCompat())
}

func (x *Adapter) toString5() string {  // MoveOnly
    return fmt.Sprintf("%v", x.GetMoveOnlyNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
type AdapterBuilder struct {
    obj *Adapter
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewAdapterBuilder() *AdapterBuilder {
    return &AdapterBuilder{
        obj: NewAdapter(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *AdapterBuilder) Name(value string) *AdapterBuilder {
    x.obj.Name = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *AdapterBuilder) AdaptedType(value string) *AdapterBuilder {
    x.obj.AdaptedType = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *AdapterBuilder) UnderlyingName(value string) *AdapterBuilder {
    x.obj.UnderlyingName = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *AdapterBuilder) ExtraNamespace(value string) *AdapterBuilder {
    x.obj.ExtraNamespace = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *AdapterBuilder) MoveOnly(value bool) *AdapterBuilder {
    x.obj.MoveOnly = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewAdapter().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *AdapterBuilder) Emit() *Adapter {
    var objCopy Adapter = *x.obj
    return &objCopy
}

func (x *Adapter) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Adapter"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Adapter) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // name
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // adaptedType
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 3:  // underlyingName
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField3(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 4:  // extraNamespace
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField4(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 5:  // moveOnly
            expectedType := thrift.Type(thrift.BOOL)
            if wireType == expectedType {
                if err := x.readField5(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Adapter) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Adapter({")
    sb.WriteString(fmt.Sprintf("Name:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("AdaptedType:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("UnderlyingName:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("ExtraNamespace:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("MoveOnly:%s", x.toString5()))
    sb.WriteString("})")

    return sb.String()
}

type PackIsset struct {
    Atomic bool `thrift:"atomic,1" json:"atomic" db:"atomic"`
}
// Compile time interface enforcer
var _ thrift.Struct = &PackIsset{}

func NewPackIsset() *PackIsset {
    return (&PackIsset{}).
        SetAtomicNonCompat(true)
}

func (x *PackIsset) GetAtomicNonCompat() bool {
    return x.Atomic
}

func (x *PackIsset) GetAtomic() bool {
    return x.Atomic
}

func (x *PackIsset) SetAtomicNonCompat(value bool) *PackIsset {
    x.Atomic = value
    return x
}

func (x *PackIsset) SetAtomic(value bool) *PackIsset {
    x.Atomic = value
    return x
}

func (x *PackIsset) writeField1(p thrift.Protocol) error {  // Atomic
    if err := p.WriteFieldBegin("atomic", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAtomicNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) readField1(p thrift.Protocol) error {  // Atomic
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetAtomicNonCompat(result)
    return nil
}

func (x *PackIsset) toString1() string {  // Atomic
    return fmt.Sprintf("%v", x.GetAtomicNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewPackIsset().Set<FieldNameFoo>().Set<FieldNameBar>()
type PackIssetBuilder struct {
    obj *PackIsset
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewPackIsset().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewPackIssetBuilder() *PackIssetBuilder {
    return &PackIssetBuilder{
        obj: NewPackIsset(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewPackIsset().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *PackIssetBuilder) Atomic(value bool) *PackIssetBuilder {
    x.obj.Atomic = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewPackIsset().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *PackIssetBuilder) Emit() *PackIsset {
    var objCopy PackIsset = *x.obj
    return &objCopy
}

func (x *PackIsset) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("PackIsset"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // atomic
            expectedType := thrift.Type(thrift.BOOL)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *PackIsset) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("PackIsset({")
    sb.WriteString(fmt.Sprintf("Atomic:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type MinimizePadding struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &MinimizePadding{}

func NewMinimizePadding() *MinimizePadding {
    return (&MinimizePadding{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewMinimizePadding().Set<FieldNameFoo>().Set<FieldNameBar>()
type MinimizePaddingBuilder struct {
    obj *MinimizePadding
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewMinimizePadding().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewMinimizePaddingBuilder() *MinimizePaddingBuilder {
    return &MinimizePaddingBuilder{
        obj: NewMinimizePadding(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewMinimizePadding().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *MinimizePaddingBuilder) Emit() *MinimizePadding {
    var objCopy MinimizePadding = *x.obj
    return &objCopy
}

func (x *MinimizePadding) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MinimizePadding"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinimizePadding) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MinimizePadding) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MinimizePadding({")
    sb.WriteString("})")

    return sb.String()
}

type TriviallyRelocatable struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &TriviallyRelocatable{}

func NewTriviallyRelocatable() *TriviallyRelocatable {
    return (&TriviallyRelocatable{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewTriviallyRelocatable().Set<FieldNameFoo>().Set<FieldNameBar>()
type TriviallyRelocatableBuilder struct {
    obj *TriviallyRelocatable
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewTriviallyRelocatable().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewTriviallyRelocatableBuilder() *TriviallyRelocatableBuilder {
    return &TriviallyRelocatableBuilder{
        obj: NewTriviallyRelocatable(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewTriviallyRelocatable().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *TriviallyRelocatableBuilder) Emit() *TriviallyRelocatable {
    var objCopy TriviallyRelocatable = *x.obj
    return &objCopy
}

func (x *TriviallyRelocatable) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TriviallyRelocatable"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TriviallyRelocatable) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *TriviallyRelocatable) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("TriviallyRelocatable({")
    sb.WriteString("})")

    return sb.String()
}

type ScopedEnumAsUnionType struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &ScopedEnumAsUnionType{}

func NewScopedEnumAsUnionType() *ScopedEnumAsUnionType {
    return (&ScopedEnumAsUnionType{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewScopedEnumAsUnionType().Set<FieldNameFoo>().Set<FieldNameBar>()
type ScopedEnumAsUnionTypeBuilder struct {
    obj *ScopedEnumAsUnionType
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewScopedEnumAsUnionType().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewScopedEnumAsUnionTypeBuilder() *ScopedEnumAsUnionTypeBuilder {
    return &ScopedEnumAsUnionTypeBuilder{
        obj: NewScopedEnumAsUnionType(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewScopedEnumAsUnionType().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *ScopedEnumAsUnionTypeBuilder) Emit() *ScopedEnumAsUnionType {
    var objCopy ScopedEnumAsUnionType = *x.obj
    return &objCopy
}

func (x *ScopedEnumAsUnionType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ScopedEnumAsUnionType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ScopedEnumAsUnionType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ScopedEnumAsUnionType) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ScopedEnumAsUnionType({")
    sb.WriteString("})")

    return sb.String()
}

type StrongType struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &StrongType{}

func NewStrongType() *StrongType {
    return (&StrongType{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewStrongType().Set<FieldNameFoo>().Set<FieldNameBar>()
type StrongTypeBuilder struct {
    obj *StrongType
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewStrongType().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewStrongTypeBuilder() *StrongTypeBuilder {
    return &StrongTypeBuilder{
        obj: NewStrongType(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewStrongType().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *StrongTypeBuilder) Emit() *StrongType {
    var objCopy StrongType = *x.obj
    return &objCopy
}

func (x *StrongType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("StrongType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *StrongType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *StrongType) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("StrongType({")
    sb.WriteString("})")

    return sb.String()
}

type FieldInterceptor struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    Noinline bool `thrift:"noinline,2" json:"noinline" db:"noinline"`
}
// Compile time interface enforcer
var _ thrift.Struct = &FieldInterceptor{}

func NewFieldInterceptor() *FieldInterceptor {
    return (&FieldInterceptor{}).
        SetNameNonCompat("").
        SetNoinlineNonCompat(false)
}

func (x *FieldInterceptor) GetNameNonCompat() string {
    return x.Name
}

func (x *FieldInterceptor) GetName() string {
    return x.Name
}

func (x *FieldInterceptor) GetNoinlineNonCompat() bool {
    return x.Noinline
}

func (x *FieldInterceptor) GetNoinline() bool {
    return x.Noinline
}

func (x *FieldInterceptor) SetNameNonCompat(value string) *FieldInterceptor {
    x.Name = value
    return x
}

func (x *FieldInterceptor) SetName(value string) *FieldInterceptor {
    x.Name = value
    return x
}

func (x *FieldInterceptor) SetNoinlineNonCompat(value bool) *FieldInterceptor {
    x.Noinline = value
    return x
}

func (x *FieldInterceptor) SetNoinline(value bool) *FieldInterceptor {
    x.Noinline = value
    return x
}

func (x *FieldInterceptor) writeField1(p thrift.Protocol) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNameNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) writeField2(p thrift.Protocol) error {  // Noinline
    if err := p.WriteFieldBegin("noinline", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNoinlineNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) readField1(p thrift.Protocol) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetNameNonCompat(result)
    return nil
}

func (x *FieldInterceptor) readField2(p thrift.Protocol) error {  // Noinline
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetNoinlineNonCompat(result)
    return nil
}

func (x *FieldInterceptor) toString1() string {  // Name
    return fmt.Sprintf("%v", x.GetNameNonCompat())
}

func (x *FieldInterceptor) toString2() string {  // Noinline
    return fmt.Sprintf("%v", x.GetNoinlineNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFieldInterceptor().Set<FieldNameFoo>().Set<FieldNameBar>()
type FieldInterceptorBuilder struct {
    obj *FieldInterceptor
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFieldInterceptor().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewFieldInterceptorBuilder() *FieldInterceptorBuilder {
    return &FieldInterceptorBuilder{
        obj: NewFieldInterceptor(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFieldInterceptor().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *FieldInterceptorBuilder) Name(value string) *FieldInterceptorBuilder {
    x.obj.Name = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFieldInterceptor().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *FieldInterceptorBuilder) Noinline(value bool) *FieldInterceptorBuilder {
    x.obj.Noinline = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFieldInterceptor().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *FieldInterceptorBuilder) Emit() *FieldInterceptor {
    var objCopy FieldInterceptor = *x.obj
    return &objCopy
}

func (x *FieldInterceptor) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("FieldInterceptor"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // name
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // noinline
            expectedType := thrift.Type(thrift.BOOL)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *FieldInterceptor) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("FieldInterceptor({")
    sb.WriteString(fmt.Sprintf("Name:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Noinline:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type UseOpEncode struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &UseOpEncode{}

func NewUseOpEncode() *UseOpEncode {
    return (&UseOpEncode{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewUseOpEncode().Set<FieldNameFoo>().Set<FieldNameBar>()
type UseOpEncodeBuilder struct {
    obj *UseOpEncode
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewUseOpEncode().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewUseOpEncodeBuilder() *UseOpEncodeBuilder {
    return &UseOpEncodeBuilder{
        obj: NewUseOpEncode(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewUseOpEncode().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *UseOpEncodeBuilder) Emit() *UseOpEncode {
    var objCopy UseOpEncode = *x.obj
    return &objCopy
}

func (x *UseOpEncode) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("UseOpEncode"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *UseOpEncode) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *UseOpEncode) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("UseOpEncode({")
    sb.WriteString("})")

    return sb.String()
}

type EnumType struct {
    Type EnumUnderlyingType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = &EnumType{}

func NewEnumType() *EnumType {
    return (&EnumType{}).
        SetTypeNonCompat(0)
}

func (x *EnumType) GetTypeNonCompat() EnumUnderlyingType {
    return x.Type
}

func (x *EnumType) GetType() EnumUnderlyingType {
    return x.Type
}

func (x *EnumType) SetTypeNonCompat(value EnumUnderlyingType) *EnumType {
    x.Type = value
    return x
}

func (x *EnumType) SetType(value EnumUnderlyingType) *EnumType {
    x.Type = value
    return x
}

func (x *EnumType) writeField1(p thrift.Protocol) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTypeNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *EnumType) readField1(p thrift.Protocol) error {  // Type
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := EnumUnderlyingType(enumResult)

    x.SetTypeNonCompat(result)
    return nil
}

func (x *EnumType) toString1() string {  // Type
    return fmt.Sprintf("%v", x.GetTypeNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnumType().Set<FieldNameFoo>().Set<FieldNameBar>()
type EnumTypeBuilder struct {
    obj *EnumType
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnumType().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewEnumTypeBuilder() *EnumTypeBuilder {
    return &EnumTypeBuilder{
        obj: NewEnumType(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnumType().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *EnumTypeBuilder) Type(value EnumUnderlyingType) *EnumTypeBuilder {
    x.obj.Type = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnumType().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *EnumTypeBuilder) Emit() *EnumType {
    var objCopy EnumType = *x.obj
    return &objCopy
}

func (x *EnumType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("EnumType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *EnumType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // type
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *EnumType) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("EnumType({")
    sb.WriteString(fmt.Sprintf("Type:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type Frozen2Exclude struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &Frozen2Exclude{}

func NewFrozen2Exclude() *Frozen2Exclude {
    return (&Frozen2Exclude{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFrozen2Exclude().Set<FieldNameFoo>().Set<FieldNameBar>()
type Frozen2ExcludeBuilder struct {
    obj *Frozen2Exclude
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFrozen2Exclude().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewFrozen2ExcludeBuilder() *Frozen2ExcludeBuilder {
    return &Frozen2ExcludeBuilder{
        obj: NewFrozen2Exclude(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFrozen2Exclude().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *Frozen2ExcludeBuilder) Emit() *Frozen2Exclude {
    var objCopy Frozen2Exclude = *x.obj
    return &objCopy
}

func (x *Frozen2Exclude) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Frozen2Exclude"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Frozen2Exclude) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Frozen2Exclude) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Frozen2Exclude({")
    sb.WriteString("})")

    return sb.String()
}

type Frozen2RequiresCompleteContainerParams struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &Frozen2RequiresCompleteContainerParams{}

func NewFrozen2RequiresCompleteContainerParams() *Frozen2RequiresCompleteContainerParams {
    return (&Frozen2RequiresCompleteContainerParams{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFrozen2RequiresCompleteContainerParams().Set<FieldNameFoo>().Set<FieldNameBar>()
type Frozen2RequiresCompleteContainerParamsBuilder struct {
    obj *Frozen2RequiresCompleteContainerParams
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFrozen2RequiresCompleteContainerParams().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewFrozen2RequiresCompleteContainerParamsBuilder() *Frozen2RequiresCompleteContainerParamsBuilder {
    return &Frozen2RequiresCompleteContainerParamsBuilder{
        obj: NewFrozen2RequiresCompleteContainerParams(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewFrozen2RequiresCompleteContainerParams().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *Frozen2RequiresCompleteContainerParamsBuilder) Emit() *Frozen2RequiresCompleteContainerParams {
    var objCopy Frozen2RequiresCompleteContainerParams = *x.obj
    return &objCopy
}

func (x *Frozen2RequiresCompleteContainerParams) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Frozen2RequiresCompleteContainerParams"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Frozen2RequiresCompleteContainerParams) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Frozen2RequiresCompleteContainerParams) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Frozen2RequiresCompleteContainerParams({")
    sb.WriteString("})")

    return sb.String()
}

// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
	  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Type", func() any { return NewType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Ref", func() any { return NewRef() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Lazy", func() any { return NewLazy() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/DisableLazyChecksum", func() any { return NewDisableLazyChecksum() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Adapter", func() any { return NewAdapter() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/PackIsset", func() any { return NewPackIsset() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/MinimizePadding", func() any { return NewMinimizePadding() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/TriviallyRelocatable", func() any { return NewTriviallyRelocatable() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/ScopedEnumAsUnionType", func() any { return NewScopedEnumAsUnionType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/StrongType", func() any { return NewStrongType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/FieldInterceptor", func() any { return NewFieldInterceptor() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/UseOpEncode", func() any { return NewUseOpEncode() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/EnumType", func() any { return NewEnumType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Frozen2Exclude", func() any { return NewFrozen2Exclude() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Frozen2RequiresCompleteContainerParams", func() any { return NewFrozen2RequiresCompleteContainerParams() })

    registry.RegisterType("facebook.com/thrift/annotation/cpp/RefType", func() any { return RefType(0) })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/EnumUnderlyingType", func() any { return EnumUnderlyingType(0) })
}
