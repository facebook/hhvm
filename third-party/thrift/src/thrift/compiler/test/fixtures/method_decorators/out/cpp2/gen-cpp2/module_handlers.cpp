/**
 * Autogenerated by Thrift for 
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#include "thrift/compiler/test/fixtures/method_decorators/gen-cpp2/module_handlers.h"
#include "thrift/compiler/test/fixtures/method_decorators/gen-cpp2/module_handlers-inl.h"
#include "thrift/compiler/test/fixtures/method_decorators/gen-cpp2/module_metadata.h"

#include <thrift/lib/cpp2/gen/service_cpp.h>

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::getProcessor() {
  return std::make_unique<::cpp2::DecoratedServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::cpp2::DecoratedService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::cpp2::DecoratedService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::cpp2::DecoratedServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_getDecorators() {
  std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> out;
  for (auto& decoratorPtr : fbthrift_methodDecorators_) {
    out.emplace_back(std::ref(*decoratorPtr));
  }
  return out;
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_createLegacyPerforms(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_createLegacyPerforms(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_createLegacyPerforms(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_createLegacyPerforms(std::move(afterParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_noop(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_noop(std::move(afterParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_echo(std::move(beforeParams), p_text);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::string>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_echo(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_increment(std::move(beforeParams), p_num);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_increment(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::vector<::std::int64_t>>::type p_nums) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_sum(std::move(beforeParams), p_nums);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_sum(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_withStruct(std::move(beforeParams), p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_withStruct(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_multiParam(std::move(beforeParams), p_text, p_num, p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_multiParam(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_before_echoInteraction(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_echoInteraction(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::fbthrift_execute_decorators_after_echoInteraction(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_echoInteraction(std::move(afterParams));
  });
}

void apache::thrift::decorate(
    apache::thrift::ServiceHandler<::cpp2::DecoratedService>& handler,
    apache::thrift::ServiceMethodDecoratorList<::cpp2::DecoratedService> decorators) {
  handler.fbthrift_methodDecorators_ = std::move(decorators);
}

std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::cpp2::DecoratedServiceServiceInfoHolder apache::thrift::ServiceHandler<::cpp2::DecoratedService>::__fbthrift_serviceInfoHolder;

//
// Service Methods
//


std::unique_ptr<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::LegacyPerformsIf> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::createLegacyPerforms() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("createLegacyPerforms");
}
//
// End of Method 'createLegacyPerforms'
//

//
// Method 'noop'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::noop() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("noop");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sync_noop() {
  return noop();
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::semifuture_noop() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_noop();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::future_noop() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_noop(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_noop() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_noop(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_noop();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::async_tm_noop(
    apache::thrift::HandlerCallbackPtr<void> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_noop.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_noop.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_noop(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_noop.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_noop();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_noop();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_noop(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_noop();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_noop();
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'noop'
//

//
// Method 'echo'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::echo(::std::string& /*_return*/, std::unique_ptr<::std::string> /*text*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("echo");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sync_echo(::std::string& _return, std::unique_ptr<::std::string> p_text) {
  return echo(_return, std::move(p_text));
}

folly::SemiFuture<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::semifuture_echo(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_echo(*ret, std::move(p_text));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::future_echo(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_echo(std::move(p_text)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_echo(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::string> /*text*/>(std::move(p_text)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_echo(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_echo(std::move(p_text));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::async_tm_echo(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>> callback, std::unique_ptr<::std::string> p_text) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_echo.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_echo.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_echo(params, std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_echo.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_echo(std::move(p_text));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_echo(std::move(p_text));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_echo(params, std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_echo(std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::std::string _return;
        sync_echo(_return, std::move(p_text));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_text) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*text*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'echo'
//

//
// Method 'increment'
//

::std::int64_t apache::thrift::ServiceHandler<::cpp2::DecoratedService>::increment(::std::int64_t /*num*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("increment");
}

::std::int64_t apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sync_increment(::std::int64_t p_num) {
  return increment(p_num);
}

folly::SemiFuture<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::semifuture_increment(::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_increment(p_num);
}

folly::Future<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::future_increment(::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_increment(p_num),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_increment(::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<::std::int64_t /*num*/>(p_num));
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_increment(
    apache::thrift::RequestParams /* params */, ::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_increment(p_num);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::async_tm_increment(
    apache::thrift::HandlerCallbackPtr<::std::int64_t> callback, ::std::int64_t p_num) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_increment.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_increment.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_increment(params, p_num);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_increment.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_increment(p_num);
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_increment(p_num);
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_increment(params, p_num);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_increment(p_num);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_increment(p_num));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_num) = std::move(ex).restoreArgs<::std::int64_t /*num*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'increment'
//

//
// Method 'sum'
//

::std::int64_t apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sum(std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum");
}

::std::int64_t apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sync_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  return sum(std::move(p_nums));
}

folly::SemiFuture<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::semifuture_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_sum(std::move(p_nums));
}

folly::Future<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::future_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_sum(std::move(p_nums)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/>(std::move(p_nums)));
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_sum(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_sum(std::move(p_nums));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::async_tm_sum(
    apache::thrift::HandlerCallbackPtr<::std::int64_t> callback, std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_sum.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_sum(params, std::move(p_nums));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_sum(std::move(p_nums));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_sum(std::move(p_nums));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_sum(params, std::move(p_nums));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_sum(std::move(p_nums));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_sum(std::move(p_nums)));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_nums) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'sum'
//

//
// Method 'withStruct'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::withStruct(::cpp2::Response& /*_return*/, std::unique_ptr<::cpp2::Request> /*request*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("withStruct");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sync_withStruct(::cpp2::Response& _return, std::unique_ptr<::cpp2::Request> p_request) {
  return withStruct(_return, std::move(p_request));
}

folly::SemiFuture<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::semifuture_withStruct(std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2::Response>();
  sync_withStruct(*ret, std::move(p_request));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::future_withStruct(std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_withStruct(std::move(p_request)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_withStruct(std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::cpp2::Request> /*request*/>(std::move(p_request)));
}

folly::coro::Task<std::unique_ptr<::cpp2::Response>> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_withStruct(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_withStruct(std::move(p_request));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::async_tm_withStruct(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2::Response>> callback, std::unique_ptr<::cpp2::Request> p_request) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_withStruct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_withStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_withStruct(params, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_withStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_withStruct(std::move(p_request));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_withStruct(std::move(p_request));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_withStruct(params, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_withStruct(std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2::Response _return;
        sync_withStruct(_return, std::move(p_request));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_request) = std::move(ex).restoreArgs<std::unique_ptr<::cpp2::Request> /*request*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'withStruct'
//

//
// Method 'multiParam'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::multiParam(::cpp2::Response& /*_return*/, std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("multiParam");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sync_multiParam(::cpp2::Response& _return, std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  return multiParam(_return, std::move(p_text), p_num, std::move(p_request));
}

folly::SemiFuture<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::semifuture_multiParam(std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2::Response>();
  sync_multiParam(*ret, std::move(p_text), p_num, std::move(p_request));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::future_multiParam(std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_multiParam(std::move(p_text), p_num, std::move(p_request)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_multiParam(std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/>(std::move(p_text), p_num, std::move(p_request)));
}

folly::coro::Task<std::unique_ptr<::cpp2::Response>> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_multiParam(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_multiParam(std::move(p_text), p_num, std::move(p_request));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::async_tm_multiParam(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2::Response>> callback, std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_multiParam.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_multiParam.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_multiParam(params, std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_multiParam.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_multiParam(std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_multiParam(std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_multiParam(params, std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_multiParam(std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2::Response _return;
        sync_multiParam(_return, std::move(p_text), p_num, std::move(p_request));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_text, p_num, p_request) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'multiParam'
//

//
// Method 'echoInteraction'
//

apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf, void> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::echoInteraction() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("echoInteraction");
}

apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf, void> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::sync_echoInteraction() {
  return echoInteraction();
}

folly::SemiFuture<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf, void>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::semifuture_echoInteraction() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_echoInteraction.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_echoInteraction();
}

folly::Future<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf, void>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::future_echoInteraction() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_echoInteraction.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_echoInteraction(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf, void>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_echoInteraction() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_echoInteraction.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf, void>> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::co_echoInteraction(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_echoInteraction.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_echoInteraction();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::async_tm_echoInteraction(
    apache::thrift::HandlerCallbackPtr<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf, void>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_echoInteraction.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_echoInteraction.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_echoInteraction(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_echoInteraction.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_echoInteraction();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_echoInteraction();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_echoInteraction(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_echoInteraction();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_echoInteraction());
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'echoInteraction'
//

//
// End of Service Methods
//

//
// Service Methods
//

//
// Method 'perform'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::LegacyPerformsIf::perform() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("perform");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::LegacyPerformsIf::sync_perform() {
  return perform();
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::LegacyPerformsIf::semifuture_perform() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_perform.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_perform();
  return folly::makeSemiFuture();
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::LegacyPerformsIf::co_perform() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_perform.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::LegacyPerformsIf::co_perform(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_perform.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_perform();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::LegacyPerformsIf::async_tm_perform(
    apache::thrift::HandlerCallbackPtr<void> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_perform.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_perform.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_perform(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_perform.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::SemiFuture,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_perform();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_perform(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_perform();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_perform();
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'perform'
//

//
// End of Service Methods
//
//
// Service Methods
//

//
// Method 'interactionEcho'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf::interactionEcho(::std::string& /*_return*/, std::unique_ptr<::std::string> /*text*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("interactionEcho");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf::sync_interactionEcho(::std::string& _return, std::unique_ptr<::std::string> p_text) {
  return interactionEcho(_return, std::move(p_text));
}

folly::SemiFuture<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf::semifuture_interactionEcho(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_interactionEcho.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_interactionEcho(*ret, std::move(p_text));
  return folly::makeSemiFuture(std::move(ret));
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf::co_interactionEcho(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_interactionEcho.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::string> /*text*/>(std::move(p_text)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf::co_interactionEcho(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_interactionEcho.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_interactionEcho(std::move(p_text));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService>::EchoInteractionIf::async_tm_interactionEcho(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>> callback, std::unique_ptr<::std::string> p_text) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_interactionEcho.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_interactionEcho.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_interactionEcho(params, std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_interactionEcho.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::SemiFuture,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_interactionEcho(std::move(p_text));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_interactionEcho(params, std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_interactionEcho(std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::std::string _return;
        sync_interactionEcho(_return, std::move(p_text));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_text) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*text*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'interactionEcho'
//

//
// End of Service Methods
//

namespace cpp2 {

void DecoratedServiceSvNull::noop() { 
}

void DecoratedServiceSvNull::echo(::std::string& /*_return*/, std::unique_ptr<::std::string> /*text*/) {  }

::std::int64_t DecoratedServiceSvNull::increment(::std::int64_t /*num*/) { 
  return 0;
}

::std::int64_t DecoratedServiceSvNull::sum(std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/) { 
  return 0;
}

void DecoratedServiceSvNull::withStruct(::cpp2::Response& /*_return*/, std::unique_ptr<::cpp2::Request> /*request*/) {  }

void DecoratedServiceSvNull::multiParam(::cpp2::Response& /*_return*/, std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/) {  }


std::string_view DecoratedServiceAsyncProcessor::getServiceName() {
  return "DecoratedService";
}

void DecoratedServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen(response);
}

void DecoratedServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void DecoratedServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const DecoratedServiceAsyncProcessor::ProcessMap& DecoratedServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const DecoratedServiceAsyncProcessor::ProcessMap DecoratedServiceAsyncProcessor::kOwnProcessMap_ {
  {"noop",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_noop<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_noop<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_noop<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_noop<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"echo",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_echo<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_echo<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_echo<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_echo<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"increment",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_increment<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_increment<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_increment<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_increment<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_sum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_sum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_sum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_sum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"withStruct",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_withStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_withStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_withStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_withStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"multiParam",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_multiParam<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_multiParam<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_multiParam<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_multiParam<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"echoInteraction",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_echoInteraction<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_echoInteraction<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_echoInteraction<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_echoInteraction<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"LegacyPerforms.perform",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_LegacyPerforms_perform<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_LegacyPerforms_perform<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_LegacyPerforms_perform<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_LegacyPerforms_perform<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"EchoInteraction.interactionEcho",
    {&DecoratedServiceAsyncProcessor::setUpAndProcess_EchoInteraction_interactionEcho<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::setUpAndProcess_EchoInteraction_interactionEcho<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_EchoInteraction_interactionEcho<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedServiceAsyncProcessor::executeRequest_EchoInteraction_interactionEcho<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& DecoratedServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap DecoratedServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"noop",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.noop",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"echo",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.echo",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"increment",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.increment",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"sum",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.sum",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"withStruct",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.withStruct",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"multiParam",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.multiParam",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"echoInteraction",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.echoInteraction",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     "EchoInteraction"}},
  {"LegacyPerforms.perform",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.LegacyPerforms.perform",
     "LegacyPerforms",
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"EchoInteraction.interactionEcho",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService.EchoInteraction.interactionEcho",
     "EchoInteraction",
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };

  return requestInfoMap;
}
const DecoratedServiceAsyncProcessor::InteractionConstructorMap& DecoratedServiceAsyncProcessor::getInteractionConstructorMap() {
  return interactionConstructorMap_;
}

const DecoratedServiceAsyncProcessor::InteractionConstructorMap DecoratedServiceAsyncProcessor::interactionConstructorMap_ {
  {"LegacyPerforms", &DecoratedServiceAsyncProcessor::createLegacyPerforms},
};

std::unique_ptr<apache::thrift::Tile> DecoratedServiceAsyncProcessor::createInteractionImpl(const std::string& name, int16_t) {
  auto fn = getInteractionConstructorMap().at(name);
  return (this->*fn)();
}} // namespace cpp2

namespace apache::thrift::detail {
::folly::Range<const ::std::string_view*>(*TSchemaAssociation<::cpp2::DecoratedService, false>::bundle)() =
    nullptr;
}

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::getProcessor() {
  return std::make_unique<::cpp2::UndecoratedServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::cpp2::UndecoratedServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::cpp2::UndecoratedServiceServiceInfoHolder apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::__fbthrift_serviceInfoHolder;

//
// Service Methods
//

//
// Method 'noop'
//

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::noop() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("noop");
}

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sync_noop() {
  return noop();
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::semifuture_noop() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_noop();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::future_noop() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_noop(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_noop() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_noop(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_noop.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_noop();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::async_tm_noop(
    apache::thrift::HandlerCallbackPtr<void> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_noop.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_noop.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_noop(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_noop.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_noop();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_noop();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_noop(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_noop();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_noop();
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'noop'
//

//
// Method 'echo'
//

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::echo(::std::string& /*_return*/, std::unique_ptr<::std::string> /*text*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("echo");
}

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sync_echo(::std::string& _return, std::unique_ptr<::std::string> p_text) {
  return echo(_return, std::move(p_text));
}

folly::SemiFuture<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::semifuture_echo(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_echo(*ret, std::move(p_text));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::future_echo(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_echo(std::move(p_text)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_echo(std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::string> /*text*/>(std::move(p_text)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_echo(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_text) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_echo.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_echo(std::move(p_text));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::async_tm_echo(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>> callback, std::unique_ptr<::std::string> p_text) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_echo.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_echo.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_echo(params, std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_echo.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_echo(std::move(p_text));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_echo(std::move(p_text));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_echo(params, std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_echo(std::move(p_text));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::std::string _return;
        sync_echo(_return, std::move(p_text));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_text) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*text*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'echo'
//

//
// Method 'increment'
//

::std::int64_t apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::increment(::std::int64_t /*num*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("increment");
}

::std::int64_t apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sync_increment(::std::int64_t p_num) {
  return increment(p_num);
}

folly::SemiFuture<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::semifuture_increment(::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_increment(p_num);
}

folly::Future<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::future_increment(::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_increment(p_num),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_increment(::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<::std::int64_t /*num*/>(p_num));
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_increment(
    apache::thrift::RequestParams /* params */, ::std::int64_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_increment.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_increment(p_num);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::async_tm_increment(
    apache::thrift::HandlerCallbackPtr<::std::int64_t> callback, ::std::int64_t p_num) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_increment.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_increment.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_increment(params, p_num);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_increment.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_increment(p_num);
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_increment(p_num);
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_increment(params, p_num);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_increment(p_num);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_increment(p_num));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_num) = std::move(ex).restoreArgs<::std::int64_t /*num*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'increment'
//

//
// Method 'sum'
//

::std::int64_t apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sum(std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum");
}

::std::int64_t apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sync_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  return sum(std::move(p_nums));
}

folly::SemiFuture<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::semifuture_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  return sync_sum(std::move(p_nums));
}

folly::Future<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::future_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_sum(std::move(p_nums)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_sum(std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/>(std::move(p_nums)));
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_sum(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_sum.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_sum(std::move(p_nums));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::async_tm_sum(
    apache::thrift::HandlerCallbackPtr<::std::int64_t> callback, std::unique_ptr<::std::vector<::std::int64_t>> p_nums) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_sum.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_sum(params, std::move(p_nums));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_sum(std::move(p_nums));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_sum(std::move(p_nums));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_sum(params, std::move(p_nums));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_sum(std::move(p_nums));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        callback->result(sync_sum(std::move(p_nums)));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_nums) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'sum'
//

//
// Method 'withStruct'
//

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::withStruct(::cpp2::Response& /*_return*/, std::unique_ptr<::cpp2::Request> /*request*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("withStruct");
}

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sync_withStruct(::cpp2::Response& _return, std::unique_ptr<::cpp2::Request> p_request) {
  return withStruct(_return, std::move(p_request));
}

folly::SemiFuture<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::semifuture_withStruct(std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2::Response>();
  sync_withStruct(*ret, std::move(p_request));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::future_withStruct(std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_withStruct(std::move(p_request)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_withStruct(std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::cpp2::Request> /*request*/>(std::move(p_request)));
}

folly::coro::Task<std::unique_ptr<::cpp2::Response>> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_withStruct(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_withStruct.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_withStruct(std::move(p_request));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::async_tm_withStruct(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2::Response>> callback, std::unique_ptr<::cpp2::Request> p_request) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_withStruct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_withStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_withStruct(params, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_withStruct.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_withStruct(std::move(p_request));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_withStruct(std::move(p_request));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_withStruct(params, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_withStruct(std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2::Response _return;
        sync_withStruct(_return, std::move(p_request));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_request) = std::move(ex).restoreArgs<std::unique_ptr<::cpp2::Request> /*request*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'withStruct'
//

//
// Method 'multiParam'
//

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::multiParam(::cpp2::Response& /*_return*/, std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("multiParam");
}

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sync_multiParam(::cpp2::Response& _return, std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  return multiParam(_return, std::move(p_text), p_num, std::move(p_request));
}

folly::SemiFuture<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::semifuture_multiParam(std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2::Response>();
  sync_multiParam(*ret, std::move(p_text), p_num, std::move(p_request));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::future_multiParam(std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_multiParam(std::move(p_text), p_num, std::move(p_request)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_multiParam(std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/>(std::move(p_text), p_num, std::move(p_request)));
}

folly::coro::Task<std::unique_ptr<::cpp2::Response>> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_multiParam(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_multiParam.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_multiParam(std::move(p_text), p_num, std::move(p_request));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::async_tm_multiParam(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2::Response>> callback, std::unique_ptr<::std::string> p_text, ::std::int64_t p_num, std::unique_ptr<::cpp2::Request> p_request) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_multiParam.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_multiParam.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_multiParam(params, std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_multiParam.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_multiParam(std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_multiParam(std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_multiParam(params, std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_multiParam(std::move(p_text), p_num, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2::Response _return;
        sync_multiParam(_return, std::move(p_text), p_num, std::move(p_request));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_text, p_num, p_request) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'multiParam'
//

//
// Method 'adaptedRequest'
//

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::adaptedRequest(::cpp2::Response& /*_return*/, std::unique_ptr<::cpp2::AdaptedRequest> /*request*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("adaptedRequest");
}

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::sync_adaptedRequest(::cpp2::Response& _return, std::unique_ptr<::cpp2::AdaptedRequest> p_request) {
  return adaptedRequest(_return, std::move(p_request));
}

folly::SemiFuture<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::semifuture_adaptedRequest(std::unique_ptr<::cpp2::AdaptedRequest> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_adaptedRequest.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::cpp2::Response>();
  sync_adaptedRequest(*ret, std::move(p_request));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::future_adaptedRequest(std::unique_ptr<::cpp2::AdaptedRequest> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_adaptedRequest.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_adaptedRequest(std::move(p_request)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::cpp2::Response>>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_adaptedRequest(std::unique_ptr<::cpp2::AdaptedRequest> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_adaptedRequest.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::cpp2::AdaptedRequest> /*request*/>(std::move(p_request)));
}

folly::coro::Task<std::unique_ptr<::cpp2::Response>> apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::co_adaptedRequest(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::cpp2::AdaptedRequest> p_request) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_adaptedRequest.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_adaptedRequest(std::move(p_request));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService>::async_tm_adaptedRequest(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2::Response>> callback, std::unique_ptr<::cpp2::AdaptedRequest> p_request) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_adaptedRequest.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_adaptedRequest.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_adaptedRequest(params, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_adaptedRequest.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_adaptedRequest(std::move(p_request));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_adaptedRequest(std::move(p_request));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_adaptedRequest(params, std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_adaptedRequest(std::move(p_request));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::cpp2::Response _return;
        sync_adaptedRequest(_return, std::move(p_request));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_request) = std::move(ex).restoreArgs<std::unique_ptr<::cpp2::AdaptedRequest> /*request*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'adaptedRequest'
//

//
// End of Service Methods
//


namespace cpp2 {

void UndecoratedServiceSvNull::noop() { 
}

void UndecoratedServiceSvNull::echo(::std::string& /*_return*/, std::unique_ptr<::std::string> /*text*/) {  }

::std::int64_t UndecoratedServiceSvNull::increment(::std::int64_t /*num*/) { 
  return 0;
}

::std::int64_t UndecoratedServiceSvNull::sum(std::unique_ptr<::std::vector<::std::int64_t>> /*nums*/) { 
  return 0;
}

void UndecoratedServiceSvNull::withStruct(::cpp2::Response& /*_return*/, std::unique_ptr<::cpp2::Request> /*request*/) {  }

void UndecoratedServiceSvNull::multiParam(::cpp2::Response& /*_return*/, std::unique_ptr<::std::string> /*text*/, ::std::int64_t /*num*/, std::unique_ptr<::cpp2::Request> /*request*/) {  }

void UndecoratedServiceSvNull::adaptedRequest(::cpp2::Response& /*_return*/, std::unique_ptr<::cpp2::AdaptedRequest> /*request*/) {  }


std::string_view UndecoratedServiceAsyncProcessor::getServiceName() {
  return "UndecoratedService";
}

void UndecoratedServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen(response);
}

void UndecoratedServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void UndecoratedServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const UndecoratedServiceAsyncProcessor::ProcessMap& UndecoratedServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const UndecoratedServiceAsyncProcessor::ProcessMap UndecoratedServiceAsyncProcessor::kOwnProcessMap_ {
  {"noop",
    {&UndecoratedServiceAsyncProcessor::setUpAndProcess_noop<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::setUpAndProcess_noop<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_noop<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_noop<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"echo",
    {&UndecoratedServiceAsyncProcessor::setUpAndProcess_echo<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::setUpAndProcess_echo<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_echo<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_echo<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"increment",
    {&UndecoratedServiceAsyncProcessor::setUpAndProcess_increment<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::setUpAndProcess_increment<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_increment<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_increment<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum",
    {&UndecoratedServiceAsyncProcessor::setUpAndProcess_sum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::setUpAndProcess_sum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_sum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_sum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"withStruct",
    {&UndecoratedServiceAsyncProcessor::setUpAndProcess_withStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::setUpAndProcess_withStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_withStruct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_withStruct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"multiParam",
    {&UndecoratedServiceAsyncProcessor::setUpAndProcess_multiParam<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::setUpAndProcess_multiParam<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_multiParam<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_multiParam<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"adaptedRequest",
    {&UndecoratedServiceAsyncProcessor::setUpAndProcess_adaptedRequest<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::setUpAndProcess_adaptedRequest<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_adaptedRequest<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedServiceAsyncProcessor::executeRequest_adaptedRequest<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& UndecoratedServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap UndecoratedServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"noop",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService.noop",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"echo",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService.echo",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"increment",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService.increment",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"sum",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService.sum",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"withStruct",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService.withStruct",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"multiParam",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService.multiParam",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"adaptedRequest",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService.adaptedRequest",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };

  return requestInfoMap;
}
} // namespace cpp2

namespace apache::thrift::detail {
::folly::Range<const ::std::string_view*>(*TSchemaAssociation<::cpp2::UndecoratedService, false>::bundle)() =
    nullptr;
}

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::getProcessor() {
  return std::make_unique<::cpp2::DecoratedService_ExtendsUndecoratedServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::cpp2::DecoratedService_ExtendsUndecoratedServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_getDecorators() {
  std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> out;
  for (auto& decoratorPtr : fbthrift_methodDecorators_) {
    out.emplace_back(std::ref(*decoratorPtr));
  }
  return out;
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_noop(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_noop(std::move(afterParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_echo(std::move(beforeParams), p_text);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::string>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_echo(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_increment(std::move(beforeParams), p_num);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_increment(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::vector<::std::int64_t>>::type p_nums) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_sum(std::move(beforeParams), p_nums);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_sum(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_withStruct(std::move(beforeParams), p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_withStruct(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_multiParam(std::move(beforeParams), p_text, p_num, p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_multiParam(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_adaptedRequest(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::cpp2::AdaptedRequest>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_adaptedRequest(std::move(beforeParams), p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_adaptedRequest(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_adaptedRequest(std::move(afterParams), result);
  });
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_before_extension(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_extension(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::fbthrift_execute_decorators_after_extension(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_extension(std::move(afterParams));
  });
}

void apache::thrift::decorate(
    apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>& handler,
    apache::thrift::ServiceMethodDecoratorList<::cpp2::DecoratedService_ExtendsUndecoratedService> decorators) {
  handler.fbthrift_methodDecorators_ = std::move(decorators);
}

std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::cpp2::DecoratedService_ExtendsUndecoratedServiceServiceInfoHolder apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::__fbthrift_serviceInfoHolder;

//
// Service Methods
//

//
// Method 'extension'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::extension() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("extension");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::sync_extension() {
  return extension();
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::semifuture_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_extension();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::future_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_extension(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::co_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::co_extension(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_extension();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>::async_tm_extension(
    apache::thrift::HandlerCallbackPtr<void> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_extension.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_extension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_extension(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_extension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_extension();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_extension();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_extension(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_extension();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_extension();
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'extension'
//

//
// End of Service Methods
//


namespace cpp2 {

void DecoratedService_ExtendsUndecoratedServiceSvNull::extension() { 
}


std::string_view DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::getServiceName() {
  return "DecoratedService_ExtendsUndecoratedService";
}

void DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>>::gen(response);
}

void DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::ProcessMap& DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::ProcessMap DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::kOwnProcessMap_ {
  {"extension",
    {&DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::setUpAndProcess_extension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::setUpAndProcess_extension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::executeRequest_extension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedService_ExtendsUndecoratedServiceAsyncProcessor::executeRequest_extension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& DecoratedService_ExtendsUndecoratedServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap DecoratedService_ExtendsUndecoratedServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"extension",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService_ExtendsUndecoratedService.extension",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };
  apache::thrift::ServiceRequestInfoMap parentMap = ::cpp2::UndecoratedServiceServiceInfoHolder::staticRequestInfoMap();
  requestInfoMap.insert(std::begin(parentMap), std::end(parentMap));

  return requestInfoMap;
}
} // namespace cpp2

namespace apache::thrift::detail {
::folly::Range<const ::std::string_view*>(*TSchemaAssociation<::cpp2::DecoratedService_ExtendsUndecoratedService, false>::bundle)() =
    nullptr;
}

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::getProcessor() {
  return std::make_unique<::cpp2::DecoratedService_ExtendsDecoratedServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::cpp2::DecoratedService_ExtendsDecoratedServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_getDecorators() {
  std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> out;
  for (auto& decoratorPtr : fbthrift_methodDecorators_) {
    out.emplace_back(std::ref(*decoratorPtr));
  }
  return out;
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_createLegacyPerforms(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_createLegacyPerforms(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_createLegacyPerforms(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_createLegacyPerforms(std::move(afterParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_noop(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_noop(std::move(afterParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_echo(std::move(beforeParams), p_text);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::string>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_echo(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_increment(std::move(beforeParams), p_num);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_increment(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::vector<::std::int64_t>>::type p_nums) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_sum(std::move(beforeParams), p_nums);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_sum(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_withStruct(std::move(beforeParams), p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_withStruct(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_multiParam(std::move(beforeParams), p_text, p_num, p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_multiParam(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_echoInteraction(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_echoInteraction(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_echoInteraction(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_echoInteraction(std::move(afterParams));
  });
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_extension(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_extension(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_extension(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_extension(std::move(afterParams));
  });
}

void apache::thrift::decorate(
    apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>& handler,
    apache::thrift::ServiceMethodDecoratorList<::cpp2::DecoratedService_ExtendsDecoratedService> decorators) {
  handler.fbthrift_methodDecorators_ = std::move(decorators);
}

std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::cpp2::DecoratedService_ExtendsDecoratedServiceServiceInfoHolder apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::__fbthrift_serviceInfoHolder;

//
// Service Methods
//

//
// Method 'extension'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::extension() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("extension");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::sync_extension() {
  return extension();
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::semifuture_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_extension();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::future_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_extension(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::co_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::co_extension(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_extension();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>::async_tm_extension(
    apache::thrift::HandlerCallbackPtr<void> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_extension.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_extension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_extension(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_extension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_extension();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_extension();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_extension(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_extension();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_extension();
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'extension'
//

//
// End of Service Methods
//


namespace cpp2 {

void DecoratedService_ExtendsDecoratedServiceSvNull::extension() { 
}


std::string_view DecoratedService_ExtendsDecoratedServiceAsyncProcessor::getServiceName() {
  return "DecoratedService_ExtendsDecoratedService";
}

void DecoratedService_ExtendsDecoratedServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>>::gen(response);
}

void DecoratedService_ExtendsDecoratedServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void DecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const DecoratedService_ExtendsDecoratedServiceAsyncProcessor::ProcessMap& DecoratedService_ExtendsDecoratedServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const DecoratedService_ExtendsDecoratedServiceAsyncProcessor::ProcessMap DecoratedService_ExtendsDecoratedServiceAsyncProcessor::kOwnProcessMap_ {
  {"extension",
    {&DecoratedService_ExtendsDecoratedServiceAsyncProcessor::setUpAndProcess_extension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedService_ExtendsDecoratedServiceAsyncProcessor::setUpAndProcess_extension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest_extension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest_extension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& DecoratedService_ExtendsDecoratedServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap DecoratedService_ExtendsDecoratedServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"extension",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService_ExtendsDecoratedService.extension",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };
  apache::thrift::ServiceRequestInfoMap parentMap = ::cpp2::DecoratedServiceServiceInfoHolder::staticRequestInfoMap();
  requestInfoMap.insert(std::begin(parentMap), std::end(parentMap));

  return requestInfoMap;
}
} // namespace cpp2

namespace apache::thrift::detail {
::folly::Range<const ::std::string_view*>(*TSchemaAssociation<::cpp2::DecoratedService_ExtendsDecoratedService, false>::bundle)() =
    nullptr;
}

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::getProcessor() {
  return std::make_unique<::cpp2::UndecoratedService_ExtendsDecoratedServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::cpp2::UndecoratedService_ExtendsDecoratedServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::cpp2::UndecoratedService_ExtendsDecoratedServiceServiceInfoHolder apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::__fbthrift_serviceInfoHolder;

//
// Service Methods
//

//
// Method 'extension'
//

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::extension() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("extension");
}

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::sync_extension() {
  return extension();
}

folly::SemiFuture<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::semifuture_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  sync_extension();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::future_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_extension(),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void>
apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::co_extension() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::co_extension(
    apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_extension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_extension();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>::async_tm_extension(
    apache::thrift::HandlerCallbackPtr<void> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_extension.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_extension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_extension(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_extension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_extension();
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_extension();
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_extension(params);
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_extension();
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        sync_extension();
        callback->done();
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'extension'
//

//
// End of Service Methods
//


namespace cpp2 {

void UndecoratedService_ExtendsDecoratedServiceSvNull::extension() { 
}


std::string_view UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::getServiceName() {
  return "UndecoratedService_ExtendsDecoratedService";
}

void UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>>::gen(response);
}

void UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::ProcessMap& UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::ProcessMap UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::kOwnProcessMap_ {
  {"extension",
    {&UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::setUpAndProcess_extension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::setUpAndProcess_extension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest_extension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &UndecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest_extension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& UndecoratedService_ExtendsDecoratedServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap UndecoratedService_ExtendsDecoratedServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"extension",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "UndecoratedService_ExtendsDecoratedService.extension",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };
  apache::thrift::ServiceRequestInfoMap parentMap = ::cpp2::DecoratedServiceServiceInfoHolder::staticRequestInfoMap();
  requestInfoMap.insert(std::begin(parentMap), std::end(parentMap));

  return requestInfoMap;
}
} // namespace cpp2

namespace apache::thrift::detail {
::folly::Range<const ::std::string_view*>(*TSchemaAssociation<::cpp2::UndecoratedService_ExtendsDecoratedService, false>::bundle)() =
    nullptr;
}

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::getProcessor() {
  return std::make_unique<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_getDecorators() {
  std::vector<std::reference_wrapper<apache::thrift::ServiceMethodDecoratorBase>> out;
  for (auto& decoratorPtr : fbthrift_methodDecorators_) {
    out.emplace_back(std::ref(*decoratorPtr));
  }
  return out;
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_createLegacyPerforms(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_createLegacyPerforms(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_createLegacyPerforms(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_createLegacyPerforms(std::move(afterParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_noop(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_noop(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_noop(std::move(afterParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_echo(std::move(beforeParams), p_text);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_echo(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::string>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_echo(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_increment(std::move(beforeParams), p_num);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_increment(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_increment(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::vector<::std::int64_t>>::type p_nums) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_sum(std::move(beforeParams), p_nums);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_sum(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::int64_t>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_sum(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_withStruct(std::move(beforeParams), p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_withStruct(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_withStruct(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_text, apache::thrift::detail::DecoratorArgType<::std::int64_t>::type p_num, apache::thrift::detail::DecoratorArgType<::cpp2::Request>::type p_request) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_multiParam(std::move(beforeParams), p_text, p_num, p_request);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_multiParam(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::cpp2::Response>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_multiParam(std::move(afterParams), result);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_echoInteraction(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_echoInteraction(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_echoInteraction(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_echoInteraction(std::move(afterParams));
  });
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_extension(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_extension(std::move(beforeParams));
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_extension(
  apache::thrift::Cpp2RequestContext& requestCtx) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_extension(std::move(afterParams));
  });
}


void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_before_secondExtension(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorArgType<::std::string>::type p_input) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::BeforeParams beforeParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->before_secondExtension(std::move(beforeParams), p_input);
  });
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::fbthrift_execute_decorators_after_secondExtension(
  apache::thrift::Cpp2RequestContext& requestCtx, apache::thrift::detail::DecoratorReturnType<::std::string>::type result) {
  std::for_each(fbthrift_methodDecorators_.begin(), fbthrift_methodDecorators_.end(), [&](auto& decorator) {
    ServiceMethodDecoratorBase::AfterParams afterParams{detail::Cpp2RequestContextUnsafeAPI(requestCtx).getDecoratorDataMutable()};
    decorator->after_secondExtension(std::move(afterParams), result);
  });
}

void apache::thrift::decorate(
    apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>& handler,
    apache::thrift::ServiceMethodDecoratorList<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService> decorators) {
  handler.fbthrift_methodDecorators_ = std::move(decorators);
}

std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceServiceInfoHolder apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::__fbthrift_serviceInfoHolder;

//
// Service Methods
//

//
// Method 'secondExtension'
//

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::secondExtension(::std::string& /*_return*/, std::unique_ptr<::std::string> /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("secondExtension");
}

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::sync_secondExtension(::std::string& _return, std::unique_ptr<::std::string> p_input) {
  return secondExtension(_return, std::move(p_input));
}

folly::SemiFuture<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::semifuture_secondExtension(std::unique_ptr<::std::string> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_secondExtension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Sync,
      std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_secondExtension(*ret, std::move(p_input));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::future_secondExtension(std::unique_ptr<::std::string> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_secondExtension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::SemiFuture,
      std::memory_order_relaxed);
  return apache::thrift::detail::si::future(
      semifuture_secondExtension(std::move(p_input)),
      getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>>
apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::co_secondExtension(std::unique_ptr<::std::string> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_secondExtension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Future,
      std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::
                             withCapturedArgs<std::unique_ptr<::std::string> /*input*/>(std::move(p_input)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::co_secondExtension(
    apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_secondExtension.compare_exchange_strong(
      expected,
      apache::thrift::detail::si::InvocationType::Coro,
      std::memory_order_relaxed);
  return co_secondExtension(std::move(p_input));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>::async_tm_secondExtension(
    apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::string>> callback, std::unique_ptr<::std::string> p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType =
      __fbthrift_invocation_secondExtension.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm: {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_secondExtension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::CoroParam,
            std::memory_order_relaxed);
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_secondExtension(params, std::move(p_input));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_secondExtension.compare_exchange_strong(
            invocationType,
            apache::thrift::detail::si::InvocationType::Future,
            std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future: {
        auto fut = future_secondExtension(std::move(p_input));
        apache::thrift::detail::si::async_tm_future(
            std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture: {
        auto fut = semifuture_secondExtension(std::move(p_input));
        apache::thrift::detail::si::async_tm_semifuture(
            std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam: {
        apache::thrift::RequestParams params{
            callback->getRequestContext(),
            callback->getThreadManager_deprecated(),
            callback->getEventBase(),
            callback->getHandlerExecutor()};
        auto task = co_secondExtension(params, std::move(p_input));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro: {
        auto task = co_secondExtension(std::move(p_input));
        apache::thrift::detail::si::async_tm_coro(
            std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync: {
        ::std::string _return;
        sync_secondExtension(_return, std::move(p_input));
        callback->result(std::move(_return));
        return;
      }
      default: {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}
//
// End of Method 'secondExtension'
//

//
// End of Service Methods
//


namespace cpp2 {

void DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceSvNull::secondExtension(::std::string& /*_return*/, std::unique_ptr<::std::string> /*input*/) {  }


std::string_view DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::getServiceName() {
  return "DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService";
}

void DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>>::gen(response);
}

void DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::ProcessMap& DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::ProcessMap DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::kOwnProcessMap_ {
  {"secondExtension",
    {&DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::setUpAndProcess_secondExtension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::setUpAndProcess_secondExtension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest_secondExtension<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceAsyncProcessor::executeRequest_secondExtension<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"secondExtension",
    { false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService.secondExtension",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };
  apache::thrift::ServiceRequestInfoMap parentMap = ::cpp2::UndecoratedService_ExtendsDecoratedServiceServiceInfoHolder::staticRequestInfoMap();
  requestInfoMap.insert(std::begin(parentMap), std::end(parentMap));

  return requestInfoMap;
}
} // namespace cpp2

namespace apache::thrift::detail {
::folly::Range<const ::std::string_view*>(*TSchemaAssociation<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService, false>::bundle)() =
    nullptr;
}

