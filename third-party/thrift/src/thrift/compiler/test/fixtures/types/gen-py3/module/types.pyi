#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
import thrift.py3.exceptions
from thrift.py3.types import __NotSet, NOTSET
import typing as _typing
from typing_extensions import Final

import sys
import itertools
import facebook.thrift.annotation.cpp.types as _facebook_thrift_annotation_cpp_types
import facebook.thrift.annotation.thrift.types as _facebook_thrift_annotation_thrift_types
import include.types as _include_types


__property__ = property


class has_bitwise_ops(thrift.py3.types.Enum):
    none: has_bitwise_ops = ...
    zero: has_bitwise_ops = ...
    one: has_bitwise_ops = ...
    two: has_bitwise_ops = ...
    three: has_bitwise_ops = ...
    def _to_python(self) -> "module.thrift_types.has_bitwise_ops": ...   # type: ignore
    def _to_py3(self) -> has_bitwise_ops: ...
    def _to_py_deprecated(self) -> int: ...


class is_unscoped(thrift.py3.types.Enum):
    hello: is_unscoped = ...
    world: is_unscoped = ...
    def _to_python(self) -> "module.thrift_types.is_unscoped": ...   # type: ignore
    def _to_py3(self) -> is_unscoped: ...
    def _to_py_deprecated(self) -> int: ...


class MyForwardRefEnum(thrift.py3.types.Enum):
    ZERO: MyForwardRefEnum = ...
    NONZERO: MyForwardRefEnum = ...
    def _to_python(self) -> "module.thrift_types.MyForwardRefEnum": ...   # type: ignore
    def _to_py3(self) -> MyForwardRefEnum: ...
    def _to_py_deprecated(self) -> int: ...


class decorated_struct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        field: bool
        pass

    field: Final[str] = ...

    def __init__(
        self, *,
        field: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[str, '__NotSet', None]=NOTSET
    ) -> decorated_struct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['decorated_struct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'decorated_struct') -> bool: ...
    def __gt__(self, other: 'decorated_struct') -> bool: ...
    def __le__(self, other: 'decorated_struct') -> bool: ...
    def __ge__(self, other: 'decorated_struct') -> bool: ...

    def _to_python(self) -> "module.thrift_types.decorated_struct": ...   # type: ignore
    def _to_py3(self) -> decorated_struct: ...
    def _to_py_deprecated(self) -> "module.ttypes.decorated_struct": ...   # type: ignore

class ContainerStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        fieldA: bool
        fieldB: bool
        fieldC: bool
        fieldD: bool
        fieldE: bool
        fieldF: bool
        fieldG: bool
        fieldH: bool
        pass

    fieldA: Final[_typing.Sequence[int]] = ...

    fieldB: Final[_typing.Sequence[int]] = ...

    fieldC: Final[_typing.Sequence[int]] = ...

    fieldD: Final[_typing.Sequence[int]] = ...

    fieldE: Final[_typing.Sequence[int]] = ...

    fieldF: Final[_typing.AbstractSet[int]] = ...

    fieldG: Final[_typing.Mapping[int, str]] = ...

    fieldH: Final[_typing.Mapping[int, str]] = ...

    def __init__(
        self, *,
        fieldA: _typing.Optional[_typing.Sequence[int]]=None,
        fieldB: _typing.Optional[_typing.Sequence[int]]=None,
        fieldC: _typing.Optional[_typing.Sequence[int]]=None,
        fieldD: _typing.Optional[_typing.Sequence[int]]=None,
        fieldE: _typing.Optional[_typing.Sequence[int]]=None,
        fieldF: _typing.Optional[_typing.AbstractSet[int]]=None,
        fieldG: _typing.Optional[_typing.Mapping[int, str]]=None,
        fieldH: _typing.Optional[_typing.Mapping[int, str]]=None
    ) -> None: ...

    def __call__(
        self, *,
        fieldA: _typing.Union[_typing.Sequence[int], '__NotSet', None]=NOTSET,
        fieldB: _typing.Union[_typing.Sequence[int], '__NotSet', None]=NOTSET,
        fieldC: _typing.Union[_typing.Sequence[int], '__NotSet', None]=NOTSET,
        fieldD: _typing.Union[_typing.Sequence[int], '__NotSet', None]=NOTSET,
        fieldE: _typing.Union[_typing.Sequence[int], '__NotSet', None]=NOTSET,
        fieldF: _typing.Union[_typing.AbstractSet[int], '__NotSet', None]=NOTSET,
        fieldG: _typing.Union[_typing.Mapping[int, str], '__NotSet', None]=NOTSET,
        fieldH: _typing.Union[_typing.Mapping[int, str], '__NotSet', None]=NOTSET
    ) -> ContainerStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ContainerStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def _to_python(self) -> "module.thrift_types.ContainerStruct": ...   # type: ignore
    def _to_py3(self) -> ContainerStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.ContainerStruct": ...   # type: ignore

class CppTypeStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        fieldA: bool
        pass

    fieldA: Final[_typing.Sequence[int]] = ...

    def __init__(
        self, *,
        fieldA: _typing.Optional[_typing.Sequence[int]]=None
    ) -> None: ...

    def __call__(
        self, *,
        fieldA: _typing.Union[_typing.Sequence[int], '__NotSet', None]=NOTSET
    ) -> CppTypeStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['CppTypeStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'CppTypeStruct') -> bool: ...
    def __gt__(self, other: 'CppTypeStruct') -> bool: ...
    def __le__(self, other: 'CppTypeStruct') -> bool: ...
    def __ge__(self, other: 'CppTypeStruct') -> bool: ...

    def _to_python(self) -> "module.thrift_types.CppTypeStruct": ...   # type: ignore
    def _to_py3(self) -> CppTypeStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.CppTypeStruct": ...   # type: ignore

class VirtualStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        MyIntField: bool
        pass

    MyIntField: Final[int] = ...

    def __init__(
        self, *,
        MyIntField: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        MyIntField: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> VirtualStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['VirtualStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'VirtualStruct') -> bool: ...
    def __gt__(self, other: 'VirtualStruct') -> bool: ...
    def __le__(self, other: 'VirtualStruct') -> bool: ...
    def __ge__(self, other: 'VirtualStruct') -> bool: ...

    def _to_python(self) -> "module.thrift_types.VirtualStruct": ...   # type: ignore
    def _to_py3(self) -> VirtualStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.VirtualStruct": ...   # type: ignore

class MyStructWithForwardRefEnum(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        a: bool
        b: bool
        pass

    a: Final[MyForwardRefEnum] = ...

    b: Final[MyForwardRefEnum] = ...

    def __init__(
        self, *,
        a: _typing.Optional[MyForwardRefEnum]=None,
        b: _typing.Optional[MyForwardRefEnum]=None
    ) -> None: ...

    def __call__(
        self, *,
        a: _typing.Union[MyForwardRefEnum, '__NotSet', None]=NOTSET,
        b: _typing.Union[MyForwardRefEnum, '__NotSet', None]=NOTSET
    ) -> MyStructWithForwardRefEnum: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyStructWithForwardRefEnum'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyStructWithForwardRefEnum') -> bool: ...
    def __gt__(self, other: 'MyStructWithForwardRefEnum') -> bool: ...
    def __le__(self, other: 'MyStructWithForwardRefEnum') -> bool: ...
    def __ge__(self, other: 'MyStructWithForwardRefEnum') -> bool: ...

    def _to_python(self) -> "module.thrift_types.MyStructWithForwardRefEnum": ...   # type: ignore
    def _to_py3(self) -> MyStructWithForwardRefEnum: ...
    def _to_py_deprecated(self) -> "module.ttypes.MyStructWithForwardRefEnum": ...   # type: ignore

class TrivialNumeric(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        a: bool
        b: bool
        pass

    a: Final[int] = ...

    b: Final[bool] = ...

    def __init__(
        self, *,
        a: _typing.Optional[int]=None,
        b: _typing.Optional[bool]=None
    ) -> None: ...

    def __call__(
        self, *,
        a: _typing.Union[int, '__NotSet', None]=NOTSET,
        b: _typing.Union[bool, '__NotSet', None]=NOTSET
    ) -> TrivialNumeric: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['TrivialNumeric'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'TrivialNumeric') -> bool: ...
    def __gt__(self, other: 'TrivialNumeric') -> bool: ...
    def __le__(self, other: 'TrivialNumeric') -> bool: ...
    def __ge__(self, other: 'TrivialNumeric') -> bool: ...

    def _to_python(self) -> "module.thrift_types.TrivialNumeric": ...   # type: ignore
    def _to_py3(self) -> TrivialNumeric: ...
    def _to_py_deprecated(self) -> "module.ttypes.TrivialNumeric": ...   # type: ignore

class TrivialNestedWithDefault(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        z: bool
        n: bool
        pass

    z: Final[int] = ...

    n: Final[TrivialNumeric] = ...

    def __init__(
        self, *,
        z: _typing.Optional[int]=None,
        n: _typing.Optional[TrivialNumeric]=None
    ) -> None: ...

    def __call__(
        self, *,
        z: _typing.Union[int, '__NotSet', None]=NOTSET,
        n: _typing.Union[TrivialNumeric, '__NotSet', None]=NOTSET
    ) -> TrivialNestedWithDefault: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['TrivialNestedWithDefault'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'TrivialNestedWithDefault') -> bool: ...
    def __gt__(self, other: 'TrivialNestedWithDefault') -> bool: ...
    def __le__(self, other: 'TrivialNestedWithDefault') -> bool: ...
    def __ge__(self, other: 'TrivialNestedWithDefault') -> bool: ...

    def _to_python(self) -> "module.thrift_types.TrivialNestedWithDefault": ...   # type: ignore
    def _to_py3(self) -> TrivialNestedWithDefault: ...
    def _to_py_deprecated(self) -> "module.ttypes.TrivialNestedWithDefault": ...   # type: ignore

class ComplexString(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        a: bool
        b: bool
        pass

    a: Final[str] = ...

    b: Final[_typing.Mapping[str, int]] = ...

    def __init__(
        self, *,
        a: _typing.Optional[str]=None,
        b: _typing.Optional[_typing.Mapping[str, int]]=None
    ) -> None: ...

    def __call__(
        self, *,
        a: _typing.Union[str, '__NotSet', None]=NOTSET,
        b: _typing.Union[_typing.Mapping[str, int], '__NotSet', None]=NOTSET
    ) -> ComplexString: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ComplexString'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ComplexString') -> bool: ...
    def __gt__(self, other: 'ComplexString') -> bool: ...
    def __le__(self, other: 'ComplexString') -> bool: ...
    def __ge__(self, other: 'ComplexString') -> bool: ...

    def _to_python(self) -> "module.thrift_types.ComplexString": ...   # type: ignore
    def _to_py3(self) -> ComplexString: ...
    def _to_py_deprecated(self) -> "module.ttypes.ComplexString": ...   # type: ignore

class ComplexNestedWithDefault(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        z: bool
        n: bool
        pass

    z: Final[str] = ...

    n: Final[ComplexString] = ...

    def __init__(
        self, *,
        z: _typing.Optional[str]=None,
        n: _typing.Optional[ComplexString]=None
    ) -> None: ...

    def __call__(
        self, *,
        z: _typing.Union[str, '__NotSet', None]=NOTSET,
        n: _typing.Union[ComplexString, '__NotSet', None]=NOTSET
    ) -> ComplexNestedWithDefault: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ComplexNestedWithDefault'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ComplexNestedWithDefault') -> bool: ...
    def __gt__(self, other: 'ComplexNestedWithDefault') -> bool: ...
    def __le__(self, other: 'ComplexNestedWithDefault') -> bool: ...
    def __ge__(self, other: 'ComplexNestedWithDefault') -> bool: ...

    def _to_python(self) -> "module.thrift_types.ComplexNestedWithDefault": ...   # type: ignore
    def _to_py3(self) -> ComplexNestedWithDefault: ...
    def _to_py_deprecated(self) -> "module.ttypes.ComplexNestedWithDefault": ...   # type: ignore

class MinPadding(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        small: bool
        big: bool
        medium: bool
        biggish: bool
        tiny: bool
        pass

    small: Final[int] = ...

    big: Final[int] = ...

    medium: Final[int] = ...

    biggish: Final[int] = ...

    tiny: Final[int] = ...

    def __init__(
        self, *,
        small: _typing.Optional[int]=None,
        big: _typing.Optional[int]=None,
        medium: _typing.Optional[int]=None,
        biggish: _typing.Optional[int]=None,
        tiny: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        small: _typing.Union[int, '__NotSet', None]=NOTSET,
        big: _typing.Union[int, '__NotSet', None]=NOTSET,
        medium: _typing.Union[int, '__NotSet', None]=NOTSET,
        biggish: _typing.Union[int, '__NotSet', None]=NOTSET,
        tiny: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> MinPadding: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MinPadding'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MinPadding') -> bool: ...
    def __gt__(self, other: 'MinPadding') -> bool: ...
    def __le__(self, other: 'MinPadding') -> bool: ...
    def __ge__(self, other: 'MinPadding') -> bool: ...

    def _to_python(self) -> "module.thrift_types.MinPadding": ...   # type: ignore
    def _to_py3(self) -> MinPadding: ...
    def _to_py_deprecated(self) -> "module.ttypes.MinPadding": ...   # type: ignore

class MinPaddingWithCustomType(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    small: Final[int] = ...

    big: Final[int] = ...

    medium: Final[int] = ...

    biggish: Final[int] = ...

    tiny: Final[int] = ...

    def __init__(
        self, *,
        small: _typing.Optional[int]=None,
        big: _typing.Optional[int]=None,
        medium: _typing.Optional[int]=None,
        biggish: _typing.Optional[int]=None,
        tiny: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        small: _typing.Union[int, '__NotSet', None]=NOTSET,
        big: _typing.Union[int, '__NotSet', None]=NOTSET,
        medium: _typing.Union[int, '__NotSet', None]=NOTSET,
        biggish: _typing.Union[int, '__NotSet', None]=NOTSET,
        tiny: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> MinPaddingWithCustomType: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MinPaddingWithCustomType'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MinPaddingWithCustomType') -> bool: ...
    def __gt__(self, other: 'MinPaddingWithCustomType') -> bool: ...
    def __le__(self, other: 'MinPaddingWithCustomType') -> bool: ...
    def __ge__(self, other: 'MinPaddingWithCustomType') -> bool: ...

    def _to_python(self) -> "module.thrift_types.MinPaddingWithCustomType": ...   # type: ignore
    def _to_py3(self) -> MinPaddingWithCustomType: ...
    def _to_py_deprecated(self) -> "module.ttypes.MinPaddingWithCustomType": ...   # type: ignore

class MyStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        MyIntField: bool
        MyStringField: bool
        majorVer: bool
        data: bool
        pass

    MyIntField: Final[int] = ...

    MyStringField: Final[str] = ...

    majorVer: Final[int] = ...

    data: Final[MyDataItem] = ...

    def __init__(
        self, *,
        MyIntField: _typing.Optional[int]=None,
        MyStringField: _typing.Optional[str]=None,
        majorVer: _typing.Optional[int]=None,
        data: _typing.Optional[MyDataItem]=None
    ) -> None: ...

    def __call__(
        self, *,
        MyIntField: _typing.Union[int, '__NotSet', None]=NOTSET,
        MyStringField: _typing.Union[str, '__NotSet', None]=NOTSET,
        majorVer: _typing.Union[int, '__NotSet', None]=NOTSET,
        data: _typing.Union[MyDataItem, '__NotSet', None]=NOTSET
    ) -> MyStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyStruct') -> bool: ...
    def __gt__(self, other: 'MyStruct') -> bool: ...
    def __le__(self, other: 'MyStruct') -> bool: ...
    def __ge__(self, other: 'MyStruct') -> bool: ...

    def _to_python(self) -> "module.thrift_types.MyStruct": ...   # type: ignore
    def _to_py3(self) -> MyStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.MyStruct": ...   # type: ignore

class MyDataItem(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> MyDataItem: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyDataItem'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyDataItem') -> bool: ...
    def __gt__(self, other: 'MyDataItem') -> bool: ...
    def __le__(self, other: 'MyDataItem') -> bool: ...
    def __ge__(self, other: 'MyDataItem') -> bool: ...

    def _to_python(self) -> "module.thrift_types.MyDataItem": ...   # type: ignore
    def _to_py3(self) -> MyDataItem: ...
    def _to_py_deprecated(self) -> "module.ttypes.MyDataItem": ...   # type: ignore

class Renaming(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        foo: bool
        pass

    foo: Final[int] = ...

    def __init__(
        self, *,
        foo: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        foo: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> Renaming: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['Renaming'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'Renaming') -> bool: ...
    def __gt__(self, other: 'Renaming') -> bool: ...
    def __le__(self, other: 'Renaming') -> bool: ...
    def __ge__(self, other: 'Renaming') -> bool: ...

    def _to_python(self) -> "module.thrift_types.Renaming": ...   # type: ignore
    def _to_py3(self) -> Renaming: ...
    def _to_py_deprecated(self) -> "module.ttypes.Renaming": ...   # type: ignore

class AnnotatedTypes(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        binary_field: bool
        list_field: bool
        pass

    binary_field: Final[bytes] = ...

    list_field: Final[_typing.Sequence[_typing.Mapping[int, str]]] = ...

    def __init__(
        self, *,
        binary_field: _typing.Optional[bytes]=None,
        list_field: _typing.Optional[_typing.Sequence[_typing.Mapping[int, str]]]=None
    ) -> None: ...

    def __call__(
        self, *,
        binary_field: _typing.Union[bytes, '__NotSet', None]=NOTSET,
        list_field: _typing.Union[_typing.Sequence[_typing.Mapping[int, str]], '__NotSet', None]=NOTSET
    ) -> AnnotatedTypes: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AnnotatedTypes'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def _to_python(self) -> "module.thrift_types.AnnotatedTypes": ...   # type: ignore
    def _to_py3(self) -> AnnotatedTypes: ...
    def _to_py_deprecated(self) -> "module.ttypes.AnnotatedTypes": ...   # type: ignore

class ForwardUsageRoot(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        ForwardUsageStruct: bool
        pass

    ForwardUsageStruct: Final[_typing.Optional[ForwardUsageStruct]] = ...

    ForwardUsageByRef: Final[_typing.Optional[ForwardUsageByRef]] = ...

    def __init__(
        self, *,
        ForwardUsageStruct: _typing.Optional[ForwardUsageStruct]=None,
        ForwardUsageByRef: _typing.Optional[ForwardUsageByRef]=None
    ) -> None: ...

    def __call__(
        self, *,
        ForwardUsageStruct: _typing.Union[ForwardUsageStruct, '__NotSet', None]=NOTSET,
        ForwardUsageByRef: _typing.Union[ForwardUsageByRef, '__NotSet', None]=NOTSET
    ) -> ForwardUsageRoot: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ForwardUsageRoot'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ForwardUsageRoot') -> bool: ...
    def __gt__(self, other: 'ForwardUsageRoot') -> bool: ...
    def __le__(self, other: 'ForwardUsageRoot') -> bool: ...
    def __ge__(self, other: 'ForwardUsageRoot') -> bool: ...

    def _to_python(self) -> "module.thrift_types.ForwardUsageRoot": ...   # type: ignore
    def _to_py3(self) -> ForwardUsageRoot: ...
    def _to_py_deprecated(self) -> "module.ttypes.ForwardUsageRoot": ...   # type: ignore

class ForwardUsageStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    foo: Final[_typing.Optional[ForwardUsageRoot]] = ...

    def __init__(
        self, *,
        foo: _typing.Optional[ForwardUsageRoot]=None
    ) -> None: ...

    def __call__(
        self, *,
        foo: _typing.Union[ForwardUsageRoot, '__NotSet', None]=NOTSET
    ) -> ForwardUsageStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ForwardUsageStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ForwardUsageStruct') -> bool: ...
    def __gt__(self, other: 'ForwardUsageStruct') -> bool: ...
    def __le__(self, other: 'ForwardUsageStruct') -> bool: ...
    def __ge__(self, other: 'ForwardUsageStruct') -> bool: ...

    def _to_python(self) -> "module.thrift_types.ForwardUsageStruct": ...   # type: ignore
    def _to_py3(self) -> ForwardUsageStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.ForwardUsageStruct": ...   # type: ignore

class ForwardUsageByRef(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    foo: Final[_typing.Optional[ForwardUsageRoot]] = ...

    def __init__(
        self, *,
        foo: _typing.Optional[ForwardUsageRoot]=None
    ) -> None: ...

    def __call__(
        self, *,
        foo: _typing.Union[ForwardUsageRoot, '__NotSet', None]=NOTSET
    ) -> ForwardUsageByRef: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ForwardUsageByRef'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ForwardUsageByRef') -> bool: ...
    def __gt__(self, other: 'ForwardUsageByRef') -> bool: ...
    def __le__(self, other: 'ForwardUsageByRef') -> bool: ...
    def __ge__(self, other: 'ForwardUsageByRef') -> bool: ...

    def _to_python(self) -> "module.thrift_types.ForwardUsageByRef": ...   # type: ignore
    def _to_py3(self) -> ForwardUsageByRef: ...
    def _to_py_deprecated(self) -> "module.ttypes.ForwardUsageByRef": ...   # type: ignore

class IncompleteMap(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        field: bool
        pass

    field: Final[_typing.Optional[_typing.Mapping[int, IncompleteMapDep]]] = ...

    def __init__(
        self, *,
        field: _typing.Optional[_typing.Mapping[int, IncompleteMapDep]]=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[_typing.Mapping[int, IncompleteMapDep], '__NotSet', None]=NOTSET
    ) -> IncompleteMap: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['IncompleteMap'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'IncompleteMap') -> bool: ...
    def __gt__(self, other: 'IncompleteMap') -> bool: ...
    def __le__(self, other: 'IncompleteMap') -> bool: ...
    def __ge__(self, other: 'IncompleteMap') -> bool: ...

    def _to_python(self) -> "module.thrift_types.IncompleteMap": ...   # type: ignore
    def _to_py3(self) -> IncompleteMap: ...
    def _to_py_deprecated(self) -> "module.ttypes.IncompleteMap": ...   # type: ignore

class IncompleteMapDep(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> IncompleteMapDep: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['IncompleteMapDep'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'IncompleteMapDep') -> bool: ...
    def __gt__(self, other: 'IncompleteMapDep') -> bool: ...
    def __le__(self, other: 'IncompleteMapDep') -> bool: ...
    def __ge__(self, other: 'IncompleteMapDep') -> bool: ...

    def _to_python(self) -> "module.thrift_types.IncompleteMapDep": ...   # type: ignore
    def _to_py3(self) -> IncompleteMapDep: ...
    def _to_py_deprecated(self) -> "module.ttypes.IncompleteMapDep": ...   # type: ignore

class CompleteMap(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        field: bool
        pass

    field: Final[_typing.Optional[_typing.Mapping[int, CompleteMapDep]]] = ...

    def __init__(
        self, *,
        field: _typing.Optional[_typing.Mapping[int, CompleteMapDep]]=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[_typing.Mapping[int, CompleteMapDep], '__NotSet', None]=NOTSET
    ) -> CompleteMap: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['CompleteMap'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def _to_python(self) -> "module.thrift_types.CompleteMap": ...   # type: ignore
    def _to_py3(self) -> CompleteMap: ...
    def _to_py_deprecated(self) -> "module.ttypes.CompleteMap": ...   # type: ignore

class CompleteMapDep(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> CompleteMapDep: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['CompleteMapDep'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'CompleteMapDep') -> bool: ...
    def __gt__(self, other: 'CompleteMapDep') -> bool: ...
    def __le__(self, other: 'CompleteMapDep') -> bool: ...
    def __ge__(self, other: 'CompleteMapDep') -> bool: ...

    def _to_python(self) -> "module.thrift_types.CompleteMapDep": ...   # type: ignore
    def _to_py3(self) -> CompleteMapDep: ...
    def _to_py_deprecated(self) -> "module.ttypes.CompleteMapDep": ...   # type: ignore

class IncompleteList(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        field: bool
        pass

    field: Final[_typing.Optional[_typing.Sequence[IncompleteListDep]]] = ...

    def __init__(
        self, *,
        field: _typing.Optional[_typing.Sequence[IncompleteListDep]]=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[_typing.Sequence[IncompleteListDep], '__NotSet', None]=NOTSET
    ) -> IncompleteList: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['IncompleteList'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'IncompleteList') -> bool: ...
    def __gt__(self, other: 'IncompleteList') -> bool: ...
    def __le__(self, other: 'IncompleteList') -> bool: ...
    def __ge__(self, other: 'IncompleteList') -> bool: ...

    def _to_python(self) -> "module.thrift_types.IncompleteList": ...   # type: ignore
    def _to_py3(self) -> IncompleteList: ...
    def _to_py_deprecated(self) -> "module.ttypes.IncompleteList": ...   # type: ignore

class IncompleteListDep(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> IncompleteListDep: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['IncompleteListDep'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'IncompleteListDep') -> bool: ...
    def __gt__(self, other: 'IncompleteListDep') -> bool: ...
    def __le__(self, other: 'IncompleteListDep') -> bool: ...
    def __ge__(self, other: 'IncompleteListDep') -> bool: ...

    def _to_python(self) -> "module.thrift_types.IncompleteListDep": ...   # type: ignore
    def _to_py3(self) -> IncompleteListDep: ...
    def _to_py_deprecated(self) -> "module.ttypes.IncompleteListDep": ...   # type: ignore

class CompleteList(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        field: bool
        pass

    field: Final[_typing.Optional[_typing.Sequence[CompleteListDep]]] = ...

    def __init__(
        self, *,
        field: _typing.Optional[_typing.Sequence[CompleteListDep]]=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[_typing.Sequence[CompleteListDep], '__NotSet', None]=NOTSET
    ) -> CompleteList: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['CompleteList'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'CompleteList') -> bool: ...
    def __gt__(self, other: 'CompleteList') -> bool: ...
    def __le__(self, other: 'CompleteList') -> bool: ...
    def __ge__(self, other: 'CompleteList') -> bool: ...

    def _to_python(self) -> "module.thrift_types.CompleteList": ...   # type: ignore
    def _to_py3(self) -> CompleteList: ...
    def _to_py_deprecated(self) -> "module.ttypes.CompleteList": ...   # type: ignore

class CompleteListDep(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass

    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> CompleteListDep: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['CompleteListDep'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'CompleteListDep') -> bool: ...
    def __gt__(self, other: 'CompleteListDep') -> bool: ...
    def __le__(self, other: 'CompleteListDep') -> bool: ...
    def __ge__(self, other: 'CompleteListDep') -> bool: ...

    def _to_python(self) -> "module.thrift_types.CompleteListDep": ...   # type: ignore
    def _to_py3(self) -> CompleteListDep: ...
    def _to_py_deprecated(self) -> "module.ttypes.CompleteListDep": ...   # type: ignore

class AdaptedList(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        field: bool
        pass

    field: Final[_typing.Optional[_typing.Sequence[AdaptedListDep]]] = ...

    def __init__(
        self, *,
        field: _typing.Optional[_typing.Sequence[AdaptedListDep]]=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[_typing.Sequence[AdaptedListDep], '__NotSet', None]=NOTSET
    ) -> AdaptedList: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AdaptedList'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AdaptedList') -> bool: ...
    def __gt__(self, other: 'AdaptedList') -> bool: ...
    def __le__(self, other: 'AdaptedList') -> bool: ...
    def __ge__(self, other: 'AdaptedList') -> bool: ...

    def _to_python(self) -> "module.thrift_types.AdaptedList": ...   # type: ignore
    def _to_py3(self) -> AdaptedList: ...
    def _to_py_deprecated(self) -> "module.ttypes.AdaptedList": ...   # type: ignore

class DependentAdaptedList(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        field: bool
        pass

    field: Final[_typing.Optional[_typing.Sequence[DependentAdaptedListDep]]] = ...

    def __init__(
        self, *,
        field: _typing.Optional[_typing.Sequence[DependentAdaptedListDep]]=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[_typing.Sequence[DependentAdaptedListDep], '__NotSet', None]=NOTSET
    ) -> DependentAdaptedList: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['DependentAdaptedList'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'DependentAdaptedList') -> bool: ...
    def __gt__(self, other: 'DependentAdaptedList') -> bool: ...
    def __le__(self, other: 'DependentAdaptedList') -> bool: ...
    def __ge__(self, other: 'DependentAdaptedList') -> bool: ...

    def _to_python(self) -> "module.thrift_types.DependentAdaptedList": ...   # type: ignore
    def _to_py3(self) -> DependentAdaptedList: ...
    def _to_py_deprecated(self) -> "module.ttypes.DependentAdaptedList": ...   # type: ignore

class AllocatorAware(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        aa_list: bool
        aa_set: bool
        aa_map: bool
        aa_string: bool
        not_a_container: bool
        pass

    aa_list: Final[_typing.Sequence[int]] = ...

    aa_set: Final[_typing.AbstractSet[int]] = ...

    aa_map: Final[_typing.Mapping[int, int]] = ...

    aa_string: Final[str] = ...

    not_a_container: Final[int] = ...

    aa_unique: Final[_typing.Optional[int]] = ...

    aa_shared: Final[_typing.Optional[int]] = ...

    def __init__(
        self, *,
        aa_list: _typing.Optional[_typing.Sequence[int]]=None,
        aa_set: _typing.Optional[_typing.AbstractSet[int]]=None,
        aa_map: _typing.Optional[_typing.Mapping[int, int]]=None,
        aa_string: _typing.Optional[str]=None,
        not_a_container: _typing.Optional[int]=None,
        aa_unique: _typing.Optional[int]=None,
        aa_shared: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        aa_list: _typing.Union[_typing.Sequence[int], '__NotSet', None]=NOTSET,
        aa_set: _typing.Union[_typing.AbstractSet[int], '__NotSet', None]=NOTSET,
        aa_map: _typing.Union[_typing.Mapping[int, int], '__NotSet', None]=NOTSET,
        aa_string: _typing.Union[str, '__NotSet', None]=NOTSET,
        not_a_container: _typing.Union[int, '__NotSet', None]=NOTSET,
        aa_unique: _typing.Union[int, '__NotSet', None]=NOTSET,
        aa_shared: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> AllocatorAware: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AllocatorAware'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AllocatorAware') -> bool: ...
    def __gt__(self, other: 'AllocatorAware') -> bool: ...
    def __le__(self, other: 'AllocatorAware') -> bool: ...
    def __ge__(self, other: 'AllocatorAware') -> bool: ...

    def _to_python(self) -> "module.thrift_types.AllocatorAware": ...   # type: ignore
    def _to_py3(self) -> AllocatorAware: ...
    def _to_py_deprecated(self) -> "module.ttypes.AllocatorAware": ...   # type: ignore

class AllocatorAware2(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        not_a_container: bool
        pass

    not_a_container: Final[int] = ...

    def __init__(
        self, *,
        not_a_container: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        not_a_container: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> AllocatorAware2: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AllocatorAware2'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AllocatorAware2') -> bool: ...
    def __gt__(self, other: 'AllocatorAware2') -> bool: ...
    def __le__(self, other: 'AllocatorAware2') -> bool: ...
    def __ge__(self, other: 'AllocatorAware2') -> bool: ...

    def _to_python(self) -> "module.thrift_types.AllocatorAware2": ...   # type: ignore
    def _to_py3(self) -> AllocatorAware2: ...
    def _to_py_deprecated(self) -> "module.ttypes.AllocatorAware2": ...   # type: ignore

class TypedefStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        i32_field: bool
        IntTypedef_field: bool
        UintTypedef_field: bool
        pass

    i32_field: Final[int] = ...

    IntTypedef_field: Final[int] = ...

    UintTypedef_field: Final[int] = ...

    def __init__(
        self, *,
        i32_field: _typing.Optional[int]=None,
        IntTypedef_field: _typing.Optional[int]=None,
        UintTypedef_field: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        i32_field: _typing.Union[int, '__NotSet', None]=NOTSET,
        IntTypedef_field: _typing.Union[int, '__NotSet', None]=NOTSET,
        UintTypedef_field: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> TypedefStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['TypedefStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'TypedefStruct') -> bool: ...
    def __gt__(self, other: 'TypedefStruct') -> bool: ...
    def __le__(self, other: 'TypedefStruct') -> bool: ...
    def __ge__(self, other: 'TypedefStruct') -> bool: ...

    def _to_python(self) -> "module.thrift_types.TypedefStruct": ...   # type: ignore
    def _to_py3(self) -> TypedefStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.TypedefStruct": ...   # type: ignore

class StructWithDoubleUnderscores(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        __field: bool
        pass

    __field: Final[int] = ...

    def __init__(
        self, *,
        __field: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        __field: _typing.Union[int, '__NotSet', None]=NOTSET
    ) -> StructWithDoubleUnderscores: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['StructWithDoubleUnderscores'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'StructWithDoubleUnderscores') -> bool: ...
    def __gt__(self, other: 'StructWithDoubleUnderscores') -> bool: ...
    def __le__(self, other: 'StructWithDoubleUnderscores') -> bool: ...
    def __ge__(self, other: 'StructWithDoubleUnderscores') -> bool: ...

    def _to_python(self) -> "module.thrift_types.StructWithDoubleUnderscores": ...   # type: ignore
    def _to_py3(self) -> StructWithDoubleUnderscores: ...
    def _to_py_deprecated(self) -> "module.ttypes.StructWithDoubleUnderscores": ...   # type: ignore

class std_unordered_map__Map__i32_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__i64T = _typing.TypeVar('_List__i64T', bound=_typing.Sequence[int])


class List__i64(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'List__i64': ...
    def __radd__(self, other: _List__i64T) -> _List__i64T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class Map__binary_i64(_typing.Mapping[bytes, int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[bytes, int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[bytes, int]: ...
    def __getitem__(self, key: bytes) -> int: ...
    def __iter__(self) -> _typing.Iterator[bytes]: ...


_List__i32T = _typing.TypeVar('_List__i32T', bound=_typing.Sequence[int])


class List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'List__i32': ...
    def __radd__(self, other: _List__i32T) -> _List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_std_list__List__i32T = _typing.TypeVar('_std_list__List__i32T', bound=_typing.Sequence[int])


class std_list__List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'std_list__List__i32': ...
    def __radd__(self, other: _std_list__List__i32T) -> _std_list__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_std_deque__List__i32T = _typing.TypeVar('_std_deque__List__i32T', bound=_typing.Sequence[int])


class std_deque__List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'std_deque__List__i32': ...
    def __radd__(self, other: _std_deque__List__i32T) -> _std_deque__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_folly_fbvector__List__i32T = _typing.TypeVar('_folly_fbvector__List__i32T', bound=_typing.Sequence[int])


class folly_fbvector__List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'folly_fbvector__List__i32': ...
    def __radd__(self, other: _folly_fbvector__List__i32T) -> _folly_fbvector__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_folly_small_vector__List__i32T = _typing.TypeVar('_folly_small_vector__List__i32T', bound=_typing.Sequence[int])


class folly_small_vector__List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'folly_small_vector__List__i32': ...
    def __radd__(self, other: _folly_small_vector__List__i32T) -> _folly_small_vector__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class folly_sorted_vector_set__Set__i32(_typing.AbstractSet[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[int]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> 'folly_sorted_vector_set__Set__i32': ...
    def intersection(self, other: _typing.AbstractSet[int]) -> 'folly_sorted_vector_set__Set__i32': ...
    def difference(self, other: _typing.AbstractSet[int]) -> 'folly_sorted_vector_set__Set__i32': ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> 'folly_sorted_vector_set__Set__i32': ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class folly_sorted_vector_map__Map__i32_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_std_list_int32_t__List__i32T = _typing.TypeVar('_std_list_int32_t__List__i32T', bound=_typing.Sequence[int])


class std_list_int32_t__List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'std_list_int32_t__List__i32': ...
    def __radd__(self, other: _std_list_int32_t__List__i32T) -> _std_list_int32_t__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class Map__string_i32(_typing.Mapping[str, int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, int]: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__std_unordered_map__Map__i32_stringT = _typing.TypeVar('_List__std_unordered_map__Map__i32_stringT', bound=_typing.Sequence[_typing.Mapping[int, str]])


class List__std_unordered_map__Map__i32_string(_typing.Sequence[_typing.Mapping[int, str]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Mapping[int, str]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Mapping[int, str]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Mapping[int, str]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Mapping[int, str]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[int, str]]) -> 'List__std_unordered_map__Map__i32_string': ...
    def __radd__(self, other: _List__std_unordered_map__Map__i32_stringT) -> _List__std_unordered_map__Map__i32_stringT: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...


class Map__i32_IncompleteMapDep(_typing.Mapping[int, IncompleteMapDep], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, IncompleteMapDep]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, IncompleteMapDep]: ...
    def __getitem__(self, key: int) -> IncompleteMapDep: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class std_unordered_map__Map__i32_CompleteMapDep(_typing.Mapping[int, CompleteMapDep], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, CompleteMapDep]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, CompleteMapDep]: ...
    def __getitem__(self, key: int) -> CompleteMapDep: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


__std_list__List__IncompleteListDepT = _typing.TypeVar('__std_list__List__IncompleteListDepT', bound=_typing.Sequence[IncompleteListDep])


class _std_list__List__IncompleteListDep(_typing.Sequence[IncompleteListDep], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[IncompleteListDep]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[IncompleteListDep]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> IncompleteListDep: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[IncompleteListDep]: ...
    def __add__(self, other: _typing.Sequence[IncompleteListDep]) -> '_std_list__List__IncompleteListDep': ...
    def __radd__(self, other: __std_list__List__IncompleteListDepT) -> __std_list__List__IncompleteListDepT: ...
    def __reversed__(self) -> _typing.Iterator[IncompleteListDep]: ...
    def __iter__(self) -> _typing.Iterator[IncompleteListDep]: ...


_folly_small_vector__List__CompleteListDepT = _typing.TypeVar('_folly_small_vector__List__CompleteListDepT', bound=_typing.Sequence[CompleteListDep])


class folly_small_vector__List__CompleteListDep(_typing.Sequence[CompleteListDep], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[CompleteListDep]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[CompleteListDep]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> CompleteListDep: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[CompleteListDep]: ...
    def __add__(self, other: _typing.Sequence[CompleteListDep]) -> 'folly_small_vector__List__CompleteListDep': ...
    def __radd__(self, other: _folly_small_vector__List__CompleteListDepT) -> _folly_small_vector__List__CompleteListDepT: ...
    def __reversed__(self) -> _typing.Iterator[CompleteListDep]: ...
    def __iter__(self) -> _typing.Iterator[CompleteListDep]: ...


_List__AdaptedListDepT = _typing.TypeVar('_List__AdaptedListDepT', bound=_typing.Sequence[AdaptedListDep])


class List__AdaptedListDep(_typing.Sequence[AdaptedListDep], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[AdaptedListDep]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[AdaptedListDep]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> AdaptedListDep: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[AdaptedListDep]: ...
    def __add__(self, other: _typing.Sequence[AdaptedListDep]) -> 'List__AdaptedListDep': ...
    def __radd__(self, other: _List__AdaptedListDepT) -> _List__AdaptedListDepT: ...
    def __reversed__(self) -> _typing.Iterator[AdaptedListDep]: ...
    def __iter__(self) -> _typing.Iterator[AdaptedListDep]: ...


_List__DependentAdaptedListDepT = _typing.TypeVar('_List__DependentAdaptedListDepT', bound=_typing.Sequence[DependentAdaptedListDep])


class List__DependentAdaptedListDep(_typing.Sequence[DependentAdaptedListDep], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[DependentAdaptedListDep]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[DependentAdaptedListDep]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> DependentAdaptedListDep: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[DependentAdaptedListDep]: ...
    def __add__(self, other: _typing.Sequence[DependentAdaptedListDep]) -> 'List__DependentAdaptedListDep': ...
    def __radd__(self, other: _List__DependentAdaptedListDepT) -> _List__DependentAdaptedListDepT: ...
    def __reversed__(self) -> _typing.Iterator[DependentAdaptedListDep]: ...
    def __iter__(self) -> _typing.Iterator[DependentAdaptedListDep]: ...


class Set__i32(_typing.AbstractSet[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[int]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def intersection(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def difference(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class Map__i32_i32(_typing.Mapping[int, int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, int]: ...
    def __getitem__(self, key: int) -> int: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


TBinary = bytes
IntTypedef = int
UintTypedef = int
